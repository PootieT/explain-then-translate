HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_2 | def sumDigits ( no ) : NEW_LINE INDENT return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) ) NEW_LINE DEDENT
SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN | def findSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i // j NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
MINIMUM_CHARACTERS_ADDED_FRONT_MAKE_STRING_PALINDROME | def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
MINIMUM_STEPS_REACH_END_ARRAY_CONSTRAINTS | def getMinStepToReachEnd ( arr , N ) : NEW_LINE INDENT visit = [ False for i in range ( N ) ] NEW_LINE distance = [ 0 for i in range ( N ) ] NEW_LINE digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT digit [ arr [ i ] ] . append ( i ) NEW_LINE DEDENT distance [ 0 ] = 0 NEW_LINE visit [ 0 ] = True NEW_LINE q = [ ] NEW_LINE q . append ( 0 ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT idx = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE if ( idx == N - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT d = arr [ idx ] NEW_LINE for i in range ( len ( digit [ d ] ) ) : NEW_LINE INDENT nextidx = digit [ d ] [ i ] NEW_LINE if ( visit [ nextidx ] == False ) : NEW_LINE INDENT visit [ nextidx ] = True NEW_LINE q . append ( nextidx ) NEW_LINE distance [ nextidx ] = distance [ idx ] + 1 NEW_LINE DEDENT DEDENT if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : NEW_LINE INDENT visit [ idx - 1 ] = True NEW_LINE q . append ( idx - 1 ) NEW_LINE distance [ idx - 1 ] = distance [ idx ] + 1 NEW_LINE DEDENT if ( idx + 1 < N and visit [ idx + 1 ] == False ) : NEW_LINE INDENT visit [ idx + 1 ] = True NEW_LINE q . append ( idx + 1 ) NEW_LINE distance [ idx + 1 ] = distance [ idx ] + 1 NEW_LINE DEDENT DEDENT return distance [ N - 1 ] NEW_LINE DEDENT
DICE_THROW_PROBLEM_1 | def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT
MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES | def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( s ) : NEW_LINE INDENT k = s - i - j NEW_LINE maxvalue = max ( maxvalue , i * j * k ) NEW_LINE DEDENT DEDENT return maxvalue NEW_LINE DEDENT
NUMBER_DAYS_TANK_WILL_BECOME_EMPTY | def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( l >= C ) : return C NEW_LINE eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_root ) + l NEW_LINE DEDENT
K_NUMBERS_DIFFERENCE_MAXIMUM_MINIMUM_K_NUMBER_MINIMIZED | def minDiff ( arr , n , k ) : NEW_LINE INDENT result = sys . maxsize NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
ROPES_DATA_STRUCTURE_FAST_STRING_CONCATENATION | def concatenate ( a , b , c , n1 , n2 ) : NEW_LINE INDENT i = - 1 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT c [ i ] = a [ i ] NEW_LINE DEDENT for j in range ( n2 ) : NEW_LINE INDENT c [ i ] = b [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
CEILING_IN_A_SORTED_ARRAY | def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
MAXIMUM_SIZE_SUB_MATRIX_WITH_ALL_1S_IN_A_BINARY_MATRIX | def printMaxSubSquare ( M ) : NEW_LINE INDENT R = len ( M ) NEW_LINE C = len ( M [ 0 ] ) NEW_LINE S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if ( M [ i ] [ j ] == 1 ) : NEW_LINE INDENT S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT S [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT max_of_s = S [ 0 ] [ 0 ] NEW_LINE max_i = 0 NEW_LINE max_j = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( max_of_s < S [ i ] [ j ] ) : NEW_LINE INDENT max_of_s = S [ i ] [ j ] NEW_LINE max_i = i NEW_LINE max_j = j NEW_LINE DEDENT DEDENT DEDENT print ( " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " ) NEW_LINE for i in range ( max_i , max_i - max_of_s , - 1 ) : NEW_LINE INDENT for j in range ( max_j , max_j - max_of_s , - 1 ) : NEW_LINE INDENT print ( M [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
PRODUCT_MAXIMUM_FIRST_ARRAY_MINIMUM_SECOND_1 | def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT max = arr1 [ 0 ] NEW_LINE min = arr2 [ 0 ] NEW_LINE i = 1 NEW_LINE while ( i < n1 and i < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE DEDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while ( i < n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while ( i < n2 ) : NEW_LINE INDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return max * min NEW_LINE DEDENT
COMPOSITE_NUMBER | def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP | def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) NEW_LINE exit . sort ( ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in = guests_in + 1 NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in = guests_in - 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " , max_guests , " at ▁ time " , time ) NEW_LINE DEDENT
PROGRAM_PRINT_IDENTITY_MATRIX | def Identity ( size ) : NEW_LINE INDENT for row in range ( 0 , size ) : NEW_LINE INDENT for col in range ( 0 , size ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( "1 ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY | def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES | def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT
COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE_1 | def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE count [ 2 ] = 2 NEW_LINE for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) NEW_LINE DEDENT return count [ dist ] NEW_LINE DEDENT
MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING_1 | def maximumChars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str1 [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str1 [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
EFFICIENTLY_FIND_FIRST_REPEATED_CHARACTER_STRING_WITHOUT_USING_ADDITIONAL_DATA_STRUCTURE_ONE_TRAVERSAL | def FirstRepeated ( string ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in string : NEW_LINE INDENT val = ord ( i ) - ord ( ' a ' ) ; NEW_LINE if ( ( checker & ( 1 << val ) ) > 0 ) : NEW_LINE INDENT return pos NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
MAXIMUM_PRODUCT_SUBARRAY_ADDED_NEGATIVE_PRODUCT_CASE | def findMaxProduct ( arr , n ) : NEW_LINE INDENT ans = - float ( ' inf ' ) NEW_LINE maxval = 1 NEW_LINE minval = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT maxval = maxval * arr [ i ] NEW_LINE minval = min ( 1 , minval * arr [ i ] ) NEW_LINE DEDENT elif arr [ i ] == 0 : NEW_LINE INDENT minval = 1 NEW_LINE maxval = 0 NEW_LINE DEDENT elif arr [ i ] < 0 : NEW_LINE INDENT prevMax = maxval NEW_LINE maxval = minval * arr [ i ] NEW_LINE minval = prevMax * arr [ i ] NEW_LINE DEDENT ans = max ( ans , maxval ) NEW_LINE if maxval <= 0 : NEW_LINE INDENT maxval = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
SURVIVAL | def survival ( S , N , M ) : NEW_LINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) / N NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 NEW_LINE DEDENT print ( " Yes ▁ " ) , NEW_LINE print ( days ) NEW_LINE DEDENT DEDENT
QUEUE_BASED_APPROACH_FOR_FIRST_NON_REPEATING_CHARACTER_IN_A_STREAM | def firstnonrepeating ( Str ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE q = Queue ( ) NEW_LINE charCount = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT q . put ( Str [ i ] ) NEW_LINE charCount [ ord ( Str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT if ( charCount [ ord ( q . queue [ 0 ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q . queue [ 0 ] , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( q . empty ( ) ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
DFS_N_ARY_TREE_ACYCLIC_GRAPH_REPRESENTED_ADJACENCY_LIST | def dfs ( List , node , arrival ) : NEW_LINE INDENT print ( node ) NEW_LINE for i in range ( len ( List [ node ] ) ) : NEW_LINE INDENT if ( List [ node ] [ i ] != arrival ) : NEW_LINE INDENT dfs ( List , List [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT DEDENT
FIND_REPETITIVE_ELEMENT_1_N_1_2 | def findRepeating ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT res = res ^ ( i + 1 ) ^ arr [ i ] NEW_LINE DEDENT res = res ^ arr [ n - 1 ] NEW_LINE return res NEW_LINE DEDENT
MOBILE_NUMERIC_KEYPAD_PROBLEM | def getCount ( keypad , n ) : NEW_LINE INDENT if ( not keypad or n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT odd = [ 0 ] * 10 NEW_LINE even = [ 0 ] * 10 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE useOdd = 0 NEW_LINE totalCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT useOdd = 1 - useOdd NEW_LINE if ( useOdd == 1 ) : NEW_LINE INDENT even [ 0 ] = odd [ 0 ] + odd [ 8 ] NEW_LINE even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] NEW_LINE even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] NEW_LINE even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] NEW_LINE even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] NEW_LINE even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] NEW_LINE even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] NEW_LINE even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] NEW_LINE even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] NEW_LINE even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] NEW_LINE DEDENT else : NEW_LINE INDENT odd [ 0 ] = even [ 0 ] + even [ 8 ] NEW_LINE odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] NEW_LINE odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] NEW_LINE odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] NEW_LINE odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] NEW_LINE odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] NEW_LINE odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] NEW_LINE odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] NEW_LINE odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] NEW_LINE odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] NEW_LINE DEDENT DEDENT totalCount = 0 NEW_LINE if ( useOdd == 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += even [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += odd [ i ] NEW_LINE DEDENT DEDENT return totalCount NEW_LINE DEDENT
COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S_1 | def countSubarrWithEqualZeroAndOne ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE Sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT Sum += arr [ i ] NEW_LINE if ( Sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( Sum in mp . keys ( ) ) : NEW_LINE INDENT count += mp [ Sum ] NEW_LINE DEDENT mp [ Sum ] = mp . get ( Sum , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
DIVIDE_CONQUER_SET_6_SEARCH_ROW_WISE_COLUMN_WISE_SORTED_2D_ARRAY | def search ( mat , fromRow , toRow , fromCol , toCol , key ) : NEW_LINE INDENT i = fromRow + ( toRow - fromRow ) // 2 NEW_LINE j = fromCol + ( toCol - fromCol ) // 2 NEW_LINE if ( mat [ i ] [ j ] == key ) : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , i , " ▁ " , j ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( i != toRow or j != fromCol ) : NEW_LINE INDENT search ( mat , fromRow , i , j , toCol , key ) NEW_LINE DEDENT if ( fromRow == toRow and fromCol + 1 == toCol ) : NEW_LINE INDENT if ( mat [ fromRow ] [ toCol ] == key ) : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , fromRow , " ▁ " , toCol ) NEW_LINE DEDENT DEDENT if ( mat [ i ] [ j ] < key ) : NEW_LINE INDENT if ( i + 1 <= toRow ) : NEW_LINE INDENT search ( mat , i + 1 , toRow , fromCol , toCol , key ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j - 1 >= fromCol ) : NEW_LINE INDENT search ( mat , fromRow , toRow , fromCol , j - 1 , key ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS_1 | def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT
CHECK_TWO_STRINGS_K_ANAGRAMS_NOT_1 | def areKAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT hash_str1 = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash_str1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
N_BONACCI_NUMBERS | def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE a [ n - 1 ] = 1 NEW_LINE for i in range ( n , m ) : NEW_LINE INDENT for j in range ( i - n , i ) : NEW_LINE INDENT a [ i ] = a [ i ] + a [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
FIND_CHARACTER_FIRST_STRING_PRESENT_MINIMUM_INDEX_SECOND_STRING | def printMinIndexChar ( Str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " , Str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT
DETECTING_NEGATIVE_CYCLE_USING_FLOYD_WARSHALL | def negCyclefloydWarshall ( graph ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT dist [ i ] [ j ] = graph [ i ] [ j ] NEW_LINE DEDENT DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ i ] < 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
FIND_STRING_LEXICOGRAPHIC_ORDER_GIVEN_TWO_STRINGS | def lexNext ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT s [ i ] = ' a ' NEW_LINE DEDENT DEDENT
GENERATE_TWO_OUTPUT_STRINGS_DEPENDING_UPON_OCCURRENCE_CHARACTER_INPUT_STRING | def printDuo ( string ) : NEW_LINE INDENT countChar = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE n = len ( string ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countChar [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str1 = " " NEW_LINE str2 = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( countChar [ i ] > 1 ) : NEW_LINE INDENT str2 = str2 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT elif ( countChar [ i ] == 1 ) : NEW_LINE INDENT str1 = str1 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT print ( " String ▁ with ▁ characters ▁ occurring ▁ once : " , " \n " , str1 ) NEW_LINE print ( " String ▁ with ▁ characters ▁ occurring " , " multiple ▁ times : " , " \n " , str2 ) NEW_LINE DEDENT
ROUND_OFF_NUMBER_GIVEN_NUMBER_SIGNIFICANT_DIGITS | def Round_off ( N , n ) : NEW_LINE INDENT b = N NEW_LINE c = floor ( N ) NEW_LINE i = 0 NEW_LINE while ( b >= 1 ) : NEW_LINE INDENT b = b / 10 NEW_LINE i = i + 1 NEW_LINE DEDENT d = n - i NEW_LINE b = N NEW_LINE b = b * pow ( 10 , d ) NEW_LINE e = b + 0.5 NEW_LINE if ( float ( e ) == float ( ceil ( b ) ) ) : NEW_LINE INDENT f = ( ceil ( b ) ) NEW_LINE h = f - 2 NEW_LINE if ( h % 2 != 0 ) : NEW_LINE INDENT e = e - 1 NEW_LINE DEDENT DEDENT j = floor ( e ) NEW_LINE m = pow ( 10 , d ) NEW_LINE j = j / m NEW_LINE print ( " The ▁ number ▁ after ▁ rounding - off ▁ is " , j ) NEW_LINE DEDENT
GENERATE_ROTATIONS_GIVEN_STRING | def printRotatedString ( str ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE temp = [ 0 ] * ( lenn ) NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT j = i NEW_LINE k = 0 NEW_LINE while ( j < len ( str ) ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT j = 0 NEW_LINE while ( j < i ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT print ( * temp , sep = " " ) NEW_LINE DEDENT DEDENT
FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS | def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 += arr [ i ] [ j ] NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
BREAKING_NUMBER_FIRST_PART_INTEGRAL_DIVISION_SECOND_POWER_10 | def calculate ( N ) : NEW_LINE INDENT length = len ( N ) NEW_LINE l = int ( ( length ) / 2 ) NEW_LINE count = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT s = N [ 0 : 0 + i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE try : NEW_LINE INDENT if s [ 0 ] == '0' or t [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT continue NEW_LINE DEDENT if s == t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2 | def printUnion ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while i < m : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS_1 | def printDistinct ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE index = [ n for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ord ( Str [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 and x != ' ▁ ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index = sorted ( index ) NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if index [ i ] == n : NEW_LINE INDENT break NEW_LINE DEDENT print ( Str [ index [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT
FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX | def findCommon ( mat ) : NEW_LINE INDENT column = [ N - 1 ] * M NEW_LINE min_row = 0 NEW_LINE while ( column [ min_row ] >= 0 ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : NEW_LINE INDENT min_row = i NEW_LINE DEDENT DEDENT eq_count = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) : NEW_LINE INDENT if ( column [ i ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT column [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT eq_count += 1 NEW_LINE DEDENT DEDENT if ( eq_count == M ) : NEW_LINE INDENT return mat [ min_row ] [ column [ min_row ] ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
C_PROGRAM_FIND_AREA_TRIANGLE_1 | def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES | def maxProfit ( prices , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE for l in range ( i ) : NEW_LINE INDENT max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) NEW_LINE DEDENT profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) NEW_LINE DEDENT DEDENT return profit [ n - 1 ] [ k ] NEW_LINE DEDENT
WILDCARD_CHARACTER_MATCHING | def match ( first , second ) : NEW_LINE INDENT if len ( first ) == 0 and len ( second ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( first ) > 1 and first [ 0 ] == ' * ' and len ( second ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( first ) > 1 and first [ 0 ] == ' ? ' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) : NEW_LINE INDENT return match ( first [ 1 : ] , second [ 1 : ] ) ; NEW_LINE DEDENT if len ( first ) != 0 and first [ 0 ] == ' * ' : NEW_LINE INDENT return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT
FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER_1 | def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE y = N / K NEW_LINE x = N % K NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) NEW_LINE return int ( ans ) NEW_LINE DEDENT
CHECK_ROWS_MATRIX_CIRCULAR_ROTATIONS | def isPermutedMatrix ( mat , n ) : NEW_LINE INDENT str_cat = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT str_cat = str_cat + " - " + str ( mat [ 0 ] [ i ] ) NEW_LINE DEDENT str_cat = str_cat + str_cat NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_str = " " NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_str = curr_str + " - " + str ( mat [ i ] [ j ] ) NEW_LINE DEDENT if ( str_cat . find ( curr_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
CHECK_GIVEN_MATRIX_SPARSE_NOT | def isSparse ( array , m , n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( array [ i ] [ j ] == 0 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT return ( counter > ( ( m * n ) // 2 ) ) NEW_LINE DEDENT
C_PROGRAM_FIND_AREA_CIRCLE | def findArea ( r ) : NEW_LINE INDENT PI = 3.142 NEW_LINE return PI * ( r * r ) NEW_LINE DEDENT
COUNT_OBTUSE_ANGLES_CIRCLE_K_EQUIDISTANT_POINTS_2_GIVEN_POINTS | def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( c1 , c2 ) NEW_LINE DEDENT
PRINT_GIVEN_MATRIX_COUNTER_CLOCK_WISE_SPIRAL_FORM | def counterClockspiralPrint ( m , n , arr ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE cnt = 0 NEW_LINE total = m * n NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( k , m ) : NEW_LINE INDENT print ( arr [ i ] [ l ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT l += 1 NEW_LINE if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( l , n ) : NEW_LINE INDENT print ( arr [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT m -= 1 NEW_LINE if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( k < m ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ k ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT
NUMBER_TRIANGLES_N_MOVES_1 | def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 NEW_LINE return ans NEW_LINE DEDENT
PRODUCT_MAXIMUM_FIRST_ARRAY_MINIMUM_SECOND | def minmaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE return arr1 [ n1 - 1 ] * arr2 [ 0 ] NEW_LINE DEDENT
TIME_MEET_ANIMALS | def timeToMeet ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 NEW_LINE time = s / V NEW_LINE print ( time ) NEW_LINE DEDENT
MINIMUM_NUMBER_CHARACTERS_REMOVED_MAKE_BINARY_STRING_ALTERNATE | def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE | def printCountRec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) NEW_LINE DEDENT
COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW_1 | def compute_average ( a , b ) : NEW_LINE INDENT return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 ) NEW_LINE DEDENT
GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1 | def countSubStr ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( st [ j ] == '1' ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
DECIMAL_REPRESENTATION_GIVEN_BINARY_STRING_DIVISIBLE_10_NOT | def isDivisibleBy10 ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT posFromRight = n - i - 1 NEW_LINE if ( posFromRight % 4 == 1 ) : NEW_LINE INDENT sum = sum + 2 NEW_LINE DEDENT elif ( posFromRight % 4 == 2 ) : NEW_LINE INDENT sum = sum + 4 NEW_LINE DEDENT elif ( posFromRight % 4 == 3 ) : NEW_LINE INDENT sum = sum + 8 NEW_LINE DEDENT elif ( posFromRight % 4 == 0 ) : NEW_LINE INDENT sum = sum + 6 NEW_LINE DEDENT DEDENT i = i - 1 NEW_LINE DEDENT if ( sum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_IN_A_SORTED_ARRAY | def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return None NEW_LINE DEDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_1 | def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = arr_size - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ i ] + A [ l ] + A [ r ] == sum ) : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , ' , ▁ ' , A [ l ] , ' , ▁ ' , A [ r ] ) NEW_LINE return True NEW_LINE DEDENT elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
CHANGE_ARRAY_PERMUTATION_NUMBERS_1_N | def makePermutation ( a , n ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count . get ( a [ i ] ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT next_missing = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : NEW_LINE INDENT count [ a [ i ] ] -= 1 NEW_LINE while count . get ( next_missing ) : NEW_LINE INDENT next_missing += 1 NEW_LINE DEDENT a [ i ] = next_missing NEW_LINE count [ next_missing ] = 1 NEW_LINE DEDENT DEDENT DEDENT
DYNAMIC_PROGRAMMING_SET_31_OPTIMAL_STRATEGY_FOR_A_GAME | def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = 0 NEW_LINE if ( ( i + 2 ) <= j ) : NEW_LINE INDENT x = table [ i + 2 ] [ j ] NEW_LINE DEDENT y = 0 NEW_LINE if ( ( i + 1 ) <= ( j - 1 ) ) : NEW_LINE INDENT y = table [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT z = 0 NEW_LINE if ( i <= ( j - 2 ) ) : NEW_LINE INDENT z = table [ i ] [ j - 2 ] NEW_LINE DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
SUM_SUBSETS_SET_FORMED_FIRST_N_NATURAL_NUMBERS | def findSumSubsets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
SUM_SERIES_ALTERNATE_SIGNED_SQUARES_AP_1 | def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT
INTERCHANGE_ELEMENTS_OF_FIRST_AND_LAST_ROWS_IN_MATRIX | def interchangeFirstLast ( mat , n , m ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE mat [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT
DYNAMIC_PROGRAMMING_SET_13_CUTTING_A_ROD | def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT
FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP_1 | def maxOverlap ( start , end ) : NEW_LINE INDENT n = len ( start ) NEW_LINE maxa = max ( start ) NEW_LINE maxb = max ( end ) NEW_LINE maxc = max ( maxa , maxb ) NEW_LINE x = ( maxc + 2 ) * [ 0 ] NEW_LINE cur = 0 idx = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x [ start [ i ] ] += 1 NEW_LINE x [ end [ i ] + 1 ] -= 1 NEW_LINE DEDENT maxy = - 1 NEW_LINE for i in range ( 0 , maxc + 1 ) : NEW_LINE INDENT cur += x [ i ] NEW_LINE if maxy < cur : NEW_LINE INDENT maxy = cur NEW_LINE idx = i NEW_LINE DEDENT DEDENT print ( " Maximum ▁ value ▁ is : ▁ { 0 : d } " . format ( maxy ) , " ▁ at ▁ position : ▁ { 0 : d } " . format ( idx ) ) NEW_LINE DEDENT
CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME_1 | def canFormPalindrome ( strr ) : NEW_LINE INDENT listt = [ ] NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT if ( strr [ i ] in listt ) : NEW_LINE INDENT listt . remove ( strr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT listt . append ( strr [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( strr ) % 2 == 0 and len ( listt ) == 0 or \ ( len ( strr ) % 2 == 1 and len ( listt ) == 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
TAIL_RECURSION_FIBONACCI | def fib ( n , a = 0 , b = 1 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT return fib ( n - 1 , b , a + b ) ; NEW_LINE DEDENT
NUMBER_ORDERED_PAIRS_AI_AJ_0 | def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] & a [ j ] ) == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
K_MAXIMUM_SUMS_NON_OVERLAPPING_CONTIGUOUS_SUB_ARRAYS | def kmax ( arr , k , n ) : NEW_LINE INDENT for c in range ( k ) : NEW_LINE INDENT max_so_far = - float ( " inf " ) NEW_LINE max_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_here += arr [ i ] NEW_LINE if ( max_so_far < max_here ) : NEW_LINE INDENT max_so_far = max_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if ( max_here < 0 ) : NEW_LINE INDENT max_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ non - overlapping ▁ sub - array ▁ sum " , c + 1 , " : ▁ " , max_so_far , " , ▁ starting ▁ index : ▁ " , start , " , ▁ ending ▁ index : ▁ " , end , " . " , sep = " " ) NEW_LINE for l in range ( start , end + 1 ) : NEW_LINE INDENT arr [ l ] = - float ( " inf " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
MINIMUM_COST_CUT_BOARD_SQUARES | def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 vert = 1 NEW_LINE i = 0 j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
K_TH_SMALLEST_ELEMENT_REMOVING_INTEGERS_NATURAL_NUMBERS | def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k is not 1 ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT DEDENT
DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_1 | def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ 0 ] * ( n + 1 ) NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( P [ 0 ] [ i ] == True ) : NEW_LINE INDENT C [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) : NEW_LINE INDENT C [ i ] = 1 + C [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ n - 1 ] NEW_LINE DEDENT
PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS | def isProduct ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i * j == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_1 | def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
LEVEL_NODE_TREE_SOURCE_NODE_USING_BFS | def printLevels ( graph , V , x ) : NEW_LINE INDENT level = [ None ] * V NEW_LINE marked = [ False ] * V NEW_LINE que = queue . Queue ( ) NEW_LINE que . put ( x ) NEW_LINE level [ x ] = 0 NEW_LINE marked [ x ] = True NEW_LINE while ( not que . empty ( ) ) : NEW_LINE INDENT x = que . get ( ) NEW_LINE for i in range ( len ( graph [ x ] ) ) : NEW_LINE INDENT b = graph [ x ] [ i ] NEW_LINE if ( not marked [ b ] ) : NEW_LINE INDENT que . put ( b ) NEW_LINE level [ b ] = level [ x ] + 1 NEW_LINE marked [ b ] = True NEW_LINE DEDENT DEDENT DEDENT print ( " Nodes " , " ▁ " , " Level " ) NEW_LINE for i in range ( V ) : NEW_LINE INDENT print ( " ▁ " , i , " ▁ - - > ▁ " , level [ i ] ) NEW_LINE DEDENT DEDENT
NUMBER_WAYS_NODE_MAKE_LOOP_SIZE_K_UNDIRECTED_COMPLETE_CONNECTED_GRAPH_N_NODES | def numOfways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n NEW_LINE DEDENT
DELANNOY_NUMBER | def dealnnoy ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT
FIND_IF_THERE_IS_A_SUBARRAY_WITH_0_SUM | def subArrayExists ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if sum == 0 or sum in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( sum ) NEW_LINE DEDENT return False NEW_LINE DEDENT
MERGE_TWO_SORTED_ARRAYS_O1_EXTRA_SPACE | def merge ( ar1 , ar2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT
LONGEST_COMMON_SUBSEQUENCE_WITH_PERMUTATIONS_ALLOWED | def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result = result + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
TAIL_RECURSION | def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
DECODE_MEDIAN_STRING_ORIGINAL_STRING | def decodeMedianString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s1 = " " NEW_LINE if ( l % 2 == 0 ) : NEW_LINE INDENT isEven = True NEW_LINE DEDENT else : NEW_LINE INDENT isEven = False NEW_LINE DEDENT for i in range ( 0 , l , 2 ) : NEW_LINE INDENT if ( isEven ) : NEW_LINE INDENT s1 = s [ i ] + s1 NEW_LINE s1 += s [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( l - i > 1 ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s1 = s [ i + 1 ] + s1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 += s [ i ] NEW_LINE DEDENT DEDENT DEDENT return s1 NEW_LINE DEDENT
MAXIMUM_PATH_SUM_STARTING_CELL_0_TH_ROW_ENDING_CELL_N_1_TH_ROW | def MaximumPath ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \ NEW_LINE INDENT Mat [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
MINIMUM_SWAPS_REQUIRED_BRING_ELEMENTS_LESS_EQUAL_K_TOGETHER | def minSwap ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT bad = 0 NEW_LINE for i in range ( 0 , count ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT DEDENT ans = bad NEW_LINE j = count NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad - 1 NEW_LINE DEDENT if ( arr [ j ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT ans = min ( ans , bad ) NEW_LINE j = j + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
PROGRAM_DECIMAL_OCTAL_CONVERSION | def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 NEW_LINE n = int ( n / 8 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
COUNT_SUM_OF_DIGITS_IN_NUMBERS_FROM_1_TO_N | def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT d = ( int ) ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) NEW_LINE DEDENT
CALCULATE_AREA_TETRAHEDRON | def vol_tetra ( side ) : NEW_LINE INDENT volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) NEW_LINE return round ( volume , 2 ) NEW_LINE DEDENT
FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE_1 | def myCopy ( s1 , s2 , index ) : NEW_LINE INDENT s2 [ index ] = s1 [ index ] NEW_LINE if ( index == len ( s1 ) - 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT myCopy ( s1 , s2 , index + 1 ) NEW_LINE DEDENT
MIN_FLIPS_OF_CONTINUOUS_CHARACTERS_TO_MAKE_ALL_CHARACTERS_SAME_IN_A_STRING | def findFlips ( str , n ) : NEW_LINE INDENT last = ' ▁ ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( last != str [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = str [ i ] NEW_LINE DEDENT return res // 2 NEW_LINE DEDENT
INTERLEAVE_FIRST_HALF_QUEUE_SECOND_HALF | def interLeaveQueue ( q ) : NEW_LINE INDENT if ( q . qsize ( ) % 2 != 0 ) : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE DEDENT s = [ ] NEW_LINE halfSize = int ( q . qsize ( ) / 2 ) NEW_LINE for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT
ODD_EVEN_SORT_BRICK_SORT | def oddEvenSort ( arr , n ) : NEW_LINE INDENT isSorted = 0 NEW_LINE while isSorted == 0 : NEW_LINE INDENT isSorted = 1 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE isSorted = 0 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE isSorted = 0 NEW_LINE DEDENT DEDENT DEDENT return NEW_LINE DEDENT
SHORTEST_UNCOMMON_SUBSEQUENCE | def shortestSeq ( S : list , T : list ) : NEW_LINE INDENT m = len ( S ) NEW_LINE n = len ( T ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ch = S [ i - 1 ] NEW_LINE k = j - 1 NEW_LINE while k >= 0 : NEW_LINE INDENT if T [ k ] == ch : NEW_LINE INDENT break NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT if k == - 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ m ] [ n ] NEW_LINE if ans >= MAX : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
LONGEST_CONSECUTIVE_SUBSEQUENCE | def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE ans = 0 NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
POWER_SET | def printPowerSet ( set , set_size ) : NEW_LINE INDENT pow_set_size = ( int ) ( math . pow ( 2 , set_size ) ) NEW_LINE counter = 0 NEW_LINE j = 0 NEW_LINE for counter in range ( 0 , pow_set_size ) : NEW_LINE INDENT for j in range ( 0 , set_size ) : NEW_LINE INDENT if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( set [ j ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
FIND_THE_MISSING_NUMBER_2 | def getMissingNo ( a , n ) : NEW_LINE INDENT x1 = a [ 0 ] NEW_LINE x2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x1 = x1 ^ a [ i ] NEW_LINE DEDENT for i in range ( 2 , n + 2 ) : NEW_LINE INDENT x2 = x2 ^ i NEW_LINE DEDENT return x1 ^ x2 NEW_LINE DEDENT
GENERATE_ROTATIONS_GIVEN_STRING_1 | def printRotatedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE temp = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
GOLD_MINE_PROBLEM | def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
TILE_STACKING_PROBLEM | def possibleWays ( n , m , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE presum = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE presum [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 0 , m + 1 ) : NEW_LINE INDENT presum [ i ] [ 0 ] = 1 NEW_LINE dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = presum [ i - 1 ] [ j ] NEW_LINE if j > k : NEW_LINE INDENT dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
ROOTS_QUADRATIC_EQUATION | def findRoots ( a , b , c ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return - 1 NEW_LINE DEDENT d = b * b - 4 * a * c NEW_LINE sqrt_val = math . sqrt ( abs ( d ) ) NEW_LINE if d > 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ " ) NEW_LINE print ( ( - b + sqrt_val ) / ( 2 * a ) ) NEW_LINE print ( ( - b - sqrt_val ) / ( 2 * a ) ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ same " ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Roots ▁ are ▁ complex " ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ + ▁ i " , sqrt_val ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ - ▁ i " , sqrt_val ) NEW_LINE DEDENT DEDENT
PROGRAM_BINARY_DECIMAL_CONVERSION | def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
SUM_FAI_AJ_PAIRS_ARRAY_N_INTEGERS | def sum ( a , n ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE ans = 0 NEW_LINE pre_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( i * a [ i ] ) - pre_sum NEW_LINE pre_sum += a [ i ] NEW_LINE if ( a [ i ] - 1 ) in cnt : NEW_LINE INDENT ans -= cnt [ a [ i ] - 1 ] NEW_LINE DEDENT if ( a [ i ] + 1 ) in cnt : NEW_LINE INDENT ans += cnt [ a [ i ] + 1 ] NEW_LINE DEDENT if a [ i ] not in cnt : NEW_LINE INDENT cnt [ a [ i ] ] = 0 NEW_LINE DEDENT cnt [ a [ i ] ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
PAPER_CUT_MINIMUM_NUMBER_SQUARES_SET_2 | def minimumSquare ( m , n ) : NEW_LINE INDENT vertical_min = sys . maxsize NEW_LINE horizontal_min = sys . maxsize NEW_LINE if m == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ m ] [ n ] != 0 : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT for i in range ( 1 , m // 2 + 1 ) : NEW_LINE INDENT horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) NEW_LINE DEDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) NEW_LINE DEDENT dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
CYCLE_SORT | def cycleSort ( array ) : NEW_LINE INDENT writes = 0 NEW_LINE for cycleStart in range ( 0 , len ( array ) - 1 ) : NEW_LINE INDENT item = array [ cycleStart ] NEW_LINE pos = cycleStart NEW_LINE for i in range ( cycleStart + 1 , len ( array ) ) : NEW_LINE INDENT if array [ i ] < item : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT if pos == cycleStart : NEW_LINE INDENT continue NEW_LINE DEDENT while item == array [ pos ] : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT array [ pos ] , item = item , array [ pos ] NEW_LINE writes += 1 NEW_LINE while pos != cycleStart : NEW_LINE INDENT pos = cycleStart NEW_LINE for i in range ( cycleStart + 1 , len ( array ) ) : NEW_LINE INDENT if array [ i ] < item : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT while item == array [ pos ] : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT array [ pos ] , item = item , array [ pos ] NEW_LINE writes += 1 NEW_LINE DEDENT DEDENT return writes NEW_LINE DEDENT
TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS | def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT
DYNAMIC_PROGRAMMING_SET_7_COIN_CHANGE | def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) NEW_LINE DEDENT
AREA_OF_A_SECTOR | def SectorArea ( radius , angle ) : NEW_LINE INDENT pi = 22 / 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT DEDENT
LARGEST_LEXICOGRAPHIC_ARRAY_WITH_AT_MOST_K_CONSECUTIVE_SWAPS | def KSwapMaximum ( n , k ) : NEW_LINE INDENT global arr NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT indexPosition = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( k <= j - i ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] > arr [ indexPosition ] ) : NEW_LINE INDENT indexPosition = j NEW_LINE DEDENT DEDENT for j in range ( indexPosition , i , - 1 ) : NEW_LINE INDENT t = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = t NEW_LINE DEDENT k = k - indexPosition - i NEW_LINE DEDENT DEDENT DEDENT
POSITION_OF_RIGHTMOST_SET_BIT_1 | def PositionRightmostSetbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( not ( n & m ) ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT
GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X | def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) : NEW_LINE INDENT print ( arr1 [ i ] , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
SPARSE_SEARCH | def sparseSearch ( arr , key , low , high ) : NEW_LINE INDENT left = 0 right = 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] == ' ' : NEW_LINE INDENT left = mid - 1 NEW_LINE right = mid + 1 NEW_LINE if left < low and right > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif right <= high and arr [ right ] != ' ' : NEW_LINE INDENT mid = right NEW_LINE DEDENT elif left >= low and arr [ left ] != ' ' : NEW_LINE INDENT mid = left NEW_LINE DEDENT DEDENT if arr [ mid ] == key : NEW_LINE INDENT print ( ' Found ▁ string ▁ { } ▁ at ▁ index ▁ { } ' . format ( arr [ mid ] , mid ) ) NEW_LINE return NEW_LINE DEDENT elif arr [ mid ] > key : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT elif arr [ mid ] < key : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT left -= 1 NEW_LINE right += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX_1 | def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT principal += mat [ i ] [ i ] NEW_LINE secondary += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT
COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS | def countSeq ( n , diff ) : NEW_LINE INDENT if ( abs ( diff ) > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 and diff == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n == 1 and abs ( diff ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_1 | def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS_1 | def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE presum1 = presum2 = 0 NEW_LINE diff = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT presum1 += arr1 [ i ] NEW_LINE presum2 += arr2 [ i ] NEW_LINE curr_diff = presum1 - presum2 NEW_LINE if curr_diff == 0 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif curr_diff not in diff : NEW_LINE INDENT diff [ curr_diff ] = i NEW_LINE DEDENT else : NEW_LINE INDENT length = i - diff [ curr_diff ] NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE | def shuffleArray ( a , n ) : NEW_LINE INDENT i , q , k = 0 , 1 , n NEW_LINE while ( i < n ) : NEW_LINE INDENT j = k NEW_LINE while ( j > i + q ) : NEW_LINE INDENT a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT
COUNT_CHARACTERS_POSITION_ENGLISH_ALPHABETS | def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K_1 | def printSumTricky ( mat , k ) : NEW_LINE INDENT global n NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT stripSum = [ [ None ] * n for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = Sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = Sum NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT Sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( Sum , end = " ▁ " ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( Sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
NUMBER_EQUAL_PAIRS_STRING | def countPairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
EULERIAN_NUMBER_1 | def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
COUNT_WORDS_IN_A_GIVEN_STRING | def countWords ( string ) : NEW_LINE INDENT state = OUT NEW_LINE wc = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' or string [ i ] == ' \n ' or string [ i ] == ' \t ' ) : NEW_LINE INDENT state = OUT NEW_LINE DEDENT elif state == OUT : NEW_LINE INDENT state = IN NEW_LINE wc += 1 NEW_LINE DEDENT DEDENT return wc NEW_LINE DEDENT
POSSIBLE_MOVES_KNIGHT | def findPossibleMoves ( mat , p , q ) : NEW_LINE INDENT global n , m NEW_LINE X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] NEW_LINE Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT x = p + X [ i ] NEW_LINE y = q + Y [ i ] NEW_LINE if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
C_PROGRAM_FACTORIAL_NUMBER_2 | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
PYTHAGOREAN_QUADRUPLE | def pythagorean_quadruple ( a , b , c , d ) : NEW_LINE INDENT sum = a * a + b * b + c * c NEW_LINE if ( d * d == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
QUERIES_ON_ARRAY_WITH_DISAPPEARING_AND_REAPPEARING_ELEMENTS | def PerformQueries ( a , vec ) : NEW_LINE INDENT ans = [ ] NEW_LINE n = len ( a ) - 1 NEW_LINE q = len ( vec ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT t = vec [ i ] [ 0 ] NEW_LINE m = vec [ i ] [ 1 ] NEW_LINE if ( m > n ) : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE DEDENT turn = t // n NEW_LINE rem = t % n NEW_LINE if ( rem == 0 and turn % 2 == 1 ) : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE DEDENT if ( rem == 0 and turn % 2 == 0 ) : NEW_LINE INDENT ans . append ( a [ m ] ) NEW_LINE continue NEW_LINE DEDENT if ( turn % 2 == 0 ) : NEW_LINE INDENT cursize = n - rem NEW_LINE if ( cursize < m ) : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE DEDENT ans . append ( a [ m + rem ] ) NEW_LINE DEDENT else : NEW_LINE INDENT cursize = rem NEW_LINE if ( cursize < m ) : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE DEDENT ans . append ( a [ m ] ) NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
FIND_SUM_NON_REPEATING_DISTINCT_ELEMENTS_ARRAY | def findSum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum NEW_LINE DEDENT
GIVEN_NUMBER_STRING_FIND_NUMBER_CONTIGUOUS_SUBSEQUENCES_RECURSIVELY_ADD_9_SET_2 | def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 for i in range ( 9 ) ] NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT
CHECK_TWO_GIVEN_SETS_DISJOINT | def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( set1 [ i ] == set2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
UGLY_NUMBERS | def getNthUglyNo ( n ) : NEW_LINE INDENT ugly = [ 0 ] * n NEW_LINE ugly [ 0 ] = 1 NEW_LINE i2 = i3 = i5 = 0 NEW_LINE next_multiple_of_2 = 2 NEW_LINE next_multiple_of_3 = 3 NEW_LINE next_multiple_of_5 = 5 NEW_LINE for l in range ( 1 , n ) : NEW_LINE INDENT ugly [ l ] = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) NEW_LINE if ugly [ l ] == next_multiple_of_2 : NEW_LINE INDENT i2 += 1 NEW_LINE next_multiple_of_2 = ugly [ i2 ] * 2 NEW_LINE DEDENT if ugly [ l ] == next_multiple_of_3 : NEW_LINE INDENT i3 += 1 NEW_LINE next_multiple_of_3 = ugly [ i3 ] * 3 NEW_LINE DEDENT if ugly [ l ] == next_multiple_of_5 : NEW_LINE INDENT i5 += 1 NEW_LINE next_multiple_of_5 = ugly [ i5 ] * 5 NEW_LINE DEDENT DEDENT return ugly [ - 1 ] NEW_LINE DEDENT
FIND_BITONIC_POINT_GIVEN_BITONIC_SEQUENCE | def binarySearch ( arr , left , right ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] < arr [ mid + 1 ] ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , right ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , left , mid - 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
MINIMUM_TIME_TO_FINISH_TASKS_WITHOUT_SKIPPING_TWO_CONSECUTIVE | def minTime ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( excl , incl ) NEW_LINE excl_new = incl NEW_LINE incl = incl_new NEW_LINE excl = excl_new NEW_LINE DEDENT return min ( incl , excl ) NEW_LINE DEDENT
MAXIMUM_DIFFERENCE_ZEROS_ONES_BINARY_STRING_SET_2_TIME | def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT
MULTIPLICATIVE_INVERSE_UNDER_MODULO_M_1 | def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT
PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD | def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
FIND_THE_LARGEST_THREE_ELEMENTS_IN_AN_ARRAY | def find3largest ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( count < 4 ) : NEW_LINE INDENT if ( check != arr [ n - i ] ) : NEW_LINE INDENT print ( arr [ n - i ] , end = " ▁ " ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
FIND_NUMBER_CURRENCY_NOTES_SUM_UPTO_GIVEN_AMOUNT | def countCurrency ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE print ( " Currency ▁ Count ▁ - > ▁ " ) NEW_LINE for i , j in zip ( notes , noteCounter ) : NEW_LINE INDENT if amount >= i : NEW_LINE INDENT j = amount // i NEW_LINE amount = amount - j * i NEW_LINE print ( i , " ▁ : ▁ " , j ) NEW_LINE DEDENT DEDENT DEDENT
REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE | def translate ( st ) : NEW_LINE INDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( st [ i - 1 ] == ' A ' and st [ i ] == ' B ' ) : NEW_LINE INDENT st [ i - 1 ] = ' C ' NEW_LINE for j in range ( i , len ( st ) - 1 ) : NEW_LINE INDENT st [ j ] = st [ j + 1 ] NEW_LINE DEDENT st [ j ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE | def PrintMinNumberForPattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == " I " : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == " D " : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( " " , last_entry , end = " " ) NEW_LINE print ( " " , curr_max , end = " " ) NEW_LINE last_entry = curr_max NEW_LINE DEDENT else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( " " , last_entry , end = " " ) NEW_LINE DEDENT for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( " " , last_entry , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == " D " : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == " D " : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_max = noOfNextD + 2 NEW_LINE print ( " " , curr_max , curr_max - 1 , end = " " ) NEW_LINE last_entry = curr_max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " " , last_entry - 1 , end = " " ) NEW_LINE last_entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
NUMBER_OF_SUBSTRINGS_WITH_ODD_DECIMAL_VALUE_IN_A_BINARY_STRING | def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
NUMBER_SUBSTRINGS_DIVISIBLE_4_STRING_INTEGERS | def countDivisbleby4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
CHECK_TWO_GIVEN_SETS_DISJOINT_1 | def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT set1 . sort ( ) NEW_LINE set2 . sort ( ) NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( set1 [ i ] < set2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( set2 [ j ] < set1 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
COUNT_STRINGS_ADJACENT_CHARACTERS_DIFFERENCE_ONE | def countStrs ( n ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
COUNT_NUMBER_OF_SOLUTIONS_OF_X2_1_MOD_P_IN_GIVEN_RANGE | def findCountOfSolutions ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == 1 ) : NEW_LINE INDENT last = x + p * ( n / p ) NEW_LINE if ( last > n ) : NEW_LINE INDENT last -= p NEW_LINE DEDENT ans += ( ( last - x ) / p + 1 ) NEW_LINE DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT
CHECK_IF_A_NUMBER_IS_JUMBLED_OR_NOT | def checkJumbled ( num ) : NEW_LINE INDENT if ( num // 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num // 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = ( num // 10 ) % 10 NEW_LINE if ( abs ( digit2 - digit1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT | def maxProd ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_val = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) NEW_LINE DEDENT return max_val NEW_LINE DEDENT
PRINT_NUMBER_ASCENDING_ORDER_CONTAINS_1_2_3_DIGITS | def printNumbers ( numbers ) : NEW_LINE INDENT numbers = map ( str , numbers ) NEW_LINE result = [ ] NEW_LINE for num in numbers : NEW_LINE INDENT if ( '1' in num and '2' in num and '3' in num ) : NEW_LINE INDENT result . append ( num ) NEW_LINE DEDENT DEDENT if not result : NEW_LINE INDENT result = [ ' - 1' ] NEW_LINE DEDENT return sorted ( result ) ; NEW_LINE DEDENT
SWAP_ALL_ODD_AND_EVEN_BITS | def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits | odd_bits ) NEW_LINE DEDENT
DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_1 | def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT
MINIMUM_DIFFERENCE_MAX_MIN_K_SIZE_SUBSETS | def minDifferenceAmongMaxMin ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = sys . maxsize NEW_LINE for i in range ( ( N - K ) + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE DEDENT return res NEW_LINE DEDENT
BELL_NUMBERS_NUMBER_OF_WAYS_TO_PARTITION_A_SET | def bellNumber ( n ) : NEW_LINE INDENT bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE bell [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return bell [ n ] [ 0 ] NEW_LINE DEDENT
SMALLEST_SUM_CONTIGUOUS_SUBARRAY | def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_ending_here > 0 ) : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT
COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION | def countDer ( n ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE if ( n == 0 ) : return 1 NEW_LINE if ( n == 2 ) : return 1 NEW_LINE return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) NEW_LINE DEDENT
FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE | def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] NEW_LINE DEDENT DEDENT
SUM_FACTORS_NUMBER_1 | def sumofFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
GOOGLE_CASE_GIVEN_SENTENCE | def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = " " NEW_LINE s1 = s1 + s [ 0 ] . lower ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' and i <= n ) : NEW_LINE INDENT s1 = s1 + " ▁ " + ( s [ i + 1 ] ) . lower ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 = s1 + ( s [ i ] ) . upper ( ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return s1 NEW_LINE DEDENT
SIEVE_ERATOSTHENES_0N_TIME_COMPLEXITY | def manipulated_seive ( N ) : NEW_LINE INDENT isprime [ 0 ] = isprime [ 1 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if isprime [ i ] == True : NEW_LINE INDENT prime . append ( i ) NEW_LINE SPF [ i ] = i NEW_LINE DEDENT j = 0 NEW_LINE while ( j < len ( prime ) and i * prime [ j ] < N and prime [ j ] <= SPF [ i ] ) : NEW_LINE INDENT isprime [ i * prime [ j ] ] = False NEW_LINE SPF [ i * prime [ j ] ] = prime [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
COUNT_DIGITS_FACTORIAL_SET_2 | def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) NEW_LINE return math . floor ( x ) + 1 NEW_LINE DEDENT
SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M_1 | def countSubSeq ( A , N , M ) : NEW_LINE INDENT ans = 0 NEW_LINE h = [ 0 ] * M NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT A [ i ] = A [ i ] % M NEW_LINE h [ A [ i ] ] = h [ A [ i ] ] + 1 NEW_LINE DEDENT for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( i , M ) : NEW_LINE INDENT rem = ( M - ( i + j ) % M ) % M NEW_LINE if ( rem < j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == j and rem == j ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 NEW_LINE DEDENT elif ( i == j ) : NEW_LINE INDENT ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) NEW_LINE DEDENT elif ( i == rem ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 NEW_LINE DEDENT elif ( rem == j ) : NEW_LINE INDENT ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + h [ i ] * h [ j ] * h [ rem ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
SEARCHING_FOR_PATTERNS_SET_1_NAIVE_PATTERN_SEARCHING | def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i ) NEW_LINE DEDENT DEDENT DEDENT
SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE | def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1_1 | def isSubset ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE if m < n : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE while i < n and j < m : NEW_LINE INDENT if arr1 [ j ] < arr2 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif arr1 [ j ] == arr2 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT elif arr1 [ j ] > arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False if i < n else True NEW_LINE DEDENT
PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_2 | def getRemainder ( num , divisor ) : NEW_LINE INDENT while ( num >= divisor ) : NEW_LINE INDENT num -= divisor NEW_LINE DEDENT return num NEW_LINE DEDENT
MAXIMIZE_SUM_CONSECUTIVE_DIFFERENCES_CIRCULAR_ARRAY | def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT sum -= ( 2 * arr [ i ] ) NEW_LINE sum += ( 2 * arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
NUMBER_FULL_BINARY_TREES_NODE_PRODUCT_CHILDREN | def numoffbt ( arr , n ) : NEW_LINE INDENT maxvalue = - sys . maxsize NEW_LINE minvalue = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxvalue = max ( maxvalue , arr [ i ] ) NEW_LINE minvalue = min ( minvalue , arr [ i ] ) NEW_LINE DEDENT mark = [ 0 for i in range ( maxvalue + 2 ) ] NEW_LINE value = [ 0 for i in range ( maxvalue + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mark [ arr [ i ] ] = 1 NEW_LINE value [ arr [ i ] ] = 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( minvalue , maxvalue + 1 ) : NEW_LINE INDENT if ( mark [ i ] != 0 ) : NEW_LINE INDENT j = i + i NEW_LINE while ( j <= maxvalue and j // i <= i ) : NEW_LINE INDENT if ( mark [ j ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) NEW_LINE if ( i != j // i ) : NEW_LINE INDENT value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) NEW_LINE DEDENT j += i NEW_LINE DEDENT DEDENT ans += value [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
PRINT_N_X_N_SPIRAL_MATRIX_USING_O1_EXTRA_SPACE | def printSpiral ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) NEW_LINE if ( i <= j ) : NEW_LINE INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = " \t " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = " \t " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
PROGRAM_BINOMIAL_COEFFICIENTS_TABLE | def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( " \n " , end = ' ' ) NEW_LINE DEDENT DEDENT
SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M | def coutSubSeq ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE INDENT sum = A [ i ] + A [ j ] + A [ k ] NEW_LINE if ( sum % M == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
MINIMIZE_MAXAI_BJ_CK_MINAI_BJ_CK_THREE_DIFFERENT_SORTED_ARRAYS | def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT
MAXIMUM_SUM_ABSOLUTE_DIFFERENCE_ARRAY | def MaxSumDifference ( a , n ) : NEW_LINE INDENT np . sort ( a ) NEW_LINE j = 0 NEW_LINE finalSequence = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT finalSequence [ j ] = a [ i ] NEW_LINE finalSequence [ j + 1 ] = a [ n - i - 1 ] NEW_LINE j = j + 2 NEW_LINE DEDENT MaximumSum = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) NEW_LINE DEDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) NEW_LINE print ( MaximumSum ) NEW_LINE DEDENT
MAXIMUM_NUMBER_2X2_SQUARES_CAN_FIT_INSIDE_RIGHT_ISOSCELES_TRIANGLE | def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base / 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT
AREA_OF_A_HEXAGON | def hexagonArea ( s ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 ) NEW_LINE DEDENT
PROGRAM_TO_PRINT_DOUBLE_HEADED_ARROW_PATTERN | def drawPattern ( N ) : NEW_LINE INDENT n = N NEW_LINE row = 1 NEW_LINE nst = 1 NEW_LINE nsp1 = n - 1 NEW_LINE nsp2 = - 1 NEW_LINE val1 = row NEW_LINE val2 = 1 NEW_LINE while ( row <= n ) : NEW_LINE INDENT csp1 = 1 NEW_LINE while ( csp1 <= nsp1 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE csp1 = csp1 + 1 NEW_LINE DEDENT cst1 = 1 NEW_LINE while ( cst1 <= nst ) : NEW_LINE INDENT print ( val1 , end = " ▁ " ) NEW_LINE val1 = val1 - 1 NEW_LINE cst1 = cst1 + 1 NEW_LINE DEDENT csp2 = 1 NEW_LINE while ( csp2 <= nsp2 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE csp2 = csp2 + 1 NEW_LINE DEDENT if ( row != 1 and row != n ) : NEW_LINE INDENT cst2 = 1 NEW_LINE while ( cst2 <= nst ) : NEW_LINE INDENT print ( val2 , end = " ▁ " ) NEW_LINE val2 = val2 + 1 NEW_LINE cst2 = cst2 + 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( row <= n // 2 ) : NEW_LINE INDENT nst = nst + 1 NEW_LINE nsp1 = nsp1 - 2 NEW_LINE nsp2 = nsp2 + 2 NEW_LINE val1 = row + 1 NEW_LINE val2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT nst = nst - 1 NEW_LINE nsp1 = nsp1 + 2 NEW_LINE nsp2 = nsp2 - 2 NEW_LINE val1 = n - row NEW_LINE val2 = 1 NEW_LINE DEDENT row = row + 1 NEW_LINE DEDENT DEDENT
COIN_GAME_WINNER_EVERY_PLAYER_THREE_CHOICES | def findWinner ( x , y , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = False NEW_LINE dp [ 1 ] = True NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i - 1 >= 0 and not dp [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - x >= 0 and not dp [ i - x ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - y >= 0 and not dp [ i - y ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = False NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
DIFFERENCE_MAXIMUM_SUM_MINIMUM_SUM_N_M_ELEMENTSIN_REVIEW | def find_difference ( arr , n , m ) : NEW_LINE INDENT max = 0 min = 0 NEW_LINE arr . sort ( ) NEW_LINE j = n - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT min += arr [ i ] NEW_LINE max += arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT return ( max - min ) NEW_LINE DEDENT
SORTING_ARRAY_REVERSE_AROUND_MIDDLE | def ifPossible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
DOUBLE_FACTORIAL | def doublefactorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) NEW_LINE DEDENT
SQUARE_ROOT_OF_AN_INTEGER_1 | def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT start = 1 NEW_LINE end = x NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( mid * mid == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid * mid < x ) : NEW_LINE INDENT start = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
PRINT_WORDS_STRING_REVERSE_ORDER | def wordReverse ( str ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE start = end = i + 1 NEW_LINE result = ' ' NEW_LINE while i >= 0 : NEW_LINE INDENT if str [ i ] == ' ▁ ' : NEW_LINE INDENT start = i + 1 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT result += ' ▁ ' NEW_LINE end = i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT start = 0 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH_1 | def shortestPath ( graph , u , v , k ) : NEW_LINE INDENT global V , INF NEW_LINE sp = [ [ None ] * V for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT sp [ i ] [ j ] = [ None ] * ( k + 1 ) NEW_LINE DEDENT DEDENT for e in range ( k + 1 ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = INF NEW_LINE if ( e == 0 and i == j ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = 0 NEW_LINE DEDENT if ( e == 1 and graph [ i ] [ j ] != INF ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] NEW_LINE DEDENT if ( e > 1 ) : NEW_LINE INDENT for a in range ( V ) : NEW_LINE INDENT if ( graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return sp [ u ] [ v ] [ k ] NEW_LINE DEDENT
PROGRAM_CHECK_WATER_TANK_OVERFLOWS_N_SOLID_BALLS_DIPPED_WATER_TANK | def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT
EXPECTATION_EXPECTED_VALUE_ARRAY | def calc_Expectation ( a , n ) : NEW_LINE INDENT prb = 1 / n NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( a [ i ] * prb ) NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT
FIND_UNCOMMON_CHARACTERS_TWO_STRINGS | def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT present [ i ] = 0 NEW_LINE DEDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( 0 , l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS | def printDistinct ( str ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT n = i NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) ] == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_1 | def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT index = n NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( int ) ( ( left + right ) / 2 ) NEW_LINE if ( arr2 [ mid ] == arr1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE | def nobleInteger ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS | def countStr ( n , bCount , cCount ) : NEW_LINE INDENT if ( bCount < 0 or cCount < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bCount == 0 and cCount == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = countStr ( n - 1 , bCount , cCount ) NEW_LINE res += countStr ( n - 1 , bCount - 1 , cCount ) NEW_LINE res += countStr ( n - 1 , bCount , cCount - 1 ) NEW_LINE return res NEW_LINE DEDENT
GCD_FACTORIALS_TWO_NUMBERS | def gcdOfFactorial ( m , n ) : NEW_LINE INDENT return math . factorial ( min ( m , n ) ) NEW_LINE DEDENT
FIND_SUBARRAY_WITH_GIVEN_SUM_IN_ARRAY_OF_INTEGERS | def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT Map = { } NEW_LINE curr_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE if curr_sum == Sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ 0 ▁ to " , i ) NEW_LINE return NEW_LINE DEDENT if ( curr_sum - Sum ) in Map : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes " , \ Map [ curr_sum - Sum ] + 1 , " to " , i ) NEW_LINE return NEW_LINE DEDENT Map [ curr_sum ] = i NEW_LINE DEDENT print ( " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ) NEW_LINE DEDENT
CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED | def checkReverse ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for front in range ( n ) : NEW_LINE INDENT if temp [ front ] != arr [ front ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for back in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if temp [ back ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if front >= back : NEW_LINE INDENT return True NEW_LINE DEDENT while front != back : NEW_LINE INDENT front += 1 NEW_LINE if arr [ front - 1 ] < arr [ front ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
FIND_FREQUENCY_EVEN_ODD_NUMBERS_MATRIX | def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even ) NEW_LINE DEDENT
LENGTH_LONGEST_STRICT_BITONIC_SUBSEQUENCE | def longLenStrictBitonicSub ( arr , n ) : NEW_LINE INDENT inc , dcr = dict ( ) , dict ( ) NEW_LINE len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if inc . get ( arr [ i ] - 1 ) in inc . values ( ) : NEW_LINE INDENT len = inc . get ( arr [ i ] - 1 ) NEW_LINE DEDENT inc [ arr [ i ] ] = len_inc [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT len = 0 NEW_LINE if dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) : NEW_LINE INDENT len = dcr . get ( arr [ i ] - 1 ) NEW_LINE DEDENT dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) : NEW_LINE INDENT longLen = len_inc [ i ] + len_dcr [ i ] - 1 NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
HOW_TO_COMPUTE_MOD_OF_A_BIG_NUMBER | def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) ) % a NEW_LINE DEDENT return res NEW_LINE DEDENT
PRINT_SHORTEST_COMMON_SUPERSEQUENCE | def printShortestSuperSeq ( x , y ) : NEW_LINE INDENT m = len ( x ) NEW_LINE n = len ( y ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT index = dp [ m ] [ n ] NEW_LINE string = " " NEW_LINE i = m NEW_LINE j = n NEW_LINE while i > 0 and j > 0 : NEW_LINE INDENT if x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] : NEW_LINE INDENT string += y [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while i > 0 : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT while j > 0 : NEW_LINE INDENT string += y [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT string = list ( string ) NEW_LINE string . reverse ( ) NEW_LINE return ' ' . join ( string ) NEW_LINE DEDENT
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_1 | def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
COUNT_NUMBER_OF_WAYS_TO_FILL_A_N_X_4_GRID_USING_1_X_4_TILES | def count ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
NUMBER_TRIANGLES_N_MOVES | def numberOfTriangles ( n ) : NEW_LINE INDENT answer = [ None ] * ( n + 1 ) NEW_LINE answer [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT answer [ i ] = answer [ i - 1 ] * 3 + 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return answer [ n ] NEW_LINE DEDENT
WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN | def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE elif ( int ( y % 2 ) == 0 ) : NEW_LINE INDENT return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT DEDENT
CHECK_LINE_PASSES_ORIGIN | def checkOrigin ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) NEW_LINE DEDENT
WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN_1 | def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : return x * temp * temp NEW_LINE else : return ( temp * temp ) / x NEW_LINE DEDENT DEDENT
FIND_DISTINCT_SUBSET_SUBSEQUENCE_SUMS_ARRAY | def printDistSum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
COUNT_POSSIBLE_WAYS_TO_CONSTRUCT_BUILDINGS | def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT countB = 1 NEW_LINE countS = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT prev_countB = countB NEW_LINE prev_countS = countS NEW_LINE countS = prev_countB + prev_countS NEW_LINE countB = prev_countS NEW_LINE DEDENT result = countS + countB NEW_LINE return ( result * result ) NEW_LINE DEDENT
PROGRAM_FOR_SCALAR_MULTIPLICATION_OF_A_MATRIX | def scalarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT
FIND_MAXIMUM_VALUE_OF_SUM_IARRI_WITH_ONLY_ROTATIONS_ON_GIVEN_ARRAY_ALLOWED | def maxSum ( arr ) : NEW_LINE INDENT arrSum = 0 NEW_LINE currVal = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arrSum = arrSum + arr [ i ] NEW_LINE currVal = currVal + ( i * arr [ i ] ) NEW_LINE DEDENT maxVal = currVal NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT currVal = currVal + arrSum - n * arr [ n - j ] NEW_LINE if currVal > maxVal : NEW_LINE INDENT maxVal = currVal NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT
LOWER_INSERTION_POINT | def LowerInsertionPoint ( arr , n , X ) : NEW_LINE INDENT if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lowerPnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lowerPnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT while ( lowerPnt < n and arr [ lowerPnt ] < X ) : NEW_LINE INDENT lowerPnt += 1 NEW_LINE DEDENT return lowerPnt NEW_LINE DEDENT
CHOCOLATE_DISTRIBUTION_PROBLEM | def findMinDiff ( arr , n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT min_diff = sys . maxsize NEW_LINE first = 0 NEW_LINE last = 0 NEW_LINE i = 0 NEW_LINE while ( i + m - 1 < n ) : NEW_LINE INDENT diff = arr [ i + m - 1 ] - arr [ i ] NEW_LINE if ( diff < min_diff ) : NEW_LINE INDENT min_diff = diff NEW_LINE first = i NEW_LINE last = i + m - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( arr [ last ] - arr [ first ] ) NEW_LINE DEDENT
REMOVE_MINIMUM_NUMBER_ELEMENTS_NO_COMMON_ELEMENT_EXIST_ARRAY | def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT countB [ b [ i ] ] = countB . get ( b [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in countA : NEW_LINE INDENT if x in countB . keys ( ) : NEW_LINE INDENT res += min ( countA [ x ] , countB [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
0_1_KNAPSACK_PROBLEM_DP_10_1 | def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE | def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return arr [ n - 1 ] < arr [ n - 2 ] and arraySortedOrNot ( arr [ 1 : ] , n - 1 ) NEW_LINE DEDENT
SCHEDULE_ELEVATOR_TO_REDUCE_THE_TOTAL_TIME_TAKEN | def minTime ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE minTime = 0 NEW_LINE for i in range ( 0 , n , k ) : NEW_LINE INDENT minTime += ( 2 * a [ i ] ) NEW_LINE DEDENT return minTime NEW_LINE DEDENT
SEARCH_INSERT_AND_DELETE_IN_AN_UNSORTED_ARRAY | def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
MAXIMUM_UNIQUE_ELEMENT_EVERY_SUBARRAY_SIZE_K | def find_max ( A , N , K ) : NEW_LINE INDENT Count = dict ( ) NEW_LINE for i in range ( K - 1 ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE DEDENT Myset = dict ( ) NEW_LINE for x in Count : NEW_LINE INDENT if ( Count [ x ] == 1 ) : NEW_LINE INDENT Myset [ x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( K - 1 , N ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE if ( Count [ A [ i ] ] == 1 ) : NEW_LINE INDENT Myset [ A [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT del Myset [ A [ i ] ] NEW_LINE DEDENT if ( len ( Myset ) == 0 ) : NEW_LINE INDENT print ( " Nothing " ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = - 10 ** 9 NEW_LINE for i in Myset : NEW_LINE INDENT maxm = max ( i , maxm ) NEW_LINE DEDENT print ( maxm ) NEW_LINE DEDENT x = A [ i - K + 1 ] NEW_LINE if x in Count . keys ( ) : NEW_LINE INDENT Count [ x ] -= 1 NEW_LINE if ( Count [ x ] == 1 ) : NEW_LINE INDENT Myset [ x ] = 1 NEW_LINE DEDENT if ( Count [ x ] == 0 ) : NEW_LINE INDENT del Myset [ x ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS | def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
NUMBER_NODES_TWO_VERTICES_ACYCLIC_GRAPH_DISJOINT_UNION_METHOD | def totalNodes ( adjac , n , x , y ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE p = [ None ] * n NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( x ) NEW_LINE visited [ x ] = True NEW_LINE m = None NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT m = q . get ( ) NEW_LINE for i in range ( len ( adjac [ m ] ) ) : NEW_LINE INDENT h = adjac [ m ] [ i ] NEW_LINE if ( not visited [ h ] ) : NEW_LINE INDENT visited [ h ] = True NEW_LINE p [ h ] = m NEW_LINE q . put ( h ) NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE i = p [ y ] NEW_LINE while ( i != x ) : NEW_LINE INDENT count += 1 NEW_LINE i = p [ i ] NEW_LINE DEDENT return count NEW_LINE DEDENT
MAGICAL_INDICES_ARRAY | def solve ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE parent = [ None ] * ( n + 1 ) NEW_LINE vis = [ None ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT parent [ i ] = - 1 NEW_LINE vis [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = i NEW_LINE if ( parent [ j ] == - 1 ) : NEW_LINE INDENT while ( parent [ j ] == - 1 ) : NEW_LINE INDENT parent [ j ] = i NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT if ( parent [ j ] == i ) : NEW_LINE INDENT while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE cnt = cnt + 1 NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
COUNT_SUBARRAYS_TOTAL_DISTINCT_ELEMENTS_ORIGINAL_ARRAY | def countDistictSubarray ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vid = dict ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while ( right < n and window < k ) : NEW_LINE INDENT if arr [ right ] in vid . keys ( ) : NEW_LINE INDENT vid [ arr [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vid [ arr [ right ] ] = 1 NEW_LINE DEDENT if ( vid [ arr [ right ] ] == 1 ) : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if ( window == k ) : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vid [ arr [ left ] ] -= 1 NEW_LINE if ( vid [ arr [ left ] ] == 0 ) : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
MAKING_ELEMENTS_OF_TWO_ARRAYS_SAME_WITH_MINIMUM_INCREMENTDECREMENT | def MinOperation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
MINIMUM_HEIGHT_TRIANGLE_GIVEN_BASE_AREA | def minHeight ( area , base ) : NEW_LINE INDENT return math . ceil ( ( 2 * area ) / base ) NEW_LINE DEDENT
CHECK_GIVEN_SENTENCE_GIVEN_SET_SIMPLE_GRAMMER_RULES | def checkSentence ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE if string [ 0 ] < ' A ' or string [ 0 ] > ' Z ' : NEW_LINE INDENT return False NEW_LINE DEDENT if string [ length - 1 ] != ' . ' : NEW_LINE INDENT return False NEW_LINE DEDENT prev_state = 0 NEW_LINE curr_state = 0 NEW_LINE index = 1 NEW_LINE while ( string [ index ] ) : NEW_LINE INDENT if string [ index ] >= ' A ' and string [ index ] <= ' Z ' : NEW_LINE INDENT curr_state = 0 NEW_LINE DEDENT elif string [ index ] == ' ▁ ' : NEW_LINE INDENT curr_state = 1 NEW_LINE DEDENT elif string [ index ] >= ' a ' and string [ index ] <= ' z ' : NEW_LINE INDENT curr_state = 2 NEW_LINE DEDENT elif string [ index ] == ' . ' : NEW_LINE INDENT curr_state = 3 NEW_LINE DEDENT if prev_state == curr_state and curr_state != 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if prev_state == 2 and curr_state == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if curr_state == 3 and prev_state != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT index += 1 NEW_LINE prev_state = curr_state NEW_LINE DEDENT return False NEW_LINE DEDENT
ALTERNATIVE_SORTING | def alternateSort ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE j -= 1 NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
POSITION_OF_RIGHTMOST_SET_BIT | def getFirstSetBitPos ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_1 | def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 9 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
MAXIMUM_EQULIBRIUM_SUM_ARRAY | def findMaxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE DEDENT suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_sum == suffix_sum ) : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
SECTION_FORMULA_POINT_DIVIDES_LINE_GIVEN_RATIO | def section ( x1 , x2 , y1 , y2 , m , n ) : NEW_LINE INDENT x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) NEW_LINE y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) NEW_LINE print ( x , y ) NEW_LINE DEDENT
CHECK_EXIST_TWO_ELEMENTS_ARRAY_WHOSE_SUM_EQUAL_SUM_REST_ARRAY | def checkPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = sum / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = sum - arr [ i ] NEW_LINE if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if val in s : NEW_LINE INDENT print ( " Pair ▁ elements ▁ are " , arr [ i ] , " and " , int ( val ) ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
COUNT_FIBONACCI_NUMBERS_GIVEN_RANGE_LOG_TIME | def countFibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT
SPLIT_N_MAXIMUM_COMPOSITE_NUMBERS | def count ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rem = n % 4 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT if ( rem == 1 ) : NEW_LINE INDENT if ( n < 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 9 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT return ( n - 6 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT if ( n < 15 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 15 ) // 4 + 2 NEW_LINE DEDENT DEDENT
KTH_NON_REPEATING_CHARACTER | def kthNonRepeating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT
BIRTHDAY_PARADOX | def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) NEW_LINE DEDENT
PROGRAM_FIND_MID_POINT_LINE | def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , ▁ " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT
GROUP_MULTIPLE_OCCURRENCE_OF_ARRAY_ELEMENTS_ORDERED_BY_FIRST_OCCURRENCE | def groupElements ( arr , n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE visited [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
CHECK_TWO_STRINGS_K_ANAGRAMS_NOT | def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT
FIND_THE_NEAREST_SMALLER_NUMBERS_ON_LEFT_SIDE_IN_AN_ARRAY | def printPrevSmaller ( arr , n ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , " , ▁ " , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
LONGEST_COMMON_SUBSTRING_1 | def lcs ( i , j , count ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT count = lcs ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT
FIND_THE_LARGEST_PAIR_SUM_IN_AN_UNSORTED_ARRAY | def findLargestSumPair ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT first = arr [ 0 ] NEW_LINE second = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT first = arr [ 1 ] NEW_LINE second = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second and arr [ i ] != first : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return ( first + second ) NEW_LINE DEDENT
CHECK_WHETHER_NUMBER_DUCK_NUMBER_NOT | def check_duck ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE count_zero = 0 NEW_LINE i = 1 NEW_LINE while i < l : NEW_LINE INDENT ch = num [ i ] NEW_LINE if ( ch == "0" ) : NEW_LINE INDENT count_zero = count_zero + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return count_zero NEW_LINE DEDENT
CHECK_OCCURRENCES_CHARACTER_APPEAR_TOGETHER | def checkIfAllTogether ( s , c ) : NEW_LINE INDENT oneSeen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT if ( oneSeen == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < n and s [ i ] == c ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED_1 | def areElementsContiguous ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr [ : n ] : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT
FIND_MINIMUM_SUM_FACTORS_NUMBER | def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT
MINIMUM_SUM_SQUARES_CHARACTERS_COUNTS_GIVEN_STRING_REMOVING_K_CHARACTERS | def minStringValue ( str , k ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( k >= l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT frequency = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT frequency [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT q = PriorityQueue ( ) NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT q . put ( - frequency [ i ] ) NEW_LINE DEDENT while ( k > 0 ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp + 1 NEW_LINE q . put ( temp , temp ) NEW_LINE k = k - 1 NEW_LINE DEDENT result = 0 ; NEW_LINE while not q . empty ( ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp * ( - 1 ) NEW_LINE result += temp * temp NEW_LINE DEDENT return result NEW_LINE DEDENT
PRINT_FIBONACCI_SERIES_REVERSE_ORDER | def reverseFibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S | def countSubarrWithEqualZeroAndOne ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) NEW_LINE if um . get ( curr_sum ) : NEW_LINE INDENT um [ curr_sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ curr_sum ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for itr in um : NEW_LINE INDENT if um [ itr ] > 1 : NEW_LINE INDENT count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) NEW_LINE DEDENT DEDENT if um . get ( 0 ) : NEW_LINE INDENT count += um [ 0 ] NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
LUCKY_NUMBERS | def isLucky ( n ) : NEW_LINE INDENT next_position = n NEW_LINE if isLucky . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % isLucky . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT next_position = next_position - next_position / isLucky . counter NEW_LINE isLucky . counter = isLucky . counter + 1 NEW_LINE return isLucky ( next_position ) NEW_LINE DEDENT
NUMBER_SUBSTRINGS_DIVISIBLE_8_NOT_3 | def count ( s , Len ) : NEW_LINE INDENT global MAX NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE Sum = [ 0 ] * MAX NEW_LINE dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE Sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ Sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i - 2 >= 0 : NEW_LINE INDENT dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = dprev * 10 + dig NEW_LINE if ( value % 8 == 0 ) and ( value % 3 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if i - 3 >= 0 : NEW_LINE INDENT dprev2 = int ( s [ i - 3 ] ) - 48 NEW_LINE dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = ( dprev2 * 100 + dprev * 10 + dig ) NEW_LINE if value % 8 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans += ( i - 2 ) NEW_LINE ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N | def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME | def canFormPalindrome ( st ) : NEW_LINE INDENT count = [ 0 ] * ( NO_OF_CHARS ) NEW_LINE for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( 0 , NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
SQUARE_ROOT_OF_A_PERFECT_SQUARE_1 | def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE while ( x > y ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY_1 | def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
DYCK_PATH | def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
MOVE_ZEROES_END_ARRAY | def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
CONVERTING_ONE_STRING_USING_APPEND_DELETE_LAST_OPERATIONS | def isConvertible ( str1 , str2 , k ) : NEW_LINE INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) : NEW_LINE INDENT return True NEW_LINE DEDENT commonLength = 0 NEW_LINE for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT commonLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
COUNT_ELEMENTS_WHICH_DIVIDE_ALL_NUMBERS_IN_RANGE_L_R | def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE_1 | def swap ( xp , yp ) : NEW_LINE INDENT if ( xp [ 0 ] == yp [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT xp [ 0 ] = xp [ 0 ] + yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE DEDENT
MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES_1 | def maxProfit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ k ] [ n - 1 ] NEW_LINE DEDENT
FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND | def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
NUMBER_OF_TRIANGLES_IN_A_PLANE_IF_NO_MORE_THAN_TWO_POINTS_ARE_COLLINEAR | def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT
SORTED_ORDER_PRINTING_OF_AN_ARRAY_THAT_REPRESENTS_A_BST | def printSorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " ▁ " ) NEW_LINE printSorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT
SEARCH_IN_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX | def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( " n ▁ Found ▁ at ▁ " , i , " , ▁ " , j ) NEW_LINE return 1 NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( " Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_1 | def findInteger ( arr , n ) : NEW_LINE INDENT neg = 0 NEW_LINE pos = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return ( sum / abs ( neg - pos ) ) NEW_LINE DEDENT
COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP | def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
SMALLEST_NUMBER_SUM_DIGITS_N_DIVISIBLE_10N | def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "9" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
CHECK_LINE_TOUCHES_INTERSECTS_CIRCLE | def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT
FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS_1 | def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
AREA_CIRCUMSCRIBED_CIRCLE_SQUARE | def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT
FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY | def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index NEW_LINE DEDENT
LONGEST_PALINDROME_SUBSEQUENCE_SPACE | def lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT back_up = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT a [ j ] = 1 NEW_LINE DEDENT elif s [ i ] == s [ j ] : NEW_LINE INDENT temp = a [ j ] NEW_LINE a [ j ] = back_up + 2 NEW_LINE back_up = temp NEW_LINE DEDENT else : NEW_LINE INDENT back_up = a [ j ] NEW_LINE a [ j ] = max ( a [ j - 1 ] , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return a [ n - 1 ] NEW_LINE DEDENT
SQUARE_ROOT_NUMBER_USING_LOG | def squareRoot ( n ) : NEW_LINE INDENT return pow ( 2 , 0.5 * math . log2 ( n ) ) NEW_LINE DEDENT
K_SMALLEST_ELEMENTS_ORDER_USING_O1_EXTRA_SPACE | def printSmall ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT max_var = arr [ k - 1 ] NEW_LINE pos = k - 1 NEW_LINE for j in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] > max_var ) : NEW_LINE INDENT max_var = arr [ j ] NEW_LINE pos = j NEW_LINE DEDENT DEDENT if ( max_var > arr [ i ] ) : NEW_LINE INDENT j = pos NEW_LINE while ( j < k - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ k - 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
REPRESENT_GIVEN_SET_POINTS_BEST_POSSIBLE_STRAIGHT_LINE | def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n NEW_LINE print ( " m ▁ = ▁ " , m ) NEW_LINE print ( " c ▁ = ▁ " , c ) NEW_LINE DEDENT
PROGRAM_SUM_COSX_SERIES | def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT
PRINT_UNIQUE_ROWS | def printArray ( matrix ) : NEW_LINE INDENT rowCount = len ( matrix ) NEW_LINE if rowCount == 0 : NEW_LINE INDENT return NEW_LINE DEDENT columnCount = len ( matrix [ 0 ] ) NEW_LINE if columnCount == 0 : NEW_LINE INDENT return NEW_LINE DEDENT row_output_format = " ▁ " . join ( [ " % s " ] * columnCount ) NEW_LINE printed = { } NEW_LINE for row in matrix : NEW_LINE INDENT routput = row_output_format % tuple ( row ) NEW_LINE if routput not in printed : NEW_LINE INDENT printed [ routput ] = True NEW_LINE print ( routput ) NEW_LINE DEDENT DEDENT DEDENT
ONE_LINE_FUNCTION_FOR_FACTORIAL_OF_A_NUMBER | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
PAINTING_FENCE_ALGORITHM | def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT
FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY | def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
PADOVAN_SEQUENCE | def pad ( n ) : NEW_LINE INDENT pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = pPrevPrev + pPrev NEW_LINE pPrevPrev = pPrev NEW_LINE pPrev = pCurr NEW_LINE pCurr = pNext NEW_LINE DEDENT return pNext ; NEW_LINE DEDENT
FIND_MAXIMUM_HEIGHT_PYRAMID_FROM_THE_GIVEN_ARRAY_OF_OBJECTS | def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE ans = 1 NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES_1 | def MaximumHeight ( a , n ) : NEW_LINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2 NEW_LINE DEDENT
COUNT_SINGLE_NODE_ISOLATED_SUB_GRAPHS_DISCONNECTED_GRAPH | def compute ( graph , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( len ( graph [ i ] ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
PRODUCT_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING | def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
A_PRODUCT_ARRAY_PUZZLE | def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE prod = [ 0 ] * n NEW_LINE left [ 0 ] = 1 NEW_LINE right [ n - 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left [ i ] = arr [ i - 1 ] * left [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ j ] = arr [ j + 1 ] * right [ j + 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT prod [ i ] = left [ i ] * right [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X_1 | def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( ( x - arr2 [ j ] ) in s ) : NEW_LINE INDENT print ( ( x - arr2 [ j ] ) , ' ' , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
SUM_SERIES_12_32_52_2N_12_1 | def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT
K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY_1 | def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME_WITH_PERMUTATIONS_ALLOWED | def minInsertion ( tr1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] % 2 == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res - 1 NEW_LINE DEDENT DEDENT
PRINT_STRING_IGNORING_ALTERNATE_OCCURRENCES_CHARACTER | def printStringAlternate ( string ) : NEW_LINE INDENT occ = { } NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT temp = string [ i ] . lower ( ) NEW_LINE occ [ temp ] = occ . get ( temp , 0 ) + 1 NEW_LINE if occ [ temp ] & 1 : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
MAXIMUM_TRIPLET_SUM_ARRAY_2 | def maxTripletSum ( arr , n ) : NEW_LINE INDENT maxA = - sys . maxsize NEW_LINE maxB = - sys . maxsize NEW_LINE maxC = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxC = arr [ i ] NEW_LINE DEDENT DEDENT return ( maxA + maxB + maxC ) NEW_LINE DEDENT
FIND_DAY_OF_THE_WEEK_FOR_A_GIVEN_DATE | def dayofweek ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= m < 3 NEW_LINE return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) NEW_LINE DEDENT
PRINTING_LONGEST_INCREASING_CONSECUTIVE_SUBSEQUENCE | def longestSubsequence ( a , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 13 ) } NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] - 1 ) in mp ) : NEW_LINE INDENT lastIndex = mp [ a [ i ] - 1 ] - 1 NEW_LINE dp [ i ] = 1 + dp [ lastIndex ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT mp [ a [ i ] ] = i + 1 NEW_LINE if ( maximum < dp [ i ] ) : NEW_LINE INDENT maximum = dp [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE DEDENT DEDENT
CHECK_NUMBER_POWER_K_USING_BASE_CHANGING_METHOD | def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT
FIND_NUMBER_PAIRS_ARRAY_XOR_0 | def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT
FIND_EQUAL_POINT_STRING_BRACKETS | def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ 0 ] * ( l + 1 ) NEW_LINE close = [ 0 ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO | def findTriplets ( arr , n ) : NEW_LINE INDENT found = True NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] , arr [ k ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ not ▁ exist ▁ " ) NEW_LINE DEDENT DEDENT
POSITION_ELEMENT_STABLE_SORT | def getIndexInSortedArray ( arr , n , idx ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ idx ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( arr [ i ] == arr [ idx ] and i < idx ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
LONGEST_REPEATING_AND_NON_OVERLAPPING_SUBSTRING | def longestRepeatedSubstring ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE LCSRe = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE res = " " NEW_LINE res_length = 0 NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) : NEW_LINE INDENT LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 NEW_LINE if ( LCSRe [ i ] [ j ] > res_length ) : NEW_LINE INDENT res_length = LCSRe [ i ] [ j ] NEW_LINE index = max ( i , index ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT LCSRe [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT if ( res_length > 0 ) : NEW_LINE INDENT for i in range ( index - res_length + 1 , index + 1 ) : NEW_LINE INDENT res = res + str [ i - 1 ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
BUBBLE_SORT_1 | def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT swapped = False NEW_LINE for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if swapped == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
MINIMUM_STEPS_TO_DELETE_A_STRING_AFTER_REPEATED_DELETION_OF_PALINDROME_SUBSTRINGS | def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
FLOOR_IN_A_SORTED_ARRAY_1 | def floorSearch ( arr , low , high , x ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( x >= arr [ high ] ) : NEW_LINE INDENT return high NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( x < arr [ mid ] ) : NEW_LINE INDENT return floorSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT return floorSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT
CHECK_WHETHER_TWO_STRINGS_ARE_ANAGRAM_OF_EACH_OTHER | def areAnagram ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if n1 != n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT str1 = sorted ( str1 ) NEW_LINE str2 = sorted ( str2 ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
MAXIMUM_SEGMENT_VALUE_PUTTING_K_BREAKPOINTS_NUMBER | def findMaxSegment ( s , k ) : NEW_LINE INDENT seg_len = len ( s ) - k NEW_LINE res = 0 NEW_LINE for i in range ( seg_len ) : NEW_LINE INDENT res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT seg_len_pow = pow ( 10 , seg_len - 1 ) NEW_LINE curr_val = res NEW_LINE for i in range ( 1 , len ( s ) - seg_len ) : NEW_LINE INDENT curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow NEW_LINE curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) NEW_LINE res = max ( res , curr_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
REARRANGE_ARRAY_ORDER_SMALLEST_LARGEST_2ND_SMALLEST_2ND_LARGEST | def rearrangeArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE tempArr = [ 0 ] * ( n + 1 ) NEW_LINE ArrIndex = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i <= n // 2 or j > n // 2 ) : NEW_LINE INDENT tempArr [ ArrIndex ] = arr [ i ] NEW_LINE ArrIndex = ArrIndex + 1 NEW_LINE tempArr [ ArrIndex ] = arr [ j ] NEW_LINE ArrIndex = ArrIndex + 1 NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = tempArr [ i ] NEW_LINE DEDENT DEDENT
FREQUENT_ELEMENT_ARRAY | def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 res = arr [ 0 ] curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
SUM_SERIES_555555_N_TERMS | def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT
MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_2 | def minSum ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE num1 , num2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE DEDENT DEDENT return num2 + num1 NEW_LINE DEDENT
REQUIRED_MINIMUM_DIGITS_REMOVE_NUMBER_MAKE_PERFECT_SQUARE | def perfectSquare ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - 1 NEW_LINE num = " " NEW_LINE for i in range ( 1 , ( 1 << n ) ) : NEW_LINE INDENT str = " " NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) : NEW_LINE INDENT str = str + s [ j ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] != '0' ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT k = int ( math . sqrt ( temp ) ) NEW_LINE if ( k * k == temp ) : NEW_LINE INDENT if ( ans < len ( str ) ) : NEW_LINE INDENT ans = len ( str ) NEW_LINE num = str NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { } ▁ " . format ( num ) , end = " " ) NEW_LINE return n - ans NEW_LINE DEDENT DEDENT
PROGRAM_CHECK_PLUS_PERFECT_NUMBER | def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x // 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x // 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT
STACK_PERMUTATIONS_CHECK_IF_AN_ARRAY_IS_STACK_PERMUTATION_OF_OTHER | def checkStackPermutation ( ip , op , n ) : NEW_LINE INDENT Input = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Input . put ( ip [ i ] ) NEW_LINE DEDENT output = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . put ( op [ i ] ) NEW_LINE DEDENT tempStack = [ ] NEW_LINE while ( not Input . empty ( ) ) : NEW_LINE INDENT ele = Input . queue [ 0 ] NEW_LINE Input . get ( ) NEW_LINE if ( ele == output . queue [ 0 ] ) : NEW_LINE INDENT output . get ( ) NEW_LINE while ( len ( tempStack ) != 0 ) : NEW_LINE INDENT if ( tempStack [ - 1 ] == output . queue [ 0 ] ) : NEW_LINE INDENT tempStack . pop ( ) NEW_LINE output . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT tempStack . append ( ele ) NEW_LINE DEDENT DEDENT return ( Input . empty ( ) and len ( tempStack ) == 0 ) NEW_LINE DEDENT
URLIFY_GIVEN_STRING_REPLACE_SPACES | def replaceSpaces ( string ) : NEW_LINE INDENT string = string . strip ( ) NEW_LINE i = len ( string ) NEW_LINE space_count = string . count ( ' ▁ ' ) NEW_LINE new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return - 1 NEW_LINE DEDENT index = new_length - 1 NEW_LINE string = list ( string ) NEW_LINE for f in range ( i - 2 , new_length - 2 ) : NEW_LINE INDENT string . append ( '0' ) NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT if string [ j ] == ' ▁ ' : NEW_LINE INDENT string [ index ] = '0' NEW_LINE string [ index - 1 ] = '2' NEW_LINE string [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index ] = string [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT
NTH_PALINDROME_K_DIGITS | def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_1 | def getOddOccurrence ( arr , size ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in Hash : NEW_LINE INDENT if ( Hash [ i ] % 2 != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX_1 | def findCommon ( mat ) : NEW_LINE INDENT global M NEW_LINE global N NEW_LINE cnt = dict ( ) NEW_LINE cnt = defaultdict ( lambda : 0 , cnt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < M ) : NEW_LINE INDENT cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 NEW_LINE j = 1 NEW_LINE while ( j < N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : NEW_LINE INDENT cnt [ mat [ i ] [ j ] ] = cnt [ mat [ i ] [ j ] ] + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT for ele in cnt : NEW_LINE INDENT if ( cnt [ ele ] == M ) : NEW_LINE INDENT return ele NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
MINIMUM_COST_FOR_ACQUIRING_ALL_COINS_WITH_K_EXTRA_COINS_ALLOWED_WITH_EVERY_COIN | def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
SUM_TWO_LARGE_NUMBERS_1 | def findSum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE diff = n2 - n1 NEW_LINE carry = 0 NEW_LINE for i in range ( n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str3 + str ( carry + '0' ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT
FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING | def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
FIND_UNIT_DIGIT_X_RAISED_POWER_Y_1 | def unitnumber ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT
POLICEMEN_CATCH_THIEVES | def policeThief ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE res = 0 NEW_LINE thi = [ ] NEW_LINE pol = [ ] NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == ' P ' : NEW_LINE INDENT pol . append ( i ) NEW_LINE DEDENT elif arr [ i ] == ' T ' : NEW_LINE INDENT thi . append ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while l < len ( thi ) and r < len ( pol ) : NEW_LINE INDENT if ( abs ( thi [ l ] - pol [ r ] ) <= k ) : NEW_LINE INDENT res += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif thi [ l ] < pol [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIND_POWER_POWER_MOD_PRIME | def calculate ( A , B , C , M ) : NEW_LINE INDENT res = pow ( B , C ) NEW_LINE ans = pow ( A , res ) NEW_LINE return ans NEW_LINE DEDENT
COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE | def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
FIND_UNIQUE_ELEMENTS_MATRIX | def unique ( mat , n , m ) : NEW_LINE INDENT maximum = 0 flag = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( maximum < mat [ i ] [ j ] ) : NEW_LINE INDENT maximum = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT uniqueElementDict = [ 0 ] * ( maximum + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT uniqueElementDict [ mat [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT for key in range ( maximum + 1 ) : NEW_LINE INDENT if uniqueElementDict [ key ] == 1 : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " No ▁ unique ▁ element ▁ in ▁ the ▁ matrix " ) NEW_LINE DEDENT DEDENT
0_1_KNAPSACK_PROBLEM_DP_10 | def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
COUNT_SUBSETS_DISTINCT_EVEN_NUMBERS | def countSubSets ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in us : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT return pow ( 2 , even_count ) - 1 NEW_LINE DEDENT
NUMBER_SUBARRAYS_SUM_EXACTLY_EQUAL_K | def findSubarraySum ( arr , n , Sum ) : NEW_LINE INDENT prevSum = defaultdict ( lambda : 0 ) NEW_LINE res = 0 NEW_LINE currsum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE if currsum == Sum : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( currsum - Sum ) in prevSum : NEW_LINE INDENT res += prevSum [ currsum - Sum ] NEW_LINE DEDENT prevSum [ currsum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
PROGRAM_PRINT_SUM_GIVEN_NTH_TERM | def summingSeries ( n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT S += i * i - ( i - 1 ) * ( i - 1 ) NEW_LINE DEDENT return S NEW_LINE DEDENT
SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE_1 | def shufleArray ( a , f , l ) : NEW_LINE INDENT if ( l > f ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( l - f == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = int ( ( f + l ) / 2 ) NEW_LINE temp = mid + 1 NEW_LINE mmid = int ( ( f + mid ) / 2 ) NEW_LINE for i in range ( mmid + 1 , mid + 1 ) : NEW_LINE INDENT ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) NEW_LINE temp += 1 NEW_LINE DEDENT shufleArray ( a , f , mid ) NEW_LINE shufleArray ( a , mid + 1 , l ) NEW_LINE DEDENT
BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS_1 | def gcdExtended ( a , b , x , y ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT x = 0 NEW_LINE y = 1 NEW_LINE return b NEW_LINE DEDENT x1 = 1 NEW_LINE y1 = 1 NEW_LINE gcd = gcdExtended ( b % a , a , x1 , y1 ) NEW_LINE x = y1 - ( b / a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd NEW_LINE DEDENT
GIVEN_A_NUMBER_N_GENERATE_BIT_PATTERNS_FROM_0_TO_2N_1_SO_THAT_SUCCESSIVE_PATTERNS_DIFFER_BY_ONE_BIT | def generateGrayarr ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT arr = list ( ) NEW_LINE arr . append ( "0" ) NEW_LINE arr . append ( "1" ) NEW_LINE i = 2 NEW_LINE j = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if i >= 1 << n : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr . append ( arr [ j ] ) NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT arr [ j ] = "0" + arr [ j ] NEW_LINE DEDENT for j in range ( i , 2 * i ) : NEW_LINE INDENT arr [ j ] = "1" + arr [ j ] NEW_LINE DEDENT i = i << 1 NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
SUM_OF_ALL_PROPER_DIVISORS_OF_A_NATURAL_NUMBER | def divSum ( num ) : NEW_LINE INDENT result = 0 NEW_LINE i = 2 NEW_LINE while i <= ( math . sqrt ( num ) ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT if ( i == ( num / i ) ) : NEW_LINE INDENT result = result + i ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + num / i ) ; NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return ( result + 1 ) ; NEW_LINE DEDENT
LONGEST_COMMON_INCREASING_SUBSEQUENCE_LCS_LIS | def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_2 | def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE curr_sum = sum - A [ i ] NEW_LINE for j in range ( i + 1 , arr_size ) : NEW_LINE INDENT if ( curr_sum - A [ j ] ) in s : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , curr_sum - A [ j ] ) NEW_LINE return True NEW_LINE DEDENT s . add ( A [ j ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
MULTIPLY_LARGE_NUMBERS_REPRESENTED_AS_STRINGS | def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - 48 NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - 48 NEW_LINE summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = summ // 10 NEW_LINE result [ i_n1 + i_n2 ] = summ % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += chr ( result [ i ] + 48 ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
COMPUTE_N_UNDER_MODULO_P | def modFact ( n , p ) : NEW_LINE INDENT if n >= p : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result = ( result * i ) % p NEW_LINE DEDENT return result NEW_LINE DEDENT
PROGRAM_SORT_STRING_DESCENDING_ORDER | def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( charCount [ i ] ) : NEW_LINE INDENT print ( chr ( 97 + i ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
COUNT_FACTORIAL_NUMBERS_IN_A_GIVEN_RANGE | def countFact ( low , high ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 1 NEW_LINE while ( fact < low ) : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT res = 0 NEW_LINE while ( fact <= high ) : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
PROGRAM_FIND_AREA_CIRCULAR_SEGMENT | def area_of_segment ( radius , angle ) : NEW_LINE INDENT area_of_sector = pi * NEW_LINE INDENT ( radius * radius ) NEW_LINE * ( angle / 360 ) NEW_LINE DEDENT area_of_triangle = 1 / 2 * NEW_LINE INDENT ( radius * radius ) * NEW_LINE math . sin ( ( angle * pi ) / 180 ) NEW_LINE DEDENT return area_of_sector - area_of_triangle ; NEW_LINE DEDENT
FIND_THE_NEAREST_SMALLER_NUMBERS_ON_LEFT_SIDE_IN_AN_ARRAY_1 | def printPrevSmaller ( arr , n ) : NEW_LINE INDENT S = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT if ( len ( S ) == 0 ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( S [ - 1 ] , end = " , ▁ " ) NEW_LINE DEDENT S . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
CHECK_STAR_GRAPH | def checkStar ( mat ) : NEW_LINE INDENT global size NEW_LINE vertexD1 = 0 NEW_LINE vertexDn_1 = 0 NEW_LINE if ( size == 1 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 ) NEW_LINE DEDENT if ( size == 2 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) NEW_LINE DEDENT for i in range ( 0 , size ) : NEW_LINE INDENT degreeI = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT degreeI = degreeI + 1 NEW_LINE DEDENT DEDENT if ( degreeI == 1 ) : NEW_LINE INDENT vertexD1 = vertexD1 + 1 NEW_LINE DEDENT elif ( degreeI == size - 1 ) : NEW_LINE INDENT vertexDn_1 = vertexDn_1 + 1 NEW_LINE DEDENT DEDENT return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 ) NEW_LINE DEDENT
EULERS_TOTIENT_FUNCTION_FOR_ALL_NUMBERS_SMALLER_THAN_OR_EQUAL_TO_N | def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Totient ▁ of ▁ " , i , " ▁ is ▁ " , phi [ i ] ) NEW_LINE DEDENT DEDENT
FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME_1 | def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEW_LINE return round ( fibo ) NEW_LINE DEDENT
MID_POINT_LINE_GENERATION_ALGORITHM | def midPoint ( X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT dx = X2 - X1 NEW_LINE dy = Y2 - Y1 NEW_LINE d = dy - ( dx / 2 ) NEW_LINE x = X1 NEW_LINE y = Y1 NEW_LINE print ( x , " , " , y , " \n " ) NEW_LINE while ( x < X2 ) : NEW_LINE INDENT x = x + 1 NEW_LINE if ( d < 0 ) : NEW_LINE INDENT d = d + dy NEW_LINE DEDENT else : NEW_LINE INDENT d = d + ( dy - dx ) NEW_LINE y = y + 1 NEW_LINE DEDENT print ( x , " , " , y , " \n " ) NEW_LINE DEDENT DEDENT
REARRANGE_ARRAY_ARRI_ARRJ_EVEN_ARRI | def rearrangeArr ( arr , n ) : NEW_LINE INDENT evenPos = int ( n / 2 ) NEW_LINE oddPos = n - evenPos NEW_LINE tempArr = np . empty ( n , dtype = object ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempArr [ i ] = arr [ i ] NEW_LINE DEDENT tempArr . sort ( ) NEW_LINE j = oddPos - 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT j = oddPos NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j + 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K | def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = " ▁ " ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
SORT_STRING_CHARACTERS_1 | def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
CHECK_IF_STACK_ELEMENTS_ARE_PAIRWISE_CONSECUTIVE | def pairWiseConsecutive ( s ) : NEW_LINE INDENT aux = [ ] NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT aux . append ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT result = True NEW_LINE while ( len ( aux ) > 1 ) : NEW_LINE INDENT x = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE y = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE if ( abs ( x - y ) != 1 ) : NEW_LINE INDENT result = False NEW_LINE DEDENT s . append ( x ) NEW_LINE s . append ( y ) NEW_LINE DEDENT if ( len ( aux ) == 1 ) : NEW_LINE INDENT s . append ( aux [ - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
BINARY_REPRESENTATION_OF_NEXT_NUMBER | def nextGreater ( num1 ) : NEW_LINE INDENT l = len ( num1 ) NEW_LINE num = list ( num1 ) NEW_LINE i = l - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT num [ i ] = '1' NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT num [ i ] = '0' NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num1 = ' ' . join ( num ) NEW_LINE if ( i < 0 ) : NEW_LINE INDENT num1 = '1' + num1 NEW_LINE DEDENT return num1 NEW_LINE DEDENT
CONSTRUCT_THE_ROOTED_TREE_BY_USING_START_AND_FINISH_TIME_OF_ITS_DFS_TRAVERSAL | def Restore_Tree ( S , E ) : NEW_LINE INDENT Identity = N * [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT Identity [ Start [ i ] ] = i NEW_LINE DEDENT parent = N * [ - 1 ] NEW_LINE curr_parent = Identity [ 0 ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT child = Identity [ j ] NEW_LINE if End [ child ] - j > 1 : NEW_LINE INDENT parent [ child ] = curr_parent NEW_LINE curr_parent = child NEW_LINE DEDENT else : NEW_LINE INDENT parent [ child ] = curr_parent NEW_LINE while End [ child ] == End [ parent [ child ] ] : NEW_LINE INDENT child = parent [ child ] NEW_LINE curr_parent = parent [ child ] NEW_LINE if curr_parent == Identity [ 0 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT parent [ i ] += 1 NEW_LINE DEDENT return parent NEW_LINE DEDENT
PASCAL_TRIANGLE_1 | def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " ▁ " ) NEW_LINE C = int ( C * ( line - i ) / i ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
MAXIMIZE_SUM_ARRII | def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
MINIMIZE_ABSOLUTE_DIFFERENCE_SUM_TWO_SUBSETS | def subsetDifference ( n ) : NEW_LINE INDENT s = int ( n * ( n + 1 ) / 2 ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 4 == 1 or n % 4 == 2 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) + 1 ) NEW_LINE print ( " Difference ▁ = ▁ " , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT DEDENT DEDENT
PERFECT_REVERSIBLE_STRING | def isReversible ( str ) : NEW_LINE INDENT i = 0 j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
WRITE_A_C_PROGRAM_TO_FIND_THE_PARITY_OF_AN_UNSIGNED_INTEGER | def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return bool ( parity ) NEW_LINE DEDENT
MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING | def maxRepeating ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT cur_count = 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_count += 1 NEW_LINE DEDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
SUM_SERIES_ALTERNATE_SIGNED_SQUARES_AP | def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIND_A_REPEATING_AND_A_MISSING_NUMBER | def printTwoElements ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ repeating ▁ element ▁ is " , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( " and ▁ the ▁ missing ▁ element ▁ is " , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND_1 | def isSubSequence ( str1 , str2 , m , n ) : NEW_LINE INDENT j = 0 NEW_LINE i = 0 NEW_LINE while j < m and i < n : NEW_LINE INDENT if str1 [ j ] == str2 [ i ] : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return j == m NEW_LINE DEDENT
SIEVE_SUNDARAM_PRINT_PRIMES_SMALLER_N | def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) / 2 ) NEW_LINE marked = [ 0 ] * ( nNew + 1 ) NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
EFFICIENT_METHOD_2S_COMPLEMENT_BINARY_STRING | def findTwoscomplement ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return '1' + str NEW_LINE DEDENT k = i - 1 NEW_LINE while ( k >= 0 ) : NEW_LINE INDENT if ( str [ k ] == '1' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '0' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '1' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE | def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT
PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE_1 | def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT
SORT_STRING_CHARACTERS | def sortString ( str ) : NEW_LINE INDENT str = ' ' . join ( sorted ( str ) ) NEW_LINE print ( str ) NEW_LINE DEDENT
COUNT_OF_PAIRS_SATISFYING_THE_GIVEN_CONDITION | def countPair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE while i < ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '9' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT result = 0 NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT result = a * len ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT result = a * ( len ( s ) - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
MINIMUM_NUMBER_OF_OPERATIONS_TO_MOVE_ALL_UPPERCASE_CHARACTERS_BEFORE_ALL_LOWER_CASE_CHARACTERS | def minOperations ( str , n ) : NEW_LINE INDENT lastUpper = - 1 NEW_LINE firstLower = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT lastUpper = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT firstLower = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( lastUpper == - 1 or firstLower == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT countUpper = 0 NEW_LINE for i in range ( firstLower , n ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT countUpper += 1 NEW_LINE DEDENT DEDENT countLower = 0 NEW_LINE for i in range ( lastUpper ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT countLower += 1 NEW_LINE DEDENT DEDENT return min ( countLower , countUpper ) NEW_LINE DEDENT
FIND_SMALLEST_VALUE_REPRESENTED_SUM_SUBSET_GIVEN_ARRAY | def findSmallest ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY_1 | def printMaxOfMin ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE left = [ - 1 ] * ( n + 1 ) NEW_LINE right = [ n ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT left [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT right [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT ans = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT ans [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT Len = right [ i ] - left [ i ] - 1 NEW_LINE ans [ Len ] = max ( ans [ Len ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_2 | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
ADD_TWO_NUMBERS_WITHOUT_USING_ARITHMETIC_OPERATORS | def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
PRINT_GIVEN_MATRIX_REVERSE_SPIRAL_FORM | def ReversespiralPrint ( m , n , a ) : NEW_LINE INDENT b = [ 0 for i in range ( 100 ) ] NEW_LINE i , k , l = 0 , 0 , 0 NEW_LINE z = 0 NEW_LINE size = m * n NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( l , n ) : NEW_LINE INDENT val = a [ k ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT val = a [ i ] [ n - 1 ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT val = a [ m - 1 ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT DEDENT m -= 1 NEW_LINE if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT val = a [ i ] [ l ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES | def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) / 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM | def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
LARGEST_SUM_CONTIGUOUS_SUBARRAY_2 | def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
MINIMUM_OPERATIONS_MAKE_GCD_ARRAY_MULTIPLE_K | def MinOperation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
SMALLEST_SUBSET_SUM_GREATER_ELEMENTS | def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
PROGRAM_TO_CALCULATE_AREA_OF_AN_CIRCLE_INSCRIBED_IN_A_SQUARE | def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI / 4 ) * a * a NEW_LINE DEDENT
LARGEST_SUM_CONTIGUOUS_SUBARRAY_3 | def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ % d " % ( max_so_far ) ) NEW_LINE print ( " Starting ▁ Index ▁ % d " % ( start ) ) NEW_LINE print ( " Ending ▁ Index ▁ % d " % ( end ) ) NEW_LINE DEDENT
LARGEST_SUBSET_GRAPH_VERTICES_EDGES_2_COLORS | def subsetGraph ( C ) : NEW_LINE INDENT global N NEW_LINE vertices = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT vertices . add ( i ) NEW_LINE DEDENT while ( len ( vertices ) != 0 ) : NEW_LINE INDENT if ( len ( vertices ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT someone_removed = False NEW_LINE for x in vertices : NEW_LINE INDENT values = set ( ) NEW_LINE for y in vertices : NEW_LINE INDENT if ( y != x ) : NEW_LINE INDENT values . add ( C [ x ] [ y ] ) NEW_LINE DEDENT DEDENT if ( len ( values ) == 1 ) : NEW_LINE INDENT vertices . remove ( x ) NEW_LINE someone_removed = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not someone_removed ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( vertices ) NEW_LINE DEDENT
MAXIMUM_XOR_VALUE_MATRIX | def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT
NUMBER_SUBSEQUENCES_FORM_AI_BJ_CK | def countSubsequences ( s ) : NEW_LINE INDENT aCount = 0 NEW_LINE bCount = 0 NEW_LINE cCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT aCount = ( 1 + 2 * aCount ) NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT bCount = ( aCount + 2 * bCount ) NEW_LINE DEDENT elif ( s [ i ] == ' c ' ) : NEW_LINE INDENT cCount = ( bCount + 2 * cCount ) NEW_LINE DEDENT DEDENT return cCount NEW_LINE DEDENT
MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING | def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
ROOTS_OF_UNITY | def printRoots ( n ) : NEW_LINE INDENT theta = math . pi * 2 / n NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( real , end = " ▁ " ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " ▁ " ) NEW_LINE DEDENT print ( abs ( img ) ) NEW_LINE DEDENT DEDENT
SIEVE_OF_ATKIN | def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = " ▁ " ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
SMALLEST_ELEMENT_REPEATED_EXACTLY_K_TIMES_NOT_LIMITED_SMALL_RANGE | def smallestKFreq ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE res1 = sys . maxsize NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == k : NEW_LINE INDENT res = min ( res , key ) NEW_LINE DEDENT DEDENT return res if res != res1 else - 1 NEW_LINE DEDENT
MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC | def minimumflip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( flip / 2 ) NEW_LINE DEDENT
TWO_ELEMENTS_WHOSE_SUM_IS_CLOSEST_TO_ZERO | def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are " , arr [ min_l ] , " and ▁ " , arr [ min_r ] ) NEW_LINE DEDENT
RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS | def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT a = arr [ 0 ] b = arr [ 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > a * b ) : NEW_LINE INDENT a = arr [ i ] b = arr [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , a , " , " , b , " } " , sep = " " ) NEW_LINE DEDENT
PROGRAM_PAGE_REPLACEMENT_ALGORITHMS_SET_2_FIFO | def pageFaults ( pages , n , capacity ) : NEW_LINE INDENT s = set ( ) NEW_LINE indexes = Queue ( ) NEW_LINE page_faults = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( s ) < capacity ) : NEW_LINE INDENT if ( pages [ i ] not in s ) : NEW_LINE INDENT s . add ( pages [ i ] ) NEW_LINE page_faults += 1 NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( pages [ i ] not in s ) : NEW_LINE INDENT val = indexes . queue [ 0 ] NEW_LINE indexes . get ( ) NEW_LINE s . remove ( val ) NEW_LINE s . add ( pages [ i ] ) NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE page_faults += 1 NEW_LINE DEDENT DEDENT DEDENT return page_faults NEW_LINE DEDENT
BIN_PACKING_PROBLEM_MINIMIZE_NUMBER_OF_USED_BINS | def nextfit ( weight , n , c ) : NEW_LINE INDENT res = 0 NEW_LINE rem = c NEW_LINE for _ in range ( n ) : NEW_LINE INDENT if rem >= weight [ _ ] : NEW_LINE INDENT rem = rem - weight [ _ ] NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 NEW_LINE rem = c - weight [ _ ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_2 | def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count , l , r = 0 , 0 , n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
PROGRAM_CIRCUMFERENCE_PARALLELOGRAM | def circumferenceparallelogram ( a , b ) : NEW_LINE INDENT return ( ( 2 * a ) + ( 2 * b ) ) NEW_LINE DEDENT
PRINT_FIRST_K_DIGITS_1N_N_POSITIVE_INTEGER | def Print ( n , k ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = " " ) NEW_LINE rem = ( 10 * rem ) % n NEW_LINE DEDENT DEDENT
STRING_K_DISTINCT_CHARACTERS_NO_CHARACTERS_ADJACENT | def findString ( n , k ) : NEW_LINE INDENT res = " " NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + count ) NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
CHECK_POSSIBLE_SORT_ARRAY_CONDITIONAL_SWAPPING_ADJACENT_ALLOWED | def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
ROUND_THE_GIVEN_NUMBER_TO_NEAREST_MULTIPLE_OF_10 | def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT
PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_1 | def getRemainder ( num , divisor ) : NEW_LINE INDENT if ( divisor == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( divisor < 0 ) : NEW_LINE INDENT divisor = - divisor NEW_LINE DEDENT if ( num < 0 ) : NEW_LINE INDENT num = - num NEW_LINE DEDENT i = 1 NEW_LINE product = 0 NEW_LINE while ( product <= num ) : NEW_LINE INDENT product = divisor * i NEW_LINE i += 1 NEW_LINE DEDENT return num - ( product - divisor ) NEW_LINE DEDENT
FIND_UNIT_DIGIT_X_RAISED_POWER_Y | def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
COST_BALANCE_PARANTHESES | def costToBalance ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT ans = 0 NEW_LINE o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT if ( s [ i ] == ' ) ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( o != c ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = [ 0 for i in range ( len ( s ) ) ] NEW_LINE if ( s [ 0 ] == ' ( ' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE DEDENT if ( a [ 0 ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
LARGEST_SUM_CONTIGUOUS_SUBARRAY | def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxint - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
COUNT_ALL_INCREASING_SUBSEQUENCES | def countSub ( arr , n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ arr [ i ] ] += count [ j ] NEW_LINE DEDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT result += count [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
MINIMUM_NUMBER_OF_BRACKET_REVERSALS_NEEDED_TO_MAKE_AN_EXPRESSION_BALANCED | def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT red_len = len ( s ) NEW_LINE n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT return ( red_len // 2 + n % 2 ) NEW_LINE DEDENT
FIND_PAIRS_B_ARRAY_B_K | def printPairs ( arr , n , k ) : NEW_LINE INDENT isPairFound = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " , end = " ▁ " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT
FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING_1 | def findRepeatFirst ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE MAX_CHAR = 256 NEW_LINE hash = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE pos = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE if ( hash [ k ] == 0 ) : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE pos [ k ] = i NEW_LINE DEDENT elif ( hash [ k ] == 1 ) : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( hash [ i ] == 2 ) : NEW_LINE INDENT if ( p == - 1 ) : NEW_LINE INDENT p = pos [ i ] NEW_LINE DEDENT elif ( p > pos [ i ] ) : NEW_LINE INDENT p = pos [ i ] NEW_LINE DEDENT DEDENT DEDENT return p NEW_LINE DEDENT
COUNT_SET_BITS_IN_AN_INTEGER_4 | def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] NEW_LINE DEDENT nibble = num & 0xf NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) NEW_LINE DEDENT
HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_1 | def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
COUNTS_PATHS_POINT_REACH_ORIGIN_1 | def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
C_PROGRAM_FACTORIAL_NUMBER_1 | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX | def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT principal += mat [ i ] [ j ] NEW_LINE DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT secondary += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT
NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_1 | def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEW_LINE DEDENT
MINIMUM_NUMBER_PLATFORMS_REQUIRED_RAILWAYBUS_STATION | def findPlatform ( arr , dep , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dep . sort ( ) NEW_LINE plat_needed = 1 NEW_LINE result = 1 NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arr [ i ] <= dep [ j ] ) : NEW_LINE INDENT plat_needed += 1 NEW_LINE i += 1 NEW_LINE if ( plat_needed > result ) : NEW_LINE INDENT result = plat_needed NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT plat_needed -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
SUBSET_SUM_DIVISIBLE_M | def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT
SUM_LARGEST_PRIME_FACTOR_NUMBER_LESS_EQUAL_N | def sumOfLargePrimeFactor ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE max = int ( n / 2 ) NEW_LINE for p in range ( 2 , max + 1 ) : NEW_LINE INDENT if prime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT sum += prime [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
NUMBER_JUMP_REQUIRED_GIVEN_LENGTH_REACH_POINT_FORM_D_0_ORIGIN_2D_PLANE | def minJumps ( a , b , d ) : NEW_LINE INDENT temp = a NEW_LINE a = min ( a , b ) NEW_LINE b = max ( temp , b ) NEW_LINE if ( d >= b ) : NEW_LINE INDENT return ( d + b - 1 ) / b NEW_LINE DEDENT if ( d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( d == a ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
COUNT_SET_BITS_IN_AN_INTEGER | def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
FIND_PERMUTED_ROWS_GIVEN_ROW_MATRIX | def permutatedRows ( mat , m , n , r ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( mat [ r ] [ j ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if i == r : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] not in s : NEW_LINE INDENT j = j - 2 NEW_LINE break NEW_LINE DEDENT DEDENT if j + 1 != n : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT DEDENT
PROGRAM_TO_PRINT_TETRAHEDRAL_NUMBERS_UPTO_NTH_TERM | def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
GIVEN_1S_2S_3S_KS_PRINT_ZIG_ZAG_WAY | def ZigZag ( rows , columns , numbers ) : NEW_LINE INDENT k = 0 NEW_LINE arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] NEW_LINE for i in range ( rows ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < columns and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT j = columns - 1 NEW_LINE while j >= 0 and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT for i in arr : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
FIND_ELEMENT_GIVEN_INDEX_NUMBER_ROTATIONS | def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = index - 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT
FORM_SMALLEST_NUMBER_USING_ONE_SWAP_OPERATION | def smallestNumber ( num ) : NEW_LINE INDENT num = list ( num ) NEW_LINE n = len ( num ) NEW_LINE rightMin = [ 0 ] * n NEW_LINE right = 0 NEW_LINE rightMin [ n - 1 ] = - 1 ; NEW_LINE right = n - 1 ; NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if num [ i ] > num [ right ] : NEW_LINE INDENT rightMin [ i ] = right NEW_LINE DEDENT else : NEW_LINE INDENT rightMin [ i ] = - 1 NEW_LINE right = i NEW_LINE DEDENT DEDENT small = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if num [ i ] != '0' : NEW_LINE INDENT if small == - 1 : NEW_LINE INDENT if num [ i ] < num [ 0 ] : NEW_LINE INDENT small = i NEW_LINE DEDENT DEDENT elif num [ i ] < num [ small ] : NEW_LINE INDENT small = i NEW_LINE DEDENT DEDENT DEDENT if small != - 1 : NEW_LINE INDENT num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if rightMin [ i ] != - 1 : NEW_LINE INDENT num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ' ' . join ( num ) NEW_LINE DEDENT
COUNT_NUMBER_WAYS_REACH_DESTINATION_MAZE | def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT for j in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
PROGRAM_FIND_SMALLEST_LARGEST_WORD_STRING | def minMaxLengthWords ( inp ) : NEW_LINE INDENT length = len ( inp ) NEW_LINE si = ei = 0 NEW_LINE min_length = length NEW_LINE min_start_index = max_length = max_start_index = 0 NEW_LINE while ei <= length : NEW_LINE INDENT if ( ei < length ) and ( inp [ ei ] != " ▁ " ) : NEW_LINE INDENT ei += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr_length = ei - si NEW_LINE if curr_length < min_length : NEW_LINE INDENT min_length = curr_length NEW_LINE min_start_index = si NEW_LINE DEDENT if curr_length > max_length : NEW_LINE INDENT max_length = curr_length NEW_LINE max_start_index = si NEW_LINE DEDENT ei += 1 NEW_LINE si = ei NEW_LINE DEDENT DEDENT minWord = inp [ min_start_index : min_start_index + min_length ] NEW_LINE maxWord = inp [ max_start_index : max_length ] NEW_LINE print ( " Minimum ▁ length ▁ word : ▁ " , minWord ) NEW_LINE print ( " Maximum ▁ length ▁ word : ▁ " , maxWord ) NEW_LINE DEDENT
PROGRAM_TO_FIND_THE_VOLUME_OF_A_TRIANGULAR_PRISM | def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT
SORT_GIVEN_STRING_USING_CHARACTER_SEARCH | def sortString ( str , n ) : NEW_LINE INDENT new_str = " " NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( str [ j ] == chr ( i ) ) : NEW_LINE INDENT new_str += str [ j ] NEW_LINE DEDENT DEDENT DEDENT return new_str NEW_LINE DEDENT
NUMBER_OF_BINARY_TREES_FOR_GIVEN_PREORDER_SEQUENCE_LENGTH | def countTrees ( n ) : NEW_LINE INDENT BT = [ 0 ] * ( n + 1 ) NEW_LINE BT [ 0 ] = BT [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT BT [ i ] += BT [ j ] * BT [ i - j - 1 ] NEW_LINE DEDENT DEDENT return BT [ n ] NEW_LINE DEDENT
COUNT_PAIRS_WITH_GIVEN_SUM | def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
CHECK_LARGE_NUMBER_DIVISIBLE_3_NOT | def check ( num ) : NEW_LINE INDENT digit_sum = 0 NEW_LINE for i in num : NEW_LINE INDENT digit_sum += int ( i ) NEW_LINE DEDENT return ( digit_sum % 3 == 0 ) NEW_LINE DEDENT
LONGEST_COMMON_SUBSTRING_SPACE_OPTIMIZED_DP_SOLUTION | def LCSubStr ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE result = 0 NEW_LINE len_mat = np . zeros ( ( 2 , n ) ) NEW_LINE currRow = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 | j == 0 ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 NEW_LINE result = max ( result , len_mat [ currRow ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT DEDENT currRow = 1 - currRow NEW_LINE DEDENT return result NEW_LINE DEDENT
DELETE_CONSECUTIVE_WORDS_SEQUENCE | def removeConsecutiveSame ( v ) : NEW_LINE INDENT n = len ( v ) NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) : NEW_LINE INDENT v = v [ : i ] NEW_LINE v = v [ : i ] NEW_LINE if ( i > 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT n = n - 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return len ( v [ : i - 1 ] ) NEW_LINE DEDENT
FIND_PERIMETER_CYLINDER | def perimeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT
POSSIBLE_TO_MAKE_A_DIVISIBLE_BY_3_NUMBER_USING_ALL_DIGITS_IN_AN_ARRAY | def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT
COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY | def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ k ] : NEW_LINE INDENT invcount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return invcount NEW_LINE DEDENT
BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER | def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n // 2 ) NEW_LINE DEDENT print ( n % 2 , end = " " ) NEW_LINE DEDENT
MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED_1 | def minSum ( ar , n ) : NEW_LINE INDENT if ( n <= 4 ) : NEW_LINE INDENT return min ( ar ) NEW_LINE DEDENT sum = [ 0 for i in range ( n ) ] NEW_LINE sum [ 0 ] = ar [ 0 ] NEW_LINE sum [ 1 ] = ar [ 1 ] NEW_LINE sum [ 2 ] = ar [ 2 ] NEW_LINE sum [ 3 ] = ar [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) NEW_LINE DEDENT return min ( sum [ n - 4 : n ] ) NEW_LINE DEDENT
FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K | def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 0 , n2 ) : NEW_LINE INDENT for k in range ( 0 , n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS_1 | def minDist ( arr , n , x , y ) : NEW_LINE INDENT min_dist = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT prev = i NEW_LINE break NEW_LINE DEDENT DEDENT while i < n : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist : NEW_LINE INDENT min_dist = i - prev NEW_LINE prev = i NEW_LINE DEDENT else : NEW_LINE INDENT prev = i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return min_dist NEW_LINE DEDENT
SCHEDULE_JOBS_SERVER_GETS_EQUAL_LOAD | def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s // n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
LEXICOGRAPHICALLY_SMALLEST_STRING_WHOSE_HAMMING_DISTANCE_GIVEN_STRING_EXACTLY_K | def findString ( str , n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE return NEW_LINE DEDENT str2 = str NEW_LINE p = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str2 [ i ] != ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' a ' ) NEW_LINE p += 1 NEW_LINE if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( p < k ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' b ' ) NEW_LINE p += 1 NEW_LINE DEDENT if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT print ( str2 ) NEW_LINE DEDENT
LONGEST_REPEATING_SUBSEQUENCE_1 | def findLongestRepeatingSubSeq ( X , m , n ) : NEW_LINE INDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT dp [ m ] [ n ] = 0 NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : NEW_LINE INDENT dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
COUNT_SUBSEQUENCES_PRODUCT_LESS_K | def productSubSeqCount ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ k ] [ n ] NEW_LINE DEDENT
WRITE_YOU_OWN_POWER_WITHOUT_USING_MULTIPLICATION_AND_DIVISION | def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT
REARRANGE_ARRAY_ARRI | def fix ( A , len ) : NEW_LINE INDENT for i in range ( 0 , len ) : NEW_LINE INDENT if ( A [ i ] != - 1 and A [ i ] != i ) : NEW_LINE INDENT x = A [ i ] NEW_LINE while ( A [ x ] != - 1 and A [ x ] != x ) : NEW_LINE INDENT y = A [ x ] NEW_LINE A [ x ] = x NEW_LINE x = y NEW_LINE DEDENT A [ x ] = x NEW_LINE if ( A [ i ] != i ) : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
MINIMUM_DIFFERENCE_BETWEEN_GROUPS_OF_SIZE_TWO | def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = [ ] NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT mini = min ( s ) NEW_LINE maxi = max ( s ) NEW_LINE return abs ( maxi - mini ) NEW_LINE DEDENT
SUM_SEQUENCE_2_22_222 | def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT
MINIMAL_OPERATIONS_MAKE_NUMBER_MAGICAL | def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS | def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
SORT_ARRAY_WAVE_FORM_2 | def sortInWave ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT
FIND_THE_ELEMENT_THAT_ODD_NUMBER_OF_TIMES_IN_OLOG_N_TIME | def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return None NEW_LINE DEDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
CHECK_LARGE_NUMBER_DIVISIBLE_6_NOT | def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT
CALCULATING_FACTORIALS_USING_STIRLING_APPROXIMATION | def stirlingFactorial ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT e = 2.71 NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) NEW_LINE return math . floor ( z ) NEW_LINE DEDENT
DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE | def checkCount ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] == arr [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count > 2 * k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED | def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
ENTRINGER_NUMBER | def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) NEW_LINE DEDENT
SPACE_OPTIMIZED_SOLUTION_LCS | def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = False NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT
FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K_1 | def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' ▁ ' ) NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
FIND_ROOT_TREE_CHILDREN_ID_SUM_EVERY_NODE_GIVEN | def findRoot ( arr , n ) : NEW_LINE INDENT root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) NEW_LINE DEDENT return root NEW_LINE DEDENT
MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY_1 | def findArea ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE continue NEW_LINE DEDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return ( first * second ) NEW_LINE DEDENT
REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_1 | def rearrange ( arr , n ) : NEW_LINE INDENT max_ele = arr [ n - 1 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE max_ele -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE min_ele += 1 NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_PRODUCT_OF_4_ADJACENT_ELEMENTS_IN_MATRIX | def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
TRIANGULAR_NUMBERS_1 | def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
CIRCLE_LATTICE_POINTS | def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
FIND_INDEX_0_REPLACED_1_GET_LONGEST_CONTINUOUS_SEQUENCE_1S_BINARY_ARRAY | def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT
LEAF_NODES_PREORDER_BINARY_SEARCH_TREE | def leafNode ( preorder , n ) : NEW_LINE INDENT s = [ ] NEW_LINE i = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT found = False NEW_LINE if preorder [ i ] > preorder [ j ] : NEW_LINE INDENT s . append ( preorder [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while len ( s ) != 0 : NEW_LINE INDENT if preorder [ j ] > s [ - 1 ] : NEW_LINE INDENT s . pop ( - 1 ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if found : NEW_LINE INDENT print ( preorder [ i ] , end = " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( preorder [ n - 1 ] ) NEW_LINE DEDENT
FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1 | def isSubset ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( arr2 [ i ] == arr1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
EFFICIENT_WAY_TO_MULTIPLY_WITH_7 | def multiplyBySeven ( n ) : NEW_LINE INDENT return ( ( n << 3 ) - n ) NEW_LINE DEDENT
UNBOUNDED_KNAPSACK_REPETITION_ITEMS_ALLOWED | def unboundedKnapsack ( W , n , val , wt ) : NEW_LINE INDENT dp = [ 0 for i in range ( W + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( wt [ j ] <= i ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY_1 | def alternateSubarray ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ prev ) == 0 ) : NEW_LINE INDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE prev = arr [ i ] NEW_LINE DEDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT
COUNT_NUMBER_OF_SUBSTRINGS_WITH_EXACTLY_K_DISTINCT_CHARACTERS | def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
MODULAR_MULTIPLICATIVE_INVERSE_1_N | def modularInverse ( n , prime ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
COUNT_OFDIFFERENT_WAYS_EXPRESS_N_SUM_1_3_4 | def countWays ( n ) : NEW_LINE INDENT DP = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 NEW_LINE DP [ 3 ] = 2 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] NEW_LINE DEDENT return DP [ n ] NEW_LINE DEDENT
COUNT_NUMBERS_THAT_DONT_CONTAIN_3 | def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE DEDENT msd = n / po NEW_LINE if msd != 3 : NEW_LINE INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( msd * po - 1 ) NEW_LINE DEDENT DEDENT
COUNT_OF_OCCURRENCES_OF_A_101_PATTERN_IN_A_STRING | def countPattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE oneSeen = False NEW_LINE count = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] == '1' and oneSeen ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( s [ i ] == '1' and oneSeen == 0 ) : NEW_LINE INDENT oneSeen = True NEW_LINE DEDENT if ( s [ i ] != '0' and s [ i ] != '1' ) : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
MAXIMUM_REMOVAL_FROM_ARRAY_WHEN_REMOVAL_TIME_WAITING_TIME | def maxRemoval ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE cummulative_sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= cummulative_sum : NEW_LINE INDENT count += 1 NEW_LINE cummulative_sum += arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
LEXICOGRAPHICAL_MAXIMUM_SUBSTRING_STRING | def LexicographicalMaxString ( str ) : NEW_LINE INDENT mx = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mx = max ( mx , str [ i : ] ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
