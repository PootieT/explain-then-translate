[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"()\") #t 0.001)\n    (check-within (candidate \"(()())\") #t 0.001)\n    (check-within (candidate \"()()(()())()\") #t 0.001)\n    (check-within (candidate \"()()((()()())())(()()(()))\") #t 0.001)\n    (check-within (candidate \"((()())))\") #f 0.001)\n    (check-within (candidate \")(()\") #f 0.001)\n    (check-within (candidate \"(\") #f 0.001)\n    (check-within (candidate \"((((\") #f 0.001)\n    (check-within (candidate \")\") #f 0.001)\n    (check-within (candidate \"(()\") #f 0.001)\n    (check-within (candidate \"()()(()())())(()\") #f 0.001)\n    (check-within (candidate \"()()(()())()))()\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for i=1, #brackets do\n        if brackets:sub(i,i) == \"(\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThe code is an implementation of checking whether a string of parentheses is correctly bracketed. The function takes a string of parentheses `brackets` as input and returns a boolean.\n\nlocal depth = 0\nThe function initializes a variable `depth` to keep track of the depth of the parentheses.\n\nfor i=1, #brackets do\n    if brackets:sub(i,i) == \"(\" then\n        depth = depth + 1\n    else\n        depth = depth - 1\n    end\n    if depth < 0 then\n        return false\n    end\nend\nThe function iterates through each character in the input string. If the character is an opening parenthesis `'('`, the function increments the `depth` variable. If the character is a closing parenthesis `')'`, the function decrements the `depth` variable. If the `depth` variable becomes negative at any point, it means that there are more closing parentheses than opening parentheses, so the function returns `false`.\n\nreturn depth == 0\nFinally, the function checks if the `depth` variable is 0. If it is, it means that the number of opening and closing parentheses are equal, so the function returns `true`. Otherwise, it returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a h)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 5 3) 7.5 0.001)\n    (check-within (candidate 2 2) 2.0 0.001)\n    (check-within (candidate 10 8) 40.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, h)\n    return a * h / 2\nend\n\n### Explanation\n\nThe code is an implementation of a function `triangle_area` which takes the base `a` and height `h` of a triangle and returns its area.\n\nreturn a * h / 2\nThe function simply multiplies the base `a` and height `h` and divides the result by 2 to get the area of the triangle.\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a h)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (special_factorial n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate special_factorial))\n    (check-within (candidate 4) 288 0.001)\n    (check-within (candidate 5) 34560 0.001)\n    (check-within (candidate 7) 125411328000 0.001)\n    (check-within (candidate 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function special_factorial(n)\n  local fact_i = 1\n  local special_fact = 1\n  for i=1, n do\n    fact_i = fact_i * i\n    special_fact = special_fact * fact_i\n  end\n  return special_fact\nend\n\n### Explanation\n\nThe code is an implementation of a function `special_factorial` which takes a number `n` as input and returns the special factorial of `n`. The special factorial of a number `n` is defined as the product of the factorials of the first `n` positive integers.\n\nlocal fact_i = 1\nlocal special_fact = 1\nThe function initializes two variables `fact_i` and `special_fact` to 1.\n\nfor i=1, n do\n    fact_i = fact_i * i\n    special_fact = special_fact * fact_i\nend\nThe function then iterates through all positive integers from 1 to `n`. For each integer `i`, it multiplies `fact_i` by `i` and then multiplies `special_fact` by `fact_i`. This effectively calculates the factorial of `i` and then multiplies it with the previous factorials to get the special factorial of `i`.\n\nreturn special_fact\nFinally, the function returns the `special_fact` variable, which contains the special factorial of `n`.\n\n### Racket version\n\n#lang racket\n\n(define (special_factorial n)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (move_one_ball arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate move_one_ball))\n    (check-within (candidate (list 3 4 5 1 2)) #t 0.001)\n    (check-within (candidate (list 3 5 10 1 2)) #t 0.001)\n    (check-within (candidate (list 4 3 1 2)) #f 0.001)\n    (check-within (candidate (list 3 5 4 1 2)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function move_one_ball(arr)\n  if #arr==0 then\n    return true\n  end\n  local sorted_array = {}\n  for i=1,#arr do\n    sorted_array[i]=arr[i]\n  end\n  table.sort(sorted_array)\n  local my_arr = {}\n  local min_value = math.min(table.unpack(arr))\n  local min_index = 1\n  for i=1,#arr do\n    if arr[i]==min_value then\n      min_index = i\n      break\n    end\n  end\n  for i=min_index,#arr do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,min_index-1 do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,#arr do\n    if my_arr[i]~=sorted_array[i] then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `move_one_ball` which takes an array of integers and returns a boolean indicating whether it is possible to move one ball from one position to another such that the array becomes sorted in non-descending order.\n\nif #arr==0 then\n    return true\nThe function first checks if the input array is empty. If it is, it returns `true`.\n\nlocal sorted_array = {}\nfor i=1,#arr do\n    sorted_array[i]=arr[i]\nend\ntable.sort(sorted_array)\nThe function creates a sorted copy of the input array `arr` and stores it in `sorted_array`.\n\nlocal my_arr = {}\nlocal min_value = math.min(table.unpack(arr))\nlocal min_index = 1\nfor i=1,#arr do\n    if arr[i]==min_value then\n        min_index = i\n        break\n    end\nend\nThe function initializes an empty array `my_arr` and finds the minimum value in the input array `arr`. It also finds the index of the first occurrence of the minimum value in the array.\n\nfor i=min_index,#arr do\n    my_arr[#my_arr+1]=arr[i]\nend\nfor i=1,min_index-1 do\n    my_arr[#my_arr+1]=arr[i]\nend\nThe function then constructs a new array `my_arr` by appending the elements of `arr` starting from the index of the minimum value to the end of the array, and then appending the elements of `arr` from the beginning of the array up to the index of the minimum value.\n\nfor i=1,#arr do\n    if my_arr[i]~=sorted_array[i] then\n        return false\n    end\nend\nThe function then checks if the new array `my_arr` is equal to the sorted array `sorted_array`. If they are not equal, it means that it is not possible to move one ball to sort the array, so the function returns `false`.\n\nreturn true\nIf the new array `my_arr` is equal to the sorted array `sorted_array`, it means that it is possible to move one ball to sort the array, so the function returns `true`.\n\n### Racket version\n\n#lang racket\n\n(define (move_one_ball arr)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digits n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 54) 5 0.001)\n    (check-within (candidate 120) 1 0.001)\n    (check-within (candidate 5014) 5 0.001)\n    (check-within (candidate 98765) 315 0.001)\n    (check-within (candidate 5576543) 2625 0.001)\n    (check-within (candidate 2468) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function digits(n)\n    local product = 1\n    local odd_count = 0\n    for digit in tostring(n):gmatch(\"%d\") do\n        local int_digit = tonumber(digit)\n        if int_digit%2 == 1 then\n            product= product*int_digit\n            odd_count=odd_count+1\n        end\n    end\n    if odd_count ==0 then\n        return 0\n    else\n        return product\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `digits` which takes a number `n` and returns the product of all its odd digits. If `n` has no odd digits, the function returns 0.\n\nlocal product = 1\nlocal odd_count = 0\nThe function initializes two variables: `product` to store the product of all odd digits, and `odd_count` to keep track of the number of odd digits.\n\nfor digit in tostring(n):gmatch(\"%d\") do\n    local int_digit = tonumber(digit)\n    if int_digit%2 == 1 then\n        product= product*int_digit\n        odd_count=odd_count+1\n    end\nend\nThe function iterates through each digit in the input number `n`. If the digit is odd, the function multiplies it to the `product` variable and increments the `odd_count` variable.\n\nif odd_count ==0 then\n    return 0\nelse\n    return product\nend\nIf `odd_count` is 0, it means that `n` has no odd digits, so the function returns 0. Otherwise, it returns the `product` variable.\n\n### Racket version\n\n#lang racket\n\n(define (digits n)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib4 n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib4))\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 28 0.001)\n    (check-within (candidate 10) 104 0.001)\n    (check-within (candidate 12) 386 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function fib4(n)\n  local results = {0, 0, 2, 0}\n  if n < 4 then\n    return results[n]\n  end\n\n  for i = 4, n do\n    table.insert(results, results[#results] + results[#results - 1] + results[#results - 2] + results[#results - 3])\n    table.remove(results, 1)\n  end\n\n  return results[#results]\nend\n\n### Explanation\n\nThe code is an implementation of the fourth-order Fibonacci sequence. It takes an integer `n` as input and returns the `n`th number in the sequence.\n\nlocal results = {0, 0, 2, 0}\nThe function initializes an array `results` with the first four numbers in the sequence: 0, 0, 2, and 0.\n\nif n < 4 then\n    return results[n]\nend\nIf `n` is less than 4, the function returns the corresponding number from the `results` array.\n\nfor i = 4, n do\n    table.insert(results, results[#results] + results[#results - 1] + results[#results - 2] + results[#results - 3])\n    table.remove(results, 1)\nend\nOtherwise, the function iterates from 4 to `n` and calculates the next number in the sequence by summing the previous four numbers in the `results` array. The new number is then appended to the `results` array and the first element is removed to keep the array length at 4.\n\nreturn results[#results]\nFinally, the function returns the last element in the `results` array, which is the `n`th number in the sequence.\n\n### Racket version\n\n#lang racket\n\n(define (fib4 n)\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_even l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_even))\n    (check-within (candidate (list 1 2 3)) (list 1 2 3) 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123) 0.001)\n    (check-within (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function sort_even(l)\n    local evens = {}\n    local odds = {}\n    for i = 1, #l, 2 do\n        table.insert(evens, l[i])\n    end\n    for i = 2, #l, 2 do\n        table.insert(odds, l[i])\n    end\n    table.sort(evens)\n    local ans = {}\n    for i = 1, math.min(#evens, #odds) do\n        table.insert(ans, evens[i])\n        table.insert(ans, odds[i])\n    end\n    if #evens > #odds then\n        table.insert(ans, evens[#evens])\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of even and odd numbers. It takes an array of numbers `l` as input and returns a sorted array of numbers where even numbers come first, sorted in ascending order, followed by odd numbers, sorted in ascending order.\n\nlocal evens = {}\nlocal odds = {}\nThe function first initializes two empty arrays `evens` and `odds` to store the even and odd numbers in the input array.\n\nfor i = 1, #l, 2 do\n    table.insert(evens, l[i])\nend\nfor i = 2, #l, 2 do\n    table.insert(odds, l[i])\nend\nThe function then iterates through the input array and appends the even numbers to the `evens` array and the odd numbers to the `odds` array.\n\ntable.sort(evens)\nThe function sorts the `evens` array in ascending order.\n\nlocal ans = {}\nfor i = 1, math.min(#evens, #odds) do\n    table.insert(ans, evens[i])\n    table.insert(ans, odds[i])\nend\nThe function then initializes an empty array `ans` to store the sorted array. It then iterates through the `evens` and `odds` arrays and appends the even and odd numbers to `ans` alternately.\n\nif #evens > #odds then\n    table.insert(ans, evens[#evens])\nend\nIf there are more even numbers than odd numbers, the function appends the last even number to the end of the `ans` array.\n\nreturn ans\nFinally, the function returns the sorted array.\n\n### Racket version\n\n#lang racket\n\n(define (sort_even l)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_happy s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n    (check-within (candidate \"a\") #f 0.001)\n    (check-within (candidate \"aa\") #f 0.001)\n    (check-within (candidate \"abcd\") #t 0.001)\n    (check-within (candidate \"aabb\") #f 0.001)\n    (check-within (candidate \"adb\") #t 0.001)\n    (check-within (candidate \"xyy\") #f 0.001)\n    (check-within (candidate \"iopaxpoi\") #t 0.001)\n    (check-within (candidate \"iopaxioi\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function is_happy(s)\n  if #s < 3 then\n    return false\n  end\n\n  for i = 1, #s - 2 do\n    if s:sub(i,i) == s:sub(i+1,i+1) or s:sub(i+1,i+1) == s:sub(i+2,i+2) or s:sub(i,i) == s:sub(i+2,i+2) then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether a string is \"happy\". A string is \"happy\" if no three consecutive characters are the same. The function takes a string `s` as input and returns a boolean.\n\nif #s < 3 then\n    return false\nThe function first checks if the length of the input string is less than 3. If it is, it returns false.\n\nfor i = 1, #s - 2 do\n    if s:sub(i,i) == s:sub(i+1,i+1) or s:sub(i+1,i+1) == s:sub(i+2,i+2) or s:sub(i,i) == s:sub(i+2,i+2) then\n        return false\n    end\nend\nOtherwise, the function iterates through each character in the string, checking if any three consecutive characters are the same. If any three consecutive characters are the same, the function returns false.\n\nreturn true\nIf no three consecutive characters are the same, the function returns true.\n\n### Racket version\n\n#lang racket\n\n(define (is_happy s)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (circular_shift x shift)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n    (check-within (candidate 100 2) \"001\" 0.001)\n    (check-within (candidate 12 2) \"12\" 0.001)\n    (check-within (candidate 97 8) \"79\" 0.001)\n    (check-within (candidate 12 1) \"21\" 0.001)\n    (check-within (candidate 11 101) \"11\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function circular_shift(x, shift)\n    local s = tostring(x)\n    if shift > #s then\n        return s:reverse()\n    else\n        return s:sub(#s-shift+1) .. s:sub(1, #s-shift)\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `circular_shift` which takes an integer `x` and a number of positions to shift `shift`, and returns the result of circularly shifting the digits of `x` by `shift` positions.\n\nif shift > #s then\n    return s:reverse()\nThe function first checks if the shift amount is greater than the length of the string representation of `x`. If it is, it simply returns the reverse of the string representation of `x`.\n\nelse\n    return s:sub(#s-shift+1) .. s:sub(1, #s-shift)\nOtherwise, the function returns the result of concatenating the substring of `s` from the `#s-shift+1`th position to the end of `s`, with the substring of `s` from the beginning to the `#s-shift`th position.\n\n### Racket version\n\n#lang racket\n\n(define (circular_shift x shift)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_fill grid capacity)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_fill))\n    (check-within (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function max_fill(grid, capacity)\n  local sum = 0\n  for i=1, #grid do\n    local row_sum = 0\n    for j=1, #grid[i] do\n      row_sum = row_sum + grid[i][j]\n    end\n    sum = sum + math.ceil(row_sum/capacity)\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `max_fill` which takes a 2D array `grid` and a number `capacity` as input, and returns the maximum number of times that the capacity can be filled in the grid.\n\nfor i=1, #grid do\n    local row_sum = 0\n    for j=1, #grid[i] do\n        row_sum = row_sum + grid[i][j]\n    end\n    sum = sum + math.ceil(row_sum/capacity)\nend\nThe function first iterates through each row of the grid, and calculates the sum of each row. It then adds the ceiling of the row sum divided by the capacity to the `sum` variable.\n\nreturn sum\nFinally, the function returns the `sum` variable, which represents the maximum number of times that the capacity can be filled in the grid.\n\n### Racket version\n\n#lang racket\n\n(define (max_fill grid capacity)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (has_close_elements numbers threshold)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function has_close_elements(numbers, threshold)\n  for idx, elem in ipairs(numbers) do\n    for idx2, elem2 in ipairs(numbers) do\n      if idx ~= idx2 then\n        local distance = math.abs(elem - elem2)\n        if distance < threshold then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `has_close_elements` which takes an array of numbers and a threshold value and returns a boolean indicating whether there are any two elements in the array whose absolute difference is less than the threshold.\n\nfor idx, elem in ipairs(numbers) do\n    for idx2, elem2 in ipairs(numbers) do\nThe function iterates through each element `elem` in the input array `numbers`, and for each element, it iterates through the array again to compare it with every other element `elem2`.\n\nif idx ~= idx2 then\n    local distance = math.abs(elem - elem2)\n    if distance < threshold then\n        return true\n    end\nend\nIf the two elements being compared are not the same, the function calculates the absolute difference between them and checks if it is less than the threshold. If it is, the function returns `true`.\n\nreturn false\nIf no two elements in the array have an absolute difference less than the threshold, the function returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (has_close_elements numbers threshold)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (numerical_letter_grade grades)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numerical_letter_grade))\n    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list \"A+\" \"B\" \"C-\" \"C\" \"A-\") 0.001)\n    (check-within (candidate (list 1.2)) (list \"D+\") 0.001)\n    (check-within (candidate (list 0.5)) (list \"D-\") 0.001)\n    (check-within (candidate (list 0.0)) (list \"E\") 0.001)\n    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list \"D\" \"D-\" \"C-\" \"B\" \"B+\") 0.001)\n    (check-within (candidate (list 0.0 0.7)) (list \"E\" \"D-\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function numerical_letter_grade(grades)\n    letter_grade = {}\n    for i, gpa in ipairs(grades) do\n        if gpa == 4.0 then\n            table.insert(letter_grade, \"A+\")\n        elseif gpa > 3.7 then\n            table.insert(letter_grade, \"A\")\n        elseif gpa > 3.3 then\n            table.insert(letter_grade, \"A-\")\n        elseif gpa > 3.0 then\n            table.insert(letter_grade, \"B+\")\n        elseif gpa > 2.7 then\n            table.insert(letter_grade, \"B\")\n        elseif gpa > 2.3 then\n            table.insert(letter_grade, \"B-\")\n        elseif gpa > 2.0 then\n            table.insert(letter_grade, \"C+\")\n        elseif gpa > 1.7 then\n            table.insert(letter_grade, \"C\")\n        elseif gpa > 1.3 then\n            table.insert(letter_grade, \"C-\")\n        elseif gpa > 1.0 then\n            table.insert(letter_grade, \"D+\")\n        elseif gpa > 0.7 then\n            table.insert(letter_grade, \"D\")\n        elseif gpa > 0.0 then\n            table.insert(letter_grade, \"D-\")\n        else\n            table.insert(letter_grade, \"E\")\n        end\n    end\n    return letter_grade\nend\n\n### Explanation\n\nThe code is an implementation of a function `numerical_letter_grade` which takes an array of numerical grades and returns an array of letter grades.\n\nletter_grade = {}\nThe function initializes an empty array `letter_grade` to store the letter grades.\n\nfor i, gpa in ipairs(grades) do\n    ...\nend\nThe function iterates through each numerical grade `gpa` in the input array `grades`.\n\nif gpa == 4.0 then\n    table.insert(letter_grade, \"A+\")\nelseif gpa > 3.7 then\n    table.insert(letter_grade, \"A\")\nelseif gpa > 3.3 then\n    table.insert(letter_grade, \"A-\")\n...\nend\nThe function then checks each numerical grade `gpa` against a series of conditions to determine the corresponding letter grade. The letter grade is then appended to the `letter_grade` array.\n\nreturn letter_grade\nFinally, the function returns the `letter_grade` array containing the letter grades.\n\n### Racket version\n\n#lang racket\n\n(define (numerical_letter_grade grades)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (x_or_y n x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate x_or_y))\n    (check-within (candidate 7 34 12) 34 0.001)\n    (check-within (candidate 15 8 5) 5 0.001)\n    (check-within (candidate 3 33 5212) 33 0.001)\n    (check-within (candidate 1259 3 52) 3 0.001)\n    (check-within (candidate 7919 -1 12) -1 0.001)\n    (check-within (candidate 3609 1245 583) 583 0.001)\n    (check-within (candidate 91 56 129) 129 0.001)\n    (check-within (candidate 6 34 1234) 1234 0.001)\n    (check-within (candidate 1 2 0) 0 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function x_or_y(n, x, y)\n    if n == 1 then\n        return y\n    end\n    for i=2, n-1 do\n        if n%i == 0 then\n            return y\n        end\n    end\n    return x\nend\n\n### Explanation\n\nThe code is an implementation of a function `x_or_y` which takes three arguments: an integer `n`, and two values `x` and `y`. The function returns `x` if `n` is prime, and `y` otherwise.\n\nif n == 1 then\n    return y\nThe function first checks if `n` is equal to 1. If it is, it returns `y`.\n\nfor i=2, n-1 do\n    if n % i == 0 then\n        return y\n    end\nend\nOtherwise, the function loops through all numbers between 2 and `n-1` (inclusive) to check if `n` is divisible by any of them. If `n` is divisible by any of them, it returns `y`.\n\nreturn x\nIf `n` is not equal to 1 and is not divisible by any number between 2 and `n-1`, the function returns `x`.\n\n### Racket version\n\n#lang racket\n\n(define (x_or_y n x y)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (specialFilter nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)\n    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)\n    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)\n    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)\n    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function specialFilter(nums)\n    local count = 0\n    for _, num in ipairs(nums) do\n        if num > 10 then\n            local odd_digits = {1, 3, 5, 7, 9}\n            local number_as_string = tostring(num)\n            if math.floor(num / 10^(#number_as_string - 1)) % 2 == 1 and num % 10 % 2 == 1 then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of a function `specialFilter` which takes an array of numbers and returns the number of elements in the array that are greater than 10 and have an odd first digit and an odd last digit.\n\nlocal count = 0\nThe function initializes a counter variable `count` to keep track of the number of elements that meet the criteria.\n\nfor _, num in ipairs(nums) do\n    if num > 10 then\n        ...\n    end\nend\nThe function iterates through each number in the input array `nums`. If the number is greater than 10, the function checks if it meets the criteria.\n\nlocal odd_digits = {1, 3, 5, 7, 9}\nlocal number_as_string = tostring(num)\nIf the number meets the criteria, the function initializes an array `odd_digits` containing the odd digits 1, 3, 5, 7, and 9. It also converts the number to a string to extract its digits.\n\nif math.floor(num / 10^(#number_as_string - 1)) % 2 == 1 and num % 10 % 2 == 1 then\n    count = count + 1\nend\nIf the first digit of the number is odd and the last digit of the number is odd, the function increments the `count` variable.\n\nreturn count\nFinally, the function returns the `count` variable containing the number of elements that meet the criteria.\n\n### Racket version\n\n#lang racket\n\n(define (specialFilter nums)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_music music_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_music))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"o o o o\") (list 4 4 4 4) 0.001)\n    (check-within (candidate \".| .| .| .|\") (list 1 1 1 1) 0.001)\n    (check-within (candidate \"o| o| .| .| o o o o\") (list 2 2 1 1 4 4 4 4) 0.001)\n    (check-within (candidate \"o| .| o| .| o o| o o|\") (list 2 1 2 1 4 2 4 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function parse_music(music_string)\n    local note_map = {o=4, ['o|']=2, ['.|']=1}\n    local notes = {}\n    for x in music_string:gmatch(\"%S+\") do\n        table.insert(notes, note_map[x])\n    end\n    return notes\nend\n\n### Explanation\n\nThe code is an implementation of parsing a string of music notes and returning an array of integers representing the notes. The function takes a string of music notes `music_string` as input and returns an array of integers.\n\nlocal note_map = {o=4, ['o|']=2, ['.|']=1}\nThe function first creates a table `note_map` that maps the note symbols to their corresponding integer values.\n\nfor x in music_string:gmatch(\"%S+\") do\n    table.insert(notes, note_map[x])\nend\nThe function then iterates through each non-space substring `x` in the input string `music_string`. It looks up the corresponding integer value of the note in the `note_map` table and appends it to the `notes` array.\n\nreturn notes\nFinally, the function returns the `notes` array containing the integer values of the notes.\n\n### Racket version\n\n#lang racket\n\n(define (parse_music music_string)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (split_words txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n    (check-within (candidate \"Hello world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello,world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello world,!\") (list \"Hello\" \"world,!\") 0.001)\n    (check-within (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\" \"!\") 0.001)\n    (check-within (candidate \"abcdef\") 3 0.001)\n    (check-within (candidate \"aaabb\") 2 0.001)\n    (check-within (candidate \"aaaBb\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function split_words(txt)\n    if string.find(txt, \" \") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt, \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    elseif string.find(txt, \",\") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt:gsub(\",\", \" \"), \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    else\n        local count = 0\n        for i = 1, #txt do\n            if string.match(txt:sub(i, i), \"%l\") and string.byte(txt:sub(i, i)) % 2 == 0 then\n                count = count + 1\n            end\n        end\n        return count\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `split_words` which takes a string as input and returns either an array of words, or a count of lowercase letters with even ASCII values, depending on the input string.\n\nif string.find(txt, \" \") ~= nil then\n    ...\nelseif string.find(txt, \",\") ~= nil then\n    ...\nelse\n    ...\nend\nThe function first checks if the input string contains spaces or commas. If it contains spaces, it splits the string into an array of words. If it contains commas, it replaces the commas with spaces and then splits the string into an array of words. If it contains neither spaces nor commas, it counts the number of lowercase letters with even ASCII values in the string.\n\nlocal words = {}\nfor word in string.gmatch(txt, \"%S+\") do\n    table.insert(words, word)\nend\nThe function uses `string.gmatch` to iterate through each word in the input string and appends each word to the `words` array.\n\nfor word in string.gmatch(txt:gsub(\",\", \" \"), \"%S+\") do\n    table.insert(words, word)\nend\nIf the input string contains commas, the function replaces the commas with spaces using `gsub`, and then uses `string.gmatch` to iterate through each word in the modified string and appends each word to the `words` array.\n\nfor i = 1, #txt do\n    if string.match(txt:sub(i, i), \"%l\") and string.byte(txt:sub(i, i)) % 2 == 0 then\n        count = count + 1\n    end\nend\nIf the input string contains neither spaces nor commas, the function initializes a counter variable `count` to 0 and iterates through each character in the input string. If the character is a lowercase letter with an even ASCII value, the function increments the `count` variable.\n\nreturn words or count\nFinally, the function returns either the `words` array or the `count` variable, depending on whether the input string contains spaces or commas.\n\n### Racket version\n\n#lang racket\n\n(define (split_words txt)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_distinct_characters string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_distinct_characters))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abcde\") 5 0.001)\n    (check-within (candidate \"abcdecadeCADE\") 5 0.001)\n    (check-within (candidate \"aaaaAAAAaaaa\") 1 0.001)\n    (check-within (candidate \"Jerry jERRY JeRRRY\") 5 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function count_distinct_characters(string)\n    local set = {}\n    for i=1, #string do\n        set[string:sub(i, i):lower()] = true\n    end\n    local count = 0\n    for k, v in pairs(set) do\n        count = count + 1\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of counting the number of distinct characters in a string. It takes a string `string` as input and returns the number of distinct characters in the string.\n\nlocal set = {}\nfor i=1, #string do\n    set[string:sub(i, i):lower()] = true\nend\nThe function first creates an empty table `set` to store the distinct characters in the string. It then iterates through each character in the string, converts it to lowercase, and adds it to the `set` table as a key.\n\nlocal count = 0\nfor k, v in pairs(set) do\n    count = count + 1\nend\nFinally, the function counts the number of keys in the `set` table and returns the count.\n\n### Racket version\n\n#lang racket\n\n(define (count_distinct_characters string)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (bf planet1 planet2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate bf))\n    (check-within (candidate \"Jupiter\" \"Neptune\") (list \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Mercury\") (list \"Venus\") 0.001)\n    (check-within (candidate \"Mercury\" \"Uranus\") (list \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\") 0.001)\n    (check-within (candidate \"Neptune\" \"Venus\") (list \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Mars\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Jupiter\" \"Makemake\") (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function bf(planet1, planet2)\n    local planet_names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    if not (table.concat(planet_names, ','):find(planet1) and table.concat(planet_names, ','):find(planet2)) or planet1 == planet2 then\n        return {}\n    end\n    local planet1_index = 0\n    local planet2_index = 0\n    for i, planet in ipairs(planet_names) do\n        if planet == planet1 then\n            planet1_index = i\n        elseif planet == planet2 then\n            planet2_index = i\n        end\n    end\n    if planet1_index < planet2_index then\n        return {table.unpack(planet_names, planet1_index + 1, planet2_index - 1)}\n    else\n        return {table.unpack(planet_names, planet2_index + 1, planet1_index - 1)}\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `bf` which takes two planet names as input and returns an array of planet names that are between the two input planets in the solar system.\n\nlocal planet_names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\nThe function first initializes an array `planet_names` containing the names of the planets in the solar system.\n\nif not (table.concat(planet_names, ','):find(planet1) and table.concat(planet_names, ','):find(planet2)) or planet1 == planet2 then\n    return {}\nend\nThe function checks if the input planet names are valid and not the same. If either of these conditions is not met, it returns an empty array.\n\nlocal planet1_index = 0\nlocal planet2_index = 0\nThe function initializes two variables `planet1_index` and `planet2_index` to 0 to keep track of the indices of the input planets in the `planet_names` array.\n\nfor i, planet in ipairs(planet_names) do\n    if planet == planet1 then\n        planet1_index = i\n    elseif planet == planet2 then\n        planet2_index = i\n    end\nend\nThe function iterates through the `planet_names` array and sets the `planet1_index` and `planet2_index` variables to the indices of the input planets.\n\nif planet1_index < planet2_index then\n    return {table.unpack(planet_names, planet1_index + 1, planet2_index - 1)}\nelse\n    return {table.unpack(planet_names, planet2_index + 1, planet1_index - 1)}\nend\nFinally, the function returns an array of planet names between the two input planets. If `planet1_index` is less than `planet2_index`, the function returns a subarray of `planet_names` containing the planets between the two input planets. Otherwise, it returns a subarray of `planet_names` containing the planets between the two input planets in reverse order.\n\n### Racket version\n\n#lang racket\n\n(define (bf planet1 planet2)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digitSum s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abAB\") 131 0.001)\n    (check-within (candidate \"abcCd\") 67 0.001)\n    (check-within (candidate \"helloE\") 69 0.001)\n    (check-within (candidate \"woArBld\") 131 0.001)\n    (check-within (candidate \"aAaaaXa\") 153 0.001)\n    (check-within (candidate \" How are yOu?\") 151 0.001)\n    (check-within (candidate \"You arE Very Smart\") 327 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function digitSum(s)\n    if s == \"\" then return 0 end\n    local sum = 0\n    for char in s:gmatch(\".\") do\n        sum = sum + (char:match(\"%u\") and string.byte(char) or 0)\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `digitSum` that takes a string as input and returns the sum of the ASCII values of all uppercase letters in the string.\n\nif s == \"\" then return 0 end\nThe function first checks if the input string is empty. If it is, it returns 0.\n\nlocal sum = 0\nfor char in s:gmatch(\".\") do\n    sum = sum + (char:match(\"%u\") and string.byte(char) or 0)\nend\nThe function then initializes a variable `sum` to 0 and iterates through each character `char` in the input string `s`. It uses the `gmatch` function to iterate through each character in the string.\n\nThe program then checks if the character is an uppercase letter using the `match` function and the pattern `%u`. If it is, it adds the ASCII value of the character to the `sum` variable. If it is not, it adds 0 to the `sum` variable.\n\nreturn sum\nFinally, the function returns the `sum` variable containing the sum of the ASCII values of all uppercase letters in the string.\n\n### Racket version\n\n#lang racket\n\n(define (digitSum s)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 1 4 9)) 14 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) 9 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1)) -3 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list -1 -5 2 -1 -5)) -126 0.001)\n    (check-within (candidate (list -56 -99 1 0 -2)) 3030 0.001)\n    (check-within (candidate (list -1 0 0 0 0 0 0 0 -1)) 0 0.001)\n    (check-within (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37)) -14196 0.001)\n    (check-within (candidate (list -1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10)) -1448 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n    local result = {}\n    for i=1, #lst do\n        if i % 3 == 1 then\n            result[#result+1] = lst[i]^2\n        elseif i % 4 == 1 and i % 3 ~= 1 then\n            result[#result+1] = lst[i]^3\n        else\n            result[#result+1] = lst[i]\n        end\n    end\n    local sum = 0\n    for i=1, #result do\n        sum = sum + result[i]\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `sum_squares` which takes an array of numbers and returns the sum of the squares of the first number, the cubes of every fourth number, and the remaining numbers.\n\nlocal result = {}\nThe function initializes an empty array `result` to store the modified numbers.\n\nfor i=1, #lst do\n    if i % 3 == 1 then\n        result[#result+1] = lst[i]^2\nIf the index of the current number is a multiple of 3 plus 1, the function squares the number and appends it to the `result` array.\n\nelseif i % 4 == 1 and i % 3 ~= 1 then\n    result[#result+1] = lst[i]^3\nIf the index of the current number is a multiple of 4 plus 1, but not a multiple of 3 plus 1, the function cubes the number and appends it to the `result` array.\n\nelse\n    result[#result+1] = lst[i]\nOtherwise, the function appends the number to the `result` array.\n\nlocal sum = 0\nfor i=1, #result do\n    sum = sum + result[i]\nend\nThe function then calculates the sum of the numbers in the `result` array.\n\nreturn sum\nFinally, the function returns the sum.\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_up_to n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_up_to))\n    (check-within (candidate 5) (list 2 3) 0.001)\n    (check-within (candidate 6) (list 2 3 5) 0.001)\n    (check-within (candidate 7) (list 2 3 5) 0.001)\n    (check-within (candidate 10) (list 2 3 5 7) 0.001)\n    (check-within (candidate 0) (list ) 0.001)\n    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)\n    (check-within (candidate 1) (list ) 0.001)\n    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)\n    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)\n    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function count_up_to(n)\n  local primes = {}\n  for i = 2, n - 1 do\n    local is_prime = true\n    for j = 2, i - 1 do\n      if i % j == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(primes, i)\n    end\n  end\n  return primes\nend\n\n### Explanation\n\nThe code is an implementation of finding all prime numbers up to a given number `n`. It takes a number `n` as input and returns an array of prime numbers.\n\nlocal primes = {}\nThe function initializes an empty array `primes` to store the prime numbers.\n\nfor i = 2, n - 1 do\n    ...\nend\nThe function iterates through all numbers between 2 and `n-1`.\n\nlocal is_prime = true\nfor j = 2, i - 1 do\n    if i % j == 0 then\n        is_prime = false\n        break\n    end\nend\nThe function then checks if each number `i` is prime by iterating through all numbers between 2 and `i-1`. If `i` is divisible by any number between 2 and `i-1`, it is not prime and the loop is broken.\n\nif is_prime then\n    table.insert(primes, i)\nend\nIf `i` is prime, it is appended to the `primes` array.\n\nreturn primes\nFinally, the function returns the `primes` array containing all prime numbers up to `n`.\n\n### Racket version\n\n#lang racket\n\n(define (count_up_to n)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)\n    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)\n    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)\n    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)\n    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)\n    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)\n    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)\n    (check-within (candidate (list 0.0)) 0 0.001)\n    (check-within (candidate (list -1.0)) 1 0.001)\n    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n  local squared = 0\n  for _, i in ipairs(lst) do\n    squared = squared + math.ceil(i)^2\n  end\n  return squared\nend\n\n### Explanation\n\nThe code is an implementation of a function `sum_squares` which takes an array of numbers and returns the sum of the squares of each element in the array.\n\nlocal squared = 0\nThe function initializes a variable `squared` to 0 to store the sum of the squares of the elements in the array.\n\nfor _, i in ipairs(lst) do\n    squared = squared + math.ceil(i)^2\nend\nThe function iterates through each element `i` in the input array `lst`. It then adds the square of the element to the `squared` variable.\n\nreturn squared\nFinally, the function returns the `squared` variable containing the sum of the squares of the elements in the array.\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique))\n    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function unique(l)\n  local s = {}\n  for _, v in ipairs(l) do\n    s[v] = true\n  end\n  local r = {}\n  for k, _ in pairs(s) do\n    table.insert(r, k)\n  end\n  table.sort(r)\n  return r\nend\n\n### Explanation\n\nThe code is an implementation of a function `unique` which takes an array of values and returns a new array containing only the unique values in the input array.\n\nlocal s = {}\nfor _, v in ipairs(l) do\n    s[v] = true\nend\nThe function first creates an empty table `s` to store the unique values in the input array. It then iterates through each value `v` in the input array `l` and adds it as a key to the `s` table with a value of `true`.\n\nlocal r = {}\nfor k, _ in pairs(s) do\n    table.insert(r, k)\nend\nThe function then creates an empty table `r` to store the unique values in the input array. It iterates through each key `k` in the `s` table and appends it to the `r` table.\n\ntable.sort(r)\nFinally, the function sorts the `r` table in ascending order and returns it.\n\n### Racket version\n\n#lang racket\n\n(define (unique l)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n    (check-within (candidate 10) 55 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 8) 21 0.001)\n    (check-within (candidate 11) 89 0.001)\n    (check-within (candidate 12) 144 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function fib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nend\n\n### Explanation\n\nThe code is an implementation of a recursive function `fib` that returns the nth Fibonacci number. It takes an integer `n` as input and returns an integer.\n\nif n == 0 then\n    return 0\nelseif n == 1 then\n    return 1\nend\nThe function first checks if `n` is 0 or 1. If it is, it returns 0 or 1 respectively, as these are the base cases of the Fibonacci sequence.\n\nreturn fib(n - 1) + fib(n - 2)\nOtherwise, the function recursively calls itself with `n-1` and `n-2` as inputs and returns the sum of the two results. This is because the nth Fibonacci number is the sum of the (n-1)th and (n-2)th Fibonacci numbers.\n\n### Racket version\n\n#lang racket\n\n(define (fib n)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fizz_buzz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n    (check-within (candidate 50) 0 0.001)\n    (check-within (candidate 78) 2 0.001)\n    (check-within (candidate 79) 3 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 200) 6 0.001)\n    (check-within (candidate 4000) 192 0.001)\n    (check-within (candidate 10000) 639 0.001)\n    (check-within (candidate 100000) 8026 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function fizz_buzz(n)\n  local ns = {}\n  for i = 0, n - 1 do\n    if i % 11 == 0 or i % 13 == 0 then\n      table.insert(ns, i)\n    end\n  end\n  local s = table.concat(ns)\n  local ans = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '7' then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function `fizz_buzz` which takes an integer `n` as input and returns the number of times the digit 7 appears in the concatenation of all numbers between 0 and `n-1` (inclusive) that are divisible by 11 or 13.\n\nlocal ns = {}\nThe function initializes an empty array `ns` to store the numbers that are divisible by 11 or 13.\n\nfor i = 0, n - 1 do\n    if i % 11 == 0 or i % 13 == 0 then\n        table.insert(ns, i)\n    end\nend\nThe function loops through all numbers between 0 and `n-1` (inclusive) and checks if each number is divisible by 11 or 13. If it is, the number is appended to the `ns` array.\n\nlocal s = table.concat(ns)\nThe function then concatenates all the numbers in the `ns` array into a single string `s`.\n\nlocal ans = 0\nfor i = 1, #s do\n    if s:sub(i, i) == '7' then\n        ans = ans + 1\n    end\nend\nThe function then loops through each character in the `s` string and increments the `ans` variable if the character is `'7'`.\n\nreturn ans\nFinally, the function returns the `ans` variable containing the number of times the digit 7 appears in the concatenation of all numbers between 0 and `n-1` (inclusive) that are divisible by 11 or 13.\n\n### Racket version\n\n#lang racket\n\n(define (fizz_buzz n)\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (Strongest_Extension class_name extensions)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n    (check-within (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\")) \"Watashi.eIGHt8OKe\" 0.001)\n    (check-within (candidate \"Boku123\" (list \"nani\" \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\" 0.001)\n    (check-within (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\" \"123NoooneB321\")) \"__YESIMHERE.NuLl__\" 0.001)\n    (check-within (candidate \"K\" (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\" 0.001)\n    (check-within (candidate \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\" 0.001)\n    (check-within (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"-_-\")) \"YameRore.okIWILL123\" 0.001)\n    (check-within (candidate \"finNNalLLly\" (list \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\" 0.001)\n    (check-within (candidate \"_\" (list \"Bb\" \"91245\")) \"_.Bb\" 0.001)\n    (check-within (candidate \"Sp\" (list \"671235\" \"Bb\")) \"Sp.671235\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function Strongest_Extension(class_name, extensions)\n    local strong = extensions[1]\n    local my_val = #extensions[1]:gsub('[^%a]', ''):gsub('[^%u]', '') - #extensions[1]:gsub('[^%a]', ''):gsub('[^%l]', '')\n    for i = 2, #extensions do\n        local s = extensions[i]\n        local val = #s:gsub('[^%a]', ''):gsub('[^%u]', '') - #s:gsub('[^%a]', ''):gsub('[^%l]', '')\n        if val > my_val then\n            strong = s\n            my_val = val\n        end\n    end\n    return class_name .. '.' .. strong\nend\n\n### Explanation\n\nThe code is an implementation of a function `Strongest_Extension` which takes a class name and an array of extensions, and returns the name of the strongest extension. The strongest extension is the one with the highest number of uppercase letters minus the number of lowercase letters.\n\nlocal strong = extensions[1]\nThe function initializes the variable `strong` to the first extension in the array.\n\nlocal my_val = #extensions[1]:gsub('[^%a]', ''):gsub('[^%u]', '') - #extensions[1]:gsub('[^%a]', ''):gsub('[^%l]', '')\nThe function initializes the variable `my_val` to the number of uppercase letters minus the number of lowercase letters in the first extension.\n\nfor i = 2, #extensions do\n    ...\nend\nThe function then iterates through the rest of the extensions in the array.\n\nlocal s = extensions[i]\nlocal val = #s:gsub('[^%a]', ''):gsub('[^%u]', '') - #s:gsub('[^%a]', ''):gsub('[^%l]', '')\nFor each extension `s`, the function calculates the number of uppercase letters minus the number of lowercase letters in `s`.\n\nif val > my_val then\n    strong = s\n    my_val = val\nIf `val` is greater than `my_val`, the function updates `strong` to `s` and `my_val` to `val`.\n\nreturn class_name .. '.' .. strong\nFinally, the function returns the class name concatenated with the strongest extension.\n\n### Racket version\n\n#lang racket\n\n(define (Strongest_Extension class_name extensions)\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_closest_elements numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function find_closest_elements(numbers)\n    local closest_pair = nil\n    local distance = nil\n\n    for idx, elem in ipairs(numbers) do\n        for idx2, elem2 in ipairs(numbers) do\n            if idx ~= idx2 then\n                if distance == nil then\n                    distance = math.abs(elem - elem2)\n                    closest_pair = {elem, elem2}\n                else\n                    new_distance = math.abs(elem - elem2)\n                    if new_distance < distance then\n                        distance = new_distance\n                        closest_pair = {elem, elem2}\n                    end\n                end\n            end\n        end\n    end\n\n    table.sort(closest_pair)\n    return closest_pair\nend\n\n### Explanation\n\nThe code is an implementation of finding the two numbers in an array that have the smallest absolute difference. It takes an array of numbers `numbers` as input and returns a sorted array of the two numbers with the smallest absolute difference.\n\nlocal closest_pair = nil\nlocal distance = nil\nThe function initializes two variables `closest_pair` and `distance` to `nil`.\n\nfor idx, elem in ipairs(numbers) do\n    for idx2, elem2 in ipairs(numbers) do\n        if idx ~= idx2 then\nThe function iterates through each element `elem` in the input array `numbers`, and for each element, it iterates through all other elements `elem2` in the array.\n\nif distance == nil then\n    distance = math.abs(elem - elem2)\n    closest_pair = {elem, elem2}\nIf the `distance` variable is `nil`, it means that this is the first pair of elements being compared, so the function sets `distance` to the absolute difference between the two elements and sets `closest_pair` to the pair of elements.\n\nelse\n    new_distance = math.abs(elem - elem2)\n    if new_distance < distance then\n        distance = new_distance\n        closest_pair = {elem, elem2}\nIf the `distance` variable is not `nil`, the function calculates the absolute difference between the two elements and compares it to the current `distance`. If the new distance is smaller than the current `distance`, the function updates `distance` to the new distance and updates `closest_pair` to the new pair of elements.\n\ntable.sort(closest_pair)\nFinally, the function sorts the `closest_pair` array in ascending order and returns it.\n\n### Racket version\n\n#lang racket\n\n(define (find_closest_elements numbers)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (valid_date date)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_date))\n    (check-within (candidate \"03-11-2000\") #t 0.001)\n    (check-within (candidate \"15-01-2012\") #f 0.001)\n    (check-within (candidate \"04-0-2040\") #f 0.001)\n    (check-within (candidate \"06-04-2020\") #t 0.001)\n    (check-within (candidate \"01-01-2007\") #t 0.001)\n    (check-within (candidate \"03-32-2011\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"04-31-3000\") #f 0.001)\n    (check-within (candidate \"06-06-2005\") #t 0.001)\n    (check-within (candidate \"21-31-2000\") #f 0.001)\n    (check-within (candidate \"04-12-2003\") #t 0.001)\n    (check-within (candidate \"04122003\") #f 0.001)\n    (check-within (candidate \"20030412\") #f 0.001)\n    (check-within (candidate \"2003-04\") #f 0.001)\n    (check-within (candidate \"2003-04-12\") #f 0.001)\n    (check-within (candidate \"04-2003\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function valid_date(date)\n    local month, day, year = date:match(\"(%d+)-(%d+)-(%d+)\")\n    if not month or not day or not year then\n        return false\n    end\n    month, day, year = tonumber(month), tonumber(day), tonumber(year)\n    if month < 1 or month > 12 then\n        return false\n    end\n    if month == 2 and (day < 1 or day > 29) then\n        return false\n    end\n    if month == 4 or month == 6 or month == 9 or month == 11 then\n        if day < 1 or day > 30 then\n            return false\n        end\n    else\n        if day < 1 or day > 31 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `valid_date` which takes a string in the format \"MM-DD-YYYY\" and returns a boolean indicating whether the date is valid.\n\nlocal month, day, year = date:match(\"(%d+)-(%d+)-(%d+)\")\nThe function first extracts the month, day, and year from the input string using pattern matching.\n\nif not month or not day or not year then\n    return false\nend\nIf any of the month, day, or year variables are nil, the function returns false.\n\nmonth, day, year = tonumber(month), tonumber(day), tonumber(year)\nThe function then converts the month, day, and year variables to numbers.\n\nif month < 1 or month > 12 then\n    return false\nend\nThe function checks if the month is between 1 and 12 (inclusive).\n\nif month == 2 and (day < 1 or day > 29) then\n    return false\nend\nIf the month is February, the function checks if the day is between 1 and 29 (inclusive).\n\nif month == 4 or month == 6 or month == 9 or month == 11 then\n    if day < 1 or day > 30 then\n        return false\n    end\nelse\n    if day < 1 or day > 31 then\n        return false\n    end\nend\nIf the month is April, June, September, or November, the function checks if the day is between 1 and 30 (inclusive). Otherwise, it checks if the day is between 1 and 31 (inclusive).\n\nreturn true\nFinally, the function returns true if the date is valid, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n(define (valid_date date)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate 0 1) 1 0.001)\n    (check-within (candidate 1 0) 1 0.001)\n    (check-within (candidate 2 3) 5 0.001)\n    (check-within (candidate 5 7) 12 0.001)\n    (check-within (candidate 7 5) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function add(x, y)\n  return x + y\nend\n\n### Explanation\n\nThe code is an implementation of a function `add` that takes two numbers `x` and `y` as input and returns their sum.\n\nreturn x + y\nThe function simply returns the sum of `x` and `y`.\n\n### Racket version\n\n#lang racket\n\n(define (add x y)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triples_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -1)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 1 2 5 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 9 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -100)) #f 0.001)\n    (check-within (candidate (list 100 3 5 -100)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function triples_sum_to_zero(l)\n  for i = 1, #l do\n    for j = i + 1, #l do\n      for k = j + 1, #l do\n        if l[i] + l[j] + l[k] == 0 then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `triples_sum_to_zero` which takes an array of integers and returns `true` if there exists a triplet of integers in the array that sum to zero, and `false` otherwise.\n\nfor i = 1, #l do\n    for j = i + 1, #l do\n        for k = j + 1, #l do\nThe function uses three nested loops to iterate through all possible triplets of integers in the array.\n\nif l[i] + l[j] + l[k] == 0 then\n    return true\nIf the sum of the current triplet is zero, the function returns `true`.\n\nreturn false\nIf no triplet is found that sums to zero, the function returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (triples_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_divisor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_divisor))\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 10) 5 0.001)\n    (check-within (candidate 100) 50 0.001)\n    (check-within (candidate 49) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function largest_divisor(n)\n    for i=n-1, 1, -1 do\n        if n % i == 0 then\n            return i\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of finding the largest divisor of a number `n`. It takes a number `n` as input and returns the largest divisor of `n`.\n\nfor i=n-1, 1, -1 do\n    if n % i == 0 then\n        return i\n    end\nend\nThe function iterates through all numbers from `n-1` down to `1`. If a number `i` is a divisor of `n`, it returns `i`.\n\n### Racket version\n\n#lang racket\n\n(define (largest_divisor n)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_numbers numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"three\") \"three\" 0.001)\n    (check-within (candidate \"three five nine\") \"three five nine\" 0.001)\n    (check-within (candidate \"five zero four seven nine eight\") \"zero four five seven eight nine\" 0.001)\n    (check-within (candidate \"six five four three two one zero\") \"zero one two three four five six\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function sort_numbers(numbers)\n    local value_map = {\n        zero = 0,\n        one = 1,\n        two = 2,\n        three = 3,\n        four = 4,\n        five = 5,\n        six = 6,\n        seven = 7,\n        eight = 8,\n        nine = 9\n    }\n    local words = {}\n    for word in numbers:gmatch(\"%w+\") do\n        table.insert(words, word)\n    end\n    table.sort(words, function(a, b) return value_map[a] < value_map[b] end)\n    return table.concat(words, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of sorting a string of numbers in words. It takes a string of numbers in words `numbers` as input and returns a string of sorted numbers in words.\n\nlocal value_map = {\n    zero = 0,\n    one = 1,\n    two = 2,\n    three = 3,\n    four = 4,\n    five = 5,\n    six = 6,\n    seven = 7,\n    eight = 8,\n    nine = 9\n}\nThe function first creates a table `value_map` that maps each number in words to its corresponding numerical value.\n\nlocal words = {}\nfor word in numbers:gmatch(\"%w+\") do\n    table.insert(words, word)\nend\nThe function then extracts all the words from the input string using the `gmatch` function and stores them in an array `words`.\n\ntable.sort(words, function(a, b) return value_map[a] < value_map[b] end)\nThe function sorts the `words` array in ascending order of their numerical values using the `value_map` table as a reference.\n\nreturn table.concat(words, ' ')\nFinally, the function concatenates the sorted words into a string separated by spaces and returns it.\n\n### Racket version\n\n#lang racket\n\n(define (sort_numbers numbers)\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (smallest_change arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallest_change))\n    (check-within (candidate (list 1 2 3 5 4 7 9 6)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 3 2 2)) 1 0.001)\n    (check-within (candidate (list 1 4 2)) 1 0.001)\n    (check-within (candidate (list 1 4 4 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 3 1 1 3)) 0 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function smallest_change(arr)\n  local ans = 0\n  for i = 1, math.floor(#arr / 2) do\n    if arr[i] ~= arr[#arr - i + 1] then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThe code is an implementation of finding the smallest number of changes needed to make an array a palindrome. It takes an array of numbers `arr` as input and returns the smallest number of changes needed to make the array a palindrome.\n\nfor i = 1, math.floor(#arr / 2) do\n    if arr[i] ~= arr[#arr - i + 1] then\n        ans = ans + 1\n    end\nend\nThe function iterates through the first half of the array and checks if the element at index `i` is equal to the element at index `#arr - i + 1`. If they are not equal, it increments the `ans` variable by 1.\n\nreturn ans\nFinally, the function returns the `ans` variable, which is the smallest number of changes needed to make the array a palindrome.\n\n### Racket version\n\n#lang racket\n\n(define (smallest_change arr)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_threshold l t)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_threshold))\n    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)\n    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function below_threshold(l, t)\n  for _, e in ipairs(l) do\n    if e >= t then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `below_threshold` which takes a list of numbers and a threshold value `t` and returns `true` if all the numbers in the list are less than `t`, and `false` otherwise.\n\nfor _, e in ipairs(l) do\n    if e >= t then\n        return false\n    end\nend\nThe function iterates through each element `e` in the input list `l`. If any element is greater than or equal to the threshold value `t`, the function returns `false`.\n\nreturn true\nIf all elements in the list are less than the threshold value `t`, the function returns `true`.\n\n### Racket version\n\n#lang racket\n\n(define (below_threshold l t)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prod_signs arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-within (candidate (list 1 2 2 -4)) -9 0.001)\n    (check-within (candidate (list 0 1)) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 3 -1 1)) -10 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 2 4 1 2 -1 -1 9)) 20 0.001)\n    (check-within (candidate (list -1 1 -1 1)) 4 0.001)\n    (check-within (candidate (list -1 1 1 1)) -4 0.001)\n    (check-within (candidate (list -1 1 1 0)) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n    local prod = 0\n    local neg_count = 0\n    for i = 1, #arr do\n        if arr[i] == 0 then\n            return 0\n        end\n        if arr[i] < 0 then\n            neg_count = neg_count + 1\n        end\n    end\n    prod = math.pow(-1, neg_count)\n    local sum = 0\n    for i = 1, #arr do\n        sum = sum + math.abs(arr[i])\n    end\n    return prod * sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `prod_signs` which takes an array of numbers and returns the product of the signs of the numbers multiplied by the sum of the absolute values of the numbers.\n\nif #arr == 0 then\n    return nil\nend\nThe function first checks if the input array is empty. If it is, it returns `nil`.\n\nfor i = 1, #arr do\n    if arr[i] == 0 then\n        return 0\n    end\nIf the input array contains a `0`, the function returns `0`.\n\nif arr[i] < 0 then\n    neg_count = neg_count + 1\nend\nThe function counts the number of negative numbers in the input array.\n\nprod = math.pow(-1, neg_count)\nThe function calculates the product of the signs of the numbers in the input array by raising -1 to the power of the number of negative numbers in the array.\n\nfor i = 1, #arr do\n    sum = sum + math.abs(arr[i])\nend\nThe function calculates the sum of the absolute values of the numbers in the input array.\n\nreturn prod * sum\nFinally, the function returns the product of the signs of the numbers multiplied by the sum of the absolute values of the numbers.\n\n### Racket version\n\n#lang racket\n\n(define (prod_signs arr)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (modp n p)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n    (check-within (candidate 3 5) 3 0.001)\n    (check-within (candidate 1101 101) 2 0.001)\n    (check-within (candidate 0 101) 1 0.001)\n    (check-within (candidate 3 11) 8 0.001)\n    (check-within (candidate 100 101) 1 0.001)\n    (check-within (candidate 30 5) 4 0.001)\n    (check-within (candidate 31 5) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function modp(n, p)\n    local ret = 1\n    for i=1, n do\n        ret = (2 * ret) % p\n    end\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function `modp` which takes two integers `n` and `p` and returns the value of `(2^n) % p`.\n\nlocal ret = 1\nThe function initializes a variable `ret` to 1.\n\nfor i=1, n do\n    ret = (2 * ret) % p\nend\nThe function then iterates `n` times, multiplying `ret` by 2 and taking the result modulo `p` each time.\n\nreturn ret\nFinally, the function returns the final value of `ret`.\n\n### Racket version\n\n#lang racket\n\n(define (modp n p)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_upper s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n    (check-within (candidate \"aBCdEf\") 1 0.001)\n    (check-within (candidate \"abcdefg\") 0 0.001)\n    (check-within (candidate \"dBBE\") 0 0.001)\n    (check-within (candidate \"B\") 0 0.001)\n    (check-within (candidate \"U\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"EEEE\") 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function count_upper(s)\n    local count = 0\n    for i = 1, #s, 2 do\n        if s:sub(i, i):match(\"[AEIOU]\") then\n            count = count + 1\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of counting the number of uppercase vowels in a string. It takes a string `s` as input and returns the number of uppercase vowels in the string.\n\nfor i = 1, #s, 2 do\n    if s:sub(i, i):match(\"[AEIOU]\") then\n        count = count + 1\n    end\nend\nThe function iterates through the string `s` by every other character. It then checks if the character is an uppercase vowel (A, E, I, O, or U) using the `match` function with the regular expression `[AEIOU]`. If the character is an uppercase vowel, it increments the `count` variable.\n\nreturn count\nFinally, the function returns the `count` variable containing the number of uppercase vowels in the string.\n\n### Racket version\n\n#lang racket\n\n(define (count_upper s)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (multiply a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate multiply))\n    (check-within (candidate 148 412) 16 0.001)\n    (check-within (candidate 19 28) 72 0.001)\n    (check-within (candidate 2020 1851) 0 0.001)\n    (check-within (candidate 14 -15) 20 0.001)\n    (check-within (candidate 76 67) 42 0.001)\n    (check-within (candidate 17 27) 49 0.001)\n    (check-within (candidate 0 1) 0 0.001)\n    (check-within (candidate 0 0) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function multiply(a, b)\n  return math.abs(a % 10) * math.abs(b % 10)\nend\n\n### Explanation\n\nThe code is an implementation of a function `multiply` which takes two numbers `a` and `b` and returns the product of the last digits of the two numbers.\n\nreturn math.abs(a % 10) * math.abs(b % 10)\nThe function first takes the absolute value of the last digit of each number using the modulo operator `%`. It then multiplies the two last digits together and returns the result.\n\n### Racket version\n\n#lang racket\n\n(define (multiply a b)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique_digits x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_digits))\n    (check-within (candidate (list 15 33 1422 1)) (list 1 15 33) 0.001)\n    (check-within (candidate (list 152 323 1422 10)) (list ) 0.001)\n    (check-within (candidate (list 12345 2033 111 151)) (list 111 151) 0.001)\n    (check-within (candidate (list 135 103 31)) (list 31 135) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function unique_digits(x)\n    local odd_digit_elements = {}\n    for i=1, #x do\n        if string.match(tostring(x[i]), '^[13579]+$') then\n            table.insert(odd_digit_elements, x[i])\n        end\n    end\n    table.sort(odd_digit_elements)\n    return odd_digit_elements\nend\n\n### Explanation\n\nThe code is an implementation of a function `unique_digits` which takes an array of numbers and returns an array of numbers that have only odd digits. The function sorts the resulting array in ascending order.\n\nlocal odd_digit_elements = {}\nThe function initializes an empty array `odd_digit_elements` to store the numbers that have only odd digits.\n\nfor i=1, #x do\n    local is_odd = true\n    for c in tostring(x[i]):gmatch\".\" do\n        if tonumber(c) % 2 == 0 then\n            is_odd = false\n            break\n        end\n    end\n    if is_odd then\n        table.insert(odd_digit_elements, x[i])\n    end\nend\nThe function iterates through each number `x[i]` in the input array `x`. It then checks if each digit in the number is odd. If all digits are odd, the number is appended to the `odd_digit_elements` array.\n\ntable.sort(odd_digit_elements)\nFinally, the function sorts the `odd_digit_elements` array in ascending order.\n\nreturn odd_digit_elements\nThe function returns the `odd_digit_elements` array.\n\n### Racket version\n\n#lang racket\n\n(define (unique_digits x)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_multiply_prime a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_multiply_prime))\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #f 0.001)\n    (check-within (candidate 125) #t 0.001)\n    (check-within (candidate 105) #t 0.001)\n    (check-within (candidate 126) #f 0.001)\n    (check-within (candidate 729) #f 0.001)\n    (check-within (candidate 891) #f 0.001)\n    (check-within (candidate 1001) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function is_multiply_prime(a)\n  local function is_prime(n)\n    for j = 2, n-1 do\n      if n%j == 0 then\n        return false\n      end\n    end\n    return true\n  end\n\n  for i = 2, 100 do\n    if not is_prime(i) then goto continue1 end\n    for j = 2, 100 do\n      if not is_prime(j) then goto continue2 end\n      for k = 2, 100 do\n        if not is_prime(k) then goto continue3 end\n        if i*j*k == a then return true end\n        ::continue3::\n      end\n      ::continue2::\n    end\n    ::continue1::\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_multiply_prime` which takes an integer `a` and returns a boolean indicating whether it is the product of three prime numbers.\n\nlocal function is_prime(n)\n    for j = 2, n-1 do\n      if n%j == 0 then\n        return false\n      end\n    end\n    return true\nend\nThe function first defines a helper function `is_prime` that takes a number and returns `true` if it is prime and `false` otherwise. This is done by checking if the number is divisible by any number between 2 and `n-1`.\n\nfor i = 2, 100 do\n    if not is_prime(i) then goto continue1 end\n    for j = 2, 100 do\n        if not is_prime(j) then goto continue2 end\n        for k = 2, 100 do\n            if not is_prime(k) then goto continue3 end\n            if i*j*k == a then return true end\n            ::continue3::\n        end\n        ::continue2::\n    end\n    ::continue1::\nend\nThe function then loops through all possible combinations of three prime numbers between 2 and 100. If the product of the three numbers is equal to `a`, the function returns `true`. Otherwise, it continues to the next combination of prime numbers.\n\nreturn false\nIf no combination of three prime numbers results in `a`, the function returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (is_multiply_prime a)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (maximum arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)\n    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)\n    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)\n    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)\n    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)\n    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)\n    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)\n    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)\n    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)\n    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)\n    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function maximum(arr, k)\n    if k == 0 then\n        return {}\n    end\n    table.sort(arr)\n    local ans = {}\n    for i=#arr-k+1, #arr do\n        table.insert(ans, arr[i])\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of finding the `k` largest elements in an array `arr`. It takes an array of numbers `arr` and an integer `k` as input and returns an array of the `k` largest elements in `arr`.\n\nif k == 0 then\n    return {}\nThe function first checks if `k` is 0. If it is, it returns an empty array.\n\ntable.sort(arr)\nThe function then sorts the input array `arr` in ascending order.\n\nfor i=#arr-k+1, #arr do\n    table.insert(ans, arr[i])\nend\nThe function then iterates through the last `k` elements of the sorted array `arr` and appends them to a new array `ans`.\n\nreturn ans\nFinally, the function returns the array `ans` containing the `k` largest elements in `arr`.\n\n### Racket version\n\n#lang racket\n\n(define (maximum arr k)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_integers values)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9) 0.001)\n    (check-within (candidate (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function filter_integers(values)\n  local result = {}\n  for _, x in ipairs(values) do\n    if type(x) == 'number' and math.floor(x) == x then\n      table.insert(result, x)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `filter_integers` which takes an array of values and returns an array containing only the integers.\n\nlocal result = {}\nThe function initializes an empty array `result` to store the filtered integers.\n\nfor _, x in ipairs(values) do\nThe function iterates through each element `x` in the input array `values`.\n\nif type(x) == 'number' and math.floor(x) == x then\n    table.insert(result, x)\nIf the element is a number and its floor value is equal to itself, it means that it is an integer, so the function appends it to the `result` array.\n\nreturn result\nThe function returns the `result` array containing only the integers.\n\n### Racket version\n\n#lang racket\n\n(define (filter_integers values)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (skjkasdkd lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)\n    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)\n    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)\n    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)\n    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)\n    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)\n    (check-within (candidate (list 8191)) 19 0.001)\n    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)\n    (check-within (candidate (list 127 97 8192)) 10 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function skjkasdkd(lst)\n  local function isPrime(n)\n    for i = 2, math.floor(n^0.5) do\n      if n % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local maxx = 0\n  local i = 1\n  while i <= #lst do\n    if lst[i] > maxx and isPrime(lst[i]) then\n      maxx = lst[i]\n    end\n    i = i + 1\n  end\n  local result = 0\n  for digit in tostring(maxx):gmatch('%d') do\n    result = result + tonumber(digit)\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `skjkasdkd` which takes an array of numbers and returns the sum of the digits of the largest prime number in the array.\n\nlocal function isPrime(n)\n    for i = 2, math.floor(n^0.5) do\n        if n % i == 0 then\n            return false\n        end\n    end\n    return true\nend\nThe function first defines a helper function `isPrime` that takes a number and returns `true` if it is prime and `false` otherwise. This is done by checking if the number is divisible by any number between 2 and the square root of the number.\n\nlocal maxx = 0\nlocal i = 1\nwhile i <= #lst do\n    if lst[i] > maxx and isPrime(lst[i]) then\n        maxx = lst[i]\n    end\n    i = i + 1\nend\nThe function then initializes a variable `maxx` to 0 to store the largest prime number in the array. It then iterates through each number in the array and checks if it is prime and greater than the current `maxx`. If it is, it updates `maxx` to the new number.\n\nlocal result = 0\nfor digit in tostring(maxx):gmatch('%d') do\n    result = result + tonumber(digit)\nend\nThe function then converts `maxx` to a string and iterates through each digit in the string, adding it to the `result` variable.\n\nreturn result\nFinally, the function returns the `result` variable containing the sum of the digits of the largest prime number in the array.\n\n### Racket version\n\n#lang racket\n\n(define (skjkasdkd lst)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (total_match lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate total_match))\n    (check-within (candidate (list ) (list )) (list ) 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\")) (list \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\" \"admin\" \"project\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list \"4\") (list \"1\" \"2\" \"3\" \"4\" \"5\")) (list \"4\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"Hi\")) (list \"hI\" \"Hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hi\")) (list \"hI\" \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hii\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list ) (list \"this\")) (list ) 0.001)\n    (check-within (candidate (list \"this\") (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function total_match(lst1, lst2)\n    local l1 = 0\n    for i = 1, #lst1 do\n        l1 = l1 + #lst1[i]\n    end\n\n    local l2 = 0\n    for i = 1, #lst2 do\n        l2 = l2 + #lst2[i]\n    end\n\n    if l1 <= l2 then\n        return lst1\n    else\n        return lst2\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `total_match` which takes two arrays of strings `lst1` and `lst2` and returns the array with the total length of all strings in the array.\n\nlocal l1 = 0\nfor i = 1, #lst1 do\n    l1 = l1 + #lst1[i]\nend\nThe function first calculates the total length of all strings in the first array `lst1`.\n\nlocal l2 = 0\nfor i = 1, #lst2 do\n    l2 = l2 + #lst2[i]\nend\nIt then calculates the total length of all strings in the second array `lst2`.\n\nif l1 <= l2 then\n    return lst1\nelse\n    return lst2\nend\nFinally, the function returns the array with the total length of all strings in the array. If the total length of `lst1` is less than or equal to the total length of `lst2`, it returns `lst1`. Otherwise, it returns `lst2`.\n\n### Racket version\n\n#lang racket\n\n(define (total_match lst1 lst2)\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (car_race_collision n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate car_race_collision))\n    (check-within (candidate 2) 4 0.001)\n    (check-within (candidate 3) 9 0.001)\n    (check-within (candidate 4) 16 0.001)\n    (check-within (candidate 8) 64 0.001)\n    (check-within (candidate 10) 100 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function car_race_collision(n)\n    return n^2\nend\n\n### Explanation\n\nThe code is an implementation of a function `car_race_collision` which takes a number `n` as input and returns the number of collisions that would occur if `n` cars were racing on a circular track.\n\nreturn n^2\nThe function returns the square of the input number `n`.\n\n### Racket version\n\n#lang racket\n\n(define (car_race_collision n)\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_simple_power x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n    (check-within (candidate 16 2) #t 0.001)\n    (check-within (candidate 143214 16) #f 0.001)\n    (check-within (candidate 4 2) #t 0.001)\n    (check-within (candidate 9 3) #t 0.001)\n    (check-within (candidate 16 4) #t 0.001)\n    (check-within (candidate 24 2) #f 0.001)\n    (check-within (candidate 128 4) #f 0.001)\n    (check-within (candidate 12 6) #f 0.001)\n    (check-within (candidate 1 1) #t 0.001)\n    (check-within (candidate 1 12) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function is_simple_power(x, n)\n    if n == 1 then\n        return x == 1\n    end\n    local power = 1\n    while power < x do\n        power = power * n\n    end\n    return power == x\nend\n\n### Explanation\n\nThe code is an implementation of checking whether a number `x` is a power of a number `n`. It takes two numbers `x` and `n` as input and returns a boolean.\n\nif n == 1 then\n    return x == 1\nThe function first checks if `n` is 1. If it is, the function returns `true` if `x` is also 1, and `false` otherwise.\n\nlocal power = 1\nwhile power < x do\n    power = power * n\nend\nThe function then initializes a variable `power` to 1 and repeatedly multiplies it by `n` until `power` is greater than or equal to `x`.\n\nreturn power == x\nFinally, the function returns `true` if `power` is equal to `x`, and `false` otherwise.\n\n### Racket version\n\n#lang racket\n\n(define (is_simple_power x n)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encode message)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n    (check-within (candidate \"TEST\") \"tgst\" 0.001)\n    (check-within (candidate \"Mudasir\") \"mWDCSKR\" 0.001)\n    (check-within (candidate \"YES\") \"ygs\" 0.001)\n    (check-within (candidate \"This is a message\") \"tHKS KS C MGSSCGG\" 0.001)\n    (check-within (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function encode(message)\n  local vowels = \"aeiouAEIOU\"\n  local vowels_replace = {}\n  for i = 1, #vowels do\n    vowels_replace[vowels:sub(i, i)] = string.char(string.byte(vowels:sub(i, i)) + 2)\n  end\n  message = message:gsub(\"%a\", function(c)\n    return c == c:upper() and c:lower() or c:upper()\n  end)\n  return message:gsub(\".\", function(c)\n    return vowels_replace[c] or c\n  end)\nend\n\n### Explanation\n\nThe code is an implementation of a function `encode` which takes a string and returns a new string with the vowels replaced by the next two letters in the alphabet (wrapping around from 'z' to 'a'). The function also capitalizes all consonants and lowercases all vowels.\n\nlocal vowels = \"aeiouAEIOU\"\nlocal vowels_replace = {}\nThe function first initializes a string `vowels` containing all vowels (both uppercase and lowercase) and an empty table `vowels_replace` to store the replacements for each vowel.\n\nfor i = 1, #vowels do\n    vowels_replace[vowels:sub(i, i)] = string.char(string.byte(vowels:sub(i, i)) + 2)\nend\nThe function then iterates through each character in the `vowels` string and adds the corresponding replacement to the `vowels_replace` table. The replacement is obtained by adding 2 to the ASCII code of the vowel character and converting it back to a character using `string.char`.\n\nmessage = message:gsub(\"%a\", function(c)\n    return c == c:upper() and c:lower() or c:upper()\nend)\nThe function then converts all consonants to uppercase and all vowels to lowercase using `gsub` and a function that checks if the character is uppercase and returns the corresponding lowercase or uppercase character.\n\nreturn message:gsub(\".\", function(c)\n    return vowels_replace[c] or c\nend)\nFinally, the function replaces each character in the input string with its corresponding replacement in the `vowels_replace` table (if it exists), or leaves it unchanged.\n\n### Racket version\n\n#lang racket\n\n(define (encode message)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (incr_list l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate incr_list))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)\n    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function incr_list(l)\n  local res = {}\n  for i = 1, #l do\n    res[i] = l[i] + 1\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function `incr_list` which takes a list of numbers and returns a new list with each element incremented by 1.\n\nlocal res = {}\nThe function initializes an empty list `res` to store the result.\n\nfor i = 1, #l do\n    res[i] = l[i] + 1\nend\nThe function then iterates through each element `l[i]` in the input list `l`, and appends `l[i] + 1` to the `res` list.\n\nreturn res\nFinally, the function returns the `res` list containing the incremented elements.\n\n### Racket version\n\n#lang racket\n\n(define (incr_list l)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (flip_case string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hello!\") \"hELLO!\" 0.001)\n    (check-within (candidate \"These violent delights have violent ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function flip_case(string)\n    return string:gsub(\"%a\", function(c) return c:match(\"%l\") and c:upper() or c:lower() end)\nend\n\n### Explanation\n\nThe code is an implementation of a function `flip_case` which takes a string and returns a new string with the case of each letter flipped.\n\nreturn string:gsub(\"%a\", function(c) return c:match(\"%l\") and c:upper() or c:lower() end)\nThe function uses the `gsub` function to replace all letters in the string with a new letter with the opposite case. The `%a` pattern matches any letter, and the function passed to `gsub` is called for each match.\n\nc:match(\"%l\") and c:upper() or c:lower()\nThe function passed to `gsub` checks if the matched letter is lowercase using the `match` function and the `%l` pattern. If the letter is lowercase, it returns the uppercase version of the letter using the `upper` function. Otherwise, it returns the lowercase version of the letter using the `lower` function.\n\n### Racket version\n\n#lang racket\n\n(define (flip_case string)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (vowels_count s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate vowels_count))\n    (check-within (candidate \"abcde\") 2 0.001)\n    (check-within (candidate \"Alone\") 3 0.001)\n    (check-within (candidate \"key\") 2 0.001)\n    (check-within (candidate \"bye\") 1 0.001)\n    (check-within (candidate \"keY\") 2 0.001)\n    (check-within (candidate \"bYe\") 1 0.001)\n    (check-within (candidate \"ACEDY\") 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function vowels_count(s)\n  local vowels = \"aeiouAEIOU\"\n  local n_vowels = 0\n  for i = 1, #s do\n    if string.find(vowels, s:sub(i, i), 1, true) then\n      n_vowels = n_vowels + 1\n    end\n  end\n  if s:sub(-1) == 'y' or s:sub(-1) == 'Y' then\n    n_vowels = n_vowels + 1\n  end\n  return n_vowels\nend\n\n### Explanation\n\nThe code is an implementation of counting the number of vowels in a string. It takes a string `s` as input and returns an integer representing the number of vowels in the string.\n\nlocal vowels = \"aeiouAEIOU\"\nThe function first defines a string `vowels` containing all the vowels.\n\nfor i = 1, #s do\n    if string.find(vowels, s:sub(i, i), 1, true) then\n        n_vowels = n_vowels + 1\n    end\nend\nThe function then iterates through each character in the input string `s`. If the character is a vowel, the function increments the `n_vowels` variable.\n\nif s:sub(-1) == 'y' or s:sub(-1) == 'Y' then\n    n_vowels = n_vowels + 1\nend\nFinally, the function checks if the last character of the input string is `'y'` or `'Y'`. If it is, the function increments the `n_vowels` variable.\n\nreturn n_vowels\nThe function returns the `n_vowels` variable representing the number of vowels in the input string.\n\n### Racket version\n\n#lang racket\n\n(define (vowels_count s)\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (words_string s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_string))\n    (check-within (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\" \"is\" \"John\") 0.001)\n    (check-within (candidate \"One, two, three, four, five, six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\") 0.001)\n    (check-within (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function words_string(s)\n    if not s then\n        return {}\n    end\n\n    local s_list = {}\n\n    for i=1, #s do\n        local letter = s:sub(i, i)\n        if letter == ',' then\n            table.insert(s_list, ' ')\n        else\n            table.insert(s_list, letter)\n        end\n    end\n\n    s_list = table.concat(s_list)\n    local words = {}\n    for word in s_list:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n    return words\nend\n\n### Explanation\n\nThe code is an implementation of a function `words_string` which takes a string of words separated by commas and returns an array of words.\n\nif not s then\n    return {}\nThe function first checks if the input string is empty. If it is, it returns an empty array.\n\nfor i=1, #s do\n    local letter = s:sub(i, i)\n    if letter == ',' then\n        table.insert(s_list, ' ')\n    else\n        table.insert(s_list, letter)\n    end\nend\nOtherwise, the function iterates through each character in the input string. If the character is a comma, it appends a space to the `s_list` array. Otherwise, it appends the character to the `s_list` array.\n\ns_list = table.concat(s_list)\nThe `s_list` array is then concatenated into a string.\n\nlocal words = {}\nfor word in s_list:gmatch(\"%S+\") do\n    table.insert(words, word)\nend\nFinally, the function uses a pattern matching function to extract the words from the concatenated string. It then appends each word to the `words` array and returns it.\n\nreturn words\n\n### Racket version\n\n#lang racket\n\n(define (words_string s)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 3 4 5) 6.0 0.001)\n    (check-within (candidate 1 2 10) -1 0.001)\n    (check-within (candidate 4 8 5) 8.18 0.001)\n    (check-within (candidate 2 2 2) 1.73 0.001)\n    (check-within (candidate 1 2 3) -1 0.001)\n    (check-within (candidate 10 5 7) 16.25 0.001)\n    (check-within (candidate 2 6 3) -1 0.001)\n    (check-within (candidate 1 1 1) 0.43 0.001)\n    (check-within (candidate 2 2 10) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, b, c)\n    if a + b <= c or a + c <= b or b + c <= a then\n        return -1 \n    end\n    s = (a + b + c)/2    \n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = math.floor(area * 100 + 0.5) / 100\n    return area\nend\n\n### Explanation\n\nThe code is an implementation of calculating the area of a triangle given the lengths of its sides. It takes three numbers `a`, `b`, and `c` as input and returns the area of the triangle.\n\nif a + b <= c or a + c <= b or b + c <= a then\n    return -1 \nend\nThe function first checks if the input sides can form a valid triangle. If not, it returns -1.\n\ns = (a + b + c)/2    \narea = math.sqrt(s * (s - a) * (s - b) * (s - c))\nThe function then calculates the area of the triangle using Heron's formula. It first calculates the semi-perimeter `s` of the triangle, then uses it to calculate the area.\n\narea = math.floor(area * 100 + 0.5) / 100\nThe area is then rounded to two decimal places.\n\nreturn area\nFinally, the function returns the area of the triangle.\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a b c)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_dict_case dict)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f 0.001)\n    (check-within (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f 0.001)\n    (check-within (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t 0.001)\n    (check-within (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t 0.001)\n    (check-within (candidate #hash()) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function check_dict_case(dict)\n    if next(dict) == nil then\n        return false\n    else\n        local state = \"start\"\n        for key, value in pairs(dict) do\n            if type(key) ~= \"string\" then\n                state = \"mixed\"\n                break\n            end\n            if state == \"start\" then\n                if key:upper() == key then\n                    state = \"upper\"\n                elseif key:lower() == key then\n                    state = \"lower\"\n                else\n                    break\n                end\n            elseif (state == \"upper\" and key:upper() ~= key) or (state == \"lower\" and key:lower() ~= key) then\n                state = \"mixed\"\n                break\n            end\n        end\n        return state == \"upper\" or state == \"lower\"\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `check_dict_case` which takes a dictionary and returns a boolean indicating whether all keys in the dictionary are in the same case (either all uppercase or all lowercase).\n\nif next(dict) == nil then\n    return false\nThe function first checks if the input dictionary is empty. If it is, it returns `false`.\n\nlocal state = \"start\"\nThe variable `state` is initialized to `\"start\"` to keep track of the case of the keys in the dictionary.\n\nfor key, value in pairs(dict) do\n    if type(key) ~= \"string\" then\n        state = \"mixed\"\n        break\n    end\n    ...\nend\nThe function iterates through each key-value pair in the dictionary.\n\nif type(key) ~= \"string\" then\n    state = \"mixed\"\n    break\nIf the key is not a string, the function sets the `state` variable to `\"mixed\"` and breaks out of the loop.\n\nif state == \"start\" then\n    if key:upper() == key then\n        state = \"upper\"\n    elseif key:lower() == key then\n        state = \"lower\"\n    else\n        break\n    end\nThe function checks the case of the first key in the dictionary. If the key is all uppercase, the `state` variable is set to `\"upper\"`. If the key is all lowercase, the `state` variable is set to `\"lower\"`. If the key is neither all uppercase nor all lowercase, the function breaks out of the loop.\n\nelseif (state == \"upper\" and key:upper() ~= key) or (state == \"lower\" and key:lower() ~= key) then\n    state = \"mixed\"\n    break\nIf the `state` variable is not `\"start\"`, the function checks if the current key is in the same case as the previous keys. If the current key is not in the same case as the previous keys, the `state` variable is set to `\"mixed\"` and the loop is broken.\n\nreturn state == \"upper\" or state == \"lower\"\nFinally, the function returns `true` if all keys are in the same case, and `false` otherwise.\n\n### Racket version\n\n#lang racket\n\n(define (check_dict_case dict)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (median l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n    (check-within (candidate (list 3 1 2 4 5)) 3 0.001)\n    (check-within (candidate (list -10 4 6 1000 10 20)) 8.0 0.001)\n    (check-within (candidate (list 5)) 5 0.001)\n    (check-within (candidate (list 6 5)) 5.5 0.001)\n    (check-within (candidate (list 8 1 3 9 9 2 7)) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function median(l)\n  table.sort(l)\n  if #l % 2 == 1 then\n    return l[math.floor(#l / 2) + 1]\n  else\n    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n  end\nend\n\n### Explanation\n\nThe code is an implementation of finding the median of a list of numbers. It takes a list of numbers `l` as input and returns the median.\n\ntable.sort(l)\nThe function first sorts the input list in ascending order.\n\nif #l % 2 == 1 then\n    return l[math.floor(#l / 2) + 1]\nIf the length of the list is odd, the function returns the middle element of the sorted list.\n\nelse\n    return (l[#l / 2] + l[#l / 2 + 1]) / 2\nend\nIf the length of the list is even, the function returns the average of the two middle elements of the sorted list.\n\n### Racket version\n\n#lang racket\n\n(define (median l)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (change_base x base)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n    (check-within (candidate 8 3) \"22\" 0.001)\n    (check-within (candidate 9 3) \"100\" 0.001)\n    (check-within (candidate 234 2) \"11101010\" 0.001)\n    (check-within (candidate 16 2) \"10000\" 0.001)\n    (check-within (candidate 8 2) \"1000\" 0.001)\n    (check-within (candidate 7 2) \"111\" 0.001)\n    (check-within (candidate 2 3) \"2\" 0.001)\n    (check-within (candidate 3 4) \"3\" 0.001)\n    (check-within (candidate 4 5) \"4\" 0.001)\n    (check-within (candidate 5 6) \"5\" 0.001)\n    (check-within (candidate 6 7) \"6\" 0.001)\n    (check-within (candidate 7 8) \"7\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function change_base(x, base)\n  local ret = \"\"\n  while x > 0 do\n    ret = tostring(x % base) .. ret\n    x = math.floor(x / base)\n  end\n  return ret\nend\n\n### Explanation\n\nThe code is an implementation of changing a number `x` to a different base `base`. It takes two integers `x` and `base` as input and returns a string representing the number `x` in the new base.\n\nwhile x > 0 do\n    ret = tostring(x % base) .. ret\n    x = math.floor(x / base)\nend\nThe function first initializes an empty string `ret` to store the result. It then repeatedly divides the input number `x` by the new base `base` and appends the remainder to the beginning of the `ret` string. This is done until `x` becomes 0.\n\nreturn ret\nFinally, the function returns the `ret` string containing the number `x` in the new base.\n\n### Racket version\n\n#lang racket\n\n(define (change_base x base)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (longest strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"x\" 0.001)\n    (check-within (candidate (list \"x\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\")) \"zzzz\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function longest(strings)\n    if not strings then\n        return nil\n    end\n\n    local maxlen = 0\n    for _, s in ipairs(strings) do\n        maxlen = math.max(maxlen, #s)\n    end\n\n    for _, s in ipairs(strings) do\n        if #s == maxlen then\n            return s\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of finding the longest string in an array of strings. It takes an array of strings `strings` as input and returns the longest string in the array.\n\nif not strings then\n    return nil\nThe function first checks if the input array is empty. If it is, it returns `nil`.\n\nlocal maxlen = 0\nfor _, s in ipairs(strings) do\n    maxlen = math.max(maxlen, #s)\nend\nThe function then initializes a variable `maxlen` to 0 to keep track of the length of the longest string. It then iterates through each string in the input array and updates `maxlen` to the maximum length of all the strings.\n\nfor _, s in ipairs(strings) do\n    if #s == maxlen then\n        return s\n    end\nend\nFinally, the function iterates through each string in the input array again and returns the first string with length equal to `maxlen`.\n\n### Racket version\n\n#lang racket\n\n(define (longest strings)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (common l1 l2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n    (check-within (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653) 0.001)\n    (check-within (candidate (list 5 3 2 8) (list 3 2)) (list 2 3) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function common(l1, l2)\n    local ret = {}\n    local set_l2 = {}\n    for i=1, #l2 do\n        set_l2[l2[i]] = true\n    end\n    for i=1, #l1 do\n        if set_l2[l1[i]] then\n            table.insert(ret, l1[i])\n        end\n    end\n    table.sort(ret)\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of finding the common elements between two arrays. It takes two arrays `l1` and `l2` as input and returns an array of common elements.\n\nlocal set_l2 = {}\nThe function first initializes an empty table `set_l2` to store the elements of `l2`.\n\nfor i=1, #l2 do\n    set_l2[l2[i]] = true\nend\nIt then iterates through each element in `l2` and adds it to the `set_l2` table.\n\nif set_l2[l1[i]] then\n    table.insert(ret, l1[i])\nend\nThe function then iterates through each element in `l1` and checks if it exists in the `set_l2` table. If it does, the element is added to the `ret` array.\n\ntable.sort(ret)\nFinally, the function sorts the `ret` array and returns it.\n\n### Racket version\n\n#lang racket\n\n(define (common l1 l2)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (cycpattern_check a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n    (check-within (candidate \"xyzw\" \"xyw\") #f 0.001)\n    (check-within (candidate \"yello\" \"ell\") #t 0.001)\n    (check-within (candidate \"whattup\" \"ptut\") #f 0.001)\n    (check-within (candidate \"efef\" \"fee\") #t 0.001)\n    (check-within (candidate \"abab\" \"aabb\") #f 0.001)\n    (check-within (candidate \"winemtt\" \"tinem\") #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function cycpattern_check(a, b)\n  local l = #b\n  local pat = b .. b\n  for i = 1, #a - l + 1 do\n    for j = 1, l + 1 do\n      if a:sub(i, i + l - 1) == pat:sub(j, j + l - 1) then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of checking if a string `a` contains a cyclic pattern of another string `b`. It takes two strings `a` and `b` as input and returns a boolean.\n\nlocal l = #b\nThe function first calculates the length of the string `b`.\n\nlocal pat = b .. b\nIt then concatenates the string `b` with itself to create a new string `pat` that is twice the length of `b`.\n\nfor i = 1, #a - l + 1 do\n    for j = 1, l + 1 do\n        if a:sub(i, i + l - 1) == pat:sub(j, j + l - 1) then\n            return true\n        end\n    end\nend\nThe function then iterates through each substring of `a` that is the same length as `b`. For each substring, it checks if it is equal to any substring of `pat`. If it is, it means that `a` contains a cyclic pattern of `b`, so the function returns `true`.\n\nreturn false\nIf the function has checked all possible substrings of `a` and has not found a cyclic pattern of `b`, it means that `a` does not contain a cyclic pattern of `b`, so the function returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (cycpattern_check a b)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minSubArraySum nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSubArraySum))\n    (check-within (candidate (list 2 3 4 1 2 4)) 1 0.001)\n    (check-within (candidate (list -1 -2 -3)) -6 0.001)\n    (check-within (candidate (list -1 -2 -3 2 -10)) -14 0.001)\n    (check-within (candidate (list -9999999999999999)) -9999999999999999 0.001)\n    (check-within (candidate (list 0 10 20 1000000)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 100 -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 10 11 13 8 3 4)) 3 0.001)\n    (check-within (candidate (list 100 -33 32 -1 0 -2)) -33 0.001)\n    (check-within (candidate (list -10)) -10 0.001)\n    (check-within (candidate (list 7)) 7 0.001)\n    (check-within (candidate (list 1 -1)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function minSubArraySum(nums)\n    local max_sum = 0\n    local s = 0\n    for i=1, #nums do\n        s = s - nums[i]\n        if s < 0 then\n            s = 0\n        end\n        max_sum = math.max(s, max_sum)\n    end\n    if max_sum == 0 then\n        max_sum = -math.huge\n        for i=1, #nums do\n            max_sum = math.max(max_sum, -nums[i])\n        end\n    end\n    local min_sum = -max_sum\n    return min_sum\nend\n\n### Explanation\n\nThe code is an implementation of finding the minimum subarray sum of an array of integers. It takes an array of integers `nums` as input and returns the minimum subarray sum.\n\nlocal max_sum = 0\nlocal s = 0\nThe function initializes the variables `max_sum` and `s` to 0.\n\nfor i=1, #nums do\n    s = s - nums[i]\n    if s < 0 then\n        s = 0\n    end\n    max_sum = math.max(s, max_sum)\nend\nThe function then iterates through each element of the input array `nums`. It subtracts the current element from the variable `s`, and if `s` becomes negative, it sets `s` to 0. The variable `max_sum` is then updated to the maximum value between `s` and `max_sum`.\n\nif max_sum == 0 then\n    max_sum = -math.huge\n    for i=1, #nums do\n        max_sum = math.max(max_sum, -nums[i])\n    end\nend\nIf `max_sum` is 0 after the loop, it means that all elements in the array are negative. In this case, the function sets `max_sum` to negative infinity and finds the maximum negative element in the array.\n\nlocal min_sum = -max_sum\nFinally, the function sets the variable `min_sum` to the negative of `max_sum` and returns it.\n\n### Racket version\n\n#lang racket\n\n(define (minSubArraySum nums)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (histogram test)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate histogram))\n    (check-within (candidate \"a b b a\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c a b\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c d g\") #hash((\"a\" .  1) (\"b\" .  1) (\"c\" .  1) (\"d\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"b b b b a\") #hash((\"b\" .  4)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"\") #hash() 0.001)\n    (check-within (candidate \"a\") #hash((\"a\" .  1)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function histogram(test)\n    local dict1 = {}\n    local list1 = {}\n    for word in test:gmatch(\"%w+\") do\n        table.insert(list1, word)\n    end\n    local t = 0\n    for i=1, #list1 do\n        if list1[i] ~= '' and list1[i] ~= nil then\n            if list1.count == nil then\n                list1.count = function(list, value)\n                    local count = 0\n                    for i=1, #list do\n                        if list[i] == value then\n                            count = count + 1\n                        end\n                    end\n                    return count\n                end\n            end\n            if list1:count(list1[i]) > t then\n                t = list1:count(list1[i])\n            end\n        end\n    end\n    if t > 0 then\n        for i=1, #list1 do\n            if list1[i] ~= '' and list1[i] ~= nil then\n                if list1:count(list1[i]) == t then\n                    dict1[list1[i]] = t\n                end\n            end\n        end\n    end\n    return dict1\nend\n\n### Explanation\n\nThe code is an implementation of a function `histogram` which takes a string of words and returns a dictionary of the most frequently occurring word(s) and their frequency.\n\nlocal dict1 = {}\nlocal list1 = {}\nThe function initializes an empty dictionary `dict1` to store the word frequency and an empty list `list1` to store the words in the input string.\n\nfor word in test:gmatch(\"%w+\") do\n    table.insert(list1, word)\nend\nThe function uses the `gmatch` function to iterate through each word in the input string and appends it to the `list1` array.\n\nif list1.count == nil then\n    list1.count = function(list, value)\n        local count = 0\n        for i=1, #list do\n            if list[i] == value then\n                count = count + 1\n            end\n        end\n        return count\n    end\nend\nThe function defines a `count` method for the `list1` array if it does not already exist. This method takes a list and a value and returns the number of times the value appears in the list.\n\nif list1:count(list1[i]) > t then\n    t = list1:count(list1[i])\nend\nThe function then iterates through each word in the `list1` array and counts the number of times it appears. It stores the maximum count in the variable `t`.\n\nif list1:count(list1[i]) == t then\n    dict1[list1[i]] = t\nend\nFinally, the function iterates through each word in the `list1` array again and adds the word to the `dict1` dictionary if its count is equal to `t`.\n\nreturn dict1\nThe function returns the `dict1` dictionary containing the most frequently occurring word(s) and their frequency.\n\n### Racket version\n\n#lang racket\n\n(define (histogram test)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_odd_collatz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_odd_collatz))\n    (check-within (candidate 14) (list 1 5 7 11 13 17) 0.001)\n    (check-within (candidate 5) (list 1 5) 0.001)\n    (check-within (candidate 12) (list 1 3 5) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function get_odd_collatz(n)\n    local odd_collatz = (n%2==0) and {} or {n}\n    while n > 1 do\n        if n % 2 == 0 then\n            n = n/2\n        else\n            n = n*3 + 1\n        end\n        if n%2 == 1 then\n            table.insert(odd_collatz, math.floor(n))\n        end\n    end\n    table.sort(odd_collatz)\n    return odd_collatz\nend\n\n### Explanation\n\nThe code is an implementation of a function `get_odd_collatz` that takes a number `n` as input and returns an array of odd numbers in the Collatz sequence starting from `n`.\n\nlocal odd_collatz = (n%2==0) and {} or {n}\nThe function first initializes an empty array `odd_collatz` if `n` is even, and an array containing `n` if `n` is odd.\n\nwhile n > 1 do\n    if n % 2 == 0 then\n        n = n/2\n    else\n        n = n*3 + 1\n    end\n    if n%2 == 1 then\n        table.insert(odd_collatz, math.floor(n))\n    end\nend\nThe function then iteratively computes the next number in the Collatz sequence until `n` reaches 1. If the next number is odd, it is appended to the `odd_collatz` array.\n\ntable.sort(odd_collatz)\nFinally, the function sorts the `odd_collatz` array in ascending order and returns it.\n\n### Racket version\n\n#lang racket\n\n(define (get_odd_collatz n)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (derivative xs)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate derivative))\n    (check-within (candidate (list 3 1 2 4 5)) (list 1 4 12 20) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 6) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 2 2) 0.001)\n    (check-within (candidate (list 3 2 1 0 4)) (list 2 2 0 16) 0.001)\n    (check-within (candidate (list 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function derivative(xs)\n    local result = {}\n    for i=1, #xs-1 do\n        result[i] = i * xs[i+1]\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of finding the derivative of a polynomial. It takes an array of coefficients `xs` as input and returns an array of coefficients representing the derivative of the polynomial.\n\nfor i=1, #xs-1 do\n    result[i] = i * xs[i+1]\nend\nThe function first initializes an empty array `result` to store the coefficients of the derivative polynomial. It then iterates through the input array `xs` from index 1 to `#xs-1` (i.e. the second to last element).\n\nresult[i] = i * xs[i+1]\nFor each index `i`, the function computes the coefficient of the derivative polynomial by multiplying the index `i` with the coefficient of the next term `xs[i+1]`.\n\nreturn result\nFinally, the function returns the array `result` containing the coefficients of the derivative polynomial.\n\n### Racket version\n\n#lang racket\n\n(define (derivative xs)\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fibfib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 1) 0 0.001)\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 24 0.001)\n    (check-within (candidate 10) 81 0.001)\n    (check-within (candidate 12) 274 0.001)\n    (check-within (candidate 14) 927 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function fibfib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    end\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\nend\n\n### Explanation\n\nThe code is an implementation of a recursive function `fibfib` that calculates the nth term of the Fibonacci-Fibonacci sequence. The function takes an integer `n` as input and returns an integer.\n\nif n == 0 then\n    return 0\nelseif n == 1 then\n    return 0\nelseif n == 2 then\n    return 1\nend\nThe function first checks if `n` is 0, 1, or 2. If it is, it returns the corresponding value of the Fibonacci-Fibonacci sequence.\n\nreturn fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\nOtherwise, the function recursively calculates the nth term of the Fibonacci-Fibonacci sequence by adding the previous three terms together.\n\n### Racket version\n\n#lang racket\n\n(define (fibfib n)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (truncate_number number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n    (check-within (candidate 3.5) 0.5 0.001)\n    (check-within (candidate 1.25) 0.25 0.001)\n    (check-within (candidate 123.0) 0.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function truncate_number(number)\n    return number % 1\nend\n\n### Explanation\n\nThe code is an implementation of truncating a number to its decimal part. It takes a number `number` as input and returns the decimal part of the number.\n\nreturn number % 1\nThe function simply returns the remainder of the number divided by 1, which is the decimal part of the number.\n\n### Racket version\n\n#lang racket\n\n(define (truncate_number number)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_element l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_element))\n    (check-within (candidate (list 1 2 3)) 3 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function max_element(l)\n    local m = l[1]\n    for i=2, #l do\n        if l[i] > m then\n            m = l[i]\n        end\n    end\n    return m\nend\n\n### Explanation\n\nThe code is an implementation of finding the maximum element in an array. It takes an array of numbers `l` as input and returns the maximum element.\n\nlocal m = l[1]\nThe function initializes the variable `m` to the first element of the input array.\n\nfor i=2, #l do\n    if l[i] > m then\n        m = l[i]\n    end\nend\nThe function then iterates through the input array and compares each element to the current maximum `m`. If an element is greater than `m`, it becomes the new maximum.\n\nreturn m\nFinally, the function returns the maximum element `m`.\n\n### Racket version\n\n#lang racket\n\n(define (max_element l)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (closest_integer value)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-within (candidate \"10\") 10 0.001)\n    (check-within (candidate \"14.5\") 15 0.001)\n    (check-within (candidate \"-15.5\") -16 0.001)\n    (check-within (candidate \"15.3\") 15 0.001)\n    (check-within (candidate \"0\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if value:find('%.5$') then\n        if num > 0 then\n            return math.ceil(num)\n        else\n            return math.floor(num)\n        end\n    elseif #value > 0 then\n        return math.floor(num + 0.5)\n    else\n        return 0\n    end\nend\n\n### Explanation\n\nThe code is an implementation of rounding a decimal number to the nearest integer. It takes a string `value` as input and returns an integer.\n\nlocal num = tonumber(value)\nThe function first converts the input string `value` to a number.\n\nif value:find('%.5$') then\n    if num > 0 then\n        return math.ceil(num)\n    else\n        return math.floor(num)\n    end\nIf the input string ends with `.5`, the function checks if the number is positive or negative. If it is positive, it rounds up to the nearest integer using `math.ceil()`. If it is negative, it rounds down to the nearest integer using `math.floor()`.\n\nelseif #value > 0 then\n    return math.floor(num + 0.5)\nIf the input string does not end with `.5`, the function rounds the number to the nearest integer using `math.floor(num + 0.5)`.\n\nelse\n    return 0\nIf the input string is empty, the function returns 0.\n\n### Racket version\n\n#lang racket\n\n(define (closest_integer value)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 3) 5 0.001)\n    (check-within (candidate 4) 13 0.001)\n    (check-within (candidate 5) 89 0.001)\n    (check-within (candidate 6) 233 0.001)\n    (check-within (candidate 7) 1597 0.001)\n    (check-within (candidate 8) 28657 0.001)\n    (check-within (candidate 9) 514229 0.001)\n    (check-within (candidate 10) 433494437 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function prime_fib(n)\n  local function is_prime(p)\n    if p < 2 then\n      return false\n    end\n    for k = 2, math.min(math.sqrt(p) + 1, p - 1) do\n      if p % k == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local f = {0, 1}\n  while true do\n    table.insert(f, f[#f] + f[#f - 1])\n    if is_prime(f[#f]) then\n      n = n - 1\n    end\n    if n == 0 then\n      return f[#f]\n    end\n  end\nend\n\n### Explanation\n\nThe code is an implementation of finding the nth prime Fibonacci number. It takes a number `n` as input and returns the nth prime Fibonacci number.\n\nlocal function is_prime(p)\n    if p < 2 then\n        return false\n    end\n    for k = 2, math.min(math.sqrt(p) + 1, p - 1) do\n        if p % k == 0 then\n            return false\n        end\n    end\n    return true\nend\nThe function first defines a helper function `is_prime` that takes a number and returns `true` if it is a prime number and `false` otherwise. This is done by checking if the number is less than 2, and then checking if it is divisible by any number between 2 and the square root of the number.\n\nlocal f = {0, 1}\nThe function initializes an array `f` with the first two Fibonacci numbers.\n\nwhile true do\n    table.insert(f, f[#f] + f[#f - 1])\n    if is_prime(f[#f]) then\n        n = n - 1\n    end\n    if n == 0 then\n        return f[#f]\n    end\nend\nThe function then enters a loop that generates the next Fibonacci number by adding the last two numbers in the `f` array. If the new number is prime, the function decrements the `n` variable. If `n` reaches 0, the function returns the last number in the `f` array, which is the nth prime Fibonacci number.\n\n### Racket version\n\n#lang racket\n\n(define (prime_fib n)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_product numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n    (check-within (candidate (list )) (list 0 1) 0.001)\n    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)\n    (check-within (candidate (list 100 0)) (list 100 0) 0.001)\n    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)\n    (check-within (candidate (list 10)) (list 10 10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function sum_product(numbers)\n    local sum_value = 0\n    local prod_value = 1\n\n    for _, n in ipairs(numbers) do\n        sum_value = sum_value + n\n        prod_value = prod_value * n\n    end\n    return {sum_value, prod_value}\nend\n\n### Explanation\n\nThe code is an implementation of a function `sum_product` that takes an array of numbers and returns a table of two numbers: the sum of the numbers and the product of the numbers.\n\nlocal sum_value = 0\nlocal prod_value = 1\nThe function initializes two variables `sum_value` and `prod_value` to 0 and 1 respectively.\n\nfor _, n in ipairs(numbers) do\n    sum_value = sum_value + n\n    prod_value = prod_value * n\nend\nThe function then iterates through each number `n` in the input array `numbers`. It adds `n` to `sum_value` and multiplies `n` to `prod_value`.\n\nreturn {sum_value, prod_value}\nFinally, the function returns a table of two numbers: `sum_value` and `prod_value`.\n\n### Racket version\n\n#lang racket\n\n(define (sum_product numbers)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (select_words s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n    (check-within (candidate \"Mary had a little lamb\" 4) (list \"little\") 0.001)\n    (check-within (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\") 0.001)\n    (check-within (candidate \"simple white space\" 2) (list ) 0.001)\n    (check-within (candidate \"Hello world\" 4) (list \"world\") 0.001)\n    (check-within (candidate \"Uncle sam\" 3) (list \"Uncle\") 0.001)\n    (check-within (candidate \"\" 4) (list ) 0.001)\n    (check-within (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"f\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function select_words(s, n)\n  local result = {}\n  for word in s:gmatch(\"%S+\") do\n    local n_consonants = 0\n    for i = 1, #word do\n      if not word:sub(i,i):lower():find(\"[aeiou]\") then\n        n_consonants = n_consonants + 1\n      end\n    end\n    if n_consonants == n then\n      table.insert(result, word)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `select_words` which takes a string `s` and an integer `n` and returns an array of words in the string that have exactly `n` consonants.\n\nfor word in s:gmatch(\"%S+\") do\n    ...\nend\nThe function first iterates through each word in the input string `s`.\n\nlocal n_consonants = 0\nfor i = 1, #word do\n    if not word:sub(i,i):lower():find(\"[aeiou]\") then\n        n_consonants = n_consonants + 1\n    end\nend\nFor each word, the function counts the number of consonants in the word by iterating through each character in the word and checking if it is a consonant (i.e., not a vowel).\n\nif n_consonants == n then\n    table.insert(result, word)\nend\nIf the number of consonants in the word is equal to `n`, the function appends the word to the `result` array.\n\nreturn result\nFinally, the function returns the `result` array containing the words with `n` consonants.\n\n### Racket version\n\n#lang racket\n\n(define (select_words s n)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add_elements arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)\n    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)\n    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)\n    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)\n    (check-within (candidate (list 1) 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function add_elements(arr, k)\n  local sum = 0\n  for i = 1, k do\n    if #tostring(arr[i]) <= 2 then\n      sum = sum + arr[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `add_elements` which takes an array of numbers `arr` and an integer `k` and returns the sum of the first `k` elements of the array that have at most two digits.\n\nlocal sum = 0\nThe function initializes a variable `sum` to 0 to store the sum of the selected elements.\n\nfor i = 1, k do\n    if #tostring(arr[i]) <= 2 then\n        sum = sum + arr[i]\n    end\nend\nThe function iterates through the first `k` elements of the array. If the number has at most two digits (i.e., its string representation has length at most 2), the function adds it to the `sum` variable.\n\nreturn sum\nThe function returns the `sum` variable containing the sum of the selected elements.\n\n### Racket version\n\n#lang racket\n\n(define (add_elements arr k)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (eat number need remaining)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate eat))\n    (check-within (candidate 5 6 10) (list 11 4) 0.001)\n    (check-within (candidate 4 8 9) (list 12 1) 0.001)\n    (check-within (candidate 1 10 10) (list 11 0) 0.001)\n    (check-within (candidate 2 11 5) (list 7 0) 0.001)\n    (check-within (candidate 4 5 7) (list 9 2) 0.001)\n    (check-within (candidate 4 5 1) (list 5 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function eat(number, need, remaining)\n    if need <= remaining then\n        return {number + need, remaining - need}\n    else\n        return {number + remaining, 0}\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `eat` that takes three arguments: `number`, `need`, and `remaining`. The function returns a table containing two numbers: the amount of food eaten and the amount of food remaining.\n\nif need <= remaining then\n    return {number + need, remaining - need}\nIf the amount of food needed is less than or equal to the amount of food remaining, the function returns a table containing the sum of `number` and `need` as the amount of food eaten, and the difference between `remaining` and `need` as the amount of food remaining.\n\nelse\n    return {number + remaining, 0}\nOtherwise, the function returns a table containing the sum of `number` and `remaining` as the amount of food eaten, and 0 as the amount of food remaining.\n\n### Racket version\n\n#lang racket\n\n(define (eat number need remaining)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (odd_count lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate odd_count))\n    (check-within (candidate (list \"1234567\")) (list \"the number of odd elements 4n the str4ng 4 of the 4nput.\") 0.001)\n    (check-within (candidate (list \"3\" \"11111111\")) (list \"the number of odd elements 1n the str1ng 1 of the 1nput.\" \"the number of odd elements 8n the str8ng 8 of the 8nput.\") 0.001)\n    (check-within (candidate (list \"271\" \"137\" \"314\")) (list \"the number of odd elements 2n the str2ng 2 of the 2nput.\" \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \"the number of odd elements 2n the str2ng 2 of the 2nput.\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function odd_count(lst)\n  local res = {}\n  for _, arr in ipairs(lst) do\n    local n = 0\n    for d in arr:gmatch('%d') do\n      if math.fmod(tonumber(d), 2) == 1 then\n        n = n + 1\n      end\n    end\n    table.insert(res, \"the number of odd elements \" .. n .. \"n the str\" .. n .. \"ng \" .. n .. \" of the \" .. n .. \"nput.\")\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function `odd_count` which takes an array of strings and returns an array of strings containing the number of odd digits in each string.\n\nlocal res = {}\nThe function initializes an empty array `res` to store the result.\n\nfor _, arr in ipairs(lst) do\n    ...\nend\nThe function iterates through each string `arr` in the input array `lst`.\n\nfor d in arr:gmatch('%d') do\n    if math.fmod(tonumber(d), 2) == 1 then\n        n = n + 1\n    end\nend\nThe function then iterates through each digit in the string using `gmatch`. If the digit is odd, it increments the `n` variable.\n\ntable.insert(res, \"the number of odd elements \" .. n .. \"n the str\" .. n .. \"ng \" .. n .. \" of the \" .. n .. \"nput.\")\nFinally, the function appends a string to the `res` array containing the number of odd digits in the string.\n\nreturn res\nThe function returns the `res` array containing the number of odd digits in each string.\n\n### Racket version\n\n#lang racket\n\n(define (odd_count lst)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (next_smallest lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)\n    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list -35 34 12 -45)) -35 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function next_smallest(lst)\n    table.sort(lst)\n    for i = 2, #lst do\n        if lst[i] > lst[1] then\n            return lst[i]\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `next_smallest` which takes an array of numbers and returns the next smallest number that is greater than the smallest number in the array.\n\ntable.sort(lst)\nThe function first sorts the input array in ascending order.\n\nfor i = 2, #lst do\n    if lst[i] > lst[1] then\n        return lst[i]\n    end\nend\nThe function then iterates through each element in the array starting from the second element. If an element is greater than the first element (the smallest element), the function returns that element.\n\n### Racket version\n\n#lang racket\n\n(define (next_smallest lst)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_prefix strings prefix)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_prefix(strings, prefix)\n    local res = {}\n    for _, x in ipairs(strings) do\n        if string.sub(x, 1, #prefix) == prefix then\n            table.insert(res, x)\n        end\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of filtering a list of strings by a given prefix. It takes a list of strings `strings` and a prefix string `prefix` as input, and returns a list of strings that start with the given prefix.\n\nlocal res = {}\nThe function initializes an empty array `res` to store the filtered strings.\n\nfor _, x in ipairs(strings) do\n    if string.sub(x, 1, #prefix) == prefix then\n        table.insert(res, x)\n    end\nend\nThe function iterates through each string `x` in the input list `strings`. If the first `#prefix` characters of the string `x` match the prefix string `prefix`, the function appends the string to the `res` array.\n\nreturn res\nFinally, the function returns the `res` array containing the filtered strings.\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_prefix strings prefix)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (choose_num x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n    (check-within (candidate 12 15) 14 0.001)\n    (check-within (candidate 13 12) -1 0.001)\n    (check-within (candidate 33 12354) 12354 0.001)\n    (check-within (candidate 5234 5233) -1 0.001)\n    (check-within (candidate 6 29) 28 0.001)\n    (check-within (candidate 27 10) -1 0.001)\n    (check-within (candidate 7 7) -1 0.001)\n    (check-within (candidate 546 546) 546 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function choose_num(x, y)\n    if x > y then\n        return -1\n    end\n    if y % 2 == 0 then\n        return y\n    end\n    if x == y then\n        return -1\n    end\n    return y - 1\nend\n\n### Explanation\n\nThe code is an implementation of a function `choose_num` which takes two numbers `x` and `y` and returns a number based on the following rules:\n\n- If `x` is greater than `y`, return -1.\n- If `y` is even, return `y`.\n- If `x` is equal to `y`, return -1.\n- Otherwise, return `y - 1`.\n\nif x > y then\n    return -1\nend\nIf `x` is greater than `y`, the function returns -1.\n\nif y % 2 == 0 then\n    return y\nend\nIf `y` is even, the function returns `y`.\n\nif x == y then\n    return -1\nend\nIf `x` is equal to `y`, the function returns -1.\n\nreturn y - 1\nOtherwise, the function returns `y - 1`.\n\n### Racket version\n\n#lang racket\n\n(define (choose_num x y)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_length string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n    (check-within (candidate \"Hello\") #t 0.001)\n    (check-within (candidate \"abcdcba\") #t 0.001)\n    (check-within (candidate \"kittens\") #t 0.001)\n    (check-within (candidate \"orange\") #f 0.001)\n    (check-within (candidate \"wow\") #t 0.001)\n    (check-within (candidate \"world\") #t 0.001)\n    (check-within (candidate \"MadaM\") #t 0.001)\n    (check-within (candidate \"Wow\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"HI\") #t 0.001)\n    (check-within (candidate \"go\") #t 0.001)\n    (check-within (candidate \"gogo\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaa\") #f 0.001)\n    (check-within (candidate \"Madam\") #t 0.001)\n    (check-within (candidate \"M\") #f 0.001)\n    (check-within (candidate \"0\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function prime_length(string)\n  local l = #string\n  if l == 0 or l == 1 then\n    return false\n  end\n  for i = 2, l - 1 do\n    if l % i == 0 then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `prime_length` which takes a string and returns a boolean indicating whether the length of the string is a prime number.\n\nif l == 0 or l == 1 then\n    return false\nThe function first checks if the length of the input string is 0 or 1. If it is, it returns false because 0 and 1 are not prime numbers.\n\nfor i = 2, l - 1 do\n    if l % i == 0 then\n        return false\n    end\nend\nOtherwise, the function checks if the length of the string is divisible by any number between 2 and `l-1`. If it is, it returns false because `l` is not a prime number.\n\nreturn true\nFinally, the function returns true if the length of the string is not 0 or 1 and is not divisible by any number between 2 and `l-1`, which means that the length of the string is a prime number.\n\n### Racket version\n\n#lang racket\n\n(define (prime_length string)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_to_n n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_to_n))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 6) 21 0.001)\n    (check-within (candidate 11) 66 0.001)\n    (check-within (candidate 30) 465 0.001)\n    (check-within (candidate 100) 5050 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function sum_to_n(n)\n  return (n * (n + 1)) / 2\nend\n\n### Explanation\n\nThe code is an implementation of a function `sum_to_n` which takes a number `n` as input and returns the sum of all integers from 1 to `n`.\n\nreturn (n * (n + 1)) / 2\nThe function returns the sum of all integers from 1 to `n` using the formula `n*(n+1)/2`.\n\n### Racket version\n\n#lang racket\n\n(define (sum_to_n n)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fix_spaces text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fix_spaces))\n    (check-within (candidate \"Example\") \"Example\" 0.001)\n    (check-within (candidate \"Mudasir Hanif \") \"Mudasir_Hanif_\" 0.001)\n    (check-within (candidate \"Yellow Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\" 0.001)\n    (check-within (candidate \"Exa   mple\") \"Exa-mple\" 0.001)\n    (check-within (candidate \"   Exa 1 2 2 mple\") \"-Exa_1_2_2_mple\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function fix_spaces(text)\n    local new_text = \"\"\n    local i = 1\n    local start, _end = 1, 1\n    while i <= #text do\n        local c = text:sub(i, i)\n        if c == \" \" then\n            _end = _end + 1\n        else\n            if _end - start > 2 then\n                new_text = new_text .. \"-\" .. c\n            elseif _end - start > 0 then\n                new_text = new_text .. (\"_\"):rep(_end - start) .. c\n            else\n                new_text = new_text .. c\n            end\n            start, _end = i+1, i+1\n        end\n        i = i + 1\n    end\n    if _end - start > 2 then\n        new_text = new_text .. \"-\"\n    elseif _end - start > 0 then\n        new_text = new_text .. \"_\"\n    end\n    return new_text\nend\n\n### Explanation\n\nThe code is an implementation of a function `fix_spaces` which takes a string of text and replaces spaces with underscores or hyphens depending on the number of spaces in a row. The function returns the modified string.\n\nlocal new_text = \"\"\nlocal i = 1\nlocal start, _end = 1, 1\nThe function initializes an empty string `new_text` to store the modified text. It also initializes a counter variable `i` to keep track of the current index in the input string `text`. The variables `start` and `_end` are initialized to 1 to keep track of the start and end indices of each group of spaces.\n\nwhile i <= #text do\n    local c = text:sub(i, i)\n    if c == \" \" then\n        _end = _end + 1\nIf the current character is a space, the function increments the `_end` variable to keep track of the end index of the current group of spaces.\n\n    else\n        if _end - start > 2 then\n            new_text = new_text .. \"-\" .. c\nIf the number of spaces in the current group is greater than 2, the function replaces the spaces with a hyphen `-` and appends the current character `c` to the `new_text` string.\n\n        elseif _end - start > 0 then\n            new_text = new_text .. (\"_\"):rep(_end - start) .. c\nIf the number of spaces in the current group is greater than 0 but less than or equal to 2, the function replaces the spaces with underscores `_` and appends the current character `c` to the `new_text` string.\n\n        else\n            new_text = new_text .. c\nIf there are no spaces in the current group, the function simply appends the current character `c` to the `new_text` string.\n\n        end\n        start, _end = i+1, i+1\nThe function then updates the `start` and `_end` variables to the next index.\n\n    end\n    i = i + 1\nThe function increments the `i` variable to move to the next character in the input string.\n\nif _end - start > 2 then\n    new_text = new_text .. \"-\"\nelseif _end - start > 0 then\n    new_text = new_text .. \"_\"\nend\nFinally, the function checks if there are any spaces left at the end of the input string. If there are more than 2 spaces, the function replaces them with a hyphen `-`. If there are less than or equal to 2 spaces, the function replaces them with underscores `_`.\n\nreturn new_text\nThe function returns the modified string.\n\n### Racket version\n\n#lang racket\n\n(define (fix_spaces text)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rolling_max numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)\n    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function rolling_max(numbers)\n    local running_max = nil\n    local result = {}\n\n    for _, n in ipairs(numbers) do\n        if running_max == nil then\n            running_max = n\n        else\n            running_max = math.max(running_max, n)\n        end\n\n        table.insert(result, running_max)\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `rolling_max` that takes an array of numbers and returns an array of the maximum value seen so far at each position in the input array.\n\nlocal running_max = nil\nlocal result = {}\nThe function initializes the variable `running_max` to `nil` to keep track of the maximum value seen so far. It also initializes an empty array `result` to store the maximum value seen so far at each position in the input array.\n\nfor _, n in ipairs(numbers) do\n    if running_max == nil then\n        running_max = n\n    else\n        running_max = math.max(running_max, n)\n    end\n\n    table.insert(result, running_max)\nend\nThe function iterates through each number `n` in the input array `numbers`. If `running_max` is `nil`, it means that the current number is the first number in the array, so the function sets `running_max` to the current number. Otherwise, the function sets `running_max` to the maximum value between `running_max` and the current number. The function then appends `running_max` to the `result` array.\n\nreturn result\nFinally, the function returns the `result` array containing the maximum value seen so far at each position in the input array.\n\n### Racket version\n\n#lang racket\n\n(define (rolling_max numbers)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (words_in_sentence sentence)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_in_sentence))\n    (check-within (candidate \"This is a test\") \"is\" 0.001)\n    (check-within (candidate \"lets go for swimming\") \"go for\" 0.001)\n    (check-within (candidate \"there is no place available here\") \"there is no place\" 0.001)\n    (check-within (candidate \"Hi I am Hussein\") \"Hi am Hussein\" 0.001)\n    (check-within (candidate \"go for it\") \"go for it\" 0.001)\n    (check-within (candidate \"here\") \"\" 0.001)\n    (check-within (candidate \"here is\") \"is\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function words_in_sentence(sentence)\n    local new_lst = {}\n    for word in sentence:gmatch(\"%S+\") do\n        local flg = 0\n        if #word == 1 then\n            flg = 1\n        end\n        for i=2, #word-1 do\n            if #word%i == 0 then\n                flg = 1\n            end\n        end\n        if flg == 0 or #word == 2 then\n            table.insert(new_lst, word)\n        end\n    end\n    return table.concat(new_lst, \" \")\nend\n\n### Explanation\n\nThe code is an implementation of a function `words_in_sentence` which takes a string of words and returns a string of words that are not divisible by any number except 1 and itself. The function removes any words that are only one character long.\n\nfor word in sentence:gmatch(\"%S+\") do\n    ...\nend\nThe function first iterates through each word in the input string `sentence` using the `gmatch` function.\n\nif #word == 1 then\n    flg = 1\nend\nIf the length of the word is 1, the function sets a flag `flg` to 1.\n\nfor i=2, #word-1 do\n    if #word%i == 0 then\n        flg = 1\n    end\nend\nThe function then checks if the length of the word is divisible by any number except 1 and itself. If it is, the function sets the `flg` variable to 1.\n\nif flg == 0 or #word == 2 then\n    table.insert(new_lst, word)\nend\nIf the `flg` variable is 0 or the length of the word is 2, the function appends the word to the `new_lst` array.\n\nreturn table.concat(new_lst, \" \")\nFinally, the function returns the `new_lst` array as a string with spaces between the words.\n\n### Racket version\n\n#lang racket\n\n(define (words_in_sentence sentence)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_closest_vowel word)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-within (candidate \"yogurt\") \"u\" 0.001)\n    (check-within (candidate \"full\") \"u\" 0.001)\n    (check-within (candidate \"easy\") \"\" 0.001)\n    (check-within (candidate \"eAsy\") \"\" 0.001)\n    (check-within (candidate \"ali\") \"\" 0.001)\n    (check-within (candidate \"bad\") \"a\" 0.001)\n    (check-within (candidate \"most\") \"o\" 0.001)\n    (check-within (candidate \"ab\") \"\" 0.001)\n    (check-within (candidate \"ba\") \"\" 0.001)\n    (check-within (candidate \"quick\") \"\" 0.001)\n    (check-within (candidate \"anime\") \"i\" 0.001)\n    (check-within (candidate \"Asia\") \"\" 0.001)\n    (check-within (candidate \"Above\") \"o\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function get_closest_vowel(word)\n    if #word < 3 then\n        return \"\"\n    end\n\n    local vowels = {a=true, e=true, i=true, o=true, u=true, A=true, E=true, I=true, O=true, U=true}\n    for i=#word-1, 2, -1 do\n        if vowels[word:sub(i, i)] then\n            if not (vowels[word:sub(i-1, i-1)] or vowels[word:sub(i+1, i+1)]) then\n                return word:sub(i, i)\n            end\n        end\n    end\n    return \"\"\nend\n\n### Explanation\n\nThe code is an implementation of finding the closest vowel in a word. It takes a string `word` as input and returns the closest vowel to the center of the word.\n\nif #word < 3 then\n    return \"\"\nend\nThe function first checks if the length of the input string is less than 3. If it is, it returns an empty string.\n\nlocal vowels = {a=true, e=true, i=true, o=true, u=true, A=true, E=true, I=true, O=true, U=true}\nThe function then initializes a table `vowels` with all the vowels in both uppercase and lowercase.\n\nfor i=#word-1, 2, -1 do\n    if vowels[word:sub(i, i)] then\n        if not (vowels[word:sub(i-1, i-1)] or vowels[word:sub(i+1, i+1)]) then\n            return word:sub(i, i)\n        end\n    end\nend\nThe function then iterates through the characters in the input string from the second to the second-to-last character. If a vowel is found, the function checks if the characters immediately before and after the vowel are not vowels. If this is true, the function returns the vowel.\n\nreturn \"\"\nIf no such vowel is found, the function returns an empty string.\n\n### Racket version\n\n#lang racket\n\n(define (get_closest_vowel word)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare game guess)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)\n    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function compare(game, guess)\n  local result = {}\n  for i = 1, #game do\n    result[i] = math.abs(game[i] - guess[i])\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `compare` that takes two arrays of numbers `game` and `guess` and returns an array of the absolute differences between the corresponding elements of the two arrays.\n\nfor i = 1, #game do\n    result[i] = math.abs(game[i] - guess[i])\nend\nThe function iterates through each element of the `game` array and computes the absolute difference between the corresponding elements of the `game` and `guess` arrays. The result is stored in the `result` array.\n\nreturn result\nFinally, the function returns the `result` array containing the absolute differences.\n\n### Racket version\n\n#lang racket\n\n(define (compare game guess)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (remove_duplicates numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_duplicates))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function remove_duplicates(numbers)\n  local c = {}\n  for _, n in ipairs(numbers) do\n    c[n] = (c[n] or 0) + 1\n  end\n  local result = {}\n  for _, n in ipairs(numbers) do\n    if c[n] <= 1 then\n      table.insert(result, n)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of removing duplicates from an array of numbers. It takes an array of numbers `numbers` as input and returns an array of numbers with duplicates removed.\n\nlocal c = {}\nfor _, n in ipairs(numbers) do\n    c[n] = (c[n] or 0) + 1\nend\nThe function first creates a table `c` where the indices are the numbers in the input array and the elements are the number of times that number appears in the array.\n\nfor _, n in ipairs(numbers) do\n    if c[n] <= 1 then\n        table.insert(result, n)\n    end\nend\nIt then iterates through each number in the input array and appends it to the `result` array if it appears only once in the input array.\n\nreturn result\nFinally, the function returns the `result` array with duplicates removed.\n\n### Racket version\n\n#lang racket\n\n(define (remove_duplicates numbers)\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (same_chars s0 s1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabc\") #t 0.001)\n    (check-within (candidate \"dddddddabc\" \"abcd\") #t 0.001)\n    (check-within (candidate \"eabcd\" \"dddddddabc\") #f 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabcf\") #f 0.001)\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f 0.001)\n    (check-within (candidate \"aabb\" \"aaccc\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function same_chars(s0, s1)\n    local set0, set1 = {}, {}\n    for i=1, #s0 do set0[s0:sub(i,i)] = true end\n    for i=1, #s1 do set1[s1:sub(i,i)] = true end\n    for k in pairs(set0) do if not set1[k] then return false end end\n    for k in pairs(set1) do if not set0[k] then return false end end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking if two strings have the same set of characters. It takes two strings `s0` and `s1` as input and returns a boolean.\n\nlocal set0, set1 = {}, {}\nThe function first initializes two empty tables `set0` and `set1` to store the characters in the two input strings.\n\nfor i=1, #s0 do set0[s0:sub(i,i)] = true end\nfor i=1, #s1 do set1[s1:sub(i,i)] = true end\nThe function then iterates through each character in the two input strings and adds it to the corresponding set.\n\nfor k in pairs(set0) do if not set1[k] then return false end end\nfor k in pairs(set1) do if not set0[k] then return false end end\nThe function then checks if each character in `set0` is also in `set1`, and vice versa. If any character is not in the other set, the function returns false.\n\nreturn true\nIf all characters in both sets are the same, the function returns true.\n\n### Racket version\n\n#lang racket\n\n(define (same_chars s0 s1)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_nested_parens paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3) 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4) 0.001)\n    (check-within (candidate \"(()(())((())))\") (list 4) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function parse_nested_parens(paren_string)\n    local function parse_paren_group(s)\n        local depth = 0\n        local max_depth = 0\n        for c in s:gmatch('.') do\n            if c == '(' then\n                depth = depth + 1\n                max_depth = math.max(depth, max_depth)\n            else\n                depth = depth - 1\n            end\n        end\n        return max_depth\n    end\n    local res = {}\n    for x in paren_string:gmatch('%S+') do\n        table.insert(res, parse_paren_group(x))\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a function `parse_nested_parens` which takes a string of parentheses and returns an array of integers representing the maximum depth of each group of parentheses.\n\nlocal function parse_paren_group(s)\n    ...\nend\nThe function first defines a helper function `parse_paren_group` that takes a string of parentheses and returns the maximum depth of the group.\n\nlocal depth = 0\nlocal max_depth = 0\nThe function initializes the `depth` variable to 0 to keep track of the current depth of the group, and the `max_depth` variable to 0 to keep track of the maximum depth of the group.\n\nfor c in s:gmatch('.') do\n    if c == '(' then\n        depth = depth + 1\n        max_depth = math.max(depth, max_depth)\n    else\n        depth = depth - 1\n    end\nend\nThe function iterates through each character `c` in the input string `s`. If the character is an opening parenthesis `'('`, the function increments the `depth` variable and updates the `max_depth` variable if the current depth is greater than the maximum depth seen so far. If the character is a closing parenthesis `')'`, the function decrements the `depth` variable.\n\nreturn max_depth\nThe function returns the `max_depth` variable, which represents the maximum depth of the group.\n\nfor x in paren_string:gmatch('%S+') do\n    table.insert(res, parse_paren_group(x))\nend\nThe `parse_nested_parens` function then iterates through each non-space substring `x` in the input string `paren_string` using the `gmatch` function. It calls the `parse_paren_group` function on each substring and appends the result to the `res` array.\n\nreturn res\nFinally, the function returns the `res` array containing the maximum depth of each group of parentheses.\n\n### Racket version\n\n#lang racket\n\n(define (parse_nested_parens paren_string)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (even_odd_count num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n    (check-within (candidate 7) (list 0 1) 0.001)\n    (check-within (candidate -78) (list 1 1) 0.001)\n    (check-within (candidate 3452) (list 2 2) 0.001)\n    (check-within (candidate 346211) (list 3 3) 0.001)\n    (check-within (candidate -345821) (list 3 3) 0.001)\n    (check-within (candidate -2) (list 1 0) 0.001)\n    (check-within (candidate -45347) (list 2 3) 0.001)\n    (check-within (candidate 0) (list 1 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_count(num)\n    local even_count = 0\n    local odd_count = 0\n    for i in tostring(math.abs(num)):gmatch(\".\") do\n        if tonumber(i)%2==0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n    end\n    return {even_count, odd_count}\nend\n\n### Explanation\n\nThe code is an implementation of counting the number of even and odd digits in a number. It takes a number `num` as input and returns a table of two numbers: even digit count and odd digit count.\n\nfor i in tostring(math.abs(num)):gmatch(\".\") do\n    ...\nend\nThe program first converts the input number to a string using `tostring(math.abs(num))` and then iterates through each character in the string using `gmatch(\".\")`.\n\nif tonumber(i)%2==0 then\n    even_count = even_count + 1\nelse\n    odd_count = odd_count + 1\nend\nFor each character `i`, the program checks if it is an even digit or an odd digit. If it is even, it increments the `even_count` variable. If it is odd, it increments the `odd_count` variable.\n\nreturn {even_count, odd_count}\nFinally, the program returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n(define (even_odd_count num)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fruit_distribution s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fruit_distribution))\n    (check-within (candidate \"5 apples and 6 oranges\" 19) 8 0.001)\n    (check-within (candidate \"5 apples and 6 oranges\" 21) 10 0.001)\n    (check-within (candidate \"0 apples and 1 oranges\" 3) 2 0.001)\n    (check-within (candidate \"1 apples and 0 oranges\" 3) 2 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 100) 95 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 5) 0 0.001)\n    (check-within (candidate \"1 apples and 100 oranges\" 120) 19 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function fruit_distribution(s, n)\n    local sum = 0\n    for i in string.gmatch(s, \"%d+\") do\n        sum = sum + tonumber(i)\n    end\n    return n - sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `fruit_distribution` which takes a string `s` containing numbers separated by non-numeric characters and an integer `n`, and returns the difference between `n` and the sum of the numbers in `s`.\n\nfor i in string.gmatch(s, \"%d+\") do\n    sum = sum + tonumber(i)\nend\nThe function first uses the `string.gmatch` function to iterate through each substring of `s` that contains only digits. It then converts each substring to a number using `tonumber` and adds it to the `sum` variable.\n\nreturn n - sum\nFinally, the function returns the difference between `n` and the `sum` of the numbers in `s`.\n\n### Racket version\n\n#lang racket\n\n(define (fruit_distribution s n)\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_xor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n    (check-within (candidate \"111000\" \"101010\") \"010010\" 0.001)\n    (check-within (candidate \"1\" \"1\") \"0\" 0.001)\n    (check-within (candidate \"0101\" \"0000\") \"0101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function string_xor(a, b)\n    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result = result .. '0'\n        else\n            result = result .. '1'\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `string_xor` which takes two binary strings of the same length and returns their XOR.\n\nlocal result = ''\nThe function initializes an empty string `result` to store the XOR result.\n\nfor i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n        result = result .. '0'\nIf the `i`-th character of `a` and `b` are the same, the function appends `'0'` to the `result` string.\n\nelse\n    result = result .. '1'\nOtherwise, the function appends `'1'` to the `result` string.\n\nreturn result\nThe function returns the `result` string containing the XOR result.\n\n### Racket version\n\n#lang racket\n\n(define (string_xor a b)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strlen string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strlen))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"x\") 1 0.001)\n    (check-within (candidate \"asdasnakj\") 9 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function strlen(string)\n    return #string\nend\n\n### Explanation\n\nThe code is an implementation of a function `strlen` which takes a string and returns its length.\n\nreturn #string\nThe function simply returns the length of the input string using the `#` operator.\n\n### Racket version\n\n#lang racket\n\n(define (strlen string)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_sequence n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n    (check-within (candidate 0) \"0\" 0.001)\n    (check-within (candidate 3) \"0 1 2 3\" 0.001)\n    (check-within (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function string_sequence(n)\n    local t = {}\n    for i = 0, n do\n        t[#t + 1] = tostring(i)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of a function `string_sequence` which takes an integer `n` and returns a string of numbers from 0 to `n` separated by spaces.\n\nlocal t = {}\nfor i = 0, n do\n    t[#t + 1] = tostring(i)\nend\nThe function first initializes an empty table `t`. It then loops through all numbers from 0 to `n` (inclusive) and appends each number as a string to the `t` table.\n\nreturn table.concat(t, ' ')\nFinally, the function returns the concatenated string of numbers in the `t` table, separated by spaces.\n\n### Racket version\n\n#lang racket\n\n(define (string_sequence n)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (can_arrange arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate can_arrange))\n    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)\n    (check-within (candidate (list 1 2 4 5)) -1 0.001)\n    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)\n    (check-within (candidate (list )) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function can_arrange(arr)\n    local ind=-1\n    local i=1\n    while i<#arr do\n      if arr[i]>arr[i+1] then\n        ind=i\n      end\n      i=i+1\n    end\n    return ind\nend\n\n### Explanation\n\nThe code is an implementation of a function `can_arrange` which takes an array of integers and returns the index of the first element that is out of order. If the array is already sorted, it returns -1.\n\nlocal ind=-1\nThe function initializes the variable `ind` to -1, which will be used to store the index of the first element that is out of order.\n\nwhile i<#arr do\n    if arr[i]>arr[i+1] then\n        ind=i\n    end\n    i=i+1\nend\nThe function iterates through the input array `arr` and checks if each element is greater than the next element. If it is, the function stores the index of the current element in the `ind` variable.\n\nreturn ind\nFinally, the function returns the index of the first element that is out of order, or -1 if the array is already sorted.\n\n### Racket version\n\n#lang racket\n\n(define (can_arrange arr)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate (list 4 88)) 88 0.001)\n    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)\n    (check-within (candidate (list 4 0 6 7)) 0 0.001)\n    (check-within (candidate (list 4 4 6 8)) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function add(lst)\n  local sum = 0\n  for i = 2, #lst, 2 do\n    if lst[i]%2 == 0 then\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `add` which takes an array of numbers and returns the sum of all even-indexed even numbers in the array.\n\nlocal sum = 0\nThe function initializes a variable `sum` to 0 to store the sum of the even-indexed even numbers.\n\nfor i = 2, #lst, 2 do\n    if lst[i]%2 == 0 then\n        sum = sum + lst[i]\n    end\nend\nThe function then iterates through the array `lst` starting at index 2 and incrementing by 2 each time. If the current element is even and has an even index, it adds the element to the `sum` variable.\n\nreturn sum\nFinally, the function returns the `sum` variable containing the sum of all even-indexed even numbers in the array.\n\n### Racket version\n\n#lang racket\n\n(define (add lst)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersperse numbers delimeter)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersperse))\n    (check-within (candidate (list ) 7) (list ) 0.001)\n    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)\n    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function intersperse(numbers, delimeter)\n    if not numbers then\n        return {}\n    end\n\n    local result = {}\n\n    for i=1, #numbers-1 do\n        table.insert(result, numbers[i])\n        table.insert(result, delimeter)\n    end\n\n    table.insert(result, numbers[#numbers])\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `intersperse` which takes an array of numbers and a delimiter and returns a new array with the delimiter interspersed between each pair of numbers.\n\nif not numbers then\n    return {}\nend\nThe function first checks if the input array `numbers` is empty. If it is, it returns an empty array.\n\nlocal result = {}\nThe function initializes an empty array `result` to store the new array with the delimiter interspersed.\n\nfor i=1, #numbers-1 do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\nend\nThe function then iterates through each number in the input array except for the last one. It appends the current number to the `result` array, followed by the delimiter.\n\ntable.insert(result, numbers[#numbers])\nFinally, the function appends the last number in the input array to the `result` array.\n\nreturn result\nThe function returns the `result` array with the delimiter interspersed between each pair of numbers.\n\n### Racket version\n\n#lang racket\n\n(define (intersperse numbers delimeter)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (match_parens lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate match_parens))\n    (check-within (candidate (list \"()(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \")\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(())\" \"())())\")) \"No\" 0.001)\n    (check-within (candidate (list \")())\" \"(()()(\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"(())))\" \"(()())((\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"()\" \"())\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(\" \"()))()\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"((((\" \"((())\")) \"No\" 0.001)\n    (check-within (candidate (list \")(()\" \"(()(\")) \"No\" 0.001)\n    (check-within (candidate (list \")(\" \")(\")) \"No\" 0.001)\n    (check-within (candidate (list \"(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \"(\")) \"Yes\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function match_parens(lst)\n    local function check(s)\n        local val = 0\n        for i=1, #s do\n            if s:sub(i, i) == '(' then\n                val = val + 1\n            else\n                val = val - 1\n            end\n            if val < 0 then\n                return false\n            end\n        end\n        return val == 0\n    end\n\n    local S1 = lst[1]..lst[2]\n    local S2 = lst[2]..lst[1]\n    if check(S1) or check(S2) then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\n\n### Explanation\n\nThe code is an implementation of checking if a list of strings contains two strings that can be concatenated to form a string with balanced parentheses. The function takes in a list of strings `lst` and returns a string `'Yes'` if there are two strings that can be concatenated to form a string with balanced parentheses, and `'No'` otherwise.\n\nlocal function check(s)\n    local val = 0\n    for i=1, #s do\n        if s:sub(i,i) == '(' then\n            val = val + 1\n        else\n            val = val - 1\n        end\n        if val < 0 then\n            return false\n        end\n    end\n    return val == 0\nend\nThe function first defines a helper function `check` that takes a string and returns `true` if the string has balanced parentheses and `false` otherwise. This is done by iterating through each character in the string and incrementing or decrementing a counter variable `val` depending on whether the character is an opening or closing parenthesis. If the counter variable ever becomes negative, it means that there are more closing parentheses than opening parentheses, so the function returns `false`. If the counter variable is 0 at the end of the iteration, it means that the string has balanced parentheses, so the function returns `true`.\n\nlocal S1 = lst[1] .. lst[2]\nlocal S2 = lst[2] .. lst[1]\nThe function concatenates the first two strings in the input list `lst` to form two new strings `S1` and `S2`.\n\nif check(S1) or check(S2) then\n    return 'Yes'\nelse\n    return 'No'\nend\nThe function then checks if either `S1` or `S2` has balanced parentheses using the `check` function. If either string has balanced parentheses, the function returns `'Yes'`. Otherwise, it returns `'No'`.\n\n### Racket version\n\n#lang racket\n\n(define (match_parens lst)\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (any_int x y z)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate any_int))\n    (check-within (candidate 2 3 1) #t 0.001)\n    (check-within (candidate 2.5 2 3) #f 0.001)\n    (check-within (candidate 1.5 5 3.5) #f 0.001)\n    (check-within (candidate 2 6 2) #f 0.001)\n    (check-within (candidate 4 2 2) #t 0.001)\n    (check-within (candidate 2.2 2.2 2.2) #f 0.001)\n    (check-within (candidate -4 6 2) #t 0.001)\n    (check-within (candidate 2 1 1) #t 0.001)\n    (check-within (candidate 3 4 7) #t 0.001)\n    (check-within (candidate 3.0 4 7) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function any_int(x, y, z)\n    if math.type(x) == \"integer\" and math.type(y) == \"integer\" and math.type(z) == \"integer\" then\n        if (x+y==z) or (x+z==y) or (y+z==x) then\n            return true\n        end\n        return false\n    end\n    return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `any_int` which takes three arguments and returns `true` if any two of the arguments sum to the third argument, and all three arguments are integers. Otherwise, it returns `false`.\n\nif math.type(x) == \"integer\" and math.type(y) == \"integer\" and math.type(z) == \"integer\" then\n    ...\nend\nThe function first checks if all three arguments are integers.\n\nif (x+y==z) or (x+z==y) or (y+z==x) then\n    return true\nend\nIf all three arguments are integers, the function checks if any two of the arguments sum to the third argument. If so, it returns `true`.\n\nreturn false\nIf none of the above conditions are met, the function returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (any_int x y z)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_substring strings substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"grunt\" \"trumpet\" \"prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_substring(strings, substring)\n    local result = {}\n    for _, v in pairs(strings) do\n        if string.find(v, substring) then\n            table.insert(result, v)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of filtering an array of strings by a substring. It takes an array of strings `strings` and a substring `substring` as input and returns an array of strings that contain the substring.\n\nfor _, v in pairs(strings) do\n    if string.find(v, substring) then\n        table.insert(result, v)\n    end\nend\nThe function iterates through each string `v` in the input array `strings`. If the string contains the substring `substring`, it is appended to the `result` array.\n\nreturn result\nFinally, the function returns the `result` array containing the filtered strings.\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_substring strings substring)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_max words)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n    (check-within (candidate (list \"name\" \"of\" \"string\")) \"string\" 0.001)\n    (check-within (candidate (list \"name\" \"enam\" \"game\")) \"enam\" 0.001)\n    (check-within (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\" 0.001)\n    (check-within (candidate (list \"abc\" \"cba\")) \"abc\" 0.001)\n    (check-within (candidate (list \"play\" \"this\" \"game\" \"of\" \"footbott\")) \"footbott\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\" 0.001)\n    (check-within (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\" 0.001)\n    (check-within (candidate (list \"b\")) \"b\" 0.001)\n    (check-within (candidate (list \"play\" \"play\" \"play\")) \"play\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function find_max(words)\n    table.sort(words, function(a, b)\n        if #a ~= #b then\n            return #a > #b\n        else\n            return a < b\n        end\n    end)\n\n    local max_word = words[1]\n    local max_count = 0\n\n    for i=1, #words do\n        local count = 0\n        local char_set = {}\n\n        for j=1, #words[i] do\n            if not char_set[words[i]:sub(j, j)] then\n                count = count + 1\n                char_set[words[i]:sub(j, j)] = true\n            end\n        end\n\n        if count > max_count then\n            max_count = count\n            max_word = words[i]\n        end\n    end\n\n    return max_word\nend\n\n### Explanation\n\nThe code is an implementation of{{{TOFILL}}}\n\n### Racket version\n\n#lang racket\n\n(define (find_max words)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (generate_integers a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate generate_integers))\n    (check-within (candidate 2 10) (list 2 4 6 8) 0.001)\n    (check-within (candidate 10 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 132 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 17 89) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function generate_integers(a, b)\n    local lower = math.max(2, math.min(a, b))\n    local upper = math.min(8, math.max(a, b))\n\n    local result = {}\n    for i=lower, upper do\n        if i%2 == 0 then\n            table.insert(result, i)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of generating a list of even integers between two numbers `a` and `b`. It takes two numbers `a` and `b` as input and returns a list of even integers between `a` and `b`.\n\nlocal lower = math.max(2, math.min(a, b))\nlocal upper = math.min(8, math.max(a, b))\nThe function first sets the lower bound to the maximum of 2 and the minimum of `a` and `b`. It sets the upper bound to the minimum of 8 and the maximum of `a` and `b`.\n\nfor i=lower, upper do\n    if i%2 == 0 then\n        table.insert(result, i)\n    end\nend\nThe function then iterates through all numbers between `lower` and `upper`, and if the number is even, it appends it to the `result` array.\n\nreturn result\nFinally, the function returns the `result` array containing the even integers between `a` and `b`.\n\n### Racket version\n\n#lang racket\n\n(define (generate_integers a b)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (exchange lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate exchange))\n    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) \"YES\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 4)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 3)) \"NO\" 0.001)\n    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) \"NO\" 0.001)\n    (check-within (candidate (list 100 200) (list 200 200)) \"YES\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function exchange(lst1, lst2)\n    local odd = 0\n    local even = 0\n    for i=1, #lst1 do\n        if lst1[i]%2 == 1 then\n            odd = odd + 1\n        end\n    end\n    for i=1, #lst2 do\n        if lst2[i]%2 == 0 then\n            even = even + 1\n        end\n    end\n    if even >= odd then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThe code is an implementation of a function `exchange` which takes two arrays of integers and returns \"YES\" if it is possible to exchange one odd number from the first array with one even number from the second array, and \"NO\" otherwise.\n\nlocal odd = 0\nlocal even = 0\nThe function initializes two counter variables `odd` and `even` to keep track of the number of odd and even numbers in the two input arrays.\n\nfor i=1, #lst1 do\n    if lst1[i]%2 == 1 then\n        odd = odd + 1\n    end\nend\nThe function then iterates through each element in the first array `lst1`, and increments the `odd` counter if the element is odd.\n\nfor i=1, #lst2 do\n    if lst2[i]%2 == 0 then\n        even = even + 1\n    end\nend\nIt then iterates through each element in the second array `lst2`, and increments the `even` counter if the element is even.\n\nif even >= odd then\n    return \"YES\"\nend\nIf the number of even elements in the second array is greater than or equal to the number of odd elements in the first array, the function returns \"YES\".\n\nreturn \"NO\"\nOtherwise, the function returns \"NO\".\n\n### Racket version\n\n#lang racket\n\n(define (exchange lst1 lst2)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (int_to_mini_roman number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n    (check-within (candidate 19) \"xix\" 0.001)\n    (check-within (candidate 152) \"clii\" 0.001)\n    (check-within (candidate 251) \"ccli\" 0.001)\n    (check-within (candidate 426) \"cdxxvi\" 0.001)\n    (check-within (candidate 500) \"d\" 0.001)\n    (check-within (candidate 1) \"i\" 0.001)\n    (check-within (candidate 4) \"iv\" 0.001)\n    (check-within (candidate 43) \"xliii\" 0.001)\n    (check-within (candidate 90) \"xc\" 0.001)\n    (check-within (candidate 94) \"xciv\" 0.001)\n    (check-within (candidate 532) \"dxxxii\" 0.001)\n    (check-within (candidate 900) \"cm\" 0.001)\n    (check-within (candidate 994) \"cmxciv\" 0.001)\n    (check-within (candidate 1000) \"m\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function int_to_mini_roman(number)\n    local num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}\n    local sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\n    local i = 13\n    local res = \"\"\n    while number > 0 do\n        local div = math.floor(number / num[i])\n        number = number % num[i]\n        while div > 0 do\n            res = res .. sym[i]\n            div = div - 1\n        end\n        i = i - 1\n    end\n    return string.lower(res)\nend\n\n### Explanation\n\nThe code is an implementation of converting an integer to a mini Roman numeral. It takes an integer `number` as input and returns a string containing the mini Roman numeral.\n\nlocal num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}\nlocal sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\nThe function first defines two arrays `num` and `sym` which contain the values and symbols of the Roman numerals.\n\nlocal i = 13\nThe variable `i` is initialized to 13, which is the index of the largest Roman numeral in the `num` array.\n\nwhile number > 0 do\n    local div = math.floor(number / num[i])\n    number = number % num[i]\n    while div > 0 do\n        res = res .. sym[i]\n        div = div - 1\n    end\n    i = i - 1\nend\nThe function then iterates through the `num` array from largest to smallest, and for each value, it calculates how many times the value can be subtracted from the input `number`. It then subtracts the value from the `number` and appends the corresponding symbol to the `res` string that will be returned. The function continues this process until `number` is reduced to 0.\n\nreturn string.lower(res)\nFinally, the function returns the `res` string in lowercase.\n\n### Racket version\n\n#lang racket\n\n(define (int_to_mini_roman number)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_equal_to_sum_even n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #t 0.001)\n    (check-within (candidate 11) #f 0.001)\n    (check-within (candidate 12) #t 0.001)\n    (check-within (candidate 13) #f 0.001)\n    (check-within (candidate 16) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function is_equal_to_sum_even(n)\n  return n%2 == 0 and n >= 8\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_equal_to_sum_even` which takes a number `n` as input and returns `true` if `n` is even and greater than or equal to 8, and `false` otherwise.\n\nreturn n%2 == 0 and n >= 8\nThe function checks if `n` is even and greater than or equal to 8. If it is, it returns `true`. Otherwise, it returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (is_equal_to_sum_even n)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_third l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_third))\n    (check-within (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5) 0.001)\n    (check-within (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5) 0.001)\n    (check-within (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5) 0.001)\n    (check-within (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function sort_third(l)\n    l = {table.unpack(l)}\n    for i = 3, #l, 3 do\n        local j = i\n        while j > 1 and l[j - 3 + 1] > l[j + 1] do\n            l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]\n            j = j - 3\n        end\n    end\n    return l\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers by every third element. It takes an array of numbers `l` as input and returns a sorted array of numbers.\n\nl = {table.unpack(l)}\nThe function first creates a copy of the input array `l` using the `table.unpack` function.\n\nfor i = 3, #l, 3 do\n    ...\nend\nThe function then iterates through every third element in the array.\n\nlocal j = i\nwhile j > 1 and l[j - 3 + 1] > l[j + 1] do\n    l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]\n    j = j - 3\nend\nWithin the loop, the function swaps the current element with the element three positions before it until it is in the correct position. The loop continues until the element is in the correct position or it reaches the beginning of the array.\n\nreturn l\nFinally, the function returns the sorted array.\n\n### Racket version\n\n#lang racket\n\n(define (sort_third l)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (simplify x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate simplify))\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/6\" \"2/1\") #f 0.001)\n    (check-within (candidate \"5/1\" \"3/1\") #t 0.001)\n    (check-within (candidate \"7/10\" \"10/2\") #f 0.001)\n    (check-within (candidate \"2/10\" \"50/10\") #t 0.001)\n    (check-within (candidate \"7/2\" \"4/2\") #t 0.001)\n    (check-within (candidate \"11/6\" \"6/1\") #t 0.001)\n    (check-within (candidate \"2/3\" \"5/2\") #f 0.001)\n    (check-within (candidate \"5/2\" \"3/5\") #f 0.001)\n    (check-within (candidate \"2/4\" \"8/4\") #t 0.001)\n    (check-within (candidate \"2/4\" \"4/2\") #t 0.001)\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/5\" \"1/5\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function simplify(x, n)\n  local a, b = x:match(\"([^/]+)/([^/]+)\")\n  local c, d = n:match(\"([^/]+)/([^/]+)\")\n  local numerator = tonumber(a) * tonumber(c)\n  local denom = tonumber(b) * tonumber(d)\n  if (numerator/denom == math.floor(numerator/denom)) then\n    return true\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of simplifying a fraction. It takes two strings `x` and `n` as input, representing the numerator and denominator of the fraction to be simplified, and returns a boolean indicating whether the fraction is already in its simplest form.\n\nlocal a, b = x:match(\"([^/]+)/([^/]+)\")\nlocal c, d = n:match(\"([^/]+)/([^/]+)\")\nThe function first extracts the numerators and denominators of the two fractions from the input strings `x` and `n`.\n\nlocal numerator = tonumber(a) * tonumber(c)\nlocal denom = tonumber(b) * tonumber(d)\nThe function then calculates the product of the two numerators and the two denominators.\n\nif (numerator/denom == math.floor(numerator/denom)) then\n    return true\nend\nIf the fraction is already in its simplest form, the function returns `true`. Otherwise, it returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (simplify x n)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solve s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate \"AsDf\") \"aSdF\" 0.001)\n    (check-within (candidate \"1234\") \"4321\" 0.001)\n    (check-within (candidate \"ab\") \"AB\" 0.001)\n    (check-within (candidate \"#a@C\") \"#A@c\" 0.001)\n    (check-within (candidate \"#AsdfW^45\") \"#aSDFw^45\" 0.001)\n    (check-within (candidate \"#6@2\") \"2@6#\" 0.001)\n    (check-within (candidate \"#$a^D\") \"#$A^d\" 0.001)\n    (check-within (candidate \"#ccc\") \"#CCC\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function solve(s)\n    local flg = 0\n    local idx = 1\n    local new_str = {}\n    for i=1, #s do\n        if string.match(s:sub(i,i), '%a') then\n            new_str[idx] = string.match(s:sub(i,i), '%a'):upper() == s:sub(i,i) and string.match(s:sub(i,i), '%a'):lower() or string.match(s:sub(i,i), '%a'):upper()\n            flg = 1\n        else\n            new_str[idx] = s:sub(i,i)\n        end\n        idx = idx + 1\n    end\n    s = table.concat(new_str)\n    if flg == 0 then\n        return s:reverse()\n    end\n    return s\nend\n\n### Explanation\n\nThe code is an implementation of a function `solve` which takes a string `s` and returns a modified string. The function capitalizes all lowercase letters and vice versa, and reverses the string if there are no letters in the input string.\n\nlocal flg = 0\nlocal idx = 1\nlocal new_str = {}\nThe function initializes a flag `flg` to 0 to keep track of whether there are any letters in the input string. It also initializes an index `idx` to 1 to keep track of the current position in the input string. The variable `new_str` is initialized to an empty array to store the modified string.\n\nif string.match(s:sub(i,i), '%a') then\n    new_str[idx] = string.match(s:sub(i,i), '%a'):upper() == s:sub(i,i) and string.match(s:sub(i,i), '%a'):lower() or string.match(s:sub(i,i), '%a'):upper()\n    flg = 1\nelse\n    new_str[idx] = s:sub(i,i)\nend\nIf the current character is a letter, the function capitalizes it if it is lowercase and vice versa, and appends it to the `new_str` array. The `flg` variable is set to 1 to indicate that there are letters in the input string. Otherwise, the function appends the character to the `new_str` array as is.\n\nidx = idx + 1\nThe function increments the `idx` variable to move to the next position in the input string.\n\ns = table.concat(new_str)\nThe function concatenates the `new_str` array into a string and assigns it to the `s` variable.\n\nif flg == 0 then\n    return s:reverse()\nend\nIf there are no letters in the input string, the function returns the reversed string.\n\nreturn s\nOtherwise, the function returns the modified string.\n\n### Racket version\n\n#lang racket\n\n(define (solve s)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (right_angle_triangle a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n    (check-within (candidate 3 4 5) #t 0.001)\n    (check-within (candidate 1 2 3) #f 0.001)\n    (check-within (candidate 10 6 8) #t 0.001)\n    (check-within (candidate 2 2 2) #f 0.001)\n    (check-within (candidate 7 24 25) #t 0.001)\n    (check-within (candidate 10 5 7) #f 0.001)\n    (check-within (candidate 5 12 13) #t 0.001)\n    (check-within (candidate 15 8 17) #t 0.001)\n    (check-within (candidate 48 55 73) #t 0.001)\n    (check-within (candidate 1 1 1) #f 0.001)\n    (check-within (candidate 2 2 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function right_angle_triangle(a, b, c)\n  return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\nend\n\n### Explanation\n\nThe code is an implementation of a function `right_angle_triangle` which takes three numbers `a`, `b`, and `c` as input and returns a boolean indicating whether they form a right-angled triangle.\n\nreturn a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\nThe function checks if any of the three conditions for a right-angled triangle is met. If any of the conditions is true, the function returns `true`, otherwise it returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (right_angle_triangle a b c)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (double_the_difference lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate double_the_difference))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 5.0 4.0)) 25 0.001)\n    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)\n    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)\n    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)\n    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)\n    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function double_the_difference(lst)\n    local sum = 0\n    for _, i in ipairs(lst) do\n        if i > 0 and i%2~=0 and math.floor(i) == i then\n            sum = sum + i^2\n        end\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `double_the_difference` which takes an array of numbers and returns the sum of the squares of all odd positive integers in the array.\n\nlocal sum = 0\nThe function initializes a variable `sum` to 0 to store the sum of the squares of all odd positive integers in the array.\n\nfor _, i in ipairs(lst) do\n    if i > 0 and i%2~=0 and math.floor(i) == i then\n        sum = sum + i^2\n    end\nend\nThe function iterates through each element `i` in the input array `lst`. If the element is a positive odd integer, it adds the square of the element to the `sum` variable.\n\nreturn sum\nThe function returns the `sum` variable containing the sum of the squares of all odd positive integers in the array.\n\n### Racket version\n\n#lang racket\n\n(define (double_the_difference lst)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare_one a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare_one))\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 2.5) 2.5 0.001)\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 5 6) 6 0.001)\n    (check-within (candidate 1 \"2,3\") \"2,3\" 0.001)\n    (check-within (candidate \"5,1\" \"6\") \"6\" 0.001)\n    (check-within (candidate \"1\" \"2\") \"2\" 0.001)\n    (check-within (candidate \"1\" 1) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function compare_one(a, b)\n  local temp_a, temp_b = a, b\n  if type(temp_a) == 'string' then temp_a = temp_a:gsub(',', '.') end\n  if type(temp_b) == 'string' then temp_b = temp_b:gsub(',', '.') end\n  if tonumber(temp_a) == tonumber(temp_b) then return nil end\n  return tonumber(temp_a) > tonumber(temp_b) and a or b\nend\n\n### Explanation\n\nThe code is an implementation of a comparison function `compare_one` that takes two arguments `a` and `b` and returns the larger of the two. The function first converts the arguments to numbers if they are strings, and then compares them.\n\nif type(temp_a) == 'string' then temp_a = temp_a:gsub(',', '.') end\nif type(temp_b) == 'string' then temp_b = temp_b:gsub(',', '.') end\nThe function first checks if the arguments are strings. If they are, it replaces any commas with periods to handle decimal numbers.\n\nif tonumber(temp_a) == tonumber(temp_b) then return nil end\nIf the arguments are equal, the function returns `nil`.\n\nreturn tonumber(temp_a) > tonumber(temp_b) and a or b\nOtherwise, the function returns the larger of the two arguments.\n\n### Racket version\n\n#lang racket\n\n(define (compare_one a b)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_zero operations)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_zero))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)\n    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)\n    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function below_zero(operations)\n    local balance = 0\n\n    for _, op in ipairs(operations) do\n        balance = balance + op\n        if balance < 0 then\n            return true\n        end\n    end\n\n    return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `below_zero` which takes an array of numbers representing operations and returns a boolean indicating whether the balance of the operations goes below zero at any point.\n\nlocal balance = 0\nThe function initializes a variable `balance` to 0 to keep track of the balance of the operations.\n\nfor _, op in ipairs(operations) do\n    balance = balance + op\n    if balance < 0 then\n        return true\n    end\nend\nThe function iterates through each operation `op` in the input array `operations`. It adds the operation to the `balance` variable and checks if the `balance` goes below 0. If it does, the function returns `true`.\n\nreturn false\nIf the `balance` never goes below 0, the function returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (below_zero operations)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (greatest_common_divisor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n    (check-within (candidate 3 7) 1 0.001)\n    (check-within (candidate 10 15) 5 0.001)\n    (check-within (candidate 49 14) 7 0.001)\n    (check-within (candidate 144 60) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function greatest_common_divisor(a, b)\n    while b ~= 0 do\n        a, b = b, a % b\n    end\n    return a\nend\n\n### Explanation\n\nThe code is an implementation of finding the greatest common divisor (GCD) of two numbers `a` and `b`. It takes two numbers `a` and `b` as input and returns their GCD.\n\nwhile b ~= 0 do\n    a, b = b, a % b\nend\nThe function uses the Euclidean algorithm to find the GCD. It repeatedly divides `a` by `b` and sets `a` to `b` and `b` to the remainder until `b` is 0. At this point, `a` is the GCD.\n\nreturn a\nFinally, the function returns `a`, which is the GCD of `a` and `b`.\n\n### Racket version\n\n#lang racket\n\n(define (greatest_common_divisor a b)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (f n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate 5) (list 1 2 6 24 15) 0.001)\n    (check-within (candidate 7) (list 1 2 6 24 15 720 28) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n    (check-within (candidate 3) (list 1 2 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function f(n)\n    local ret = {}\n    for i=1,n do\n        if i%2 == 0 then\n            local x = 1\n            for j=1,i do x = x*j end\n            table.insert(ret, x)\n        else\n            local x = 0\n            for j=1,i do x = x+j end\n            table.insert(ret, x)\n        end\n    end\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function `f` that takes a number `n` as input and returns an array of numbers. The function generates the array by iterating through the numbers from 1 to `n` and applying a different formula depending on whether the number is even or odd.\n\nfor i=1,n do\n    if i%2 == 0 then\n        local x = 1\n        for j=1,i do x = x*j end\n        table.insert(ret, x)\n    else\n        local x = 0\n        for j=1,i do x = x+j end\n        table.insert(ret, x)\n    end\nend\nWithin the for-loop, the program checks if the current number `i` is even or odd. If it is even, it calculates the factorial of `i` and appends it to the `ret` array. If it is odd, it calculates the sum of the numbers from 1 to `i` and appends it to the `ret` array.\n\nreturn ret\nFinally, the function returns the `ret` array containing the generated numbers.\n\n### Racket version\n\n#lang racket\n\n(define (f n)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (monotonic l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n    (check-within (candidate (list 1 2 4 10)) #t 0.001)\n    (check-within (candidate (list 1 2 4 20)) #t 0.001)\n    (check-within (candidate (list 1 20 4 10)) #f 0.001)\n    (check-within (candidate (list 4 1 0 -10)) #t 0.001)\n    (check-within (candidate (list 4 1 1 0)) #t 0.001)\n    (check-within (candidate (list 1 2 3 2 5 60)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 60)) #t 0.001)\n    (check-within (candidate (list 9 9 9 9)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function monotonic(l)\n    local is_increasing = true\n    local is_decreasing = true\n\n    for i=2, #l do\n        if l[i] > l[i-1] then\n            is_decreasing = false\n        elseif l[i] < l[i-1] then\n            is_increasing = false\n        end\n    end\n\n    return is_increasing or is_decreasing\nend\n\n### Explanation\n\nThe code is an implementation of a function `monotonic` which takes an array of numbers and returns `true` if the array is monotonic (either non-increasing or non-decreasing) and `false` otherwise.\n\nlocal is_increasing = true\nlocal is_decreasing = true\nThe function initializes two boolean variables `is_increasing` and `is_decreasing` to `true`.\n\nfor i=2, #l do\n    if l[i] < l[i-1] then\n        is_increasing = false\n    end\n    if l[i] > l[i-1] then\n        is_decreasing = false\n    end\nend\nThe function then iterates through the array and checks if each element is greater than or less than the previous element. If an element is less than the previous element, `is_increasing` is set to `false`. If an element is greater than the previous element, `is_decreasing` is set to `false`.\n\nreturn is_increasing or is_decreasing\nFinally, the function returns `true` if either `is_increasing` or `is_decreasing` is `true`, and `false` otherwise.\n\n### Racket version\n\n#lang racket\n\n(define (monotonic l)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (by_length arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate by_length))\n    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\") 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -1 55)) (list \"One\") 0.001)\n    (check-within (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\") 0.001)\n    (check-within (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function by_length(arr)\n    local dic = {\n        [1] = \"One\",\n        [2] = \"Two\",\n        [3] = \"Three\",\n        [4] = \"Four\",\n        [5] = \"Five\",\n        [6] = \"Six\",\n        [7] = \"Seven\",\n        [8] = \"Eight\",\n        [9] = \"Nine\",\n    }\n    table.sort(arr, function(a, b) return a > b end)\n    local new_arr = {}\n    for i, var in ipairs(arr) do\n        if dic[var] then\n            table.insert(new_arr, dic[var])\n        end\n    end\n    return new_arr\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers by their length. It takes an array of numbers `arr` as input and returns a sorted array of strings.\n\nlocal dic = {\n    [1] = \"One\",\n    [2] = \"Two\",\n    [3] = \"Three\",\n    [4] = \"Four\",\n    [5] = \"Five\",\n    [6] = \"Six\",\n    [7] = \"Seven\",\n    [8] = \"Eight\",\n    [9] = \"Nine\",\n}\nThe function first creates a dictionary `dic` where the keys are the numbers 1 to 9 and the values are their corresponding string representation.\n\ntable.sort(arr, function(a, b) return a > b end)\nThe function then sorts the input array in descending order.\n\nfor i, var in ipairs(arr) do\n    if dic[var] then\n        table.insert(new_arr, dic[var])\n    end\nend\nFinally, the function iterates through the sorted array and appends the corresponding string representation of each number to a new array `new_arr`. If the number is not in the dictionary, it is skipped.\n\nreturn new_arr\nThe function returns the sorted array of strings.\n\n### Racket version\n\n#lang racket\n\n(define (by_length arr)\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (remove_vowels text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_vowels))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"abcdef\nghijklm\") \"bcdf\nghjklm\" 0.001)\n    (check-within (candidate \"fedcba\") \"fdcb\" 0.001)\n    (check-within (candidate \"eeeee\") \"\" 0.001)\n    (check-within (candidate \"acBAA\") \"cB\" 0.001)\n    (check-within (candidate \"EcBOO\") \"cB\" 0.001)\n    (check-within (candidate \"ybcd\") \"ybcd\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function remove_vowels(text)\n    return text:gsub(\"[aeiouAEIOU]\", \"\")\nend\n\n### Explanation\n\nThe code is an implementation of removing vowels from a string. It takes a string `text` as input and returns a new string with all vowels removed.\n\nreturn text:gsub(\"[aeiouAEIOU]\", \"\")\nThe function uses the `gsub` function to replace all vowels in the input string with an empty string. The pattern `[aeiouAEIOU]` matches all vowels (both upper and lower case) in the string.\n\n### Racket version\n\n#lang racket\n\n(define (remove_vowels text)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n    (check-within (candidate \"apple\") #f 0.001)\n    (check-within (candidate \"apple pi e\") #t 0.001)\n    (check-within (candidate \"eeeee\") #f 0.001)\n    (check-within (candidate \"A\") #t 0.001)\n    (check-within (candidate \"Pumpkin pie \") #f 0.001)\n    (check-within (candidate \"Pumpkin pie 1\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"eeeee e \") #f 0.001)\n    (check-within (candidate \"apple pie\") #f 0.001)\n    (check-within (candidate \"apple pi e \") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function check_if_last_char_is_a_letter(txt)\n    local check = txt:match(\"%a%a*$\")\n    return check ~= nil and #check == 1\nend\n\n### Explanation\n\nThe code is an implementation of a function `check_if_last_char_is_a_letter` which takes a string and returns a boolean indicating whether the last character of the string is a letter.\n\nlocal check = txt:match(\"%a%a*$\")\nThe function uses a regular expression to match the last letter in the string. `%a` matches any letter and `$` matches the end of the string. `%a*$` matches any sequence of letters at the end of the string.\n\nreturn check ~= nil and #check == 1\nIf a match is found, the function returns `true` if the length of the match is 1, indicating that there is only one letter at the end of the string. Otherwise, it returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (iscube a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate iscube))\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate -1) #t 0.001)\n    (check-within (candidate 64) #t 0.001)\n    (check-within (candidate 180) #f 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 0) #t 0.001)\n    (check-within (candidate 1729) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function iscube(a)\n    a = math.abs(a)\n    return math.floor(a^(1/3) + 0.5)^3 == a\nend\n\n### Explanation\n\nThe code is an implementation of a function `iscube` which takes a number `a` and returns `true` if it is a perfect cube and `false` otherwise.\n\na = math.abs(a)\nThe function first takes the absolute value of the input number `a`.\n\nmath.floor(a^(1/3) + 0.5)^3 == a\nIt then calculates the cube root of `a` using the formula `a^(1/3)`, rounds it to the nearest integer using `math.floor(a^(1/3) + 0.5)`, and cubes it using the exponent operator `^3`. If the result is equal to the original number `a`, then `a` is a perfect cube and the function returns `true`. Otherwise, the function returns `false`.\n\n### Racket version\n\n#lang racket\n\n(define (iscube a)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (mean_absolute_deviation numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mean_absolute_deviation))\n    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function mean_absolute_deviation(numbers)\n    local mean = 0\n    for _, v in ipairs(numbers) do\n        mean = mean + v\n    end\n    mean = mean / #numbers\n    local sum = 0\n    for _, v in ipairs(numbers) do\n        sum = sum + math.abs(v - mean)\n    end\n    return sum / #numbers\nend\n\n### Explanation\n\nThe code is an implementation of calculating the mean absolute deviation of a list of numbers. It takes a list of numbers `numbers` as input and returns a number.\n\nlocal mean = 0\nfor _, v in ipairs(numbers) do\n    mean = mean + v\nend\nmean = mean / #numbers\nThe function first calculates the mean of the input list of numbers.\n\nlocal sum = 0\nfor _, v in ipairs(numbers) do\n    sum = sum + math.abs(v - mean)\nend\nIt then calculates the sum of the absolute differences between each number and the mean.\n\nreturn sum / #numbers\nFinally, the function returns the mean of the absolute differences.\n\n### Racket version\n\n#lang racket\n\n(define (mean_absolute_deviation numbers)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"<>\") #t 0.001)\n    (check-within (candidate \"<<><>>\") #t 0.001)\n    (check-within (candidate \"<><><<><>><>\") #t 0.001)\n    (check-within (candidate \"<><><<<><><>><>><<><><<>>>\") #t 0.001)\n    (check-within (candidate \"<<<><>>>>\") #f 0.001)\n    (check-within (candidate \"><<>\") #f 0.001)\n    (check-within (candidate \"<\") #f 0.001)\n    (check-within (candidate \"<<<<\") #f 0.001)\n    (check-within (candidate \">\") #f 0.001)\n    (check-within (candidate \"<<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>><<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>>><>\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for b in brackets:gmatch(\".\") do\n        if b == \"<\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThe code is an implementation of checking whether a string of brackets is correctly balanced. It takes a string of brackets `brackets` as input and returns a boolean.\n\nlocal depth = 0\nThe function initializes a variable `depth` to 0 to keep track of the depth of the current bracket.\n\nfor b in brackets:gmatch(\".\") do\n    if b == \"<\" then\n        depth = depth + 1\n    else\n        depth = depth - 1\n    end\n    if depth < 0 then\n        return false\n    end\nend\nThe function iterates through each character `b` in the input string `brackets`. If the character is an opening bracket `'<'`, the function increments the `depth` variable. If the character is a closing bracket `'>'`, the function decrements the `depth` variable. If the `depth` variable becomes negative, it means that there are more closing brackets than opening brackets, so the function returns false.\n\nreturn depth == 0\nFinally, the function checks if the `depth` variable is 0, which means that the number of opening brackets is equal to the number of closing brackets, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rescale_to_unit numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)\n    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)\n    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function rescale_to_unit(numbers)\n    local min_number = math.min(table.unpack(numbers))\n    local max_number = math.max(table.unpack(numbers))\n    local result = {}\n    for i, x in ipairs(numbers) do\n        result[i] = (x - min_number) / (max_number - min_number)\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of rescaling an array of numbers to the unit interval [0, 1]. It takes an array of numbers `numbers` as input and returns a rescaled array of numbers.\n\nlocal min_number = math.min(table.unpack(numbers))\nlocal max_number = math.max(table.unpack(numbers))\nThe function first finds the minimum and maximum values in the input array.\n\nfor i, x in ipairs(numbers) do\n    result[i] = (x - min_number) / (max_number - min_number)\nend\nThe function then iterates through each number in the input array and rescales it to the unit interval using the formula `(x - min_number) / (max_number - min_number)`. The rescaled number is then added to the `result` array.\n\nreturn result\nFinally, the function returns the `result` array containing the rescaled numbers.\n\n### Racket version\n\n#lang racket\n\n(define (rescale_to_unit numbers)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersection interval1 interval2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersection))\n    (check-within (candidate (list 1 2) (list 2 3)) \"NO\" 0.001)\n    (check-within (candidate (list -1 1) (list 0 4)) \"NO\" 0.001)\n    (check-within (candidate (list -3 -1) (list -5 5)) \"YES\" 0.001)\n    (check-within (candidate (list -2 2) (list -4 0)) \"YES\" 0.001)\n    (check-within (candidate (list -11 2) (list -1 -1)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 3 5)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 1 2)) \"NO\" 0.001)\n    (check-within (candidate (list -2 -2) (list -3 -2)) \"NO\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function intersection(interval1, interval2)\n    local function is_prime(num)\n        if num == 1 or num == 0 then\n            return false\n        end\n        if num == 2 then\n            return true\n        end\n        for i=2,num-1 do\n            if num%i == 0 then\n                return false\n            end\n        end\n        return true\n    end\n\n    local l = math.max(interval1[1], interval2[1])\n    local r = math.min(interval1[2], interval2[2])\n    local length = r - l\n    if length > 0 and is_prime(length) then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThe code is an implementation of a function `intersection` which takes two intervals as input and returns \"YES\" if the length of the intersection of the two intervals is a prime number, and \"NO\" otherwise.\n\nlocal function is_prime(num)\n    if num == 1 or num == 0 then\n        return false\n    end\n    if num == 2 then\n        return true\n    end\n    for i=2,num-1 do\n        if num%i == 0 then\n            return false\n        end\n    end\n    return true\nend\nThe function first defines a helper function `is_prime` that takes a number and returns `true` if it is a prime number and `false` otherwise.\n\nlocal l = math.max(interval1[1], interval2[1])\nlocal r = math.min(interval1[2], interval2[2])\nThe function then finds the left and right endpoints of the intersection of the two intervals.\n\nlocal length = r - l\nThe function calculates the length of the intersection.\n\nif length > 0 and is_prime(length) then\n    return \"YES\"\nend\nIf the length of the intersection is greater than 0 and is a prime number, the function returns \"YES\".\n\nreturn \"NO\"\nOtherwise, the function returns \"NO\".\n\n### Racket version\n\n#lang racket\n\n(define (intersection interval1 interval2)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (hex_key num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n    (check-within (candidate \"AB\") 1 0.001)\n    (check-within (candidate \"1077E\") 2 0.001)\n    (check-within (candidate \"ABED1A33\") 4 0.001)\n    (check-within (candidate \"2020\") 2 0.001)\n    (check-within (candidate \"123456789ABCDEF0\") 6 0.001)\n    (check-within (candidate \"112233445566778899AABBCCDDEEFF00\") 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function hex_key(num)\n    local primes = {'2', '3', '5', '7', 'B', 'D'}\n    local total = 0\n    for i = 1, #num do\n        if table.concat(primes):find(num:sub(i, i)) then\n            total = total + 1\n        end\n    end\n    return total\nend\n\n### Explanation\n\nThe code is an implementation of a function `hex_key` which takes a hexadecimal number as input and returns a number that represents the \"key\" of the number. The key is calculated by counting the number of prime digits in the hexadecimal number.\n\nlocal primes = {'2', '3', '5', '7', 'B', 'D'}\nThe function first initializes an array `primes` containing the prime digits in hexadecimal.\n\nfor i = 1, #num do\n    if table.concat(primes):find(num:sub(i, i)) then\n        total = total + 1\n    end\nend\nThe function then iterates through each digit in the input hexadecimal number `num`. If the digit is a prime digit, the function increments the `total` variable.\n\nreturn total\nFinally, the function returns the `total` variable, which represents the key of the input hexadecimal number.\n\n### Racket version\n\n#lang racket\n\n(define (hex_key num)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strange_sort_list lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n    (check-within (candidate (list 1 2 3 4)) (list 1 4 2 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7) 0.001)\n    (check-within (candidate (list 5 5 5 5)) (list 5 5 5 5) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5) 0.001)\n    (check-within (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2) 0.001)\n    (check-within (candidate (list 111111)) (list 111111) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function strange_sort_list(lst)\n    local res, switch = {}, true\n    while #lst > 0 do\n        if switch then\n            table.insert(res, math.min(table.unpack(lst)))\n        else\n            table.insert(res, math.max(table.unpack(lst)))\n        end\n        local index = 0\n        for i, v in ipairs(lst) do\n            if v == res[#res] then\n                index = i\n                break\n            end\n        end\n        table.remove(lst, index)\n        switch = not switch\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a function `strange_sort_list` which takes a list of numbers and returns a list sorted in a strange way. The function alternates between selecting the smallest and largest remaining element in the list and appending it to the result list. The function returns the sorted list.\n\nlocal res, switch = {}, true\nThe function initializes an empty array `res` to store the sorted list and a boolean variable `switch` to keep track of whether to select the smallest or largest remaining element.\n\nwhile #lst > 0 do\n    if switch then\n        table.insert(res, math.min(table.unpack(lst)))\n    else\n        table.insert(res, math.max(table.unpack(lst)))\n    end\nThe function enters a while loop that continues until the input list `lst` is empty. Within the loop, the function checks the value of `switch` and selects the smallest or largest remaining element in the list using `math.min` or `math.max`, respectively. The selected element is then appended to the `res` array.\n\nlocal index = 0\nfor i, v in ipairs(lst) do\n    if v == res[#res] then\n        index = i\n        break\n    end\nend\nThe function then finds the index of the selected element in the input list `lst`.\n\ntable.remove(lst, index)\nThe function removes the selected element from the input list `lst`.\n\nswitch = not switch\nFinally, the function toggles the value of `switch` to alternate between selecting the smallest and largest remaining element.\n\nreturn res\nThe function returns the sorted list.\n\n### Racket version\n\n#lang racket\n\n(define (strange_sort_list lst)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (all_prefixes string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate all_prefixes))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"asdfgh\") (list \"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\") 0.001)\n    (check-within (candidate \"WWW\") (list \"W\" \"WW\" \"WWW\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function all_prefixes(string)\n    local result = {}\n\n    for i=1, #string do\n        table.insert(result, string:sub(1, i))\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `all_prefixes` which takes a string and returns an array of all the prefixes of the string.\n\nlocal result = {}\nThe function initializes an empty array `result` to store the prefixes.\n\nfor i=1, #string do\n    table.insert(result, string:sub(1, i))\nend\nThe function iterates through each character in the input string `string` and appends the substring from the beginning of the string to the current index to the `result` array.\n\nreturn result\nFinally, the function returns the `result` array containing all the prefixes of the input string.\n\n### Racket version\n\n#lang racket\n\n(define (all_prefixes string)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (how_many_times string substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n    (check-within (candidate \"\" \"x\") 0 0.001)\n    (check-within (candidate \"xyxyxyx\" \"x\") 4 0.001)\n    (check-within (candidate \"cacacacac\" \"cac\") 4 0.001)\n    (check-within (candidate \"john doe\" \"john\") 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function how_many_times(string, substring)\n  local times = 0\n  for i = 1, #string - #substring + 1 do\n    if string:sub(i, i + #substring - 1) == substring then\n      times = times + 1\n    end\n  end\n  return times\nend\n\n### Explanation\n\nThe code is an implementation of a function `how_many_times` which takes two strings as input: `string` and `substring`, and returns the number of times the `substring` appears in the `string`.\n\nlocal times = 0\nThe function initializes a counter variable `times` to keep track of the number of times the `substring` appears in the `string`.\n\nfor i = 1, #string - #substring + 1 do\n    if string:sub(i, i + #substring - 1) == substring then\n        times = times + 1\n    end\nend\nThe function iterates through each possible starting index `i` of the `substring` in the `string`. For each starting index, it checks if the substring starting from that index is equal to the `substring`. If it is, it increments the `times` counter.\n\nreturn times\nThe function returns the `times` counter.\n\n### Racket version\n\n#lang racket\n\n(define (how_many_times string substring)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solution lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solution))\n    (check-within (candidate (list 5 8 7 1)) 12 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 9 0.001)\n    (check-within (candidate (list 30 13 24 321)) 0 0.001)\n    (check-within (candidate (list 5 9)) 5 0.001)\n    (check-within (candidate (list 2 4 8)) 0 0.001)\n    (check-within (candidate (list 30 13 23 32)) 23 0.001)\n    (check-within (candidate (list 3 13 2 9)) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function solution(lst)\n  local sum = 0\n  for idx, x in ipairs(lst) do\n    if idx%2==1 and x%2==1 then\n      sum = sum + x\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `solution` which takes an array of numbers and returns the sum of the odd-indexed odd numbers.\n\nlocal sum = 0\nThe function initializes a variable `sum` to 0 to store the sum of the odd-indexed odd numbers.\n\nfor idx, x in ipairs(lst) do\n    if idx%2==1 and x%2==1 then\n        sum = sum + x\n    end\nend\nThe function iterates through each element `x` in the input array `lst` along with its index `idx`. If the index is odd and the element is odd, the function adds the element to the `sum` variable.\n\nreturn sum\nFinally, the function returns the `sum` variable containing the sum of the odd-indexed odd numbers.\n\n### Racket version\n\n#lang racket\n\n(define (solution lst)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (search lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate search))\n    (check-within (candidate (list 5 5 5 5 1)) 1 0.001)\n    (check-within (candidate (list 4 1 4 1 4 4)) 4 0.001)\n    (check-within (candidate (list 3 3)) -1 0.001)\n    (check-within (candidate (list 8 8 8 8 8 8 8 8)) 8 0.001)\n    (check-within (candidate (list 2 3 3 2 2)) 2 0.001)\n    (check-within (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1 0.001)\n    (check-within (candidate (list 3 2 8 2)) 2 0.001)\n    (check-within (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1 0.001)\n    (check-within (candidate (list 8 8 3 6 5 6 4)) -1 0.001)\n    (check-within (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1 0.001)\n    (check-within (candidate (list 1 9 10 1 3)) 1 0.001)\n    (check-within (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n    (check-within (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4 0.001)\n    (check-within (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2 0.001)\n    (check-within (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1 0.001)\n    (check-within (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4 0.001)\n    (check-within (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4 0.001)\n    (check-within (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2 0.001)\n    (check-within (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1 0.001)\n    (check-within (candidate (list 10)) -1 0.001)\n    (check-within (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2 0.001)\n    (check-within (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1 0.001)\n    (check-within (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1 0.001)\n    (check-within (candidate (list 3 10 10 9 2)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function search(lst)\n    local frq = {}\n    for i=1, math.max(table.unpack(lst)) do\n        frq[i] = 0\n    end\n    for i=1, #lst do\n        frq[lst[i]] = frq[lst[i]] + 1\n    end\n\n    local ans = -1\n    for i=1, #frq do\n        if frq[i] >= i then\n            ans = i\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of finding the smallest number that appears at least as many times as it appears in the array. The function takes in an array of numbers and returns the smallest number that satisfies the condition.\n\nlocal frq = {}\nfor i=1, math.max(table.unpack(lst)) do\n    frq[i] = 0\nend\nThe function first initializes a table `frq` where the indices are the numbers in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    frq[lst[i]] = frq[lst[i]] + 1\nend\nIt then counts the frequency of each number in the array by incrementing the corresponding element in the `frq` table.\n\nfor i=1, #frq do\n    if frq[i] >= i then\n        ans = i\n    end\nend\nFinally, the function iterates through the `frq` table and returns the smallest number `i` such that the frequency of `i` is greater than or equal to `i`.\n\n### Racket version\n\n#lang racket\n\n(define (search lst)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pluck arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n    (check-within (candidate (list 4 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5 0 3 0 4 2)) (list 0 1) 0.001)\n    (check-within (candidate (list 1 2 3 0 5 3)) (list 0 3) 0.001)\n    (check-within (candidate (list 5 4 8 4 8)) (list 4 1) 0.001)\n    (check-within (candidate (list 7 6 7 1)) (list 6 1) 0.001)\n    (check-within (candidate (list 7 9 7 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function pluck(arr)\n    if(#arr == 0) then return {} end\n    local evens = {}\n    for _, v in ipairs(arr) do\n        if(v%2 == 0) then table.insert(evens, v) end\n    end\n    if(#evens == 0) then return {} end\n    local min_val = math.min(table.unpack(evens))\n    for i, v in ipairs(arr) do\n        if(v == min_val) then return {min_val, i-1} end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `pluck` which takes an array of integers and returns the minimum even integer and its index in the array.\n\nif(#arr == 0) then return {} end\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nlocal evens = {}\nfor _, v in ipairs(arr) do\n    if(v%2 == 0) then table.insert(evens, v) end\nend\nThe function then creates an empty array `evens` to store all even integers in the input array. It then iterates through each element `v` in the input array and appends it to the `evens` array if it is even.\n\nif(#evens == 0) then return {} end\nIf there are no even integers in the input array, the function returns an empty array.\n\nlocal min_val = math.min(table.unpack(evens))\nThe function then finds the minimum even integer in the `evens` array using the `math.min` function.\n\nfor i, v in ipairs(arr) do\n    if(v == min_val) then return {min_val, i-1} end\nend\nFinally, the function iterates through the input array and returns a table containing the minimum even integer and its index in the input array.\n\n### Racket version\n\n#lang racket\n\n(define (pluck arr)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pairs_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 30)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 31)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 30)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 31)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function pairs_sum_to_zero(l)\n  for i, l1 in ipairs(l) do\n    for j = i + 1, #l do\n      if l1 + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `pairs_sum_to_zero` which takes an array of integers and returns true if there are any two distinct elements in the array that sum to zero, and false otherwise.\n\nfor i, l1 in ipairs(l) do\n    for j = i + 1, #l do\n        if l1 + l[j] == 0 then\n            return true\n        end\n    end\nend\nThe function iterates through each element `l1` in the input array `l`, and for each element, it iterates through the remaining elements in the array to check if there is any element `l2` such that `l1 + l2 = 0`. If such a pair is found, the function returns true.\n\nreturn false\nIf no such pair is found, the function returns false.\n\n### Racket version\n\n#lang racket\n\n(define (pairs_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_palindrome string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"xyz\") \"xyzyx\" 0.001)\n    (check-within (candidate \"xyx\") \"xyx\" 0.001)\n    (check-within (candidate \"jerry\") \"jerryrrej\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function make_palindrome(string)\n    if not string then\n        return ''\n    end\n\n    local beginning_of_suffix = 0\n\n    while string:sub(beginning_of_suffix+1) ~= string:sub(beginning_of_suffix+1):reverse() do\n        beginning_of_suffix = beginning_of_suffix + 1\n    end\n\n    return string .. string:sub(1, beginning_of_suffix):reverse()\nend\n\n### Explanation\n\nThe code is an implementation of making a palindrome from a string. It takes a string `string` as input and returns a palindrome string.\n\nif not string then\n    return ''\nThe function first checks if the input string is empty. If it is, it returns an empty string.\n\nwhile string:sub(beginning_of_suffix+1) ~= string:sub(beginning_of_suffix+1):reverse() do\n    beginning_of_suffix = beginning_of_suffix + 1\nend\nOtherwise, the function finds the longest suffix of the input string that is also a palindrome. It does this by iterating through the string, starting from the beginning, and checking if the suffix starting from the current index is a palindrome. If it is not, it increments the `beginning_of_suffix` variable and tries again.\n\nreturn string .. string:sub(1, beginning_of_suffix):reverse()\nFinally, the function returns the input string concatenated with the reverse of the substring from the beginning of the string to the end of the longest palindrome suffix.\n\n### Racket version\n\n#lang racket\n\n(define (make_palindrome string)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (starts_one_ends n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 2) 18 0.001)\n    (check-within (candidate 3) 180 0.001)\n    (check-within (candidate 4) 1800 0.001)\n    (check-within (candidate 5) 18000 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function starts_one_ends(n)\n  if n == 1 then return 1 end\n  return 18 * (10 ^ (n - 2))\nend\n\n### Explanation\n\nThe code is an implementation of a function `starts_one_ends` which takes an integer `n` and returns the number of integers between 1 and 10^n that start with 1 and end with 1.\n\nif n == 1 then return 1 end\nThe function first checks if `n` is 1. If it is, it returns 1 since there is only one number between 1 and 10^1 that starts and ends with 1.\n\nreturn 18 * (10 ^ (n - 2))\nOtherwise, the function returns the number of integers between 1 and 10^n that start with 1 and end with 1. This is calculated by multiplying 18 (the number of digits that can be in between the first and last digits) by 10^(n-2) (the number of possible digits in between the first and last digits).\n\n### Racket version\n\n#lang racket\n\n(define (starts_one_ends n)\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_positive l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)\n    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)\n    (check-within (candidate (list -1 -2)) (list ) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function get_positive(l)\n  local res = {}\n  for _, e in ipairs(l) do\n    if e > 0 then\n      table.insert(res, e)\n    end\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function `get_positive` which takes an array of numbers and returns an array of only the positive numbers.\n\nlocal res = {}\nThe function initializes an empty array `res` to store the positive numbers.\n\nfor _, e in ipairs(l) do\n    if e > 0 then\n        table.insert(res, e)\n    end\nend\nThe function iterates through each element `e` in the input array `l`. If the element is positive, it appends the element to the `res` array.\n\nreturn res\nThe function returns the `res` array containing the positive numbers.\n\n### Racket version\n\n#lang racket\n\n(define (get_positive l)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (concatenate strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate concatenate))\n    (check-within (candidate (list )) \"\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"xyz\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\" \"w\" \"k\")) \"xyzwk\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function concatenate(strings)\n  return table.concat(strings)\nend\n\n### Explanation\n\nThe code is an implementation of a function `concatenate` which takes an array of strings and returns a single string that is the concatenation of all the strings in the array.\n\nreturn table.concat(strings)\nThe function simply returns the result of calling `table.concat` on the input array `strings`.\n\n### Racket version\n\n#lang racket\n\n(define (concatenate strings)\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_nested string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n    (check-within (candidate \"[[]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]][[[[[]\") #f 0.001)\n    (check-within (candidate \"[][]\") #f 0.001)\n    (check-within (candidate \"[]\") #f 0.001)\n    (check-within (candidate \"[[[[]]]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]]]]]\") #f 0.001)\n    (check-within (candidate \"[][][[]]\") #t 0.001)\n    (check-within (candidate \"[[]\") #f 0.001)\n    (check-within (candidate \"[]]\") #f 0.001)\n    (check-within (candidate \"[[]][[\") #t 0.001)\n    (check-within (candidate \"[[][]]\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"[[[[[[[[\") #f 0.001)\n    (check-within (candidate \"]]]]]]]]\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function is_nested(string)\n    local opening_bracket_index = {}\n    local closing_bracket_index = {}\n    for i=1, #string do\n        if string:sub(i,i) == '[' then\n            table.insert(opening_bracket_index, i)\n        else\n            table.insert(closing_bracket_index, i)\n        end\n    end\n    table.sort(closing_bracket_index, function(a,b) return a>b end)\n    local cnt = 0\n    local i = 1\n    local l = #closing_bracket_index\n    for _, idx in ipairs(opening_bracket_index) do\n        if i <= l and idx < closing_bracket_index[i] then\n            cnt = cnt + 1\n            i = i + 1\n        end\n    end\n    return cnt >= 2\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_nested` which takes a string of square brackets and returns a boolean indicating whether the string contains at least two nested square brackets.\n\nlocal opening_bracket_index = {}\nlocal closing_bracket_index = {}\nThe function initializes two empty arrays `opening_bracket_index` and `closing_bracket_index` to store the indices of opening and closing brackets in the input string.\n\nfor i=1, #string do\n    if string:sub(i,i) == '[' then\n        table.insert(opening_bracket_index, i)\n    else\n        table.insert(closing_bracket_index, i)\n    end\nend\nThe function iterates through each character in the input string, and appends the index of opening brackets to `opening_bracket_index` and the index of closing brackets to `closing_bracket_index`.\n\ntable.sort(closing_bracket_index, function(a,b) return a>b end)\nThe function then sorts the `closing_bracket_index` array in descending order.\n\nfor _, idx in ipairs(opening_bracket_index) do\n    if i <= l and idx < closing_bracket_index[i] then\n        cnt = cnt + 1\n        i = i + 1\n    end\nend\nThe function then iterates through each index in `opening_bracket_index`, and checks if there is a corresponding closing bracket that appears after the opening bracket. If there are at least two such pairs of brackets, the function returns `true`. Otherwise, it returns `false`.\n\nreturn cnt >= 2\nThe function returns a boolean indicating whether there are at least two nested square brackets in the input string.\n\n### Racket version\n\n#lang racket\n\n(define (is_nested string)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_palindrome text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n    (check-within (candidate \"\") #t 0.001)\n    (check-within (candidate \"aba\") #t 0.001)\n    (check-within (candidate \"aaaaa\") #t 0.001)\n    (check-within (candidate \"zbcd\") #f 0.001)\n    (check-within (candidate \"xywyx\") #t 0.001)\n    (check-within (candidate \"xywyz\") #f 0.001)\n    (check-within (candidate \"xywzx\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function is_palindrome(text)\n    for i=1, #text do\n        if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether a string is a palindrome. It takes a string `text` as input and returns a boolean.\n\nfor i=1, #text do\n    if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n        return false\n    end\nend\nThe function iterates through each character in the string `text`. It checks if the character at position `i` is equal to the character at position `#text - i + 1` (i.e. the corresponding character on the other end of the string). If any pair of characters is not equal, the function returns `false`.\n\nreturn true\nIf all pairs of characters are equal, the function returns `true`.\n\n### Racket version\n\n#lang racket\n\n(define (is_palindrome text)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (factorize n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate factorize))\n    (check-within (candidate 2) (list 2) 0.001)\n    (check-within (candidate 4) (list 2 2) 0.001)\n    (check-within (candidate 8) (list 2 2 2) 0.001)\n    (check-within (candidate 57) (list 3 19) 0.001)\n    (check-within (candidate 3249) (list 3 3 19 19) 0.001)\n    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)\n    (check-within (candidate 20577) (list 3 19 19 19) 0.001)\n    (check-within (candidate 18) (list 2 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function factorize(n)\n    local fact = {}\n    local i = 2\n    while i <= math.sqrt(n) + 1 do\n        if n % i == 0 then\n            table.insert(fact, i)\n            n = n / i\n        else\n            i = i + 1\n        end\n    end\n    if n > 1 then\n        table.insert(fact, n)\n    end\n    return fact\nend\n\n### Explanation\n\nThe code is an implementation of factorizing a number `n` into its prime factors. It takes a number `n` as input and returns an array of prime factors.\n\nlocal fact = {}\nThe function initializes an empty array `fact` to store the prime factors.\n\nwhile i <= math.sqrt(n) + 1 do\n    if n % i == 0 then\n        table.insert(fact, i)\n        n = n / i\n    else\n        i = i + 1\n    end\nend\nThe function uses a while loop to iterate through all possible factors of `n`. It starts with `i=2` and checks if `n` is divisible by `i`. If it is, it appends `i` to the `fact` array and divides `n` by `i`. If `n` is not divisible by `i`, it increments `i` by 1 and continues the loop.\n\nif n > 1 then\n    table.insert(fact, n)\nend\nIf `n` is still greater than 1 after the loop, it means that `n` itself is a prime factor, so it is appended to the `fact` array.\n\nreturn fact\nFinally, the function returns the `fact` array containing the prime factors of `n`.\n\n### Racket version\n\n#lang racket\n\n(define (factorize n)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_prime_factor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n    (check-within (candidate 15) 5 0.001)\n    (check-within (candidate 27) 3 0.001)\n    (check-within (candidate 63) 7 0.001)\n    (check-within (candidate 330) 11 0.001)\n    (check-within (candidate 13195) 29 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function largest_prime_factor(n)\n  local function is_prime(k)\n    if k < 2 then\n      return false\n    end\n    for i = 2, k - 1 do\n      if k % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local largest = 1\n  for j = 2, n + 1 do\n    if n % j == 0 and is_prime(j) then\n      largest = math.max(largest, j)\n    end\n  end\n  return largest\nend\n\n### Explanation\n\nThe code is an implementation of finding the largest prime factor of a given number `n`. It takes a number `n` as input and returns the largest prime factor of `n`.\n\nlocal function is_prime(k)\n    if k < 2 then\n      return false\n    end\n    for i = 2, k - 1 do\n      if k % i == 0 then\n        return false\n      end\n    end\n    return true\nend\nThe function first defines a helper function `is_prime` that takes a number and returns `true` if it is a prime number and `false` otherwise. This is done by checking if the number is less than 2 (which is not prime), and then checking if it is divisible by any number between 2 and `k-1`.\n\nlocal largest = 1\nThe variable `largest` is initialized to 1 to keep track of the largest prime factor.\n\nfor j = 2, n + 1 do\n    if n % j == 0 and is_prime(j) then\n        largest = math.max(largest, j)\n    end\nend\nThe function then loops through all numbers between 2 and `n+1`, and checks if each number is a factor of `n` and prime. If it is, the function updates the `largest` variable to the maximum of its current value and the current number.\n\nreturn largest\nFinally, the function returns the `largest` variable, which contains the largest prime factor of `n`.\n\n### Racket version\n\n#lang racket\n\n(define (largest_prime_factor n)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_max_triples n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 10) 36 0.001)\n    (check-within (candidate 100) 53361 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function get_max_triples(n)\n  local A = {}\n  for i=1,n do\n    A[i] = i*i - i + 1\n  end\n  local ans = {}\n  for i=1,n do\n    for j=i+1,n do\n      for k=j+1,n do\n        if (A[i]+A[j]+A[k])%3 == 0 then\n          table.insert(ans, {A[i],A[j],A[k]})\n        end\n      end\n    end\n  end\n  return #ans\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of triples of integers `(i, j, k)` such that `i < j < k` and `(i^2 - i + 1) + (j^2 - j + 1) + (k^2 - k + 1)` is divisible by 3. It takes a number `n` as input and returns the number of such triples.\n\nlocal A = {}\nfor i=1,n do\n    A[i] = i*i - i + 1\nend\nThe function first creates an array `A` of length `n` where the `i`th element is `i^2 - i + 1`.\n\nlocal ans = {}\nfor i=1,n do\n    for j=i+1,n do\n        for k=j+1,n do\n            if (A[i]+A[j]+A[k])%3 == 0 then\n                table.insert(ans, {A[i],A[j],A[k]})\n            end\n        end\n    end\nend\nThe function then loops through all possible triples `(i, j, k)` such that `i < j < k`. It checks if the sum of the corresponding elements in `A` is divisible by 3. If it is, it appends the triple to the `ans` array.\n\nreturn #ans\nFinally, the function returns the length of the `ans` array, which is the number of such triples.\n\n### Racket version\n\n#lang racket\n\n(define (get_max_triples n)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (anti_shuffle s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate anti_shuffle))\n    (check-within (candidate \"Hi\") \"Hi\" 0.001)\n    (check-within (candidate \"hello\") \"ehllo\" 0.001)\n    (check-within (candidate \"number\") \"bemnru\" 0.001)\n    (check-within (candidate \"abcd\") \"abcd\" 0.001)\n    (check-within (candidate \"Hello World!!!\") \"Hello !!!Wdlor\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst .Rboot How aer ?ouy\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function anti_shuffle(s)\n    local t = {}\n    for i in s:gmatch('%S+') do\n        local u = {}\n        for j = 1, #i do\n            u[j] = i:sub(j, j)\n        end\n        table.sort(u)\n        t[#t + 1] = table.concat(u)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of a function `anti_shuffle` which takes a string `s` and returns a string where each word is sorted in alphabetical order.\n\nlocal t = {}\nThe function initializes an empty array `t` to store the sorted words.\n\nfor i in s:gmatch('%S+') do\n    local u = {}\n    for j = 1, #i do\n        u[j] = i:sub(j, j)\n        end\n    table.sort(u)\n    t[#t + 1] = table.concat(u)\nend\nThe function iterates through each word `i` in the input string `s`. For each word, it initializes an empty array `u` to store the characters of the word. It then sorts the characters in alphabetical order using `table.sort(u)` and concatenates them into a string using `table.concat(u)`. The sorted word is then appended to the `t` array.\n\nreturn table.concat(t, ' ')\nFinally, the function concatenates the sorted words in the `t` array into a string separated by a space using `table.concat(t, ' ')` and returns the resulting string.\n\n### Racket version\n\n#lang racket\n\n(define (anti_shuffle s)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minPath grid k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minPath))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)\n    (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)\n    (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)\n    (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)\n    (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)\n    (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)\n    (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function minPath(grid, k)\n    local n = #grid\n    local val = n * n + 1\n    for i = 1, n do\n        for j = 1, n do\n            if grid[i][j] == 1 then\n                local temp = {}\n                if i ~= 1 then\n                    table.insert(temp, grid[i-1][j])\n                end\n\n                if j ~= 1 then\n                    table.insert(temp, grid[i][j-1])\n                end\n\n                if i ~= n then\n                    table.insert(temp, grid[i+1][j])\n                end\n\n                if j ~= n then\n                    table.insert(temp, grid[i][j+1])\n                end\n\n                val = math.min(table.unpack(temp))\n            end\n        end\n    end\n\n    local ans = {}\n    for i = 1, k do\n        if i % 2 == 1 then\n            table.insert(ans, 1)\n        else\n            table.insert(ans, val)\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function `minPath` that takes a 2D array `grid` and an integer `k` as input, and returns an array of `k` integers. The function first finds the minimum value of the neighboring cells of all cells with value 1 in the `grid`. It then returns an array of `k` integers where the odd-indexed elements are 1 and the even-indexed elements are the minimum value found.\n\nlocal n = #grid\nlocal val = n * n + 1\nThe function first initializes the variable `n` to the size of the `grid`. It also initializes the variable `val` to a large number.\n\nfor i = 1, n do\n    for j = 1, n do\n        if grid[i][j] == 1 then\n            ...\n        end\n    end\nend\nThe function then loops through each cell in the `grid` and checks if the cell has a value of 1.\n\nlocal temp = {}\nif i ~= 1 then\n    table.insert(temp, grid[i-1][j])\nend\n\nif j ~= 1 then\n    table.insert(temp, grid[i][j-1])\nend\n\nif i ~= n then\n    table.insert(temp, grid[i+1][j])\nend\n\nif j ~= n then\n    table.insert(temp, grid[i][j+1])\nend\nIf the cell has a value of 1, the function creates an empty array `temp` and adds the neighboring cells to `temp`. The neighboring cells are added to `temp` only if they are within the bounds of the `grid`.\n\nval = math.min(table.unpack(temp))\nThe function then finds the minimum value in `temp` and sets `val` to that value.\n\nfor i = 1, k do\n    if i % 2 == 1 then\n        table.insert(ans, 1)\n    else\n        table.insert(ans, val)\n    end\nend\nFinally, the function creates an empty array `ans` and loops through `k` times. If the index is odd, the function appends 1 to `ans`. If the index is even, the function appends `val` to `ans`. The function then returns `ans`.\n\n### Racket version\n\n#lang racket\n\n(define (minPath grid k)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encrypt s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n    (check-within (candidate \"hi\") \"lm\" 0.001)\n    (check-within (candidate \"asdfghjkl\") \"ewhjklnop\" 0.001)\n    (check-within (candidate \"gf\") \"kj\" 0.001)\n    (check-within (candidate \"et\") \"ix\" 0.001)\n    (check-within (candidate \"faewfawefaewg\") \"jeiajeaijeiak\" 0.001)\n    (check-within (candidate \"hellomyfriend\") \"lippsqcjvmirh\" 0.001)\n    (check-within (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" 0.001)\n    (check-within (candidate \"a\") \"e\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function encrypt(s)\n    local d = 'abcdefghijklmnopqrstuvwxyz'\n    local out = ''\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if d:find(c) then\n            out = out .. d:sub((d:find(c) + 2*2 - 1) % 26 + 1, (d:find(c) + 2*2 - 1) % 26 + 1)\n        else\n            out = out .. c\n        end\n    end\n    return out\nend\n\n### Explanation\n\nThe code is an implementation of a simple encryption function that takes a string `s` as input and returns an encrypted string. The encryption algorithm is a simple Caesar cipher with a shift of 4.\n\nlocal d = 'abcdefghijklmnopqrstuvwxyz'\nThe function first initializes a string `d` containing the lowercase English alphabet.\n\nfor i = 1, #s do\n    local c = s:sub(i, i)\nThe function iterates through each character `c` in the input string `s`.\n\nif d:find(c) then\n    out = out .. d:sub((d:find(c) + 2*2 - 1) % 26 + 1, (d:find(c) + 2*2 - 1) % 26 + 1)\nIf the character is a lowercase letter, the function finds its index in the `d` string using the `find` function. It then applies the Caesar cipher by adding 4 to the index (equivalent to a shift of 4), wrapping around to the beginning of the alphabet if necessary using the modulo operator `%`, and then extracting the corresponding character from the `d` string using the `sub` function. The resulting character is appended to the `out` string.\n\nelse\n    out = out .. c\nIf the character is not a lowercase letter, it is simply appended to the `out` string.\n\nreturn out\nFinally, the function returns the encrypted string.\n\n### Racket version\n\n#lang racket\n\n(define (encrypt s)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_a_pile n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_a_pile))\n    (check-within (candidate 3) (list 3 5 7) 0.001)\n    (check-within (candidate 4) (list 4 6 8 10) 0.001)\n    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)\n    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)\n    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function make_a_pile(n)\n  local pile = {}\n  for i = 0, n-1 do\n    pile[i+1] = n + 2*i\n  end\n  return pile\nend\n\n### Explanation\n\nThe code is an implementation of creating a pile of stones for a game. It takes an integer `n` as input and returns an array of integers representing the pile of stones.\n\nlocal pile = {}\nThe function initializes an empty array `pile` to store the pile of stones.\n\nfor i = 0, n-1 do\n    pile[i+1] = n + 2*i\nend\nThe function then iterates from 0 to `n-1` and assigns the value `n + 2*i` to the `i+1`th element of the `pile` array.\n\nreturn pile\nFinally, the function returns the `pile` array.\n\n### Racket version\n\n#lang racket\n\n(define (make_a_pile n)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_prime n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 101) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 13441) #t 0.001)\n    (check-within (candidate 61) #t 0.001)\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 1) #f 0.001)\n    (check-within (candidate 5) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 17) #t 0.001)\n    (check-within (candidate 85) #f 0.001)\n    (check-within (candidate 77) #f 0.001)\n    (check-within (candidate 255379) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of finding the number of even and odd palindrome numbers between 1 and `n` (inclusive). It takes a number `n` as input and returns a table of two number: even and odd palindrome number counts. A palindrome is a number that reads the same forwards and backwards.\n\nlocal function is_palindrome(n)\n    return tostring(n) == string.reverse(tostring(n))\nend\nThe function first defines a helper function `is_palindrome` that takes a number and returns `true` if it is a palindrome and `false` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nlocal even_palindrome_count = 0\nlocal odd_palindrome_count = 0\nThe counter variable `even_palindrome_count` and `odd_palindrome_count` are used to record the result.\n\nfor i=1, n do\n    ...\nend\nThe loops goes through all numbers between 1 and `n` (inclusive)\n\nif i%2 == 1 and is_palindrome(i) then\n    odd_palindrome_count = odd_palindrome_count + 1\nelseif i%2 == 0 and is_palindrome(i) then\n    even_palindrome_count = even_palindrome_count + 1\nend\nWithin the for-loop, the program checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nreturn {even_palindrome_count, odd_palindrome_count}\nFinally, the function returns a table of the two counters.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of checking whether an array is sorted in non-descending order and has no more than two occurrences of any number. The function takes in an array of numbers and returns a boolean.\n\nlocal count_digit = {}\nfor i=1, #lst do\n    count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\nend\nThe function first creates a table where the indices are the number in the array and the elements are the number of times that number appears in the array.\n\nfor i=1, #lst do\n    if count_digit[lst[i]] > 2 then\n        return false\n    end\nend\nIt then checks if any number appears more than twice in the array, and returns false if so.\n\nfor i=2, #lst do\n    if lst[i-1] > lst[i] then\n        return false\n    end\nend\nreturn true\nFinally, it checks if the array is sorted in non-descending order, and returns true if so, and false otherwise.\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `separate_paren_groups` which takes a string of parentheses and returns an array of strings containing the groups of parentheses.\n\nlocal result = {}\nlocal current_string = {}\nlocal current_depth = 0\nThe function initializes an empty array `result` to store the groups of parentheses. It also initializes an empty array `current_string` to store the current group of parentheses being processed. The variable `current_depth` is initialized to 0 to keep track of the depth of the current group of parentheses.\n\nfor i=1, #paren_string do\n    local c = paren_string:sub(i, i)\nThe function iterates through each character `c` in the input string `paren_string`.\n\nif c == '(' then\n    current_depth = current_depth + 1\n    table.insert(current_string, c)\nIf the character is an opening parenthesis `'('`, the function increments the `current_depth` variable and appends the character to the `current_string` array.\n\nelseif c == ')' then\n    current_depth = current_depth - 1\n    table.insert(current_string, c)\n    ...\nend\nIf the character is a closing parenthesis `')'`, the function decrements the `current_depth` variable and appends the character to the `current_string` array.\n\nif current_depth == 0 then\n    table.insert(result, table.concat(current_string))\n    current_string = {}\nend\nIf the `current_depth` variable reaches 0, it means that the current group of parentheses has been fully processed, so the function concats the `current_string` array into a string and inserts it to the `result` array. The `current_string` array is then initialized to an empty array to start processing the next group of parentheses.\n\nreturn result\nThe function returns the `result` array containing the groups of parentheses.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of sorting an array of numbers. It takes an array of numbers `array` as input and returns a sorted array of numbers.\n\nif #array == 0 then\n    return {}\nThe function first checks if the input array is empty. If it is, it returns an empty array.\n\nif (array[1] + array[#array]) % 2 == 0 then\n    table.sort(array, function(a, b) return a > b end)\nelse\n    table.sort(array)\nend\nOtherwise, the program sorts the array in order: if the sum of the first and the last element of the array is even, the array will be sorted in descending order. Otherwise, the array will be sorted in ascending order.\n\nreturn array\nFinally, the program returns the sorted array (if the input array is not empty)\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Lua version\n\nmath = require('math')\nlocal function is_prime(n)\n    if n < 2 then\n        return false\n    end\n    for k=2, n-1 do\n        if n % k == 0 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_prime` which takes a number `n` as input and returns `true` if it is a prime number and `false` otherwise.\n\nif n < 2 then\n    return false\nThe function first checks if the input number is less than 2. If it is, it returns `false` since 1 is not a prime number.\n\nfor k=2, n-1 do\n    if n % k == 0 then\n        return false\n    end\nend\nThe function then iterates through all numbers between 2 and `n-1` (inclusive) and checks if `n` is divisible by any of them. If `n` is divisible by any number between 2 and `n-1`, it means that `n` is not a prime number, so the function returns `false`.\n\nreturn true\nIf the function has not returned `false` by this point, it means that `n` is not divisible by any number between 2 and `n-1`, so it must be a prime number. The function returns `true`.\n\n### Racket version\n\n#lang racket\n\n(define (is_prime n)\n"
  }
]