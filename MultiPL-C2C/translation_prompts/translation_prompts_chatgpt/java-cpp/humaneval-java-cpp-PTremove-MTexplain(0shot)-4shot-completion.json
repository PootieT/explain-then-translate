[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool correct_bracketing(std::string brackets) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean correctBracketing(String brackets) {\n        int depth = 0;\n        for (char b : brackets.toCharArray()) {\n            if (b == '(') {\n                depth++;\n            } else {\n                depth--;\n            }\n            if (depth < 0) {\n                return false;\n            }\n        }\n        return depth == 0;\n    }\n}\n\n### Explanation\n\nThis program checks if a string of brackets is correctly balanced. If the brackets are balanced, the function returns `true`, otherwise it returns `false`. The function iterates through each character in the string, incrementing a counter when it encounters an opening bracket and decrementing it when it encounters a closing bracket. If the counter ever goes negative, it means there was a closing bracket without a corresponding opening bracket, so the function returns `false`. If the counter is zero at the end of the iteration, it means all brackets were balanced, so the function returns `true`. To rewrite this program in C++, you would need to replace the Java-specific syntax with equivalent C++ syntax. For example, you would need to replace `import` statements with `#include` statements, and replace the `String` type with `std::string`. You would also need to remove any Java-specific libraries that are not available in C++, and replace any Java-specific methods with equivalent C++ methods. For example, you would need to replace the `toCharArray()` method with a loop that iterates over each character in the string. Finally, you would need to define a `main()` function that calls the `correctBracketing()` function with a test string and prints the result.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool correct_bracketing(std::string brackets) {\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat triangle_area(long a, long h) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static float triangleArea(long a, long h) {\n        return a * h / 2.0f;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` which has a single static method called `triangleArea`. The method takes two arguments, both of which are `long` integers. The method returns the area of a triangle given the base and height of the triangle. The formula used to calculate the area is `a * h / 2.0f`, where `a` is the base and `h` is the height. The method returns a `float` value.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat triangle_area(long a, long h) {\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong special_factorial(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long specialFactorial(long n) {\n        long factI = 1;\n        long specialFact = 1;\n        for (long i = 1; i <= n; i++) {\n            factI *= i;\n            specialFact *= factI;\n        }\n        return specialFact;\n    }\n}\n\n### Explanation\n\nThis program defines a static method called `specialFactorial` that takes in a long integer `n` and returns a long integer. The method calculates a special factorial of `n` by first calculating the factorial of each integer from 1 to `n`, and then multiplying all of these factorials together. The method then returns the final result.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong special_factorial(long n) {\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool move_one_ball(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean moveOneBall(ArrayList<Long> arr) {\n        if (arr.size() == 0) {\n            return true;\n        }\n        List<Long> sortedArray = new ArrayList<>(arr);\n        Collections.sort(sortedArray);\n        int minIndex = arr.indexOf(Collections.min(arr));\n        List<Long> myArr = new ArrayList<>(arr.subList(minIndex, arr.size()));\n        myArr.addAll(arr.subList(0, minIndex));\n        for (int i = 0; i < arr.size(); i++) {\n            if (!myArr.get(i).equals(sortedArray.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `moveOneBall` that takes an ArrayList of Long integers as input and returns a boolean. The function checks if it is possible to move one ball from one position to another in the array such that the array becomes sorted in ascending order. If the array is already sorted, the function returns true. If the array is empty, the function also returns true. The function first sorts a copy of the input array, then finds the index of the minimum value in the original array. It then creates a new array by concatenating the subarray starting from the minimum value index to the end of the array, with the subarray starting from the beginning of the array to the minimum value index. Finally, it checks if the new array is equal to the sorted array, and returns true if it is, and false otherwise.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool move_one_ball(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong digits(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long digits(long n) {\n        long product = 1;\n        int oddCount = 0;\n        for (char c : Long.toString(n).toCharArray()) {\n            int digit = Character.getNumericValue(c);\n            if (digit % 2 == 1) {\n                product *= digit;\n                oddCount++;\n            }\n        }\n        return oddCount == 0 ? 0 : product;\n    }\n}\n\n### Explanation\n\nThis program defines a function `digits` that takes a long integer `n` and returns the product of all odd digits in `n`. If `n` has no odd digits, the function returns 0. The function first initializes a variable `product` to 1 and a variable `oddCount` to 0. It then iterates over the digits in `n` by converting `n` to a string and iterating over the characters in the string. For each digit, it checks if it is odd by taking its modulus with 2. If it is odd, it multiplies `product` by the digit and increments `oddCount`. Finally, it returns `product` if `oddCount` is greater than 0, and 0 otherwise.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong digits(long n) {\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fib4(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long fib4(long n) {\n        ArrayList<Long> results = new ArrayList<Long>(Arrays.asList(0L, 0L, 2L, 0L));\n        if (n < 4) {\n            return results.get((int)n);\n        }\n\n        for (long i = 4; i <= n; i++) {\n            results.add(results.get(3) + results.get(2) + results.get(1) + results.get(0));\n            results.remove(0);\n        }\n\n        return results.get(3);\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `fib4` that returns the 4th Fibonacci number. It does this by creating an ArrayList of Longs, and initializing it with the first 4 Fibonacci numbers. It then iteratively calculates the next Fibonacci number by summing the last 4 numbers in the list, and removing the first number in the list. Finally, it returns the last number in the list, which is the 4th Fibonacci number. To rewrite this program in C++, you would need to replace the ArrayList with a vector, and replace the Long type with the long long type. You would also need to remove the import statements at the beginning of the file, and replace the `ArrayList<Long>` type with `vector<long long>`. The `Arrays.asList` method call would need to be replaced with a vector initialization, and the `remove` method call would need to be replaced with a call to `erase` on the vector. The `stream` method call would need to be removed, as it is not available in C++. Finally, the `class` keyword would need to be replaced with the `struct` keyword, as C++ does not have classes in the same way that Java does.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fib4(long n) {\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_even(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortEven(ArrayList<Long> l) {\n        ArrayList<Long> evens = new ArrayList<Long>();\n        ArrayList<Long> odds = new ArrayList<Long>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                evens.add(l.get(i));\n            } else {\n                odds.add(l.get(i));\n            }\n        }\n        Collections.sort(evens);\n        ArrayList<Long> ans = new ArrayList<Long>();\n        for (int i = 0; i < evens.size(); i++) {\n            ans.add(evens.get(i));\n            if (i < odds.size()) {\n                ans.add(odds.get(i));\n            }\n        }\n        return ans;\n    }\n}\n\n### Explanation\n\nThis program defines a class `Problem` with a single static method `sortEven` that takes an `ArrayList` of `Long`s and returns a new `ArrayList` with the even elements sorted in ascending order, and the odd elements in their original order. The method first separates the even and odd elements into two separate lists, sorts the even list, and then interleaves the two lists into a single list.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_even(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> orderByPoints(ArrayList<Long> nums) {\n        return nums.stream().sorted((a, b) -> Long.compare(digitsSum(a), digitsSum(b))).collect(Collectors.toCollection(ArrayList::new));\n    }\n    private static long digitsSum(long n) {\n        long neg = 1;\n        if (n < 0) {\n            n = -1 * n;\n            neg = -1;\n        }\n        String s = Long.toString(n);\n        long[] digits = new long[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            digits[i] = s.charAt(i) - '0';\n        }\n        digits[0] *= neg;\n        return Arrays.stream(digits).sum();\n    }\n}\n\n### Explanation\n\nThis program defines a class `Problem` with two methods: `orderByPoints` and `digitsSum`. The `orderByPoints` method takes an ArrayList of Longs and returns a new ArrayList of Longs sorted by the sum of their digits. The `digitsSum` method takes a long and returns the sum of its digits. The `digitsSum` method first checks if the input is negative, and if so, it multiplies it by -1 and sets a flag `neg` to -1. It then converts the long to a string and creates an array of longs representing the digits of the number. It multiplies the first digit by `neg` to account for the negative sign, and then returns the sum of the digits using the `Arrays.stream(digits).sum()` method. \n\nTo rewrite this program in C++, you would need to replace the ArrayLists with vectors, and replace the `stream` and `collect` methods with a for loop. Here is a possible C++ implementation:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> order_by_points(std::vector<long> nums) {\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_happy(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isHappy(String s) {\n        if (s.length() < 3) return false;\n        for (int i = 0; i < s.length() - 2; i++) {\n            if (s.charAt(i) == s.charAt(i+1) || s.charAt(i+1) == s.charAt(i+2) || s.charAt(i) == s.charAt(i+2)) return false;\n        }\n        return true;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `isHappy` that takes a string `s` as input and returns a boolean. The function returns true if the string `s` has no consecutive characters that are the same, and false otherwise. The function first checks if the length of the string is less than 3, and if so, returns false. Otherwise, it iterates through the string, checking each group of three consecutive characters to see if any two of them are the same. If any two are the same, the function returns false. If the function makes it through the entire string without finding any consecutive characters that are the same, it returns true. \n\nTo rewrite this program in C++, you would need to replace the Java-specific syntax with C++-specific syntax. You would also need to include the necessary headers for the libraries used in the Java program. Here is an example of what the C++ version might look like:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_happy(std::string s) {\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string circular_shift(long x, long shift) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String circularShift(long x, long shift) {\n        String s = Long.toString(x);\n        if (shift > s.length()) {\n            return new StringBuilder(s).reverse().toString();\n        }\n        return s.substring((int) (s.length() - shift)) + s.substring(0, (int) (s.length() - shift));\n    }\n    \n}\n\n### Explanation\n\nThis program defines a static method `circularShift` that takes two long integers `x` and `shift` as input and returns a string. The method first converts `x` to a string and then shifts the string by `shift` positions. If `shift` is greater than the length of the string, the method returns the reverse of the string. The program imports several Java libraries and classes, including `java.util.*`, `java.lang.reflect.*`, `org.javatuples.*`, `java.security.*`, `java.math.*`, `java.io.*`, and `java.util.stream.*`, but none of these are used in the `circularShift` method. To rewrite this program in C++, you would need to define a function with the same name and signature as the `circularShift` method, and then implement the same logic using C++ string and integer operations.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string circular_shift(long x, long shift) {\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long maxFill(ArrayList<ArrayList<Long>> grid, long capacity) {\n        return grid.stream().mapToLong(arr -> (long)Math.ceil(arr.stream().mapToLong(x -> x).sum()/(double)capacity)).sum();\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function called `maxFill` that takes in a 2D array of integers called `grid` and a `long` called `capacity`. The function returns a `long`. \n\nThe function first maps each row of the `grid` to a `long` value which is the sum of all the elements in the row divided by the `capacity`. The `Math.ceil` function is used to round up the result of the division to the nearest integer. \n\nThe function then returns the sum of all the values obtained from the previous step.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean hasCloseElements(ArrayList<Float> numbers, float threshold) {\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = 0; j < numbers.size(); j++) {\n                if (i != j) {\n                    float distance = Math.abs(numbers.get(i) - numbers.get(j));\n                    if (distance < threshold) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `hasCloseElements` that takes in an ArrayList of floats and a float called `threshold`. The function returns a boolean value. The function iterates through the ArrayList twice and calculates the absolute difference between each pair of elements. If the difference is less than the threshold, the function returns true. If no pairs of elements have a difference less than the threshold, the function returns false.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> numericalLetterGrade(ArrayList<Float> grades) {\n        ArrayList<String> letterGrade = new ArrayList<String>();\n        for (Float gpa : grades) {\n            if (gpa == 4.0f) {\n                letterGrade.add(\"A+\");\n            } else if (gpa > 3.7f) {\n                letterGrade.add(\"A\");\n            } else if (gpa > 3.3f) {\n                letterGrade.add(\"A-\");\n            } else if (gpa > 3.0f) {\n                letterGrade.add(\"B+\");\n            } else if (gpa > 2.7f) {\n                letterGrade.add(\"B\");\n            } else if (gpa > 2.3f) {\n                letterGrade.add(\"B-\");\n            } else if (gpa > 2.0f) {\n                letterGrade.add(\"C+\");\n            } else if (gpa > 1.7f) {\n                letterGrade.add(\"C\");\n            } else if (gpa > 1.3f) {\n                letterGrade.add(\"C-\");\n            } else if (gpa > 1.0f) {\n                letterGrade.add(\"D+\");\n            } else if (gpa > 0.7f) {\n                letterGrade.add(\"D\");\n            } else if (gpa > 0.0f) {\n                letterGrade.add(\"D-\");\n            } else {\n                letterGrade.add(\"E\");\n            }\n        }\n        return letterGrade;\n    }\n    \n}\n\n### Explanation\n\nThis program takes in a list of grades as floats and returns a list of letter grades as strings. The letter grades are calculated based on the following scale:\n\n- A+ for 4.0\n- A for 3.7 to 4.0\n- A- for 3.3 to 3.7\n- B+ for 3.0 to 3.3\n- B for 2.7 to 3.0\n- B- for 2.3 to 2.7\n- C+ for 2.0 to 2.3\n- C for 1.7 to 2.0\n- C- for 1.3 to 1.7\n- D+ for 1.0 to 1.3\n- D for 0.7 to 1.0\n- D- for 0.0 to 0.7\n- E for anything below 0.0\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong x_or_y(long n, long x, long y) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long xOrY(long n, long x, long y) {\n        if (n == 1) {\n            return y;\n        }\n        for (long i = 2; i < n; i++) {\n            if (n % i == 0) {\n                return y;\n            }\n        }\n        return x;\n    }\n}\n\n### Explanation\n\nThis program defines a function `xOrY` that takes three long integers as arguments, `n`, `x`, and `y`. The function returns `y` if `n` is 1 or if `n` is not a prime number. Otherwise, the function returns `x`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong x_or_y(long n, long x, long y) {\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong specialFilter(std::vector<long> nums) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long specialFilter(ArrayList<Long> nums) {\n        long count = 0;\n        for (long num : nums) {\n            if (num > 10) {\n                if (isOdd(num / (long) Math.pow(10, (long) Math.log10(num))) && isOdd(num % 10)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static boolean isOdd(long n) {\n        return n % 2 == 1;\n    }\n}\n\n### Explanation\n\nThis program defines a function called `specialFilter` which takes an ArrayList of long integers and returns a long integer. The function iterates over each number in the ArrayList and checks if it is greater than 10. If it is, it checks if the first and last digits of the number are odd. If they are, it increments a counter. The final count is returned. \n\nTo rewrite this program in C++, you would need to replace the ArrayList with a vector, and replace the `Math` functions with their C++ equivalents. You would also need to include the necessary headers for the libraries used in the Java program. \n\nHere is the C++ equivalent of the program:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong specialFilter(std::vector<long> nums) {\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> parse_music(std::string music_string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> parseMusic(String music_string) {\n        HashMap<String, Long> note_map = new HashMap<String, Long>() {{\n            put(\"o\", 4L);\n            put(\"o|\", 2L);\n            put(\".|\", 1L);\n        }};\n        return Arrays.stream(music_string.split(\" \")).filter(x -> !x.isEmpty()).map(x -> note_map.get(x)).collect(Collectors.toCollection(ArrayList::new));\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `parseMusic` which takes a string `music_string` as input and returns an ArrayList of Longs. The function first defines a HashMap `note_map` which maps note strings to their corresponding Long values. The function then splits the input string by spaces, filters out any empty strings, maps each note string to its corresponding Long value using the `note_map`, and collects the resulting Long values into an ArrayList. The program requires the following imports: `java.util.*`, `java.lang.reflect.*`, `org.javatuples.*`, `java.security.*`, `java.math.*`, and `java.io.*`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> parse_music(std::string music_string) {\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong count_distinct_characters(std::string string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long countDistinctCharacters(String string) {\n        return string.toLowerCase().chars().distinct().count();\n    }\n}\n\n### Explanation\n\nThis program defines a function `countDistinctCharacters` that takes a string as input and returns the number of distinct characters in the string. The function first converts the string to lowercase, then converts it to a stream of characters, then applies the `distinct` operation to the stream to remove duplicates, and finally counts the number of remaining characters using the `count` operation. To rewrite this program in C++, you would need to use the `std::unordered_set` container to keep track of the distinct characters, and then return the size of the set. Here's an example implementation:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong count_distinct_characters(std::string string) {\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> bf(String planet1, String planet2) {\n        ArrayList<String> planetNames = new ArrayList<>(Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"));\n        if (!planetNames.contains(planet1) || !planetNames.contains(planet2) || planet1.equals(planet2)) {\n            return new ArrayList<>();\n        }\n        int planet1Index = planetNames.indexOf(planet1);\n        int planet2Index = planetNames.indexOf(planet2);\n        if (planet1Index < planet2Index) {\n            return new ArrayList<>(planetNames.subList(planet1Index + 1, planet2Index));\n        } else {\n            return new ArrayList<>(planetNames.subList(planet2Index + 1, planet1Index));\n        }\n    }\n}\n\n### Explanation\n\nThis program defines a function `bf` that takes two strings `planet1` and `planet2` as input and returns an ArrayList of strings. The function first creates an ArrayList of strings called `planetNames` containing the names of the planets in our solar system. If either of the input strings is not in this list or if they are the same, the function returns an empty ArrayList. Otherwise, the function finds the indices of the two input strings in the `planetNames` list and returns a new ArrayList containing the names of all the planets between the two input strings (excluding the input strings themselves). If `planet1` comes before `planet2` in the `planetNames` list, the function returns the sublist of `planetNames` starting from the index of `planet1` plus one and ending at the index of `planet2`. Otherwise, it returns the sublist of `planetNames` starting from the index of `planet2` plus one and ending at the index of `planet1`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong digitSum(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long digitSum(String s) {\n        if (s.equals(\"\")) return 0;\n        return s.chars().filter(Character::isUpperCase).sum();\n    }\n    \n}\n\n### Explanation\n\nThis program defines a class called `Problem` that has a single static method called `digitSum`. The method takes a string as input and returns a long. If the input string is empty, the method returns 0. Otherwise, it computes the sum of the ASCII values of all uppercase characters in the string and returns the result.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong digitSum(std::string s) {\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong sum_squares(std::vector<long> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long sumSquares(ArrayList<Long> lst) {\n        long result = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                result += Math.pow(lst.get(i), 2);\n            } else if (i % 4 == 0 && i % 3 != 0) {\n                result += Math.pow(lst.get(i), 3);\n            } else {\n                result += lst.get(i);\n            }\n        }\n        return result;\n    }\n}\n\n### Explanation\n\nThis program defines a function `sumSquares` that takes an ArrayList of Longs as input and returns a Long. The function iterates over the input list and for each element, it checks if the index is divisible by 3 or 4. If the index is divisible by 3, it adds the square of the element to the result. If the index is divisible by 4 but not 3, it adds the cube of the element to the result. Otherwise, it adds the element itself to the result. The function then returns the final result.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong sum_squares(std::vector<long> lst) {\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> count_up_to(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> countUpTo(long n) {\n        ArrayList<Long> primes = new ArrayList<>();\n        for (long i = 2; i < n; i++) {\n            boolean isPrime = true;\n            for (long j = 2; j < i; j++) {\n                if (i % j == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}\n\n### Explanation\n\nThis program generates a list of prime numbers up to a given number n. It does this by iterating through all numbers from 2 to n and checking if each number is prime. If a number is prime, it is added to an ArrayList of primes. The ArrayList is then returned. \n\nTo rewrite this program in C++, you would need to replace the Java-specific syntax with C++ equivalents. For example, you would need to replace ArrayList with a C++ container like vector, and replace the for-each loop with a traditional for loop. You would also need to include the necessary C++ libraries for math functions and containers. \n\nHere is an example of what the C++ version might look like:\n\n```cpp\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> count_up_to(long n) {\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong sum_squares(std::vector<float> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long sumSquares(ArrayList<Float> lst) {\n        long squared = 0;\n        for (float i : lst) {\n            squared += Math.ceil(i) * Math.ceil(i);\n        }\n        return squared;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `sumSquares` that takes an ArrayList of floats and returns a long. The function iterates over the list, and for each element, it rounds up to the nearest integer and squares the result. It then adds the squared value to a running total. The final total is returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong sum_squares(std::vector<float> lst) {\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> unique(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> unique(ArrayList<Long> l) {\n        return new ArrayList<Long>(new HashSet<Long>(l));\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `unique`. The `unique` method takes an `ArrayList` of `Long` objects as input, and returns another `ArrayList` of `Long` objects. The returned list contains only the unique elements of the input list, in the order in which they first appear in the input list. The method uses the `HashSet` class to remove duplicates from the input list.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> unique(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fib(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long fib(long n) {\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return 1;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n\n### Explanation\n\nThis program defines a function `fib` that returns the nth Fibonacci number. The function is defined recursively, with the base cases being `fib(0) = 0` and `fib(1) = 1`. The function is called with a single argument, `n`, which is the index of the Fibonacci number to be returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fib(long n) {\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fizz_buzz(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long fizzBuzz(long n) {\n        List<Long> ns = new ArrayList<>();\n        for (long i = 0; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                ns.add(i);\n            }\n        }\n        long s = ns.stream().map(i -> String.valueOf(i)).flatMapToInt(String::chars).filter(c -> c == '7').count();\n        return s;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `fizzBuzz` that takes a long integer `n` as input and returns a long integer. The function creates an empty list `ns` and then iterates over all integers from 0 to `n-1`. If the integer is divisible by 11 or 13, it is added to the list `ns`. The function then converts each integer in `ns` to a string, flattens the resulting list of characters, filters out all characters that are not '7', and counts the remaining characters. The count is then returned as the output of the function. \n\nTo rewrite this program in C++, you would need to replace the Java-specific libraries and syntax with their C++ equivalents. For example, you would need to replace `java.util.*` with `#include <vector>` and `java.lang.reflect.*` with `#include <typeinfo>`. You would also need to replace the `List` and `ArrayList` classes with C++ containers such as `std::vector`. Finally, you would need to replace the Java-specific stream operations with C++ equivalents such as `std::transform` and `std::count_if`. \n\nHere is an example of what the C++ code might look like:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fizz_buzz(long n) {\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String StrongestExtension(String class_name, ArrayList<String> extensions) {\n        String strong = extensions.get(0);\n        int myVal = extensions.get(0).replaceAll(\"[^A-Z]\", \"\").length() - extensions.get(0).replaceAll(\"[^a-z]\", \"\").length();\n        for (String s : extensions) {\n            int val = s.replaceAll(\"[^A-Z]\", \"\").length() - s.replaceAll(\"[^a-z]\", \"\").length();\n            if (val > myVal) {\n                strong = s;\n                myVal = val;\n            }\n        }\n        return class_name + \".\" + strong;\n    }\n}\n\n### Explanation\n\nThis program takes a string `class_name` and an array of strings `extensions`. It then iterates over each string in the array and calculates the difference between the number of uppercase and lowercase letters in the string. The string with the largest difference is returned with the `class_name` prepended to it.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Float, Float> findClosestElements(ArrayList<Float> numbers) {\n        Pair<Float, Float> closestPair = null;\n        Float distance = null;\n\n        for (int idx = 0; idx < numbers.size(); idx++) {\n            Float elem = numbers.get(idx);\n            for (int idx2 = 0; idx2 < numbers.size(); idx2++) {\n                Float elem2 = numbers.get(idx2);\n                if (idx != idx2) {\n                    Float newDistance = Math.abs(elem - elem2);\n                    if (distance == null || newDistance < distance) {\n                        distance = newDistance;\n                        closestPair = Pair.with(Math.min(elem, elem2), Math.max(elem, elem2));\n                    }\n                }\n            }\n        }\n\n        return closestPair;\n    }\n}\n\n### Explanation\n\nThis program finds the closest pair of numbers in an array of floating point numbers. It does this by iterating over each element in the array, and then iterating over all other elements in the array to calculate the distance between the two. If the distance is smaller than the previous smallest distance, then the pair of elements is saved as the closest pair. The program returns the closest pair of elements as a tuple of two floats.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool valid_date(std::string date) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean validDate(String date) {\n        try {\n            date = date.trim();\n            String[] parts = date.split(\"-\");\n            int month = Integer.parseInt(parts[0]);\n            int day = Integer.parseInt(parts[1]);\n            int year = Integer.parseInt(parts[2]);\n            if (month < 1 || month > 12) {\n                return false;\n            }\n            if (Arrays.asList(1,3,5,7,8,10,12).contains(month) && (day < 1 || day > 31)) {\n                return false;\n            }\n            if (Arrays.asList(4,6,9,11).contains(month) && (day < 1 || day > 30)) {\n                return false;\n            }\n            if (month == 2 && (day < 1 || day > 29)) {\n                return false;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program contains a single method called `validDate` which takes a string as input and returns a boolean. The string is expected to be in the format \"MM-DD-YYYY\" where MM is the month, DD is the day, and YYYY is the year. The method checks whether the input string is a valid date and returns true if it is, and false otherwise. The method first trims the input string to remove any leading or trailing whitespace. It then splits the string into its component parts using the \"-\" character as a delimiter. It then converts the month, day, and year parts to integers using the `parseInt` method of the `Integer` class. It then checks whether the month is between 1 and 12, and whether the day is valid for that month. If the month is February, it checks whether the day is between 1 and 29. If any of these checks fail, the method returns false. If any exceptions are thrown during the execution of the method, it catches them and returns false. Otherwise, it returns true.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool valid_date(std::string date) {\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong add(long x, long y) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long add(long x, long y) {\n        return x + y;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` which has a static method called `add` that takes two long integers and returns their sum. The program imports several Java libraries, but none of them are used in the code. The program does not contain a `main` method, so it cannot be run directly. To use the `add` method, another class would need to import the `Problem` class and call the `add` method with two long integers as arguments.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong add(long x, long y) {\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool triples_sum_to_zero(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean triplesSumToZero(ArrayList<Long> l) {\n        for (int i=0; i<l.size(); i++) {\n            for (int j=i+1; j<l.size(); j++) {\n                for (int k=j+1; k<l.size(); k++) {\n                    if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `triplesSumToZero` that takes in an array of long integers and returns true if there exists three distinct elements in the array that sum to zero. The function uses three nested loops to iterate over all possible triples of elements in the array and checks if their sum is zero. If such a triple is found, the function returns true. Otherwise, it returns false.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool triples_sum_to_zero(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong largest_divisor(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long largestDivisor(long n) {\n        for (long i = n-1; i >= 1; i--) {\n            if (n % i == 0) {\n                return i;\n            }\n        }\n        return 1;\n    }\n}\n\n### Explanation\n\nThis program defines a single function `largestDivisor` that takes a single argument `n` of type `long` and returns a value of type `long`. The function returns the largest divisor of `n` that is less than `n`. The function iterates over all numbers from `n-1` to `1` and returns the first number that divides `n` without a remainder. If no such number is found, the function returns `1`. The program imports a number of standard Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. It also uses the `java.util.stream` package. The program does not contain any code that would require these libraries, so they could be removed without affecting the functionality of the program. The program does not contain a `main` function, so it cannot be run directly. To use the `largestDivisor` function, it would need to be called from another program or function. To translate this program to C++, you would need to define a function with the same name and signature, and implement the same logic using C++ syntax. You would also need to remove the import statements and any other Java-specific syntax.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong largest_divisor(long n) {\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string sort_numbers(std::string numbers) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String sortNumbers(String numbers) {\n        Map<String, Integer> valueMap = new HashMap<String, Integer>() {{\n            put(\"zero\", 0);\n            put(\"one\", 1);\n            put(\"two\", 2);\n            put(\"three\", 3);\n            put(\"four\", 4);\n            put(\"five\", 5);\n            put(\"six\", 6);\n            put(\"seven\", 7);\n            put(\"eight\", 8);\n            put(\"nine\", 9);\n        }};\n        return String.join(\" \", Arrays.stream(numbers.split(\" \")).filter(x -> !x.isEmpty()).sorted((x, y) -> valueMap.get(x) - valueMap.get(y)).toArray(String[]::new));\n    }\n}\n\n### Explanation\n\nThis program takes a string of numbers written in English and sorts them in ascending order. The numbers are first mapped to their corresponding integer values and then sorted using the `sorted` method of the `Stream` class. The sorted numbers are then joined together into a single string and returned. To rewrite this program in C++, you would need to replace the Java-specific classes and methods with their C++ equivalents. For example, you would need to use a `std::map` to map the English words to their integer values and use the `std::sort` algorithm to sort the numbers. You would also need to replace the `String.join` method with a loop that concatenates the sorted numbers into a single string.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string sort_numbers(std::string numbers) {\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong smallest_change(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long smallestChange(ArrayList<Long> arr) {\n        long ans = 0;\n        for (int i = 0; i < arr.size() / 2; i++) {\n            if (arr.get(i) != arr.get(arr.size() - i - 1)) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n### Explanation\n\nThis program defines a function `smallestChange` that takes an ArrayList of Longs and returns a Long. The function iterates over the first half of the ArrayList and checks if the element at the current index is different from the element at the corresponding index in the second half of the ArrayList. If they are different, the function increments a counter. The final value of the counter is returned as the result of the function.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong smallest_change(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool below_threshold(std::vector<long> l, long t) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean belowThreshold(ArrayList<Long> l, long t) {\n        for (long e : l) {\n            if (e >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` which has a single static method called `belowThreshold`. The method takes in an `ArrayList` of `Long`s and a `long` value `t`. The method returns `true` if all elements in the list are less than `t`, otherwise it returns `false`. \n\nThe program imports several Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. It also uses the `java.util.stream` package.\n\nTo rewrite this program in C++, you would need to define a similar class with a static method that takes in a vector of `long long` values and a `long long` value `t`. The method would need to iterate through the vector and check if each element is less than `t`. If all elements are less than `t`, the method should return `true`, otherwise it should return `false`. You would also need to include any necessary C++ libraries. \n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool below_threshold(std::vector<long> l, long t) {\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Optional<Long> prodSigns(ArrayList<Long> arr) {\n        if (arr.isEmpty()) return Optional.empty();\n        long prod = arr.contains(0L) ? 0L : (long) Math.pow(-1, arr.stream().filter(x -> x < 0).count());\n        return Optional.of(prod * arr.stream().map(Math::abs).reduce(0L, Long::sum));\n    }\n}\n\n### Explanation\n\nThis program defines a function `prodSigns` that takes an ArrayList of Longs and returns an Optional of a Long. The function returns an empty Optional if the input ArrayList is empty. Otherwise, it calculates the product of the signs of the elements in the ArrayList (i.e., whether each element is positive or negative) and multiplies it by the sum of the absolute values of the elements. If the ArrayList contains a 0, the product is 0. The function returns an Optional of the final result.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<long> prod_signs(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong modp(long n, long p) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long modp(long n, long p) {\n        long ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret = (2 * ret) % p;\n        }\n        return ret;\n    }\n}\n\n### Explanation\n\nThis program defines a function `modp` that takes two long integers `n` and `p` as input and returns a long integer. The function calculates `2^n % p` and returns the result. The function uses a loop to calculate the result, and the loop runs `n` times. The function uses the formula `2 * ret % p` to calculate the result at each iteration of the loop. The function returns the final value of `ret`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong modp(long n, long p) {\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong count_upper(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long countUpper(String s) {\n        long count = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            if (\"AEIOU\".indexOf(s.charAt(i)) >= 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `countUpper`. The method takes a string as input and returns a long. The method counts the number of uppercase vowels in the string. The string is assumed to have an even length, and the vowels are assumed to be in every other position starting from the first position. The method returns the number of uppercase vowels found.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong count_upper(std::string s) {\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong multiply(long a, long b) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long multiply(long a, long b) {\n        return Math.abs(a % 10) * Math.abs(b % 10);\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a static method called `multiply`. The method takes two long integers as input and returns the product of the absolute values of the last digits of the two numbers.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong multiply(long a, long b) {\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> uniqueDigits(ArrayList<Long> x) {\n        ArrayList<Long> oddDigitElements = new ArrayList<>();\n        for (long i : x) {\n            if (Long.toString(i).chars().allMatch(c -> c % 2 == 1)) {\n                oddDigitElements.add(i);\n            }\n        }\n        Collections.sort(oddDigitElements);\n        return oddDigitElements;\n    }\n}\n\n### Explanation\n\nThis program defines a function `uniqueDigits` which takes an ArrayList of Longs as an argument and returns another ArrayList of Longs. The function returns a list of all elements in the input list that have only odd digits in their decimal representation. The returned list is sorted in ascending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> unique_digits(std::vector<long> x) {\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool will_it_fly(std::vector<long> q, long w) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean willItFly(ArrayList<Long> q, long w) {\n        if(q.stream().mapToLong(Long::longValue).sum() > w) return false;\n        int i = 0, j = q.size()-1;\n        while(i < j) {\n            if(q.get(i) != q.get(j)) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `willItFly` that takes an ArrayList of Longs and a long as input. It returns a boolean indicating whether or not the sum of the ArrayList is less than or equal to the long input, and whether or not the ArrayList is a palindrome. \n\nThe function first checks if the sum of the ArrayList is greater than the long input. If it is, it returns false. \n\nNext, it sets two pointers, `i` and `j`, to the beginning and end of the ArrayList, respectively. It then iterates through the ArrayList, comparing the values at `i` and `j`. If they are not equal, the function returns false. If they are equal, it increments `i` and decrements `j`, and continues iterating until `i` is greater than or equal to `j`. If all values are equal, the function returns true. \n\nTo rewrite this program in C++, you would need to replace the ArrayList with a vector, and replace the `stream()` and `mapToLong()` functions with a loop that sums the values in the vector. You would also need to replace the `get()` function with the `[]` operator. Here is an example of what the C++ code might look like:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool will_it_fly(std::vector<long> q, long w) {\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_multiply_prime(long a) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isMultiplyPrime(long a) {\n        for (int i = 2; i < 101; i++) {\n            if (!isPrime(i)) continue;\n            for (int j = 2; j < 101; j++) {\n                if (!isPrime(j)) continue;\n                for (int k = 2; k < 101; k++) {\n                    if (!isPrime(k)) continue;\n                    if (i*j*k == a) return true;\n                }\n            }\n        }\n        return false;\n    }\n    public static boolean isPrime(int n) {\n        for (int j = 2; j < n; j++) {\n            if (n%j == 0) return false;\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program checks if a number is the product of three prime numbers between 2 and 100. It does this by iterating over all possible combinations of three prime numbers between 2 and 100 and checking if their product is equal to the input number. If the input number is the product of three prime numbers between 2 and 100, the function returns true, otherwise it returns false.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_multiply_prime(long a) {\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> maximum(ArrayList<Long> arr, long k) {\n        if (k == 0) {\n            return new ArrayList<Long>();\n        }\n        Collections.sort(arr);\n        return new ArrayList<Long>(arr.subList(arr.size() - (int)k, arr.size()));\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `maximum` that takes in an array of longs and a long `k`. The function returns the `k` largest elements of the array. If `k` is 0, the function returns an empty array. The function sorts the input array in ascending order and returns the `k` largest elements in the array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> filterIntegers(ArrayList<Object> values) {\n        return values.stream().filter(x -> x instanceof Long).map(x -> (Long) x).collect(Collectors.toCollection(ArrayList::new));\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `filterIntegers`. The method takes an `ArrayList` of `Object`s called `values` as an argument. It returns a new `ArrayList` containing only the `Long` values from the original `ArrayList`. The method uses Java 8 streams to filter the `values` list, keeping only the elements that are instances of `Long`. It then maps each of these `Long` values to itself (casting the `Object` to a `Long`), and collects the resulting stream into a new `ArrayList`. \n\nTo translate this program into C++, you would need to replace the `ArrayList` and `Object` types with their C++ equivalents (e.g., `std::vector` and `std::any`), and use the appropriate C++ functions to filter and map the list. Here's an example implementation in C++ using the `std::vector` and `std::any` types:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong skjkasdkd(std::vector<long> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long skjkasdkd(ArrayList<Long> lst) {\n        long maxx = 0;\n        for (long i : lst) {\n            if (i > maxx && isPrime(i)) {\n                maxx = i;\n            }\n        }\n        return Long.toString(maxx).chars().map(c -> c - '0').sum();\n    }\n\n    private static boolean isPrime(long n) {\n        for (long i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `skjkasdkd` that takes an ArrayList of long integers as input. It then iterates through the list and returns the largest prime number in the list. If there are no prime numbers in the list, it returns 0. The function then converts the largest prime number to a string, maps each character to its integer value, and returns the sum of those values.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong skjkasdkd(std::vector<long> lst) {\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> totalMatch(ArrayList<String> lst1, ArrayList<String> lst2) {\n        int l1 = lst1.stream().mapToInt(String::length).sum();\n        int l2 = lst2.stream().mapToInt(String::length).sum();\n        return l1 <= l2 ? lst1 : lst2;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `totalMatch`. The method takes two arguments, both of which are `ArrayList<String>` objects. The method calculates the total length of all the strings in each list, and returns the list with the smaller total length.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<std::string> string_to_md5(std::string text) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_162_string_to_md5.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Optional<String> stringToMd5(String text) {\n        if (text == null || text.isEmpty()) {\n            return Optional.empty();\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hash = md.digest(text.getBytes(\"ASCII\"));\n            BigInteger bigInt = new BigInteger(1, hash);\n            return Optional.of(String.format(\"%032x\", bigInt));\n        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n            return Optional.empty();\n        }\n    }\n}\n\n### Explanation\n\nThis program defines a function called `stringToMd5` that takes a string as input and returns an optional string. The function returns an empty optional if the input string is null or empty. Otherwise, it calculates the MD5 hash of the input string using the `MessageDigest` class from the `java.security` package. It then converts the resulting hash to a `BigInteger` and formats it as a 32-character hexadecimal string using the `String.format` method. The resulting string is wrapped in an `Optional` and returned. \n\nTo rewrite this program in C++, you would need to use a different library for calculating the MD5 hash, since `MessageDigest` is a Java-specific class. One option would be to use the `md5` function from the `openssl/md5.h` header file. You would also need to replace the `Optional` type with a different mechanism for handling optional return values, such as a pointer or a `std::optional` object from the C++17 standard library. Here is an example implementation in C++:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<std::string> string_to_md5(std::string text) {\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong car_race_collision(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long carRaceCollision(long n) {\n        return n*n;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a static method called `carRaceCollision`. The method takes a single long integer as input and returns the square of that integer. The program imports several Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. It also uses the `java.util.stream` package. The purpose of these libraries is unclear, as they are not used in the `carRaceCollision` method. To rewrite this program in C++, you would define a function with the same name and signature as the `carRaceCollision` method, and use the `pow` function from the `cmath` library to calculate the square of the input. Here is an example implementation:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong car_race_collision(long n) {\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_simple_power(long x, long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSimplePower(long x, long n) {\n        if (n == 1) return (x == 1);\n        long power = 1;\n        while (power < x) power = power * n;\n        return (power == x);\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `isSimplePower` that takes two long integers `x` and `n` as input. The function returns a boolean value indicating whether `x` is a power of `n` or not. The function first checks if `n` is equal to 1 and `x` is equal to 1, in which case it returns true. Otherwise, it initializes a variable `power` to 1 and enters a loop that multiplies `power` by `n` until `power` is greater than or equal to `x`. If `power` is equal to `x`, the function returns true, otherwise it returns false.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_simple_power(long x, long n) {\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string encode(std::string message) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String encode(String message) {\n        String vowels = \"aeiouAEIOU\";\n        Map<Character, Character> vowels_replace = new HashMap<>();\n        for (char i : vowels.toCharArray()) {\n            vowels_replace.put(i, (char)(i + 2));\n        }\n        message = swapCase(message);\n        StringBuilder sb = new StringBuilder();\n        for (char i : message.toCharArray()) {\n            sb.append(vowels_replace.containsKey(i) ? vowels_replace.get(i) : i);\n        }\n        return sb.toString();\n    }\n    public static String swapCase(String str) {\n        StringBuilder sb = new StringBuilder();\n        for (char i : str.toCharArray()) {\n            sb.append(Character.isUpperCase(i) ? Character.toLowerCase(i) : Character.toUpperCase(i));\n        }\n        return sb.toString();\n    }\n    \n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` with two static methods `encode` and `swapCase`. The `encode` method takes a string as input, swaps the case of each character in the string, and replaces each vowel with the character two positions to the right in the ASCII table. The `swapCase` method takes a string as input and returns a new string with the case of each character swapped. \n\nTo rewrite this program in C++, you would need to replace the Java-specific syntax with C++ equivalents. For example, you would need to replace the `import` statements with `#include` statements, and replace the `Map` and `StringBuilder` classes with C++ equivalents. You would also need to replace the `char` data type with `char` or `std::string` as appropriate. Here is an example C++ implementation of the `encode` method:\n\n```cpp\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string encode(std::string message) {\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> incr_list(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> incrList(ArrayList<Long> l) {\n        return l.stream().map(e -> e + 1).collect(Collectors.toCollection(ArrayList::new));\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `incrList` that takes an ArrayList of Long integers and returns a new ArrayList with each element incremented by 1. The function uses Java 8 streams to map each element to its incremented value, and then collects the results into a new ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> incr_list(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string flip_case(std::string string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String flipCase(String string) {\n        return Stream.of(string.split(\"\"))\n            .map(s -> s.equals(s.toUpperCase()) ? s.toLowerCase() : s.toUpperCase())\n            .collect(Collectors.joining(\"\"));\n    }\n}\n\n### Explanation\n\nThis program defines a function called `flipCase` that takes a string as input and returns a new string where the case of each letter is flipped. The function does this by splitting the input string into an array of individual characters, then mapping over each character and checking if it is uppercase. If it is, it is converted to lowercase, and vice versa. Finally, the mapped characters are joined back together into a single string and returned. \n\nTo rewrite this program in C++, you would need to define a function with the same name and input parameters, and then implement the same logic for flipping the case of each character in the string. You would also need to include any necessary libraries for working with strings and streams. Here is an example implementation in C++:\n\n```cpp\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string flip_case(std::string string) {\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong vowels_count(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long vowelsCount(String s) {\n        String vowels = \"aeiouAEIOU\";\n        long nVowels = s.chars().filter(c -> vowels.indexOf(c) != -1).count();\n        if (s.charAt(s.length()-1) == 'y' || s.charAt(s.length()-1) == 'Y') {\n            nVowels++;\n        }\n        return nVowels;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `vowelsCount`. This method takes a string as input and returns the number of vowels in the string. The method first defines a string called `vowels` which contains all the vowels in both upper and lower case. It then uses the `chars` method of the `String` class to get a stream of integer values corresponding to the Unicode code points of the characters in the string. It then uses the `filter` method of the `IntStream` class to keep only those code points that correspond to vowels (i.e., those that are in the `vowels` string). Finally, it uses the `count` method of the `LongStream` class to count the number of remaining code points, which is the number of vowels in the string. If the last character of the string is 'y' or 'Y', it adds one to the count, since 'y' and 'Y' can sometimes be considered vowels.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong vowels_count(std::string s) {\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> sortedListSum(ArrayList<String> lst) {\n        lst.sort(null);\n        ArrayList<String> new_lst = new ArrayList<String>();\n        for (String i : lst) {\n            if (i.length() % 2 == 0) {\n                new_lst.add(i);\n            }\n        }\n        new_lst.sort((a, b) -> a.length() - b.length());\n        return new_lst;\n    }\n}\n\n### Explanation\n\nThis program sorts a list of strings in ascending order, then creates a new list with only the even-length strings from the original list. The new list is then sorted in ascending order by string length and returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> words_string(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> wordsString(String s) {\n        if (s.isEmpty()) {\n            return new ArrayList<String>();\n        }\n\n        ArrayList<String> sList = new ArrayList<String>();\n\n        for (char c : s.toCharArray()) {\n            if (c == ',') {\n                sList.add(\" \");\n            } else {\n                sList.add(Character.toString(c));\n            }\n        }\n\n        String joinedString = String.join(\"\", sList);\n        return new ArrayList<String>(Arrays.asList(joinedString.split(\"\\\\s+\")));\n    }\n}\n\n### Explanation\n\nThis program defines a function `wordsString` that takes a string as input and returns a list of words in the string. The function first checks if the input string is empty and returns an empty list if it is. Otherwise, it creates an empty list `sList` and iterates through each character in the input string. If the character is a comma, it adds a space to `sList`, otherwise it adds the character as a string. It then joins the strings in `sList` together into a single string `joinedString` and splits it into a list of words using whitespace as the delimiter. The list of words is returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> words_string(std::string s) {\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat triangle_area(long a, long b, long c) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static float triangleArea(long a, long b, long c) {\n        float s = (a + b + c) / 2.0f;\n        float area = (float) Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        return a + b <= c || a + c <= b || b + c <= a ? -1 : Math.round(area * 100.0f) / 100.0f;\n    }\n}\n\n### Explanation\n\nThis program defines a function `triangleArea` that takes three long integers as input and returns a float. The function calculates the area of a triangle using Heron's formula and rounds the result to two decimal places. If the input values do not form a valid triangle (i.e. the sum of any two sides is less than or equal to the third side), the function returns -1. \n\nThe program imports several Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. However, none of these libraries are actually used in the `triangleArea` function. \n\nTo rewrite this program in C++, you would need to define a similar function that takes three long integers as input and returns a float. You would also need to include the necessary C++ libraries for math functions and input/output. \n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat triangle_area(long a, long b, long c) {\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean checkDictCase(HashMap<String,String> dict) {\n        if (dict.keySet().size() == 0) {\n            return false;\n        } else {\n            String state = \"start\";\n            for (String key : dict.keySet()) {\n                if (!(key instanceof String)) {\n                    state = \"mixed\";\n                    break;\n                }\n                if (state == \"start\") {\n                    if (key.matches(\"^[A-Z]+$\")) {\n                        state = \"upper\";\n                    } else if (key.matches(\"^[a-z]+$\")) {\n                        state = \"lower\";\n                    } else {\n                        break;\n                    }\n                } else if ((state == \"upper\" && !key.matches(\"^[A-Z]+$\")) || (state == \"lower\" && !key.matches(\"^[a-z]+$\"))) {\n                    state = \"mixed\";\n                    break;\n                } else {\n                    break;\n                }\n            }\n            return state == \"upper\" || state == \"lower\";\n        }\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `checkDictCase` that takes a dictionary (HashMap) of strings as input. The function returns true if all keys in the dictionary are either all uppercase or all lowercase, and false otherwise. The function first checks if the dictionary is empty, and returns false if it is. Otherwise, it iterates over the keys in the dictionary and checks if they are all of the same case (either all uppercase or all lowercase). If they are not, the function returns false. If all keys are of the same case, the function returns true.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n"
  },
  {
    "name": "HumanEval_130_tri",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> tri(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_130_tri.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> tri(long n) {\n        if (n == 0) {\n            return new ArrayList<Long>(Arrays.asList(1L));\n        }\n        ArrayList<Long> my_tri = new ArrayList<Long>(Arrays.asList(1L, 3L));\n        for (int i = 2; i <= n; i++) {\n            long term = i % 2 == 0 ? i / 2 + 1 : my_tri.get(i - 1) + my_tri.get(i - 2) + (i + 3) / 2;\n            my_tri.add(term);\n        }\n        return my_tri;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `tri` that takes in a long integer `n` and returns an ArrayList of long integers. The ArrayList contains the first `n` terms of a sequence of numbers called the \"triangular numbers\". The first term is 1, and each subsequent term is the sum of the previous term and the next integer. For example, the first few terms of the sequence are:\n\n1, 3, 6, 10, 15, 21, ...\n\nThe function calculates the triangular numbers using a loop that iterates from 2 to `n`. For each iteration, it calculates the next term in the sequence using a formula that depends on whether the iteration number is even or odd. If the iteration number is even, the formula is `i / 2 + 1`. If the iteration number is odd, the formula is `my_tri.get(i - 1) + my_tri.get(i - 2) + (i + 3) / 2`. The function returns the ArrayList of triangular numbers.\n\nTo rewrite this program in C++, you would need to replace the Java-specific syntax with C++ equivalents. For example, you would need to replace `ArrayList<Long>` with `vector<long>` and `Arrays.asList` with `vector<long>{}`. You would also need to replace the Java-specific classes and methods with C++ equivalents. For example, you would need to replace `Math` with `cmath` and `System.out.println` with `cout`. Finally, you would need to translate the Java-specific syntax of the loop and the conditional statements into C++ syntax. For example, you would need to replace `for (int i = 2; i <= n; i++)` with `for (int i = 2; i <= n; i++)` and `i % 2 == 0 ? i / 2 + 1 : my_tri.get(i - 1) + my_tri.get(i - 2) + (i + 3) / 2` with `i % 2 == 0 ? i / 2 + 1 : my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2`. The resulting C++ program would be functionally equivalent to the original Java program.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> tri(long n) {\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat median(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static float median(ArrayList<Long> l) {\n        Collections.sort(l);\n        int n = l.size();\n        if (n % 2 == 1) {\n            return l.get(n / 2);\n        } else {\n            return (l.get(n / 2 - 1) + l.get(n / 2)) / 2.0f;\n        }\n    }\n}\n\n### Explanation\n\nThis program defines a function `median` that takes an ArrayList of Longs and returns their median. The median is calculated by sorting the ArrayList and then returning the middle element if the ArrayList has an odd number of elements, or the average of the two middle elements if the ArrayList has an even number of elements.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat median(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string change_base(long x, long base) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String changeBase(long x, long base) {\n        String ret = \"\";\n        while (x > 0) {\n            ret = x % base + ret;\n            x /= base;\n        }\n        return ret;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `changeBase` that takes two arguments, a long integer `x` and a long integer `base`. The function returns a string that represents the base `base` representation of the number `x`. \n\nThe function works by repeatedly dividing `x` by `base` and adding the remainder to the beginning of the result string. This process continues until `x` is zero. \n\nTo use this function, call it with the desired `x` and `base` values and store the result in a string variable.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string change_base(long x, long base) {\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Optional<String> longest(ArrayList<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longest = strings.get(0);\n        for (String s : strings) {\n            if (s.length() > longest.length()) {\n                longest = s;\n            }\n        }\n        return Optional.of(longest);\n    }\n}\n\n### Explanation\n\nThis Java program defines a class called \"Problem\" that contains a static method called \"longest\". The method takes an ArrayList of Strings as an argument and returns an Optional String. If the ArrayList is empty, the method returns an empty Optional. Otherwise, it iterates over the Strings in the ArrayList and returns an Optional containing the longest String. \n\nTo rewrite this program in C++, you would need to replace the ArrayList with a vector, and replace the Optional with a std::optional (C++17 or later) or boost::optional (C++11 or later). You would also need to replace the for-each loop with a standard for loop. The resulting C++ code might look something like this:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    // In this Kata, you have to sort an array array list of non-negative integers according to\n    // number of ones in their binary representation in ascending order.\n    // For similar number of ones, sort based on decimal value.\n    // It must be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4])\n    // [1, 2, 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6])\n    // [-6, -5, -4, -3, -2]\n    // >>> sort_array([1, 0, 2, 3, 4])\n    // [0, 1, 2, 3, 4]\n    public static ArrayList<Long> sortArray(ArrayList<Long> arr) {\n        return arr.stream().sorted((a, b) -> {\n            int aCount = Long.bitCount(Math.abs(a));\n            int bCount = Long.bitCount(Math.abs(b));\n            if (aCount == bCount) {\n                return Long.compare(a, b);\n            }\n            return Integer.compare(aCount, bCount);\n        }).collect(Collectors.toCollection(ArrayList::new));\n    }\n}\n\n### Explanation\n\nThis Java program sorts an array list of non-negative integers according to the number of ones in their binary representation in ascending order. For similar number of ones, it sorts based on decimal value. The function `sortArray` takes an ArrayList of Longs and returns a sorted ArrayList of Longs. The function uses Java 8 streams to sort the ArrayList. The `sorted` method takes a lambda expression that compares two Longs. The lambda expression first counts the number of ones in the binary representation of the two Longs. If the counts are equal, the lambda expression compares the two Longs based on their decimal value. Finally, the `collect` method is used to collect the sorted Longs into a new ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long> l2) {\n        Set<Long> set = new HashSet<>(l1);\n        set.retainAll(l2);\n        ArrayList<Long> ret = new ArrayList<>(set);\n        Collections.sort(ret);\n        return ret;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `common`. The `common` method takes two arguments, both of which are `ArrayList<Long>` objects. The method returns a new `ArrayList<Long>` object that contains the intersection of the two input lists. The returned list is sorted in ascending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool cycpattern_check(std::string a, std::string b) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean cycpatternCheck(String a, String b) {\n        int l = b.length();\n        String pat = b + b;\n        for (int i = 0; i <= a.length() - l; i++) {\n            for (int j = 0; j <= l; j++) {\n                if (a.substring(i, i+l).equals(pat.substring(j, j+l))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n### Explanation\n\nThis program defines a function `cycpatternCheck` that takes two strings `a` and `b` as input. The function returns `true` if `b` is a cyclic pattern of `a`, and `false` otherwise. A cyclic pattern means that `b` can be obtained by concatenating `a` with itself any number of times and then taking a substring of the resulting string. The function checks all possible substrings of `a` of length `l`, where `l` is the length of `b`, and checks if `b` is a substring of the concatenation of the substring with itself. If `b` is found, the function returns `true`, otherwise it returns `false`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool cycpattern_check(std::string a, std::string b) {\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong minSubArraySum(std::vector<long> nums) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long minSubArraySum(ArrayList<Long> nums) {\n        long max_sum = 0;\n        long s = 0;\n        for (long num : nums) {\n            s += -num;\n            if (s < 0) {\n                s = 0;\n            }\n            max_sum = Math.max(s, max_sum);\n        }\n        if (max_sum == 0) {\n            max_sum = nums.stream().mapToLong(i -> -i).max().getAsLong();\n        }\n        long min_sum = -max_sum;\n        return min_sum;\n    }\n}\n\n### Explanation\n\nThis program takes an ArrayList of Longs and returns the minimum subarray sum. It does this by iterating through the ArrayList and keeping track of the maximum sum and the current sum. If the current sum becomes negative, it is reset to 0. If the maximum sum is 0, it is set to the maximum negative value in the ArrayList. Finally, the minimum sum is calculated as the negative of the maximum sum and returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong minSubArraySum(std::vector<long> nums) {\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::map<std::string,long> histogram(std::string test) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static HashMap<String,Long> histogram(String test) {\n        HashMap<String,Long> dict1=new HashMap<String,Long>();\n        List<String> list1=Arrays.asList(test.split(\" \"));\n        long t=0;\n        for(String i:list1) {\n            if(Collections.frequency(list1,i)>t && !i.equals(\"\")) {\n                t=Collections.frequency(list1,i);\n            }\n        }\n        if(t>0) {\n            for(String i:list1) {\n                if(Collections.frequency(list1,i)==t) {\n                    dict1.put(i,t);\n                }\n            }\n        }\n        return dict1;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function called `histogram` that takes a string as input and returns a hash map with the frequency of the most common word in the string. The function first splits the string into a list of words, then iterates over the list to find the frequency of the most common word. It then iterates over the list again to add any words with that frequency to the hash map. The hash map is then returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::map<std::string,long> histogram(std::string test) {\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> get_odd_collatz(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> getOddCollatz(long n) {\n        ArrayList<Long> oddCollatz = new ArrayList<Long>();\n        if (n % 2 == 1) {\n            oddCollatz.add(n);\n        }\n        while (n > 1) {\n            if (n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = n * 3 + 1;\n            }\n            if (n % 2 == 1) {\n                oddCollatz.add(n);\n            }\n        }\n        oddCollatz.sort(null);\n        return oddCollatz;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `getOddCollatz` that takes an integer `n` and returns an ArrayList of all odd numbers in the Collatz sequence starting from `n`. The Collatz sequence is defined as follows: if `n` is even, divide it by 2; if `n` is odd, multiply it by 3 and add 1. Repeat this process until `n` becomes 1. The function first checks if `n` is odd and adds it to the ArrayList if it is. Then it repeatedly applies the Collatz sequence until `n` becomes 1, adding each odd number to the ArrayList along the way. Finally, it sorts the ArrayList and returns it.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> get_odd_collatz(long n) {\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> derivative(std::vector<long> xs) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> derivative(ArrayList<Long> xs) {\n        return IntStream.range(1, xs.size()).mapToObj(i -> i * xs.get(i)).collect(Collectors.toCollection(ArrayList::new));\n    }\n}\n\n### Explanation\n\nThis program defines a function called `derivative` that takes an ArrayList of Longs as input and returns another ArrayList of Longs as output. The output ArrayList is the derivative of the input ArrayList. The derivative of an ArrayList of Longs is an ArrayList of Longs where each element is the product of the index of the element and the value of the element. For example, if the input ArrayList is [1, 2, 3, 4], the output ArrayList is [0, 2, 6, 12].\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> derivative(std::vector<long> xs) {\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fibfib(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long fibfib(long n) {\n        return n == 0 ? 0 : n == 1 ? 0 : n == 2 ? 1 : fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n    }\n}\n\n### Explanation\n\nThis program defines a function called `fibfib` which returns the nth number in the Fibonacci sequence. The function is defined recursively, with the base cases being 0 and 1. The function is then called with the argument `n - 1` and `n - 2` and `n - 3` to get the nth number in the sequence.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fibfib(long n) {\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat truncate_number(float number) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static float truncateNumber(float number) {\n        return number % 1.0f;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` that has a single static method called `truncateNumber` that takes a single float argument and returns the float modulo 1.0f. The modulo operator returns the remainder of a division operation. The program imports several Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. The program also uses the `java.util.stream` package. The purpose of these libraries is not clear from the code provided, but they may be used elsewhere in the program. To rewrite this program in C++, you would need to define a class called `Problem` with a single static method called `truncateNumber` that takes a single float argument and returns the float modulo 1.0f. You would also need to include any necessary C++ libraries.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat truncate_number(float number) {\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong max_element(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long maxElement(ArrayList<Long> l) {\n        long m = l.get(0);\n        for (long e : l) {\n            m = Math.max(m, e);\n        }\n        return m;\n    }\n}\n\n### Explanation\n\nThis program defines a function `maxElement` that takes an ArrayList of longs and returns the maximum element. It does this by iterating through the list and keeping track of the maximum element seen so far. The function is defined as static, so it can be called without creating an instance of the class. The program imports several Java libraries, including `java.util.*`, `java.lang.reflect.*`, `org.javatuples.*`, `java.security.*`, `java.math.*`, and `java.io.*`. It also uses a for-each loop to iterate through the list, and the `Math.max` function to compare elements. To rewrite this program in C++, you would need to replace the ArrayList with a vector, and use a for loop instead of a for-each loop. You would also need to include the appropriate C++ libraries for any functions used in the program.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong max_element(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong closest_integer(std::string value) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long closestInteger(String value) {\n        if (value == null || value.length() == 0) return 0;\n        if (value.indexOf('.') == -1) return Long.parseLong(value);\n        value = value.replaceAll(\"0*$\", \"\");\n        double num = Double.parseDouble(value);\n        if (value.endsWith(\".5\")) {\n            return (long)(num > 0 ? Math.ceil(num) : Math.floor(num));\n        } else {\n            return Math.round(num);\n        }\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function called `closestInteger` that takes a string as input and returns a long. The function first checks if the input is null or empty, and if so, returns 0. It then checks if the input contains a decimal point, and if not, returns the long value of the input. If the input ends with \".5\", the function returns the ceiling of the input if it is positive, and the floor of the input if it is negative. Otherwise, the function returns the rounded value of the input. \n\nTo rewrite this program in C++, you would need to include the necessary libraries and replace the `long` and `double` types with their C++ equivalents. You would also need to replace the `Math.ceil` and `Math.floor` functions with their C++ equivalents. \n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong closest_integer(std::string value) {\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong prime_fib(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long primeFib(long n) {\n        int[] f = {0, 1};\n        while (true) {\n            int next = f[0] + f[1];\n            f[0] = f[1];\n            f[1] = next;\n            if (isPrime(next)) {\n                n--;\n            }\n            if (n == 0) {\n                return next;\n            }\n        }\n    }\n    private static boolean isPrime(int p) {\n        if (p < 2) {\n            return false;\n        }\n        for (int k = 2; k <= Math.min((int)Math.sqrt(p) + 1, p - 1); k++) {\n            if (p % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `primeFib` that takes in a long integer `n` and returns the `n`th prime Fibonacci number. The function first initializes an array `f` with the first two Fibonacci numbers, and then iteratively computes the next Fibonacci number by summing the previous two. If the next Fibonacci number is prime, the function decrements `n`. Once `n` reaches 0, the function returns the last computed Fibonacci number. The function `isPrime` is a helper function that checks whether a given integer is prime.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong prime_fib(long n) {\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> sumProduct(ArrayList<Long> numbers) {\n        long sum = 0;\n        long prod = 1;\n        for (long n : numbers) {\n            sum += n;\n            prod *= n;\n        }\n        return Pair.with(sum, prod);\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function called `sumProduct` that takes an array of long integers and returns a pair of long integers. The first element of the pair is the sum of all the numbers in the array, and the second element of the pair is the product of all the numbers in the array. The function uses a for loop to iterate over the array and calculate the sum and product. The `Pair` class is used to return the two values as a single object. \n\nTo rewrite this program in C++, you would need to replace the `ArrayList` class with a `vector` and the `Pair` class with a `pair`. You would also need to change the syntax of the for loop to use iterators instead of a for-each loop. Here is an example of what the C++ code might look like:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> select_words(std::string s, long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> selectWords(String s, long n) {\n        ArrayList<String> result = new ArrayList<String>();\n        for (String word : s.split(\" \")) {\n            long n_consonants = 0;\n            for (int i = 0; i < word.length(); i++) {\n                if (!\"aeiouAEIOU\".contains(String.valueOf(word.charAt(i)))) {\n                    n_consonants++;\n                }\n            }\n            if (n_consonants == n) {\n                result.add(word);\n            }\n        }\n        return result;\n    }\n}\n\n### Explanation\n\nThis program defines a function called `selectWords` that takes in a string `s` and a long `n`. The function splits the string `s` into words and then counts the number of consonants in each word. If the number of consonants in a word is equal to `n`, then the word is added to an ArrayList called `result`. The function then returns the `result` ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> select_words(std::string s, long n) {\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong add_elements(std::vector<long> arr, long k) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long addElements(ArrayList<Long> arr, long k) {\n        return arr.stream().limit(k).filter(i -> i.toString().length() <= 2).mapToLong(i -> i).sum();\n    }\n    \n}\n\n### Explanation\n\nThis program defines a class called `Problem` which has a single static method called `addElements`. The method takes two arguments, an `ArrayList` of `Long` integers and a `long` integer. The method returns a `long` integer. \n\nThe method first limits the number of elements in the input array to `k`. It then filters out all elements that have a string representation longer than 2 characters. Finally, it sums up all the remaining elements and returns the result.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong add_elements(std::vector<long> arr, long k) {\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> eat(long number, long need, long remaining) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> eat(long number, long need, long remaining) {\n        return (need <= remaining) ? new ArrayList<Long>(Arrays.asList(number + need, remaining - need)) : new ArrayList<Long>(Arrays.asList(number + remaining, 0L));\n    }\n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` that has a static method called `eat`. The method takes three arguments: `number`, `need`, and `remaining`, all of which are of type `long`. The method returns an `ArrayList` of `Long` objects.\n\nThe method first checks if `need` is less than or equal to `remaining`. If it is, the method returns an `ArrayList` containing two `Long` objects: `number + need` and `remaining - need`. Otherwise, the method returns an `ArrayList` containing two `Long` objects: `number + remaining` and `0L`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> eat(long number, long need, long remaining) {\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> oddCount(ArrayList<String> lst) {\n        ArrayList<String> res = new ArrayList<String>();\n        for (String arr : lst) {\n            int n = (int) Arrays.stream(arr.split(\"\")).filter(d -> Integer.parseInt(d) % 2 == 1).count();\n            res.add(\"the number of odd elements \" + n + \"n the str\"+ n +\"ng \"+ n +\" of the \"+ n +\"nput.\");\n        }\n        return res;\n    }\n}\n\n### Explanation\n\nThis program takes an ArrayList of strings as input and returns an ArrayList of strings. For each string in the input ArrayList, it counts the number of odd digits in the string and returns a string that describes the count and the original string. The output string is then added to the output ArrayList. The program uses Java's stream API to filter the odd digits and count them. The output string is constructed using string concatenation. To rewrite this program in C++, you would need to replace the ArrayLists with vectors and use C++'s equivalent of the stream API to count the odd digits. You would also need to use C++'s string concatenation to construct the output string.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Optional<Long> nextSmallest(ArrayList<Long> lst) {\n        return lst.stream().sorted().distinct().skip(1).findFirst();\n    }\n    \n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` which contains a single static method called `nextSmallest`. The method takes an ArrayList of Longs as input and returns an Optional Long. The method returns the next smallest element in the list. If there is no such element, it returns an empty Optional.\n\nThe method works by first sorting the list in ascending order. It then removes any duplicates and skips the first element (which is the smallest element in the list). Finally, it returns the first element in the resulting stream (which is the next smallest element in the list).\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::optional<long> next_smallest(std::vector<long> lst) {\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Pair<Long, Long>> getRow(ArrayList<ArrayList<Long>> lst, long x) {\n        ArrayList<Pair<Long, Long>> coords = new ArrayList<Pair<Long, Long>>();\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    coords.add(new Pair<Long, Long>((long)i, (long)j));\n                }\n            }\n        }\n        coords.sort((a, b) -> {\n            if (a.getValue0() == b.getValue0()) {\n                return b.getValue1().compareTo(a.getValue1());\n            }\n            return a.getValue0().compareTo(b.getValue0());\n        });\n        return coords;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function called `getRow` that takes a 2D list of integers called `lst` and a single integer called `x`. The function returns a list of pairs of integers that represent the coordinates of all occurrences of `x` in `lst`. The pairs are sorted first by row (ascending) and then by column (descending).\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> filterByPrefix(ArrayList<String> strings, String prefix) {\n        return (ArrayList<String>)strings.stream().filter(s -> s.startsWith(prefix)).collect(Collectors.toList());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `filterByPrefix` that takes an array of strings and a string prefix as input. The function returns a new array of strings that only contains the strings that start with the given prefix. The function uses the Java 8 Stream API to filter the input array and collect the filtered strings into a new ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong choose_num(long x, long y) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long chooseNum(long x, long y) {\n        if (x > y) {\n            return -1;\n        }\n        if (y % 2 == 0) {\n            return y;\n        }\n        if (x == y) {\n            return -1;\n        }\n        return y - 1;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `chooseNum`. The method takes two arguments, `x` and `y`, both of which are long integers. If `x` is greater than `y`, the method returns `-1`. If `y` is even, the method returns `y`. If `x` is equal to `y`, the method returns `-1`. Otherwise, the method returns `y - 1`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong choose_num(long x, long y) {\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool prime_length(std::string string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean primeLength(String string) {\n        int l = string.length();\n        if (l <= 1) {\n            return false;\n        }\n        for (int i = 2; i < l; i++) {\n            if (l % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `primeLength`. The method takes a string as input and returns a boolean indicating whether the length of the string is a prime number. The method checks whether the length of the string is less than or equal to 1, and if so, returns false. Otherwise, it checks whether the length of the string is divisible by any number between 2 and the length of the string - 1, and if so, returns false. If the length of the string is not divisible by any number between 2 and the length of the string - 1, the method returns true.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool prime_length(std::string string) {\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong sum_to_n(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long sumToN(long n) {\n        return n * (n + 1) / 2;\n    }\n}\n\n### Explanation\n\nThis is a Java program that defines a class called `Problem` that has a single static method called `sumToN`. The `sumToN` method takes a single argument, `n`, which is a `long` integer. The method returns the sum of all integers from 1 to `n`, inclusive. The implementation of the method is based on the formula for the sum of an arithmetic series, which is `n * (n + 1) / 2`. \n\nTo rewrite this program in C++, you would need to define a similar class with a static method that takes a `long` integer as an argument and returns a `long` integer as the sum of all integers from 1 to `n`, inclusive. The implementation of the method would be the same as in the Java version. You would also need to include the necessary headers for the standard library functions and classes used in the Java version. \n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong sum_to_n(long n) {\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string fix_spaces(std::string text) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String fixSpaces(String text) {\n        String newText = \"\";\n        int i = 0;\n        int start = 0, end = 0;\n        while (i < text.length()) {\n            if (text.charAt(i) == ' ') {\n                end++;\n            } else {\n                if (end - start > 2) {\n                    newText += \"-\"+text.charAt(i);\n                } else if (end - start > 0) {\n                    newText += \"_\".repeat(end - start)+text.charAt(i);\n                } else {\n                    newText += text.charAt(i);\n                }\n                start = i+1; end = i+1;\n            }\n            i++;\n        }\n        if (end - start > 2) {\n            newText += \"-\";\n        } else if (end - start > 0) {\n            newText += \"_\";\n        }\n        return newText;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a single function called `fixSpaces` which takes a string as input and returns a string. The function replaces all spaces in the input string with either a single underscore or a hyphen followed by the next character in the string, depending on the number of consecutive spaces. If there are more than two consecutive spaces, a hyphen is used, otherwise an underscore is used. The output string is returned by the function.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string fix_spaces(std::string text) {\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> rollingMax(ArrayList<Long> numbers) {\n        long running_max = Long.MIN_VALUE;\n        ArrayList<Long> result = new ArrayList<Long>();\n\n        for (long n : numbers) {\n            running_max = Math.max(running_max, n);\n            result.add(running_max);\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis program defines a function called `rollingMax` that takes an ArrayList of Long integers and returns another ArrayList of Long integers. The returned ArrayList contains the maximum value seen so far in the input ArrayList up to that point. The function iterates over the input ArrayList, keeping track of the maximum value seen so far in a variable called `running_max`. For each element in the input ArrayList, the function adds the current `running_max` value to the output ArrayList and updates `running_max` to be the maximum of the current value and the previous `running_max`. \n\nTo rewrite this program in C++, you would need to replace the ArrayList data type with a vector and replace the Long data type with a long long. You would also need to include the necessary headers for the math functions used in the program. Here is an example of what the C++ code might look like:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string words_in_sentence(std::string sentence) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String wordsInSentence(String sentence) {\n        List<String> newLst = new ArrayList<>();\n        for (String word : sentence.split(\" \")) {\n            int flg = 0;\n            if (word.length() == 1) {\n                flg = 1;\n            }\n            for (int i = 2; i < word.length(); i++) {\n                if (word.length() % i == 0) {\n                    flg = 1;\n                }\n            }\n            if (flg == 0 || word.length() == 2) {\n                newLst.add(word);\n            }\n        }\n        return String.join(\" \", newLst);\n    }\n}\n\n### Explanation\n\nThis program takes in a string `sentence` and returns a new string with only the words that have a length of 1 or a length that is a prime number. The program first splits the input string into words and then iterates over each word. For each word, it checks if the length of the word is 1 or if it is a prime number. If either of these conditions are true, the word is added to a new list of words. Finally, the program joins the words in the new list together with spaces and returns the resulting string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string words_in_sentence(std::string sentence) {\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string get_closest_vowel(std::string word) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String getClosestVowel(String word) {\n        String vowels = \"aeiouAEIOU\";\n        for (int i = word.length() - 2; i > 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                if (vowels.indexOf(word.charAt(i + 1)) == -1 && vowels.indexOf(word.charAt(i - 1)) == -1) {\n                    return word.charAt(i) + \"\";\n                }\n            }\n        }\n        return \"\";\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function called `getClosestVowel` that takes a string as input and returns a string. The function searches the input string for the closest vowel to the second-to-last character in the string. If there is a vowel immediately before or after the closest vowel, the function returns an empty string. Otherwise, the function returns the closest vowel.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string get_closest_vowel(std::string word) {\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> compare(ArrayList<Long> game, ArrayList<Long> guess) {\n        return (ArrayList<Long>) IntStream.range(0, game.size()).mapToObj(i -> Math.abs(game.get(i) - guess.get(i))).collect(Collectors.toList());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `compare` that takes two ArrayLists of Longs as input and returns an ArrayList of Longs. The function returns a new ArrayList that contains the absolute difference between each element of the two input ArrayLists. The function uses Java 8's Stream API to map each element of the input ArrayLists to its absolute difference and then collects the results into a new ArrayList. \n\nTo rewrite this program in C++, you would need to replace the ArrayLists with vectors and use a for loop to iterate over the elements of the vectors and calculate the absolute difference between each element. Here is an example C++ implementation of the same function:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> removeDuplicates(ArrayList<Long> numbers) {\n        Map<Long, Long> counts = new HashMap<>();\n        for (Long n : numbers) {\n            counts.put(n, counts.getOrDefault(n, 0L) + 1L);\n        }\n        return numbers.stream().filter(n -> counts.get(n) <= 1L).collect(Collectors.toCollection(ArrayList::new));\n    }\n    \n}\n\n### Explanation\n\nThis Java program defines a function `removeDuplicates` that takes an ArrayList of Longs and returns a new ArrayList of Longs with all duplicates removed. The function uses a HashMap to count the number of occurrences of each element in the input ArrayList, and then filters out all elements that occur more than once. The function then returns the filtered ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool same_chars(std::string s0, std::string s1) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean sameChars(String s0, String s1) {\n        return new HashSet<>(Arrays.asList(s0.split(\"\"))).equals(new HashSet<>(Arrays.asList(s1.split(\"\"))));\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `sameChars`. The method takes two strings as input and returns a boolean value. The method returns true if the two strings contain the same set of characters, and false otherwise. The method uses the `HashSet` class to determine the set of characters in each string, and then compares the two sets for equality.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool same_chars(std::string s0, std::string s1) {\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> parseNestedParens(String paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n\n        for (String s : paren_string.split(\" \")) {\n            long depth = 0;\n            long max_depth = 0;\n\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (c == '(') {\n                    depth += 1;\n                    max_depth = Math.max(depth, max_depth);\n                } else {\n                    depth -= 1;\n                }\n            }\n\n            result.add(max_depth);\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` with a single static method called `parseNestedParens` that takes a string as input and returns an ArrayList of long integers. The input string is assumed to be a space-separated list of strings, each of which is a sequence of parentheses. The output ArrayList contains the maximum depth of each sequence of parentheses in the input string. The depth of a sequence of parentheses is defined as the maximum number of nested parentheses that occur in the sequence. For example, the depth of the string \"((()))\" is 3, while the depth of the string \"()()()\" is 1. The program uses a loop to iterate over each string in the input, and then uses another loop to compute the depth of each string. The depth is computed by counting the number of open parentheses encountered while iterating over the string, and keeping track of the maximum number of open parentheses seen at any point during the iteration. The depth is then added to the output ArrayList. The program uses several built-in Java classes and libraries, including ArrayList, Math, and String. The program does not have any side effects, and does not modify any external state. It is a pure function that can be easily translated to C++ by replacing the ArrayList with a vector, and using the equivalent C++ functions for computing the maximum and splitting the input string.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<long, long> even_odd_count(long num) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddCount(long num) {\n        long evenCount = 0;\n        long oddCount = 0;\n        for (char i : Long.toString(Math.abs(num)).toCharArray()) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n        return Pair.with(evenCount, oddCount);\n    }\n}\n\n### Explanation\n\nThis program defines a function `evenOddCount` that takes a long integer `num` as input and returns a tuple of two long integers: the number of even digits in `num` and the number of odd digits in `num`. The function first converts `num` to a string, then iterates over each character in the string and increments either the `evenCount` or `oddCount` variable depending on whether the character is even or odd. The function then returns a tuple of the two counts. \n\nTo translate this program to C++, you would need to include the following libraries: `tuple`, `string`, `cmath`, `iostream`, and `algorithm`. You would then need to define a function with the same signature as `evenOddCount` that performs the same operations. You would also need to replace the `Pair` class with a `std::tuple` and replace the `Pair.with` method with a `std::make_tuple` call. Finally, you would need to replace the `long` data type with `long long` in C++. \n\nHere is the C++ version of the program:\n\n```cpp\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<long, long> even_odd_count(long num) {\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fruit_distribution(std::string s, long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long fruitDistribution(String s, long n) {\n        long sum = 0;\n        for (String i : s.split(\" \")) {\n            if (i.matches(\"\\\\d+\")) {\n                sum += Long.parseLong(i);\n            }\n        }\n        return n - sum;\n    }\n}\n\n### Explanation\n\nThis program takes in a string `s` and a long `n`. The string `s` is split by spaces and each element is checked to see if it is a number. If it is a number, it is added to a running total `sum`. The function returns the difference between `n` and `sum`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong fruit_distribution(std::string s, long n) {\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string string_xor(std::string a, std::string b) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String stringXor(String a, String b) {\n        return IntStream.range(0, a.length()).mapToObj(i -> a.charAt(i) == b.charAt(i) ? \"0\" : \"1\").collect(Collectors.joining());\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function called `stringXor` that takes two strings `a` and `b` and returns a string that is the result of performing a bitwise XOR operation on the two input strings. The function does this by iterating over the characters in the input strings and comparing them at each position. If the characters are the same, the corresponding bit in the output string is set to 0, otherwise it is set to 1. The program imports several Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`, but none of these are actually used in the `stringXor` function. To rewrite this program in C++, you would need to define a function with the same name and input parameters, and implement the same bitwise XOR logic using C++ syntax. You would not need to include any of the Java libraries that are imported in the original program.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string string_xor(std::string a, std::string b) {\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong string_length(std::string string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long strlen(String string) {\n        return string.length();\n    }\n}\n\n### Explanation\n\nThis program imports several libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. It then defines a class called `Problem` with a single static method called `strlen` that takes a string as input and returns the length of the string as a long integer.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong string_length(std::string string) {\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string string_sequence(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String stringSequence(long n) {\n        return LongStream.rangeClosed(0, n).mapToObj(Long::toString).collect(Collectors.joining(\" \"));\n    }\n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` with a single static method called `stringSequence`. The method takes a single argument `n` of type `long` and returns a `String`. The method returns a space-separated sequence of numbers from 0 to `n`, inclusive. The sequence is generated using a `LongStream` and the `mapToObj` method to convert each number to a `String`. The `collect` method is then used to join the resulting `String` objects with a space separator.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string string_sequence(long n) {\n"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string file_name_check(std::string file_name) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_141_file_name_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String fileNameCheck(String file_name) {\n        String[] suf = {\"txt\", \"exe\", \"dll\"};\n        String[] lst = file_name.split(\"\\\\.\");\n        if (lst.length != 2) {\n            return \"No\";\n        }\n        if (!Arrays.asList(suf).contains(lst[1])) {\n            return \"No\";\n        }\n        if (lst[0].length() == 0 || !Character.isLetter(lst[0].charAt(0))) {\n            return \"No\";\n        }\n        int t = lst[0].replaceAll(\"\\\\D\", \"\").length();\n        if (t > 3) {\n            return \"No\";\n        }\n        return \"Yes\";\n    }\n}\n\n### Explanation\n\nThis program defines a function `fileNameCheck` that takes a string `file_name` and returns \"Yes\" if the file name is valid and \"No\" otherwise. A valid file name has the following properties:\n\n- It has exactly one period separating the file name and extension.\n- The extension is one of \"txt\", \"exe\", or \"dll\".\n- The file name starts with a letter.\n- The file name contains at most three digits.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string file_name_check(std::string file_name) {\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong can_arrange(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long canArrange(ArrayList<Long> arr) {\n        long ind = -1;\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i-1)) {\n                ind = i;\n            }\n        }\n        return ind;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `canArrange`. The method takes an `ArrayList` of `Long` integers as input and returns a single `long` integer. The method iterates over the input array and returns the index of the first element that is smaller than the previous element. If no such element is found, it returns -1.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong can_arrange(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong add(std::vector<long> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long add(ArrayList<Long> lst) {\n        return IntStream.range(1, lst.size()).filter(i -> i % 2 != 0 && lst.get(i) % 2 == 0).mapToLong(i -> lst.get(i)).sum();\n    }\n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` with a single static method called `add`. The method takes an `ArrayList` of `Long` integers as input and returns a `long`. The method returns the sum of all even integers in the list that are at odd positions (1-based index).\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong add(std::vector<long> lst) {\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> intersperse(ArrayList<Long> numbers, long delimeter) {\n        ArrayList<Long> result = new ArrayList<Long>();\n\n        if (numbers.size() == 0) {\n            return result;\n        }\n\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            result.add(numbers.get(i));\n            result.add(delimeter);\n        }\n\n        result.add(numbers.get(numbers.size() - 1));\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis program defines a function `intersperse` that takes an ArrayList of Longs and a long delimeter. The function returns a new ArrayList where the delimeter is inserted between each element of the original ArrayList. If the original ArrayList is empty, the function returns an empty ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string match_parens(std::vector<std::string> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String matchParens(ArrayList<String> lst) {\n        return check(lst.get(0) + lst.get(1)) || check(lst.get(1) + lst.get(0)) ? \"Yes\" : \"No\";\n    }\n    public static boolean check(String s) {\n        int val = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                val++;\n            } else {\n                val--;\n            }\n            if (val < 0) {\n                return false;\n            }\n        }\n        return val == 0 ? true : false;\n    }\n    \n}\n\n### Explanation\n\nThis program takes an ArrayList of two strings, and checks if the two strings can be concatenated in any order to form a string with balanced parentheses. If the parentheses are balanced, it returns \"Yes\", otherwise it returns \"No\". \n\nThe check function takes a string as input and returns true if the parentheses in the string are balanced, and false otherwise. It does this by iterating through the string and keeping track of the number of open and closed parentheses. If the number of closed parentheses ever exceeds the number of open parentheses, the function returns false. Otherwise, if the number of open and closed parentheses are equal at the end of the string, the function returns true. \n\nTo rewrite this program in C++, you would need to replace the ArrayList with a vector, and replace the check function with a C++ equivalent. You would also need to include the appropriate libraries for the functions used in the Java program.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string match_parens(std::vector<std::string> lst) {\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> filterBySubstring(ArrayList<String> strings, String substring) {\n        return strings.stream().filter(x -> x.contains(substring)).collect(Collectors.toCollection(ArrayList::new));\n    }\n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` with a single static method called `filterBySubstring`. The method takes two arguments: an ArrayList of Strings called `strings`, and a String called `substring`. The method returns a new ArrayList of Strings containing only the elements of the original ArrayList that contain the given substring. The method uses Java 8 streams to filter the ArrayList, and then collects the filtered elements into a new ArrayList using the `Collectors.toCollection` method. \n\nTo rewrite this program in C++, you would need to define a function that takes an `std::vector<std::string>` and a `std::string` as arguments, and returns a new `std::vector<std::string>` containing only the elements of the original vector that contain the given substring. You could use the `std::copy_if` algorithm to filter the vector, and then use the `std::back_inserter` iterator to insert the filtered elements into a new vector. Here's an example implementation:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string find_max(std::vector<std::string> words) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String findMax(ArrayList<String> words) {\n        return words.stream()\n            .sorted(Comparator.comparing((String s) -> -s.chars().distinct().count())\n                    .thenComparing(Comparator.naturalOrder()))\n            .findFirst().get();\n    }\n    \n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `findMax`. The method takes an `ArrayList` of `String`s called `words` as input and returns a `String`. The method returns the `String` in the `ArrayList` that has the most unique characters. If there are multiple `String`s with the same number of unique characters, the method returns the lexicographically smallest one. \n\nThe method uses the `Stream` API to sort the `ArrayList` of `String`s. The `sorted` method takes a `Comparator` object as input. The `Comparator` object is created using the `Comparator.comparing` method, which takes a lambda function as input. The lambda function returns the number of unique characters in a `String`. The `Comparator` object is then chained with another `Comparator` object created using the `Comparator.thenComparing` method. This `Comparator` object sorts the `String`s lexicographically. The `findFirst` method is then called on the `Stream` object to get the first `String` in the sorted `ArrayList`. \n\nTo rewrite this program in C++, you would need to replace the `ArrayList` with a `vector`, the `Stream` API with a `for` loop, and the lambda function with a custom comparison function. Here is an example implementation in C++:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string find_max(std::vector<std::string> words) {\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> generate_integers(long a, long b) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> generateIntegers(long a, long b) {\n        long lower = Math.max(2, Math.min(a, b));\n        long upper = Math.min(8, Math.max(a, b));\n        ArrayList<Long> res = new ArrayList<>();\n        for (long i = lower; i <= upper; i++) {\n            if (i % 2 == 0) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}\n\n### Explanation\n\nThis program defines a function `generateIntegers` that takes two long integers as input and returns an ArrayList of long integers. The function returns an ArrayList of even numbers between the two input numbers, inclusive. If the input numbers are the same, the function returns an empty ArrayList. If the input numbers are not even, the function returns an empty ArrayList. The function uses the Math.max and Math.min functions to determine the lower and upper bounds of the range of numbers to be generated. The function then uses a for loop to iterate over the range of numbers and add the even numbers to the ArrayList. Finally, the function returns the ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> generate_integers(long a, long b) {\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String exchange(ArrayList<Long> lst1, ArrayList<Long> lst2) {\n        long odd = lst1.stream().filter(i -> i % 2 == 1).count();\n        long even = lst2.stream().filter(i -> i % 2 == 0).count();\n        return even >= odd ? \"YES\" : \"NO\";\n    }\n}\n\n### Explanation\n\nThis program defines a function called `exchange` that takes two lists of long integers as input. The function counts the number of odd integers in the first list and the number of even integers in the second list. If the number of even integers is greater than or equal to the number of odd integers, the function returns the string \"YES\", otherwise it returns \"NO\". \n\nTo rewrite this program in C++, you would need to replace the Java-specific syntax with equivalent C++ syntax. For example, you would need to replace `ArrayList<Long>` with `vector<long long>`, and `stream()` with a for loop or range-based for loop. You would also need to include the appropriate headers for the libraries used in the Java version. Here is an example C++ implementation:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string int_to_mini_roman(long number) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String intToMiniRoman(long number) {\n        long[] num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n        String[] sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\n        int i = 12;\n        String res = \"\";\n        while (number > 0) {\n            long div = number / num[i];\n            number %= num[i];\n            while (div > 0) {\n                res += sym[i];\n                div--;\n            }\n            i--;\n        }\n        return res.toLowerCase();\n    }\n}\n\n### Explanation\n\nThis program defines a function `intToMiniRoman` that takes an integer and returns a string. The string is the Roman numeral representation of the integer, but with some abbreviations. For example, 4 is represented as \"iv\" instead of \"iiii\". The function works by iterating through an array of Roman numeral values and symbols, and adding the appropriate symbols to the result string. The function then returns the result string in lowercase.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string int_to_mini_roman(long number) {\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_equal_to_sum_even(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isEqualToSumEven(long n) {\n        return n%2 == 0 && n > 7;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `isEqualToSumEven`. The method takes a single argument, a `long` integer, and returns a boolean. The method returns `true` if the input integer is even and greater than 7, and `false` otherwise.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_equal_to_sum_even(long n) {\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string decimal_to_binary(long decimal) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String decimalToBinary(long decimal) {\n        return \"db\" + Long.toBinaryString(decimal) + \"db\";\n    }\n}\n\n### Explanation\n\nThis program defines a class `Problem` with a single static method `decimalToBinary` that takes a `long` integer and returns a `String` with the binary representation of the input. The returned string is prefixed with the string \"db\".\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string decimal_to_binary(long decimal) {\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_third(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortThird(ArrayList<Long> l) {\n        for (int i=2; i<l.size(); i+=3) {\n            int j=i-2;\n            while (j>=0 && l.get(j+3)<l.get(j)) {\n                long tmp=l.get(j);\n                l.set(j,l.get(j+3));\n                l.set(j+3,tmp);\n                j-=3;\n            }\n        }\n        return l;\n    }\n    \n}\n\n### Explanation\n\nThis Java program defines a function called `sortThird` that takes an array of long integers as input and returns the same array sorted by its third element. The sorting is done in-place using an insertion sort algorithm. The function iterates over the array in steps of 3, starting from the third element, and for each group of 3 elements, it compares the third element with the third element of the previous group and swaps them if necessary until the third element of the current group is greater than or equal to the third element of the previous group. The function then returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_third(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool simplify(std::string x, std::string n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean simplify(String x, String n) {\n        String[] a = x.split(\"/\");\n        String[] b = n.split(\"/\");\n        int numerator = Integer.parseInt(a[0]) * Integer.parseInt(b[0]);\n        int denom = Integer.parseInt(a[1]) * Integer.parseInt(b[1]);\n        return numerator % denom == 0;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `simplify`. The method takes two strings as input, `x` and `n`. The strings are expected to be in the format of a fraction, e.g. \"1/2\". The method returns a boolean indicating whether the fraction `x` can be simplified by `n`.\n\nTo simplify a fraction, we need to multiply both the numerator and denominator by the same number. To check if `x` can be simplified by `n`, we first split the strings into their numerator and denominator components. We then multiply the numerators and denominators together to get a common denominator. If the numerator is divisible by the denominator, then the fraction can be simplified by `n`, and we return `true`. Otherwise, we return `false`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool simplify(std::string x, std::string n) {\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string solve(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String solve(String s) {\n        int flg = 0;\n        int idx = 0;\n        char[] newStr = s.toCharArray();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                newStr[idx] = Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\n                flg = 1;\n            }\n            idx++;\n        }\n        if (flg == 0) {\n            return new StringBuilder(s).reverse().toString();\n        }\n        return new String(newStr);\n    }\n}\n\n### Explanation\n\nThis program takes a string as input and returns a modified version of the string. The modified version of the string is obtained by swapping the case of all the letters in the string. If the input string does not contain any letters, the program returns the reverse of the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string solve(std::string s) {\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool right_angle_triangle(long a, long b, long c) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean rightAngleTriangle(long a, long b, long c) {\n        return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b;\n    }\n}\n\n### Explanation\n\nThis program defines a function `rightAngleTriangle` that takes three long integers `a`, `b`, and `c` as input and returns a boolean value. The function returns true if the input values represent the sides of a right-angled triangle, and false otherwise. A right-angled triangle is one in which the square of the length of one side is equal to the sum of the squares of the lengths of the other two sides. \n\nTo rewrite this program in C++, you would need to include the necessary headers and define the function in a similar way. Here is an example implementation in C++:\n\n```cpp\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool right_angle_triangle(long a, long b, long c) {\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong double_the_difference(std::vector<float> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long doubleTheDifference(ArrayList<Float> lst) {\n        return lst.stream().filter(i -> i > 0 && i%2!=0 && i == Math.floor(i)).mapToLong(i -> (long) Math.pow(i, 2)).sum();\n    }\n}\n\n### Explanation\n\nThis program takes in an ArrayList of Floats and returns the sum of the squares of all the odd positive integers in the list.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong double_the_difference(std::vector<float> lst) {\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool below_zero(std::vector<long> operations) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean belowZero(ArrayList<Long> operations) {\n        long balance = 0;\n        for (long op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n### Explanation\n\nThis program defines a function called `belowZero` that takes an ArrayList of long integers as input. The function returns a boolean value. The function iterates over the input list and keeps a running total of the sum of the elements. If the running total ever becomes negative, the function returns true. Otherwise, it returns false. \n\nTo translate this program to C++, you would need to replace the ArrayList with a vector, and change the syntax for iterating over the vector. You would also need to include the appropriate headers for the libraries used in the Java version. Here is an example C++ implementation:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool below_zero(std::vector<long> operations) {\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong greatest_common_divisor(long a, long b) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long greatestCommonDivisor(long a, long b) {\n        while (b != 0) {\n            long t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n}\n\n### Explanation\n\nThis is a Java program that defines a function called `greatestCommonDivisor` that takes two long integers as input and returns their greatest common divisor. The function uses the Euclidean algorithm to calculate the greatest common divisor. The program imports several Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. It also uses a `while` loop to iterate through the Euclidean algorithm until the greatest common divisor is found.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong greatest_common_divisor(long a, long b) {\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> f(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> f(long n) {\n        ArrayList<Long> ret = new ArrayList<Long>();\n        for (long i=1; i<=n; i++) {\n            if (i%2 == 0) {\n                long x = 1;\n                for (long j=1; j<=i; j++) x *= j;\n                ret.add(x);\n            } else {\n                long x = 0;\n                for (long j=1; j<=i; j++) x += j;\n                ret.add(x);\n            }\n        }\n        return ret;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `f` that takes a long integer `n` as input and returns an ArrayList of long integers. The ArrayList contains `n` elements. If the index of the element is even, the element is the factorial of the index. If the index of the element is odd, the element is the sum of the first `i` integers.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> f(long n) {\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool monotonic(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean monotonic(ArrayList<Long> l) {\n        if (l.equals(l.stream().sorted().collect(Collectors.toList())) || l.equals(l.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()))) {\n            return true;\n        }\n        return false;\n    }\n}\n\n### Explanation\n\nThis program defines a function `monotonic` that takes an ArrayList of Longs and returns a boolean. The function returns true if the ArrayList is sorted in either ascending or descending order, and false otherwise.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool monotonic(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> byLength(ArrayList<Long> arr) {\n        String[] dic = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        ArrayList<Long> sortedArr = (ArrayList<Long>) arr.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());\n        ArrayList<String> newArr = new ArrayList<String>();\n        for (Long var : sortedArr) {\n            if (var >= 1 && var <= 9) {\n                newArr.add(dic[var.intValue()-1]);\n            }\n        }\n        return newArr;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `byLength` that takes in an ArrayList of Longs and returns an ArrayList of Strings. The function sorts the input ArrayList in descending order, and then creates a new ArrayList of Strings. The function then iterates through the sorted ArrayList of Longs, and if the value of the Long is between 1 and 9 (inclusive), it adds the corresponding String value (\"One\", \"Two\", \"Three\", etc.) to the new ArrayList of Strings. The function then returns the new ArrayList of Strings.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string remove_vowels(std::string text) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String removeVowels(String text) {\n        return text.replaceAll(\"(?i)[aeiou]\", \"\");\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `removeVowels`. The method takes a single string argument called `text` and returns a new string with all vowels removed. The method uses the `replaceAll` method of the `String` class to replace all vowels with an empty string. The regular expression `\"(?i)[aeiou]\"` matches all vowels in a case-insensitive manner. The `(?i)` at the beginning of the regular expression specifies that the match should be case-insensitive. \n\nTo rewrite this program in C++, you would define a function called `removeVowels` that takes a `std::string` argument and returns a new `std::string` with all vowels removed. You would use the `std::regex_replace` function to replace all vowels with an empty string. The regular expression `\"[aeiouAEIOU]\"` matches all vowels in a case-insensitive manner. Here is an example implementation:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string remove_vowels(std::string text) {\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean checkIfLastCharIsALetter(String txt) {\n        String check = txt.substring(txt.lastIndexOf(' ')+1);\n        return (check.length() == 1 && (97 <= Character.toLowerCase(check.charAt(0)) && Character.toLowerCase(check.charAt(0)) <= 122));\n    }\n    \n}\n\n### Explanation\n\nThis program defines a single function called `checkIfLastCharIsALetter` which takes a string as input and returns a boolean. The function checks if the last character of the last word in the input string is a letter. If it is, the function returns true, otherwise it returns false.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool check_if_last_char_is_a_letter(std::string txt) {\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool iscube(long a) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean iscube(long a) {\n        a = Math.abs(a);\n        return Math.pow(Math.round(Math.cbrt(a)), 3) == a;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `iscube` that takes a long integer as input and returns a boolean. The function returns true if the input is a perfect cube, and false otherwise. The function first takes the absolute value of the input, then uses the `Math.cbrt` function to compute the cube root of the input. The result is rounded to the nearest integer using the `Math.round` function, and then cubed using the `Math.pow` function. If the result is equal to the original input, the function returns true, otherwise it returns false. \n\nTo rewrite this program in C++, you would need to include the appropriate headers and replace the `Math` functions with their C++ equivalents. For example, `Math.abs` would become `std::abs`, `Math.cbrt` would become `std::cbrt`, `Math.round` would become `std::round`, and `Math.pow` would become `std::pow`. You would also need to define the `iscube` function in a C++ program and call it appropriately. \n\nHere is an example C++ implementation of the `iscube` function:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool iscube(long a) {\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<String, Boolean> reverseDelete(String s, String c) {\n        s = s.chars().filter(ch -> c.indexOf(ch) == -1).mapToObj(Character::toString).collect(Collectors.joining());\n        return Pair.with(s, new StringBuilder(s).reverse().toString().equals(s));\n    }\n}\n\n### Explanation\n\nThis program defines a function `reverseDelete` that takes two strings `s` and `c` as input and returns a `Pair` object containing a string and a boolean. The function removes all characters from `s` that are also in `c`, reverses the resulting string, and returns a `Pair` object containing the resulting string and a boolean indicating whether the resulting string is a palindrome.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static float meanAbsoluteDeviation(ArrayList<Float> numbers) {\n        float mean = numbers.stream().reduce(0.0f, Float::sum) / numbers.size();\n        return numbers.stream().map(x -> Math.abs(x - mean)).reduce(0.0f, Float::sum) / numbers.size();\n    }\n}\n\n### Explanation\n\nThis Java program defines a class called `Problem` that has a single static method called `meanAbsoluteDeviation`. The method takes an ArrayList of floats called `numbers` as input and returns a float. The method first calculates the mean of the input numbers using the `reduce` method of the `Stream` class and then calculates the mean absolute deviation of the input numbers using the `map` and `reduce` methods of the `Stream` class. The mean absolute deviation is the average of the absolute differences between each number and the mean. The method then returns the mean absolute deviation.\n\nTo rewrite this program in C++, you would need to use the C++ equivalent of the Java classes and methods used in the program. For example, you would need to use the `vector` class instead of the `ArrayList` class, and you would need to use the `accumulate` function instead of the `reduce` method. You would also need to use the `abs` function instead of the `Math.abs` method. Here is an example C++ implementation of the `meanAbsoluteDeviation` method:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool correct_bracketing(std::string brackets) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean correctBracketing(String brackets) {\n        int depth = 0;\n        for (char b : brackets.toCharArray()) {\n            if (b == '<') {\n                depth++;\n            } else {\n                depth--;\n            }\n            if (depth < 0) {\n                return false;\n            }\n        }\n        return depth == 0;\n    }\n}\n\n### Explanation\n\nThis program defines a function `correctBracketing` that takes a string of brackets and returns true if the brackets are correctly balanced. The function iterates over each character in the string, incrementing a counter for each `<` it encounters and decrementing it for each `>`. If the counter ever goes negative, the function returns false. If the counter is zero at the end of the string, the function returns true. To rewrite this program in C++, you would need to replace the Java-specific imports and use the appropriate syntax for the language. Here is an example implementation in C++:\n\n```cpp\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool correct_bracketing(std::string brackets) {\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Float> rescaleToUnit(ArrayList<Float> numbers) {\n        float minNumber = Collections.min(numbers);\n        float maxNumber = Collections.max(numbers);\n        return numbers.stream().map(x -> (x - minNumber) / (maxNumber - minNumber)).collect(Collectors.toCollection(ArrayList::new));\n    }\n}\n\n### Explanation\n\nThis program defines a function `rescaleToUnit` that takes in an ArrayList of floats and returns a new ArrayList of floats. The new ArrayList is the same as the input ArrayList, but with each element rescaled to be between 0 and 1. The rescaling is done by subtracting the minimum value in the input ArrayList from each element, and then dividing by the range of the input ArrayList (i.e. the difference between the maximum and minimum values). \n\nTo rewrite this program in C++, you would need to replace the ArrayList type with a C++ container that can hold floats (e.g. a vector), and replace the `Collections` and `Collectors` classes with equivalent C++ functions or algorithms. You would also need to include the appropriate headers for the libraries used in the Java program (e.g. `cmath` for math functions, `iostream` for input/output). Here is an example of what the C++ code might look like:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String intersection(Pair<Long, Long> interval1, Pair<Long, Long> interval2) {\n        long l = Math.max(interval1.getValue0(), interval2.getValue0());\n        long r = Math.min(interval1.getValue1(), interval2.getValue1());\n        long length = r - l;\n        if (length > 0 && isPrime(length)) {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n    private static boolean isPrime(long n) {\n        if (n == 1 || n == 0) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        for (long i = 2; i < n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with two methods. The `intersection` method takes two pairs of longs, which represent intervals, and returns \"YES\" if the intersection of the two intervals is a prime number, and \"NO\" otherwise. The `isPrime` method takes a long and returns true if it is prime, and false otherwise. The program uses several Java libraries, including `java.util`, `java.lang.reflect`, `org.javatuples`, `java.security`, `java.math`, and `java.io`. To rewrite this program in C++, you would need to replace the Java-specific libraries with their C++ equivalents, and translate the Java syntax into C++ syntax.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong hex_key(std::string num) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long hexKey(String num) {\n        String primes = \"2357BD\";\n        long total = 0;\n        for (int i = 0; i < num.length(); i++) {\n            if (primes.indexOf(num.charAt(i)) >= 0) {\n                total++;\n            }\n        }\n        return total;\n    }\n}\n\n### Explanation\n\nThis program defines a single function `hexKey` that takes a string as input and returns a long. The function counts the number of times that a character in the input string is one of the characters in the string \"2357BD\" and returns that count.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong hex_key(std::string num) {\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> strangeSortList(ArrayList<Long> lst) {\n        ArrayList<Long> res = new ArrayList<>();\n        boolean switch_ = true;\n        while (!lst.isEmpty()) {\n            res.add(switch_ ? Collections.min(lst) : Collections.max(lst));\n            lst.remove(res.get(res.size() - 1));\n            switch_ = !switch_;\n        }\n        return res;\n    }\n}\n\n### Explanation\n\nThis program defines a function called `strangeSortList` that takes an ArrayList of Longs as input and returns another ArrayList of Longs. The function sorts the input list in a strange way: it repeatedly adds the minimum or maximum element to the output list, alternating between the two, until the input list is empty. The sorted list is then returned. The function uses the `Collections.min` and `Collections.max` methods to find the minimum and maximum elements of the input list, respectively. The `boolean` variable `switch_` is used to alternate between adding the minimum and maximum elements to the output list.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong is_bored(std::string S) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long isBored(String S) {\n        String[] sentences = S.split(\"[.?!]\\\\s*\");\n        return Arrays.stream(sentences).filter(s -> s.startsWith(\"I \")).count();\n    }\n    \n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `isBored`. The method takes a single string argument `S` and returns a long integer.\n\nThe method first splits the input string `S` into an array of sentences by splitting on the characters `.`, `?`, and `!` followed by any number of whitespace characters. It then filters the array of sentences to only include those that start with the string `\"I \"`. Finally, it returns the count of the filtered array.\n\nThe purpose of the program is to count the number of sentences in the input string `S` that start with the string `\"I \"`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong is_bored(std::string S) {\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> all_prefixes(std::string string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> allPrefixes(String string) {\n        ArrayList<String> result = new ArrayList<>();\n\n        for (int i = 0; i < string.length(); i++) {\n            result.add(string.substring(0, i+1));\n        }\n        return result;\n    }\n}\n\n### Explanation\n\nThis program defines a function `allPrefixes` that takes a string as input and returns an ArrayList of all the prefixes of the input string. A prefix is defined as a string that is formed by taking the first n characters of the input string, where n is any integer between 1 and the length of the input string. The function uses a for loop to iterate over the input string and add each prefix to the ArrayList. The ArrayList is then returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> all_prefixes(std::string string) {\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong how_many_times(std::string string, std::string substring) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long howManyTimes(String string, String substring) {\n        long times = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                times++;\n            }\n        }\n        return times;\n    }\n}\n\n### Explanation\n\nThis program defines a function `howManyTimes` that takes two strings as input and returns the number of times the second string appears in the first string. It does this by iterating over all possible substrings of the first string of the same length as the second string, and checking if they are equal to the second string. If so, it increments a counter. The final count is returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong how_many_times(std::string string, std::string substring) {\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong solution(std::vector<long> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long solution(ArrayList<Long> lst) {\n        return IntStream.range(0, lst.size()).filter(i -> i%2==0 && lst.get(i)%2==1).mapToLong(i -> lst.get(i)).sum();\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `solution` that takes an ArrayList of Long integers as input and returns a Long integer. The function returns the sum of all odd numbers in the ArrayList that are at odd indices (i.e. indices 1, 3, 5, ...).\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong solution(std::vector<long> lst) {\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong search(std::vector<long> lst) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long search(ArrayList<Long> lst) {\n        long[] frq = new long[Collections.max(lst).intValue() + 1];\n        lst.stream().forEach(i -> frq[i.intValue()]++);\n\n        long ans = -1;\n        for (int i = 1; i < frq.length; i++) {\n            if (frq[i] >= i) {\n                ans = i;\n            }\n        }\n\n        return ans;\n    }\n}\n\n### Explanation\n\nThis program takes in an ArrayList of Longs and returns the largest integer i such that i is less than or equal to the frequency of i in the ArrayList. If no such i exists, it returns -1. \n\nHere is the equivalent C++ code:\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong search(std::vector<long> lst) {\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> pluck(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> pluck(ArrayList<Long> arr) {\n        if (arr.size() == 0) return new ArrayList<Long>();\n        List<Long> evens = arr.stream().filter(x -> x % 2 == 0).collect(Collectors.toList());\n        if (evens.size() == 0) return new ArrayList<Long>();\n        long min = Collections.min(evens);\n        return new ArrayList<Long>(Arrays.asList(min, (long) arr.indexOf(min)));\n    }\n}\n\n### Explanation\n\nThis program defines a function called `pluck` that takes an ArrayList of Longs as input and returns an ArrayList of Longs. The function first checks if the input ArrayList is empty, and if it is, returns an empty ArrayList. If the input ArrayList is not empty, the function filters out all even numbers from the input ArrayList and stores them in a new List called `evens`. If `evens` is empty, the function returns an empty ArrayList. Otherwise, the function finds the minimum value in `evens` and returns an ArrayList containing the minimum value and the index of the minimum value in the original input ArrayList.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> pluck(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean pairsSumToZero(ArrayList<Long> l) {\n        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n                if (l.get(i) + l.get(j) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n### Explanation\n\nThis program defines a function `pairsSumToZero` that takes an ArrayList of Longs and returns true if there are any two elements in the list that sum to zero, and false otherwise. The function iterates over all pairs of elements in the list and checks if their sum is zero. If it finds such a pair, it immediately returns true. If it iterates over all pairs without finding a sum of zero, it returns false.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool pairs_sum_to_zero(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string make_palindrome(std::string string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String makePalindrome(String string) {\n        if (string.isEmpty()) {\n            return \"\";\n        }\n        int beginningOfSuffix = 0;\n        while (!string.substring(beginningOfSuffix).equals(new StringBuilder(string.substring(beginningOfSuffix)).reverse().toString())) {\n            beginningOfSuffix++;\n        }\n        return string + new StringBuilder(string.substring(0, beginningOfSuffix)).reverse().toString();\n    }\n}\n\n### Explanation\n\nThis program defines a function `makePalindrome` that takes a string as an argument and returns a string. The function returns the input string concatenated with the reverse of the input string up to the point where the input string is a palindrome. If the input string is already a palindrome, the function returns the input string. If the input string is empty, the function returns an empty string. The function uses a while loop to find the beginning of the suffix of the input string that needs to be reversed to make the input string a palindrome. The function uses the `StringBuilder` class to reverse the suffix of the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string make_palindrome(std::string string) {\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong starts_one_ends(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long startsOneEnds(long n) {\n        if (n == 1) return 1;\n        return 18 * (long)Math.pow(10, n - 2);\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `startsOneEnds`. The method takes a single argument `n` of type `long` and returns a value of type `long`. If `n` is equal to 1, the method returns 1. Otherwise, the method returns 18 times 10 raised to the power of `n - 2`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong starts_one_ends(long n) {\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> get_positive(std::vector<long> l) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> getPositive(ArrayList<Long> l) {\n        return (ArrayList<Long>) l.stream().filter(e -> e > 0).collect(Collectors.toList());\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` which has a single static method called `getPositive`. The method takes an `ArrayList` of `Long` objects as input and returns a new `ArrayList` containing only the positive elements of the input list. The method uses Java 8 streams to filter the input list and collect the positive elements into a new list. The method is public and can be called from other classes without creating an instance of the `Problem` class.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> get_positive(std::vector<long> l) {\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string concatenate(std::vector<std::string> strings) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String concatenate(ArrayList<String> strings) {\n        return String.join(\"\", strings);\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` which has a single static method called `concatenate`. The method takes an `ArrayList` of `String`s and returns a single `String` that is the concatenation of all the `String`s in the `ArrayList`. The `String.join` method is used to concatenate the `String`s.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string concatenate(std::vector<std::string> strings) {\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_nested(std::string string) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isNested(String string) {\n        List<Integer> openingBracketIndex = new ArrayList<>();\n        List<Integer> closingBracketIndex = new ArrayList<>();\n        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i) == '[') {\n                openingBracketIndex.add(i);\n            } else {\n                closingBracketIndex.add(i);\n            }\n        }\n        Collections.reverse(closingBracketIndex);\n        int cnt = 0;\n        int i = 0;\n        int l = closingBracketIndex.size();\n        for (int idx : openingBracketIndex) {\n            if (i < l && idx < closingBracketIndex.get(i)) {\n                cnt++;\n                i++;\n            }\n        }\n        return cnt >= 2;\n    }\n}\n\n### Explanation\n\nThis program checks if a string has at least two nested square brackets. It does this by first finding the indices of all opening and closing square brackets in the string. Then, it reverses the list of closing bracket indices and iterates through the opening bracket indices. For each opening bracket index, it checks if there is a closing bracket index that comes after it (using the reversed list of closing bracket indices). If there is, it increments a counter. If the counter reaches 2 or more, the function returns true. Otherwise, it returns false.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_nested(std::string string) {\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_palindrome(std::string text) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isPalindrome(String text) {\n        StringBuilder sb = new StringBuilder(text);\n        return text.equals(sb.reverse().toString());\n    }\n}\n\n### Explanation\n\nThis program defines a function `isPalindrome` that takes a string as input and returns a boolean indicating whether the string is a palindrome. A string is a palindrome if it reads the same forwards and backwards. The function first creates a new StringBuilder object with the input string, then reverses the StringBuilder object and converts it back to a string. Finally, it compares the original input string to the reversed string to determine if they are equal. \n\nTo rewrite this program in C++, you would need to create a new function with the same name and input parameter, and then implement the same logic using C++ syntax. You would also need to include any necessary header files at the beginning of the program. \n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_palindrome(std::string text) {\n"
  },
  {
    "name": "HumanEval_108_count_nums",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong count_nums(std::vector<long> arr) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_108_count_nums.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long countNums(ArrayList<Long> arr) {\n        return arr.stream().map(i -> digitsSum(i)).filter(i -> i > 0).count();\n    }\n\n    private static long digitsSum(long n) {\n        long neg = 1;\n        if (n < 0) {\n            n = -1 * n;\n            neg = -1;\n        }\n        String[] digits = Long.toString(n).split(\"\");\n        digits[0] = Long.toString(Long.parseLong(digits[0]) * neg);\n        return Arrays.stream(digits).mapToLong(Long::parseLong).sum();\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` which has two methods: `countNums` and `digitsSum`. The `countNums` method takes an `ArrayList` of `Long`s and returns the number of elements in the list for which the `digitsSum` method returns a positive number. The `digitsSum` method takes a `long` and returns the sum of its digits. If the input number is negative, the method returns the sum of the absolute values of its digits, but with the sign of the original number. The `digitsSum` method first converts the input number to a string, splits the string into an array of strings representing each digit, multiplies the first digit by -1 if the input number is negative, converts each string to a `long`, and then returns the sum of all the `long`s in the array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong count_nums(std::vector<long> arr) {\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> factorize(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> factorize(long n) {\n        ArrayList<Long> fact = new ArrayList<>();\n        long i = 2;\n        while (i <= n) {\n            if (n % i == 0) {\n                fact.add(i);\n                n /= i;\n            } else {\n                i++;\n            }\n        }\n        return fact;\n    }\n}\n\n### Explanation\n\nThis program defines a function `factorize` that takes a long integer `n` and returns an ArrayList of long integers that are the prime factors of `n`. The function works by iterating over all integers `i` from 2 to `n`, and checking if `i` is a factor of `n`. If `i` is a factor of `n`, it is added to the ArrayList and `n` is divided by `i`. If `i` is not a factor of `n`, `i` is incremented by 1 and the loop continues. The function returns the ArrayList of prime factors of `n`. \n\nTo rewrite this program in C++, you would need to replace the ArrayList with a vector, and change the syntax of the function definition and return statement to C++ syntax. You would also need to include the necessary headers for the functions used in the Java program. Here is an example of what the C++ code might look like:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> factorize(long n) {\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong largest_prime_factor(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long largestPrimeFactor(long n) {\n        long largest = 1;\n        for (long j = 2; j <= n; j++) {\n            if (n % j == 0 && isPrime(j)) {\n                largest = Math.max(largest, j);\n            }\n        }\n        return largest;\n    }\n    public static boolean isPrime(long k) {\n        if (k < 2) return false;\n        for (long i = 2; i < k; i++) {\n            if (k % i == 0) return false;\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis Java program defines two functions, `largestPrimeFactor` and `isPrime`. The `largestPrimeFactor` function takes an integer `n` and returns the largest prime factor of `n`. The `isPrime` function takes an integer `k` and returns `true` if `k` is prime, and `false` otherwise. The `largestPrimeFactor` function iterates over all integers `j` from 2 to `n`, and checks if `j` is a factor of `n` and if `j` is prime. If both conditions are true, `j` is the largest prime factor of `n` found so far, and the function updates the `largest` variable to `j`. Finally, the function returns the value of `largest`. The `isPrime` function checks if `k` is less than 2, and if so, returns `false`. Otherwise, it iterates over all integers `i` from 2 to `k-1`, and checks if `i` is a factor of `k`. If any `i` is a factor of `k`, the function returns `false`. Otherwise, the function returns `true`. To rewrite this program in C++, you would need to replace the Java-specific syntax and libraries with their C++ equivalents. For example, you would need to replace `import` statements with `#include` statements, and replace the `java.util.*` library with the appropriate C++ libraries for input/output and data structures. You would also need to replace the `Math.max` function with the appropriate C++ function or implementation. Finally, you would need to compile and run the C++ program using a C++ compiler and runtime environment.<|im_end|>\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong largest_prime_factor(long n) {\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong get_max_triples(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static long getMaxTriples(long n) {\n        long ans = 0;\n        long[] A = new long[(int)n+1];\n        for (int i = 1; i <= n; i++) {\n            A[i] = i*i-i+1;\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = i+1; j <= n; j++) {\n                for (int k = j+1; k <= n; k++) {\n                    if ((A[i]+A[j]+A[k])%3 == 0) {\n                        ans++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n    \n}\n\n### Explanation\n\nThis program defines a function `getMaxTriples` that takes an integer `n` and returns the number of triples `(i,j,k)` such that `1 <= i < j < k <= n` and `(i^2 - i + 1) + (j^2 - j + 1) + (k^2 - k + 1)` is divisible by 3. The function first initializes an array `A` of length `n+1` where `A[i] = i^2 - i + 1` for `1 <= i <= n`. It then loops over all triples `(i,j,k)` such that `1 <= i < j < k <= n` and checks if the sum of the corresponding values in `A` is divisible by 3. If so, it increments a counter `ans`. Finally, it returns `ans`.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nlong get_max_triples(long n) {\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string anti_shuffle(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String antiShuffle(String s) {\n        return Arrays.stream(s.split(\" \")).map(i -> new String(i.chars().sorted().toArray(), 0, i.length())).collect(Collectors.joining(\" \"));\n    }\n    \n}\n\n### Explanation\n\nThis program takes a string as input and returns a string. The input string is split into words using the space character as a delimiter. Each word is then sorted and the sorted characters are concatenated to form a new string. The new strings are then concatenated with space characters to form the output string. The program uses Java 8 streams to perform the sorting and concatenation operations.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string anti_shuffle(std::string s) {\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string solve(long N) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String solve(long N) {\n        return Long.toBinaryString(Long.toString(N).chars().map(c -> c - '0').sum());\n    }\n}\n\n### Explanation\n\nThis program takes an integer N as input, and returns a string of the binary representation of the sum of the digits of N.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string solve(long N) {\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> minPath(ArrayList<ArrayList<Long>> grid, long k) {\n        long n = grid.size();\n        long val = n * n + 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid.get(i).get(j) == 1) {\n                    ArrayList<Long> temp = new ArrayList<>();\n                    if (i != 0) {\n                        temp.add(grid.get(i - 1).get(j));\n                    }\n                    if (j != 0) {\n                        temp.add(grid.get(i).get(j - 1));\n                    }\n                    if (i != n - 1) {\n                        temp.add(grid.get(i + 1).get(j));\n                    }\n                    if (j != n - 1) {\n                        temp.add(grid.get(i).get(j + 1));\n                    }\n                    val = Collections.min(temp);\n                }\n            }\n        }\n        ArrayList<Long> ans = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            if (i % 2 == 0) {\n                ans.add(1L);\n            } else {\n                ans.add(val);\n            }\n        }\n        return ans;\n    }\n}\n\n### Explanation\n\nThis program takes in a 2D grid of long integers, and a long integer k. It then finds the minimum value of the adjacent cells to the cells that contain the value 1. It then returns an ArrayList of long integers of length k, where the even indices contain the value 1, and the odd indices contain the minimum value of the adjacent cells to the cells that contain the value 1.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string encrypt(std::string s) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static String encrypt(String s) {\n        String d = \"abcdefghijklmnopqrstuvwxyz\";\n        String out = \"\";\n        for (char c : s.toCharArray()) {\n            if (d.indexOf(c) != -1) {\n                out += d.charAt((d.indexOf(c)+2*2) % 26);\n            } else {\n                out += c;\n            }\n        }\n        return out;\n    }\n}\n\n### Explanation\n\nThis program defines a class called `Problem` with a single static method called `encrypt`. The method takes a string as input and returns a string. The method iterates over each character in the input string and checks if it is a letter. If it is, it shifts the letter two positions to the right in the alphabet (wrapping around if necessary). If it is not a letter, it leaves it unchanged. The resulting string is returned.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::string encrypt(std::string s) {\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> make_a_pile(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> makeAPile(long n) {\n        return IntStream.range(0, (int) n).mapToObj(i -> n + 2 * i).collect(Collectors.toCollection(ArrayList::new));\n    }\n}\n\n### Explanation\n\nThis program defines a function called `makeAPile` that takes in a long integer `n` as input and returns an ArrayList of long integers. The ArrayList contains `n` elements, where each element is equal to `n + 2 * i`, where `i` is the index of the element in the ArrayList (0-indexed). \n\nThe function first creates an IntStream of integers from 0 to `n - 1` using the `range` method of the `IntStream` class. It then maps each integer `i` to the value `n + 2 * i` using the `mapToObj` method. Finally, it collects the resulting objects into an ArrayList using the `collect` method of the `Collectors` class.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> make_a_pile(long n) {\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "cpp",
    "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_prime(long n) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Java program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in C++?\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static Pair<Long, Long> evenOddPalindrome(long n) {\n        long evenPalindromeCount = 0;\n        long oddPalindromeCount = 0;\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 1 & & isPalindrome(i)) {\n                oddPalindromeCount++;\n            } else if (i % 2 == 0 & & isPalindrome(i)) {\n                evenPalindromeCount++;\n            }\n        }\n        return Pair.with(evenPalindromeCount, oddPalindromeCount);\n    }\n\n    private static boolean isPalindrome(long n) {\n        return Long.toString(n).equals(new StringBuilder(Long.toString(n)).reverse().toString());\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `evenOddPalindrome` that takes a long integer `n` as input and returns a pair of long integers. The function counts the number of even and odd palindromic numbers between 1 and `n` (inclusive), and returns the counts as a pair. A number is palindromic if it reads the same forwards and backwards (e.g. 121, 12321). The function uses the helper function `isPalindrome` to check whether a number is palindromic. The function returns the counts as a `Pair` object from the `org.javatuples` package.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    auto is_palindrome = [](long n) -> bool {\n        std::string s = std::to_string(n);\n        return std::equal(s.begin(), s.end(), s.rbegin());\n    };\n    long even_palindrome_count = 0;\n    long odd_palindrome_count = 0;\n    for(long i=1; i<=n; i++) {\n        if(i%2 == 1 && is_palindrome(i)) {\n            odd_palindrome_count++;\n        } else if(i%2 == 0 && is_palindrome(i)) {\n            even_palindrome_count++;\n        }\n    }\n    return std::make_tuple(even_palindrome_count, odd_palindrome_count);\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isSorted(ArrayList<Long> lst) {\n        HashMap<Long, Long> count_digit = new HashMap<Long, Long>();\n        for (long i : lst) {\n            if (count_digit.containsKey(i)) {\n                count_digit.put(i, count_digit.get(i) + 1);\n            } else {\n                count_digit.put(i, 1L);\n            }\n        }\n        for (long i : lst) {\n            if (count_digit.get(i) > 2) {\n                return false;\n            }\n        }\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis program defines a function `isSorted` that takes an ArrayList of Longs and returns a boolean indicating whether the list is sorted in non-descending order and contains at most two of each element. The function first creates a HashMap to count the frequency of each element in the list, then checks that no element appears more than twice. Finally, it checks that the list is sorted in non-descending order.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_sorted(std::vector<long> lst) {\n    std::map<long, long> count_digit;\n    for (auto i: lst) {\n        count_digit[i]++;\n    }\n    for (auto i: lst) {\n        if (count_digit[i] > 2) {\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<String> separateParenGroups(String paren_string) {\n        ArrayList<String> result = new ArrayList<String>();\n        ArrayList<Character> current_string = new ArrayList<Character>();\n        int current_depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(') {\n                current_depth += 1;\n                current_string.add(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.add(c);\n\n                if (current_depth == 0) {\n                    StringBuilder sb = new StringBuilder(current_string.size());\n                    for (Character ch : current_string) {\n                        sb.append(ch);\n                    }\n                    result.add(sb.toString());\n                    current_string.clear();\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function called `separateParenGroups` that takes a string as input and returns an ArrayList of strings. The function separates the input string into groups of characters that are enclosed in parentheses. Each group is returned as a separate string in the ArrayList.\n\nThe function works by iterating over each character in the input string. If the character is an opening parenthesis, the function increments a counter that keeps track of the current depth of nested parentheses. The character is added to a list of characters that make up the current group. If the character is a closing parenthesis, the function decrements the counter and adds the character to the list of characters. If the counter reaches zero, the current group is complete and is added to the result ArrayList. The function then clears the list of characters and continues iterating over the input string.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n    int current_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            current_depth++;\n            current_string.push_back(c);\n        } else if (c == ')') {\n            current_depth--;\n            current_string.push_back(c);\n            if (current_depth == 0) {\n                result.push_back(current_string);\n                current_string.clear();\n            }\n        }\n    }\n    return result;\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static ArrayList<Long> sortArray(ArrayList<Long> array) {\n        if (array.size() == 0) {\n            return new ArrayList<Long>();\n        } else {\n            boolean reverse = (array.get(0) + array.get(array.size() - 1)) % 2 == 0;\n            Collections.sort(array);\n            if (reverse) {\n                Collections.reverse(array);\n            }\n            return array;\n        }\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `sortArray` that takes an array of long integers and returns a sorted version of that array. If the input array is empty, the function returns an empty array. Otherwise, the function sorts the input array in ascending order and then reverses it if the sum of the first and last elements of the input array is even. The function returns the sorted array.\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty()) {\n        return std::vector<long>();\n    } else {\n        bool isReversed = (array[0] + array[array.size() - 1]) % 2 == 0;\n        std::sort(array.begin(), array.end(), [&](long a, long b) {\n            return isReversed ? a > b : a < b;\n        });\n        return array;\n    }\n}\n\n### Java version\n\nimport java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\nimport java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Problem {\n    public static boolean isPrime(long n) {\n        if (n < 2) {\n            return false;\n        }\n        for (long k = 2; k < n; k++) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n### Explanation\n\nThis Java program defines a function `isPrime` that takes a long integer `n` and returns a boolean indicating whether `n` is prime. The function checks whether `n` is less than 2 and returns false if it is. Otherwise, it checks whether `n` is divisible by any integer between 2 and `n-1`, inclusive, and returns false if it is. If `n` is not divisible by any integer between 2 and `n-1`, the function returns true.\n\nTo rewrite this program in C++, you can define a similar function with the same name and signature, and copy the body of the Java function into the C++ function. Here's an example:\n\n```c++\n\n### C++ version\n\n#include<assert.h>\n#include<bits/stdc++.h>\n#include<vector>\n#include<sstream>\n#include<regex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\nbool is_prime(long n) {\n"
  }
]