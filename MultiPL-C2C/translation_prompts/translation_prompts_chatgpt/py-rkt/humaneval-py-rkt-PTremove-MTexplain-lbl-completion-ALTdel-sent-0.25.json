[
  {
    "name": "HumanEval_30_get_positive",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_positive l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)\n    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)\n    (check-within (candidate (list -1 -2)) (list ) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n    return [e for e in l if e > 0]\n\n### Explanation\n\nThe code is an implementation of  `get_positive` function that takes a list of integers and returns a list of integers that are greater than 0.\n\n```python\ndef get_positive(l: List[int]) -> List[int]:\n```\nThis line defines a function called `get_positive`. The function takes a single argument `l` which is a list of integers. The `-> List[int]` part of the function definition specifies that the function returns a list of integers.\n\n```python\nreturn [e for e in l if e > 0]\n```\nThis line uses a list comprehension to create a new list containing only the positive integers from the input list. The `if e > 0` part of the list comprehension is a filter that only includes elements that are greater than 0.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_positive l)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (parse_nested_parens paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3) 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4) 0.001)\n    (check-within (candidate \"(()(())((())))\") (list 4) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n\n### Explanation\n\nThe code is an implementation of  a function `parse_nested_parens` that takes a string of nested parentheses and returns a list of integers representing the maximum depth of each group of parentheses.\n\n```python\nfrom typing import List\n```\nImporting the List module from the typing package.\n\n```python\ndef parse_nested_parens(paren_string: str) -> List[int]:\n```\nDefining a function `parse_nested_parens` that takes a string `paren_string` as input and returns a list of integers. The `-> List[int]` specifies the return type of the function.\n\n```python\n    def parse_paren_group(s):\n```\nDefining a nested function `parse_paren_group` that takes a string `s` as input.\n\n```python\n        depth = 0\n        max_depth = 0\n```\nInitializing two variables `depth` and `max_depth` to 0.\n\n```python\n        return max_depth\n```\nReturn the `max_depth` variable.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (parse_nested_parens paren_string)\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_row lst x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_row))\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 4) (list 1 0) (list 2 5) (list 2 0)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6)) 2) (list (list 0 1) (list 1 1) (list 2 1) (list 3 1) (list 4 1) (list 5 1)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 1 3 4 5 6) (list 1 2 1 4 5 6) (list 1 2 3 1 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 0) (list 2 1) (list 2 0) (list 3 2) (list 3 0) (list 4 3) (list 4 0) (list 5 4) (list 5 0) (list 6 5) (list 6 0)) 0.001)\n    (check-within (candidate (list ) 1) (list ) 0.001)\n    (check-within (candidate (list (list 1)) 2) (list ) 0.001)\n    (check-within (candidate (list (list ) (list 1) (list 1 2 3)) 3) (list (list 2 2)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n\n### Explanation\n\nThe code is an implementation of  `get_row` function which takes a list of lists of integers and an integer `x` as input and returns a list of tuples representing the coordinates of all occurrences of `x` in the list of lists. The tuples are sorted first by row and then by column.\n\n3. The `coords` variable is initialized with a list comprehension that iterates over all the rows and columns of `lst` and returns a tuple `(i, j)` for each occurrence of `x` in `lst`. The `if` statement filters out all the elements that are not equal to `x`.\n\n4. The `sorted` function is called twice on `coords`. The first call sorts the tuples by column in descending order, and the second call sorts the tuples by row in ascending order.\n\n5. The sorted list of tuples is returned as the result of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_row lst x)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)\n    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)\n    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)\n    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)\n    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)\n    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)\n    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)\n    (check-within (candidate (list 0.0)) 0 0.001)\n    (check-within (candidate (list -1.0)) 1 0.001)\n    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n\n### Explanation\n\nThe code is an implementation of  `sum_squares` function that takes a list of floats and returns the sum of the squares of each element in the list. \n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is used to define a list of a specific type. In this case, a list of floats.\n\n```python\ndef sum_squares(lst: List[float]) -> int:\n```\nThis line defines the `sum_squares` function that takes a list of floats as an argument and returns an integer. The function signature specifies the types of the input and output.\n\n```python\nimport math\n```\nThis line imports the math module which provides mathematical functions.\n\n```python\nfor i in lst:\n```\nThis line starts a for loop that iterates over each element in the input list.\n\n```python\nsquared += math.ceil(i)**2\n```\nThis line calculates the square of each element in the list by first rounding up the element to the nearest integer using the `math.ceil` function, then squaring the result using the exponentiation operator `**`. The squared value is then added to the `squared` variable.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (derivative xs)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate derivative))\n    (check-within (candidate (list 3 1 2 4 5)) (list 1 4 12 20) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 6) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 2 2) 0.001)\n    (check-within (candidate (list 3 2 1 0 4)) (list 2 2 0 16) 0.001)\n    (check-within (candidate (list 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef derivative(xs: List[int]) -> List[int]:\n    return [(i * x) for i, x in enumerate(xs)][1:]\n\n### Explanation\n\nThe code is an implementation of 1st order derivative of a polynomial function. It takes a list of integers as input and returns a list of integers as output.\n\n2. `def derivative(xs: List[int]) -> List[int]:` - Defining a function called `derivative` that takes a list of integers as input and returns a list of integers as output.\n\n3. `return [(i * x) for i, x in enumerate(xs)][1:]` - The function returns a list comprehension that iterates over the input list `xs` and multiplies each element by its index. The `[1:]` at the end of the list comprehension is used to remove the first element of the resulting list, which is always zero.\n\n4. `enumerate(xs)` - This function returns an iterator that generates tuples containing the index and the value of each element in the input list.\n\n5. `i * x` - This multiplies the index and the value of each element in the input list.\n\n7. `[(i * x) for i, x in enumerate(xs)]` - This is a list comprehension that generates a list of integers by multiplying each element in the input list by its index.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (derivative xs)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_multiply_prime a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_multiply_prime))\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #f 0.001)\n    (check-within (candidate 125) #t 0.001)\n    (check-within (candidate 105) #t 0.001)\n    (check-within (candidate 126) #f 0.001)\n    (check-within (candidate 729) #f 0.001)\n    (check-within (candidate 891) #f 0.001)\n    (check-within (candidate 1001) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_multiply_prime(a: int) -> bool:\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n\n### Explanation\n\nThe code is an implementation of  a function called `is_multiply_prime` that takes an integer `a` as input and returns a boolean value. The function checks if the input integer is a product of three prime numbers between 2 and 100 (inclusive). \n\nThe function first defines an inner function called `is_prime` that takes an integer `n` as input and returns a boolean value indicating whether `n` is a prime number or not. The function checks if `n` is divisible by any integer between 2 and `n-1` (inclusive) and returns `False` if it is, otherwise it returns `True`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_multiply_prime a)\n"
  },
  {
    "name": "HumanEval_103_rounded_avg",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (rounded_avg n m)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_103_rounded_avg.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rounded_avg))\n    (check-within (candidate 1 5) \"0b11\" 0.001)\n    (check-within (candidate 7 13) \"0b1010\" 0.001)\n    (check-within (candidate 964 977) \"0b1111001010\" 0.001)\n    (check-within (candidate 996 997) \"0b1111100100\" 0.001)\n    (check-within (candidate 560 851) \"0b1011000010\" 0.001)\n    (check-within (candidate 185 546) \"0b101101110\" 0.001)\n    (check-within (candidate 362 496) \"0b110101101\" 0.001)\n    (check-within (candidate 350 902) \"0b1001110010\" 0.001)\n    (check-within (candidate 197 233) \"0b11010111\" 0.001)\n    (check-within (candidate 7 5) -1 0.001)\n    (check-within (candidate 5 1) -1 0.001)\n    (check-within (candidate 5 5) \"0b101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Union\n\ndef rounded_avg(n: int, m: int) -> Union[str, int]:\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, `n` and `m`, and returns the binary representation of the rounded average of all the integers between `n` and `m` inclusive. If `m` is less than `n`, the function returns `-1`.\n\n```python\nfrom typing import Union\n```\nThe `typing` module provides support for type hints. `Union` is a type hint that allows a function to return one of several types.\n\n```python\ndef rounded_avg(n: int, m: int) -> Union[str, int]:\n```\nThis line defines the function `rounded_avg` that takes two arguments, `n` and `m`, both of which are integers. The function returns either a string or an integer.\n\n```python\nfor i in range(n, m+1):\n    summation += i\n```\nThis loop iterates over all the integers between `n` and `m` inclusive, and adds each integer to `summation`.\n\n```python\nreturn bin(round(summation/(m - n + 1)))\n```\nThis line returns the binary representation of the rounded average of all the integers between `n` and `m` inclusive. The average is calculated by dividing the sum of the integers by the number of integers, which is `m - n + 1`. The `round` function rounds the average to the nearest integer, and the `bin` function returns the binary representation of the rounded average.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (rounded_avg n m)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (eat number need remaining)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate eat))\n    (check-within (candidate 5 6 10) (list 11 4) 0.001)\n    (check-within (candidate 4 8 9) (list 12 1) 0.001)\n    (check-within (candidate 1 10 10) (list 11 0) 0.001)\n    (check-within (candidate 2 11 5) (list 7 0) 0.001)\n    (check-within (candidate 4 5 7) (list 9 2) 0.001)\n    (check-within (candidate 4 5 1) (list 5 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef eat(number: int, need: int, remaining: int) -> List[int]:\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n\n### Explanation\n\nThe function first checks if the `need` value is less than or equal to the `remaining` value. If it is, the function returns a list containing two integers: `number + need` and `remaining - need`. If `need` is greater than `remaining`, the function returns a list containing two integers: `number + remaining` and `0`.\n\nThe `if` statement checks if `need` is less than or equal to `remaining`. If it is, the function returns a list containing two integers: `number + need` and `remaining - need`. If `need` is greater than `remaining`, the function returns a list containing two integers: `number + remaining` and `0`.\n\nThe `return` keyword is used to return a value from the function. In this case, the function returns a list containing two integers.\n\nThe `else` statement is used to handle the case where `need` is greater than `remaining`. If this is the case, the function returns a list containing two integers: `number + remaining` and `0`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (eat number need remaining)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (find_max words)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n    (check-within (candidate (list \"name\" \"of\" \"string\")) \"string\" 0.001)\n    (check-within (candidate (list \"name\" \"enam\" \"game\")) \"enam\" 0.001)\n    (check-within (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\" 0.001)\n    (check-within (candidate (list \"abc\" \"cba\")) \"abc\" 0.001)\n    (check-within (candidate (list \"play\" \"this\" \"game\" \"of\" \"footbott\")) \"footbott\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\" 0.001)\n    (check-within (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\" 0.001)\n    (check-within (candidate (list \"b\")) \"b\" 0.001)\n    (check-within (candidate (list \"play\" \"play\" \"play\")) \"play\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef find_max(words: List[str]) -> str:\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n\n### Explanation\n\nThe code is an implementation of  `find_max` function that takes a list of strings as input and returns the string with the maximum number of unique characters. \n\nThe `lambda` function `lambda x: (-len(set(x)), x)` is used as the key function. It takes a string `x` as input and returns a tuple of two values. The first value is the negative length of the set of unique characters in the string. The negative sign is used to sort the strings in descending order of the length of the set of unique characters. The second value is the string itself. This ensures that if two strings have the same length of unique characters, they are sorted lexicographically. \n\nFinally, the function returns the first element of the sorted list, which is the string with the maximum number of unique characters.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (find_max words)\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_sorted lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_sorted))\n    (check-within (candidate (list 5)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 7)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n    (check-within (candidate (list 1)) #t 0.001)\n    (check-within (candidate (list 3 2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 2 2 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 3 3 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 2 3 3 4)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThe code is an implementation of 2 functions. The first function is `is_sorted` which takes a list of integers as input and returns a boolean indicating whether the list is sorted in non-descending order and has no more than 2 occurrences of any integer. The second function is `main` which is not implemented.\n\nThe second line defines the `is_sorted` function which takes a list of integers as input and returns a boolean indicating whether the list is sorted in non-descending order and has no more than 2 occurrences of any integer.\n\nThe third line creates a dictionary called `count_digit` which is used to count the number of occurrences of each integer in the input list. The dictionary is initialized with keys equal to the integers in the input list and values equal to 0.\n\nThe fourth line loops through the input list and increments the value of the corresponding key in the `count_digit` dictionary for each integer encountered.\n\nThe fifth line checks if any integer in the input list occurs more than twice. If so, the function returns False.\n\nThe `main` function is not implemented and is left as an exercise for the reader.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_sorted lst)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (match_parens lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate match_parens))\n    (check-within (candidate (list \"()(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \")\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(())\" \"())())\")) \"No\" 0.001)\n    (check-within (candidate (list \")())\" \"(()()(\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"(())))\" \"(()())((\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"()\" \"())\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(\" \"()))()\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"((((\" \"((())\")) \"No\" 0.001)\n    (check-within (candidate (list \")(()\" \"(()(\")) \"No\" 0.001)\n    (check-within (candidate (list \")(\" \")(\")) \"No\" 0.001)\n    (check-within (candidate (list \"(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \"(\")) \"Yes\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n\n### Explanation\n\nThe function `match_parens` has a nested function `check` that takes a string `s` as input and returns `True` if the string has balanced parentheses, and `False` otherwise. The function `check` uses a variable `val` to keep track of the number of open parentheses encountered so far. It iterates over the characters in the string `s`, incrementing `val` for each open parenthesis and decrementing it for each close parenthesis. If `val` becomes negative at any point, it means that there are more close parentheses than open parentheses, and the function returns `False`. If `val` is zero at the end of the iteration, it means that the string has balanced parentheses, and the function returns `True`. Otherwise, it returns `False`.\n\nThe main body of the `match_parens` function concatenates the two strings in the list `lst` in two different orders, and checks if either of the resulting strings has balanced parentheses using the `check` function. If either string has balanced parentheses, the function returns 'Yes'. Otherwise, it returns 'No'.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (match_parens lst)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (triangle_area a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 3 4 5) 6.0 0.001)\n    (check-within (candidate 1 2 10) -1 0.001)\n    (check-within (candidate 4 8 5) 8.18 0.001)\n    (check-within (candidate 2 2 2) 1.73 0.001)\n    (check-within (candidate 1 2 3) -1 0.001)\n    (check-within (candidate 10 5 7) 16.25 0.001)\n    (check-within (candidate 2 6 3) -1 0.001)\n    (check-within (candidate 1 1 1) 0.43 0.001)\n    (check-within (candidate 2 2 10) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef triangle_area(a: int, b: int, c: int) -> float:\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n\n### Explanation\n\nThe code is an implementation of  Heron's formula for calculating the area of a triangle given the length of its sides. \n\n1. `def triangle_area(a: int, b: int, c: int) -> float:` - This is a function definition that takes in three integer arguments `a`, `b` and `c` representing the length of the sides of a triangle. The function returns a float value representing the area of the triangle.\n\n2. `if a + b <= c or a + c <= b or b + c <= a:` - This is a conditional statement that checks if the sum of any two sides of the triangle is less than or equal to the length of the third side. If this condition is true, it means that the sides do not form a valid triangle and the function returns -1.\n\n3. `s = (a + b + c)/2` - This line calculates the semi-perimeter of the triangle by adding the lengths of all three sides and dividing by 2.\n\n6. `return area` - This line returns the calculated area of the triangle.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (triangle_area a b c)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"<>\") #t 0.001)\n    (check-within (candidate \"<<><>>\") #t 0.001)\n    (check-within (candidate \"<><><<><>><>\") #t 0.001)\n    (check-within (candidate \"<><><<<><><>><>><<><><<>>>\") #t 0.001)\n    (check-within (candidate \"<<<><>>>>\") #f 0.001)\n    (check-within (candidate \"><<>\") #f 0.001)\n    (check-within (candidate \"<\") #f 0.001)\n    (check-within (candidate \"<<<<\") #f 0.001)\n    (check-within (candidate \">\") #f 0.001)\n    (check-within (candidate \"<<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>><<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>>><>\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Explanation\n\nThe code is an implementation of  a function named `correct_bracketing` that takes in a string of brackets and returns a boolean value indicating whether the brackets are correctly balanced. \n\nThe function takes in a single argument `brackets` which is of type string. The function returns a boolean value.\n\nIt then iterates over each character in the string `brackets` using a for loop. \n\nFor each character `b` in `brackets`, the function checks if it is an opening bracket `<`. If it is, the function increments the `depth` variable by 1. \n\nIf the character is not an opening bracket, the function assumes it is a closing bracket and decrements the `depth` variable by 1. \n\nIf at any point the `depth` variable becomes negative, the function returns `False` indicating that the brackets are not balanced.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (incr_list l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate incr_list))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)\n    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef incr_list(l: List[int]) -> List[int]:\n    return [(e + 1) for e in l]\n\n### Explanation\n\nThe code is an implementation of  a function called `incr_list` that takes a list of integers as input and returns a new list with each element incremented by 1.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is a generic class that is used to represent a list of elements of a specific type.\n\n```python\ndef incr_list(l: List[int]) -> List[int]:\n```\nThis line defines a function called `incr_list` that takes a single argument `l` of type `List[int]` and returns a value of type `List[int]`. The `List[int]` type annotation indicates that the function expects a list of integers as input.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (incr_list l)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (filter_by_substring strings substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"grunt\" \"trumpet\" \"prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]\n\n### Explanation\n\nThe function takes two arguments:\n- `strings`: a list of strings to be filtered\n- `substring`: a string that is used to filter the list of strings\n\nThe function returns a list of strings that contain the given substring.\n\nThe function is implemented using a list comprehension. The list comprehension iterates over the input list `strings` and filters out all strings that do not contain the given substring. The filtered strings are then returned as a new list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (filter_by_substring strings substring)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (median l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n    (check-within (candidate (list 3 1 2 4 5)) 3 0.001)\n    (check-within (candidate (list -10 4 6 1000 10 20)) 8.0 0.001)\n    (check-within (candidate (list 5)) 5 0.001)\n    (check-within (candidate (list 6 5)) 5.5 0.001)\n    (check-within (candidate (list 8 1 3 9 9 2 7)) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef median(l: List[int]) -> float:\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n\n### Explanation\n\nThe code is an implementation of  a function that calculates the median of a list of integers. The function takes a list of integers as input and returns a float. The function is defined with the name `median` and takes a single argument `l` of type `List[int]`. The function returns a float value.\n\nThe first line of the function sorts the list of integers in ascending order using the `sorted` function. The sorted function returns a new list that is sorted in ascending order. The original list is not modified.\n\nThe `//` operator is used to perform integer division. This ensures that the index used to access the middle elements of the list is always an integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (median l)\n"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (string_to_md5 text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_162_string_to_md5.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_to_md5))\n    (check-within (candidate \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\" 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"A B C\") \"0ef78513b0cb8cef12743f5aeb35f888\" 0.001)\n    (check-within (candidate \"password\") \"5f4dcc3b5aa765d61d8327deb882cf99\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Optional\n\ndef string_to_md5(text: str) -> Optional[str]:\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n\n### Explanation\n\nThe code is an implementation of  a Python function that converts a string to its MD5 hash. The function takes a string as an input and returns the MD5 hash of the string. If the input string is empty, the function returns None.\n\nThis line imports the `Optional` type hint from the `typing` module. The `Optional` type hint is used to indicate that a function argument or return value can be `None`.\n\n```python\ndef string_to_md5(text: str) -> Optional[str]:\n```\n\nThis line defines a function called `string_to_md5` that takes a single argument `text` of type `str`. The function returns an optional string (`Optional[str]`), which means it can return either a string or `None`.\n\n```python\nimport hashlib\n```\n\n```python\nreturn hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n```\n\nIf the input string is empty (`if text`), the function returns `None`. Otherwise, it returns the MD5 hash of the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (string_to_md5 text)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (strange_sort_list lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n    (check-within (candidate (list 1 2 3 4)) (list 1 4 2 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7) 0.001)\n    (check-within (candidate (list 5 5 5 5)) (list 5 5 5 5) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5) 0.001)\n    (check-within (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2) 0.001)\n    (check-within (candidate (list 111111)) (list 111111) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n\n### Explanation\n\nThe function starts by initializing two variables `res` and `switch` to empty list and `True` respectively. `res` is used to store the sorted list while `switch` is used to alternate between finding the minimum and maximum values in the list.\n\nThe function then enters a while loop that runs as long as the input list `lst` is not empty. In each iteration of the loop, the function appends either the minimum or maximum value of the input list to the `res` list depending on the value of `switch`. The function then removes the last element of the `lst` list which is the value that was just appended to the `res` list. Finally, the function toggles the value of `switch` by negating it.\n\nThe function returns the `res` list which contains the sorted list of integers.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (strange_sort_list lst)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_upper s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n    (check-within (candidate \"aBCdEf\") 1 0.001)\n    (check-within (candidate \"abcdefg\") 0 0.001)\n    (check-within (candidate \"dBBE\") 0 0.001)\n    (check-within (candidate \"B\") 0 0.001)\n    (check-within (candidate \"U\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"EEEE\") 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef count_upper(s: str) -> int:\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n\n### Explanation\n\nThe code is an implementation of  a function called `count_upper` that takes a string as an argument and returns the number of uppercase vowels in the string. \n\nThe function then loops through the string `s` using a `for` loop. The loop starts at the first character of the string and increments by 2 until the end of the string is reached. This means that the loop only looks at every other character in the string. \n\nInside the loop, the function checks if the current character is an uppercase vowel. If it is, the `count` variable is incremented by 1.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_upper s)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_odd_collatz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_odd_collatz))\n    (check-within (candidate 14) (list 1 5 7 11 13 17) 0.001)\n    (check-within (candidate 5) (list 1 5) 0.001)\n    (check-within (candidate 12) (list 1 3 5) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef get_odd_collatz(n: int) -> List[int]:\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n\n### Explanation\n\nThe code is an implementation of  the Collatz conjecture. The conjecture is that for any positive integer n, the sequence of numbers obtained by repeatedly applying the following function will eventually reach the number 1:\n\nThe program takes an integer n as input and returns a sorted list of all odd numbers in the sequence starting from n. \n\nThe first line imports the List class from the typing module. This is used to specify the type of the output of the function.\n\nThe third line checks if n is even. If it is, an empty list is assigned to the variable odd_collatz. If it is odd, a list containing n is assigned to odd_collatz.\n\nIf n is even, it is divided by 2 on line 7. If it is odd, it is multiplied by 3 and 1 is added on line 9.\n\nIf n is odd, it is appended to the odd_collatz list on line 11.\n\nThe function returns the odd_collatz list sorted in ascending order on line 14.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_odd_collatz n)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (minPath grid k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minPath))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)\n    (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)\n    (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)\n    (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)\n    (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)\n    (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)\n    (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n\n### Explanation\n\n```python\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n```\nDefining a function `minPath` that takes in a 2D list of integers `grid` and an integer `k` and returns a list of integers. \n\n```python\n    n = len(grid)\n```\nAssigning the length of the `grid` to the variable `n`.\n\n```python\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n```\nIterating over the `grid` and checking if the current element is equal to `1`. If it is, then we create an empty list `temp`. We then check if the current element is not in the first row, if it is not, we append the element above it to `temp`. We then check if the current element is not in the first column, if it is not, we append the element to the left of it to `temp`. We then check if the current element is not in the last row, if it is not, we append the element below it to `temp`. We then check if the current element is not in the last column, if it is not, we append the element to the right of it to `temp`. We then assign the minimum value of `temp` to `val`.\n\n```python\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n```\nCreating an empty list `ans`. We then iterate over the range of `k`. If the current index is even, we append `1` to `ans`, else we append `val` to `ans`. We then return `ans`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (minPath grid k)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (compare game guess)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)\n    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef compare(game: List[int],guess: List[int]) -> List[int]:\n    return [abs(x-y) for x,y in zip(game,guess)]\n\n### Explanation\n\nThe code is an implementation of  a function called `compare` that takes two lists of integers as input and returns a list of integers. The function is defined using the `def` keyword and takes two arguments `game` and `guess` which are both lists of integers. The function returns a list of integers.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (compare game guess)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 1 4 9)) 14 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) 9 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1)) -3 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list -1 -5 2 -1 -5)) -126 0.001)\n    (check-within (candidate (list -56 -99 1 0 -2)) 3030 0.001)\n    (check-within (candidate (list -1 0 0 0 0 0 0 0 -1)) 0 0.001)\n    (check-within (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37)) -14196 0.001)\n    (check-within (candidate (list -1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10)) -1448 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[int]) -> int:\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n\n### Explanation\n\nThe code is an implementation of  `sum_squares` function that takes a list of integers and returns the sum of the squares of the integers in the list. The function is defined with the `def` keyword and takes a single argument, `lst`, which is a list of integers. The function returns an integer.\n\n```python\nfrom typing import List\n```\nThis line imports the `List` type from the `typing` module. This is used to specify the type of the `lst` argument in the function definition.\n\n```python\nresult =[]\n```\nThis line initializes an empty list called `result`. This list will be used to store the squares of the integers in the input list.\n\n```python\nfor i in range(len(lst)):\n```\nThis line starts a `for` loop that iterates over the indices of the input list. The `range(len(lst))` function generates a sequence of integers from `0` to `len(lst) - 1`.\n\n```python\nelse:\n    result.append(lst[i])\n```\nThis line is executed if neither of the previous conditions are met. In this case, the integer at the current index is simply appended to the `result` list.\n\n```python\nreturn sum(result)\n```\nThis line returns the sum of the integers in the `result` list using the built-in `sum()` function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (digitSum s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abAB\") 131 0.001)\n    (check-within (candidate \"abcCd\") 67 0.001)\n    (check-within (candidate \"helloE\") 69 0.001)\n    (check-within (candidate \"woArBld\") 131 0.001)\n    (check-within (candidate \"aAaaaXa\") 153 0.001)\n    (check-within (candidate \" How are yOu?\") 151 0.001)\n    (check-within (candidate \"You arE Very Smart\") 327 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef digitSum(s: str) -> int:\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n\n### Explanation\n\n1. `def digitSum(s: str) -> int:` defines a function called `digitSum` that takes a string `s` as an argument and returns an integer.\n2. `if s == \"\": return 0` checks if the string `s` is empty. If it is, the function returns 0.\n3. `return sum(ord(char) if char.isupper() else 0 for char in s)` computes the sum of the ASCII values of all uppercase characters in the string `s`. It does this by iterating over each character in the string `s` and checking if it is uppercase. If it is, it adds the ASCII value of the character to the sum. If it is not, it adds 0 to the sum. The `ord()` function is used to get the ASCII value of the character. The `sum()` function is used to add up all the values.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (digitSum s)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_third l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_third))\n    (check-within (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5) 0.001)\n    (check-within (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5) 0.001)\n    (check-within (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5) 0.001)\n    (check-within (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n\n### Explanation\n\n```python\nfrom typing import List\n```\nThe `typing` module is used to specify the type of the input and output of the function. Here, the input is a list of integers and the output is also a list of integers.\n\n```python\nl = list(l)\n```\nThe input list `l` is converted to a new list `l` using the `list()` constructor. This is done to avoid modifying the original list.\n\n```python\nl[::3] = sorted(l[::3])\n```\nThe `l[::3]` is a slice of the list `l` that contains every third element of the list. The `sorted()` function is used to sort this slice in ascending order. The sorted slice is then assigned back to the original slice using the `=` operator. This sorts every third element of the list.\n\n```python\nreturn l\n```\nThe sorted list `l` is returned as output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_third l)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fizz_buzz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n    (check-within (candidate 50) 0 0.001)\n    (check-within (candidate 78) 2 0.001)\n    (check-within (candidate 79) 3 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 200) 6 0.001)\n    (check-within (candidate 4000) 192 0.001)\n    (check-within (candidate 10000) 639 0.001)\n    (check-within (candidate 100000) 8026 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fizz_buzz(n: int) -> int:\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n\n### Explanation\n\nThe code is an implementation of  FizzBuzz. The function takes an integer `n` as input and returns the number of times the digit `7` appears in the numbers that are multiples of 11 or 13 up to `n`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fizz_buzz n)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (intersection interval1 interval2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersection))\n    (check-within (candidate (list 1 2) (list 2 3)) \"NO\" 0.001)\n    (check-within (candidate (list -1 1) (list 0 4)) \"NO\" 0.001)\n    (check-within (candidate (list -3 -1) (list -5 5)) \"YES\" 0.001)\n    (check-within (candidate (list -2 2) (list -4 0)) \"YES\" 0.001)\n    (check-within (candidate (list -11 2) (list -1 -1)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 3 5)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 1 2)) \"NO\" 0.001)\n    (check-within (candidate (list -2 -2) (list -3 -2)) \"NO\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n\n### Explanation\n\nThe function then initializes two variables `l` and `r` to the maximum of the first element of the first input tuple and the first element of the second input tuple, and the minimum of the second element of the first input tuple and the second element of the second input tuple, respectively. These variables represent the left and right endpoints of the intersection of the two intervals.\n\nThe function then calculates the length of the intersection by subtracting `l` from `r`, and stores the result in a variable called `length`.\n\nFinally, the function checks if the length of the intersection is greater than 0 and is a prime number by calling the `is_prime` function on `length`. If it is, the function returns \"YES\". Otherwise, the function returns \"NO\".<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (intersection interval1 interval2)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_numbers numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"three\") \"three\" 0.001)\n    (check-within (candidate \"three five nine\") \"three five nine\" 0.001)\n    (check-within (candidate \"five zero four seven nine eight\") \"zero four five seven eight nine\" 0.001)\n    (check-within (candidate \"six five four three two one zero\") \"zero one two three four five six\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n\n### Explanation\n\nThe function takes a single argument `numbers` which is a string of space-separated numbers in English. The return type of the function is also a string.\n\nThe function then splits the input string `numbers` into a list of individual words using the `split` method. The argument to the `split` method is a space character, which specifies that the string should be split at each space character.\n\nThe resulting list of words is then filtered using a list comprehension to remove any empty strings. This is done using the `if x` condition, which checks if the string `x` is not empty.\n\nThe filtered list of words is then sorted in ascending order using the `sorted` function. The `key` argument to the `sorted` function is a lambda function that maps each word to its corresponding integer value using the `value_map` dictionary.\n\nFinally, the sorted list of words is joined back into a string using the `join` method. The argument to the `join` method is a space character, which specifies that each word should be separated by a space character.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_numbers numbers)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (make_a_pile n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_a_pile))\n    (check-within (candidate 3) (list 3 5 7) 0.001)\n    (check-within (candidate 4) (list 4 6 8 10) 0.001)\n    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)\n    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)\n    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2*i for i in range(n)]\n\n### Explanation\n\nThe function takes an integer `n` as input and returns a list of integers. The `List` type is imported from the `typing` module. The `List` type is a generic type that is used to represent a list of elements of a specific type. In this case, the list contains integers.\n\nThe `make_a_pile` function uses a list comprehension to generate the list of integers. The list comprehension is a concise way of creating a list in Python. The list comprehension consists of an expression that is evaluated for each element in the range `0` to `n-1`. The expression is `n + 2*i`, which adds `2*i` to `n` for each `i` in the range `0` to `n-1`. The resulting list is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (make_a_pile n)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (iscube a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate iscube))\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate -1) #t 0.001)\n    (check-within (candidate 64) #t 0.001)\n    (check-within (candidate 180) #f 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 0) #t 0.001)\n    (check-within (candidate 1729) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef iscube(a: int) -> bool:\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n\n### Explanation\n\nHere is a line-by-line explanation of the code:\n\n```python\n    a = abs(a)\n```\nThis line takes the absolute value of the input integer `a`. This is done to ensure that the function works correctly for negative integers as well.\n\n```python\n    return int(round(a ** (1. / 3))) ** 3 == a\n```\nThis line checks if the input integer `a` is a perfect cube or not. It does this by taking the cube root of `a` using the `**(1./3)` operator, which raises `a` to the power of `1/3`. The `round` function is used to round the result to the nearest integer, and the `int` function is used to convert the result to an integer. The result is then cubed using the `**3` operator, and compared to the original input integer `a`. If the two values are equal, then `a` is a perfect cube and the function returns `True`. Otherwise, the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (iscube a)\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (will_it_fly q w)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate will_it_fly))\n    (check-within (candidate (list 3 2 3) 9) #t 0.001)\n    (check-within (candidate (list 1 2) 5) #f 0.001)\n    (check-within (candidate (list 3) 5) #t 0.001)\n    (check-within (candidate (list 3 2 3) 1) #f 0.001)\n    (check-within (candidate (list 1 2 3) 6) #f 0.001)\n    (check-within (candidate (list 5) 5) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef will_it_fly(q: List[int], w: int) -> bool:\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n\n### Explanation\n\nThe code is an implementation of  a function `will_it_fly` that takes two arguments, a list of integers `q` and an integer `w`. The function returns a boolean value indicating whether or not the sum of the integers in `q` is less than or equal to `w` and whether the list is a palindrome.\n\nThe first line of the code imports the `List` class from the `typing` module. This is used to specify the type of the `q` argument as a list of integers.\n\n```python\nfrom typing import List\n```\n\n```python\ndef will_it_fly(q: List[int], w: int) -> bool:\n```\n\n```python\n    if sum(q) > w:\n        return False\n```\n\nThe next two lines initialize two variables `i` and `j` to `0` and `len(q)-1` respectively. These variables are used to traverse the list `q` from both ends.\n\n```python\n    i, j = 0, len(q)-1\n```\n\nFinally, if the loop completes without returning `False`, the function returns `True`.\n\n```python\n    return True\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (will_it_fly q w)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_equal_to_sum_even n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #t 0.001)\n    (check-within (candidate 11) #f 0.001)\n    (check-within (candidate 12) #t 0.001)\n    (check-within (candidate 13) #f 0.001)\n    (check-within (candidate 16) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_equal_to_sum_even(n: int) -> bool:\n    return n%2 == 0 and n >= 8\n\n### Explanation\n\nThe code is an implementation of  a function that takes an integer as input and returns a boolean. The function returns True if the input integer is greater than or equal to 8 and is even. Otherwise, it returns False.\n\nThe function is named `is_equal_to_sum_even` and it takes a single argument `n` which is an integer. The function definition specifies that the input argument should be of type `int` and that the function will return a boolean.\n\nThe line of code uses the logical operator `and` to combine the two expressions. If both expressions evaluate to True, then the entire expression will evaluate to True. If either expression evaluates to False, then the entire expression will evaluate to False.\n\nFinally, the function returns the result of the expression as a boolean value. If the expression evaluates to True, then the function will return True. If the expression evaluates to False, then the function will return False.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_equal_to_sum_even n)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (largest_prime_factor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n    (check-within (candidate 15) 5 0.001)\n    (check-within (candidate 27) 3 0.001)\n    (check-within (candidate 63) 7 0.001)\n    (check-within (candidate 330) 11 0.001)\n    (check-within (candidate 13195) 29 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef largest_prime_factor(n: int) -> int:\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n\n### Explanation\n\nThe code is an implementation of  a function that takes an integer and returns the largest prime factor of that integer. \n\n```python\ndef largest_prime_factor(n: int) -> int:\n```\nThis line defines a function called `largest_prime_factor` that takes an integer `n` as input and returns an integer.\n\n```python\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n```\nThis line defines a helper function called `is_prime` that takes an integer `k` as input and returns a boolean value indicating whether `k` is prime or not. The function checks if `k` is less than 2, in which case it returns `False`. Otherwise, it checks if `k` is divisible by any number between 2 and `k-1`. If it is, then `k` is not prime and the function returns `False`. If no such number is found, then `k` is prime and the function returns `True`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_prime_factor n)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (has_close_elements numbers threshold)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n### Explanation\n\nThe code is an implementation of  `has_close_elements` function that takes in a list of numbers and a threshold value. The function returns a boolean value indicating whether there are any two elements in the list that are closer to each other than the threshold value.\n\n```python\nfrom typing import List\n```\nThe `typing` module provides support for type hints. This line imports the `List` type hint from the module.\n\n```python\nfor idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n```\nThis line starts a nested loop that iterates through all possible pairs of elements in the `numbers` list. The `enumerate` function is used to get the index and value of each element in the list.\n\n```python\nif idx != idx2:\n```\nThis line checks if the current pair of elements are not the same element. If they are the same element, then the distance between them is 0 and we don't need to check if it's less than the threshold.\n\n```python\nif distance < threshold:\n    return True\n```\nThis line checks if the distance between the two elements is less than the threshold. If it is, then we have found a pair of elements that are too close to each other and we return `True`.\n\n```python\nreturn False\n```\nIf we have iterated through all possible pairs of elements and haven't found any that are too close to each other, then we return `False`. This means that there are no pairs of elements in the list that are closer to each other than the threshold value.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (has_close_elements numbers threshold)\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sorted_list_sum lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sorted_list_sum))\n    (check-within (candidate (list \"aa\" \"a\" \"aaa\")) (list \"aa\") 0.001)\n    (check-within (candidate (list \"school\" \"AI\" \"asdf\" \"b\")) (list \"AI\" \"asdf\" \"school\") 0.001)\n    (check-within (candidate (list \"d\" \"b\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"d\" \"dcba\" \"abcd\" \"a\")) (list \"abcd\" \"dcba\") 0.001)\n    (check-within (candidate (list \"AI\" \"ai\" \"au\")) (list \"AI\" \"ai\" \"au\") 0.001)\n    (check-within (candidate (list \"a\" \"b\" \"b\" \"c\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"aaaa\" \"bbbb\" \"dd\" \"cc\")) (list \"cc\" \"dd\" \"aaaa\" \"bbbb\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sorted_list_sum(lst: List[str]) -> List[str]:\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n\n### Explanation\n\nThe code is an implementation of  a function called `sorted_list_sum` that takes a list of strings as input and returns a sorted list of strings that have an even number of characters. \n\n```python\ndef sorted_list_sum(lst: List[str]) -> List[str]:\n```\nThis line defines the function `sorted_list_sum` that takes a list of strings as input and returns a list of strings. The `->` is used to define the return type of the function.\n\n```python\nlst.sort()\n```\nThis line sorts the input list in ascending order.\n\n```python\nnew_lst = []\n```\nThis line creates an empty list called `new_lst`.\n\n```python\nreturn sorted(new_lst, key=len)\n```\nThis line sorts the `new_lst` in ascending order based on the length of the strings in the list. The `key=len` argument is used to specify that the sorting should be based on the length of the strings. The sorted list is then returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sorted_list_sum lst)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (mean_absolute_deviation numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mean_absolute_deviation))\n    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n### Explanation\n\nThe code is an implementation of  mean absolute deviation (MAD) in Python. MAD is a statistical measure that calculates the average deviation of a set of data from its mean. \n\nThe first line of the function calculates the mean of the input list by dividing the sum of the numbers by the length of the list. The result is assigned to the variable `mean`.\n\nThe second line of the function calculates the MAD of the input list. It does this by subtracting the mean from each number in the list, taking the absolute value of the result, and then summing all of these values. The final result is divided by the length of the list to get the average deviation. This value is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (mean_absolute_deviation numbers)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (common l1 l2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n    (check-within (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653) 0.001)\n    (check-within (candidate (list 5 3 2 8) (list 3 2)) (list 2 3) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n\n### Explanation\n\nThe code is an implementation of  a function called `common` that takes two lists of integers and returns a list of integers that are common to both lists. The function uses a set to store the common elements and then returns a sorted list of the elements in the set.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is a generic class that can be used to represent a list of any type.\n\n```python\nret = set()\n```\nThis line creates an empty set called `ret`. The set will be used to store the common elements between the two lists.\n\n```python\nfor e1 in l1:\n    for e2 in l2:\n        if e1 == e2:\n            ret.add(e1)\n```\nThese lines use nested loops to iterate over each element in `l1` and `l2`. If an element in `l1` is equal to an element in `l2`, the element is added to the `ret` set.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (common l1 l2)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (search lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate search))\n    (check-within (candidate (list 5 5 5 5 1)) 1 0.001)\n    (check-within (candidate (list 4 1 4 1 4 4)) 4 0.001)\n    (check-within (candidate (list 3 3)) -1 0.001)\n    (check-within (candidate (list 8 8 8 8 8 8 8 8)) 8 0.001)\n    (check-within (candidate (list 2 3 3 2 2)) 2 0.001)\n    (check-within (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1 0.001)\n    (check-within (candidate (list 3 2 8 2)) 2 0.001)\n    (check-within (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1 0.001)\n    (check-within (candidate (list 8 8 3 6 5 6 4)) -1 0.001)\n    (check-within (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1 0.001)\n    (check-within (candidate (list 1 9 10 1 3)) 1 0.001)\n    (check-within (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n    (check-within (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4 0.001)\n    (check-within (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2 0.001)\n    (check-within (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1 0.001)\n    (check-within (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4 0.001)\n    (check-within (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4 0.001)\n    (check-within (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2 0.001)\n    (check-within (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1 0.001)\n    (check-within (candidate (list 10)) -1 0.001)\n    (check-within (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2 0.001)\n    (check-within (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1 0.001)\n    (check-within (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1 0.001)\n    (check-within (candidate (list 3 10 10 9 2)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef search(lst: List[int]) -> int:\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n\n### Explanation\n\nThe code is an implementation of  a function called `search` that takes a list of integers as input and returns an integer. The function is implemented in Python. The function is designed to find the smallest integer that appears at least as many times as itself in the input list. \n\nThe function starts by importing the List module from the typing package. This module is used to define the type of the input parameter and the return value of the function. \n\n```python\nfrom typing import List\n```\n\n```python\ndef search(lst: List[int]) -> int:\n```\n\nThe function creates a new list called `frq` with a length equal to the maximum value in the input list plus one. The `max` function is used to find the maximum value in the input list. The `+1` is added to ensure that the list has enough space to store the frequency of all the integers in the input list. \n\n```python\n    frq = [0] * (max(lst) + 1)\n```\n\n```python\n    for i in lst:\n        frq[i] += 1;\n```\n\n```python\n    ans = -1\n```\n\nThe function then iterates over the `frq` list starting from index 1. The loop checks if the frequency of the integer at the current index is greater than or equal to the value of the index. If this condition is true, then the answer is updated to the current index. \n\n```python\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n```\n\nFinally, the function returns the answer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (search lst)\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_array arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5) 0.001)\n    (check-within (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3) 0.001)\n    (check-within (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77) 0.001)\n    (check-within (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n\n### Explanation\n\n```python\nfrom typing import List\n```\n\nThe `sort_array` function sorts the input array twice. The first sort is to ensure that the integers are sorted in ascending order. The second sort is based on the number of 1 bits in the binary representation of each integer. \n\nThe `sorted` function is used to sort the array in ascending order. The `key` argument is used to specify the sorting criteria. The `lambda` function takes in an integer `x` and returns the number of 1 bits in the binary representation of `x`. The `bin` function is used to convert the integer to its binary representation. The `[2:]` slice is used to remove the `0b` prefix from the binary representation. The `count` method is used to count the number of 1 bits in the binary representation.\n\n```python\nsorted(arr), key=lambda x: bin(x)[2:].count('1')\n```\n\nThe `sort_array` function returns the sorted array.\n\n```python\nreturn sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_array arr)\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (Strongest_Extension class_name extensions)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n    (check-within (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\")) \"Watashi.eIGHt8OKe\" 0.001)\n    (check-within (candidate \"Boku123\" (list \"nani\" \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\" 0.001)\n    (check-within (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\" \"123NoooneB321\")) \"__YESIMHERE.NuLl__\" 0.001)\n    (check-within (candidate \"K\" (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\" 0.001)\n    (check-within (candidate \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\" 0.001)\n    (check-within (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"-_-\")) \"YameRore.okIWILL123\" 0.001)\n    (check-within (candidate \"finNNalLLly\" (list \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\" 0.001)\n    (check-within (candidate \"_\" (list \"Bb\" \"91245\")) \"_.Bb\" 0.001)\n    (check-within (candidate \"Sp\" (list \"671235\" \"Bb\")) \"Sp.671235\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n### Explanation\n\nThe code is an implementation of  a function `Strongest_Extension` that takes in two parameters: `class_name` and `extensions`. `class_name` is a string representing the name of a class, while `extensions` is a list of strings representing the names of classes that extend the class represented by `class_name`.\n\nThe function returns a string that is the name of the class in `extensions` that has the strongest extension. The strength of an extension is determined by the difference between the number of uppercase letters and the number of lowercase letters in the name of the class. The class with the highest difference is considered to have the strongest extension.\n\nThe function then iterates through the remaining elements of the `extensions` list, calculates the strength of each element, and compares it to `my_val`. If the strength of the current element is greater than `my_val`, then `strong` is updated to the current element and `my_val` is updated to the strength of the current element.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (Strongest_Extension class_name extensions)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_max_triples n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 10) 36 0.001)\n    (check-within (candidate 100) 53361 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef get_max_triples(n: int) -> int:\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n\n### Explanation\n\nThe code is an implementation of 3SUM problem. The 3SUM problem is a classic computer science problem that asks if there exist three elements in an array whose sum equals to zero. The problem statement is as follows:\n\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nThe first line of the function creates a list `A` of length `n` where the i-th element of the list is i^2 - i + 1. This is done using a list comprehension. \n\nThe second line of the function initializes an empty list `ans`.\n\nFinally, the function returns the length of the list `ans`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_max_triples n)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (exchange lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate exchange))\n    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) \"YES\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 4)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 3)) \"NO\" 0.001)\n    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) \"NO\" 0.001)\n    (check-within (candidate (list 100 200) (list 200 200)) \"YES\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n\n### Explanation\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is used to indicate that the input arguments `lst1` and `lst2` are lists of integers.\n\n```python\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n```\nThis line defines the function `exchange` that takes two arguments `lst1` and `lst2`, both of which are lists of integers. The function returns a string.\n\n```python\nodd = 0\neven = 0\n```\nThese lines initialize two variables `odd` and `even` to 0. These variables will be used to count the number of odd and even numbers in `lst1` and `lst2`.\n\n```python\nfor i in lst2:\n    if i%2 == 0:\n        even += 1\n```\nThis loop iterates over each element `i` in `lst2`. If `i` is even (i.e., `i%2 == 0`), then the `even` variable is incremented by 1.\n\n```python\nif even >= odd:\n    return \"YES\"\nreturn \"NO\"\n```\nThis code block checks if the number of even numbers in `lst2` is greater than or equal to the number of odd numbers in `lst1`. If it is, then the function returns \"YES\". Otherwise, it returns \"NO\".<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (exchange lst1 lst2)\n"
  },
  {
    "name": "HumanEval_130_tri",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (tri n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_130_tri.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate tri))\n    (check-within (candidate 3) (list 1 3 2 8) 0.001)\n    (check-within (candidate 4) (list 1 3 2 8 3) 0.001)\n    (check-within (candidate 5) (list 1 3 2 8 3 15) 0.001)\n    (check-within (candidate 6) (list 1 3 2 8 3 15 4) 0.001)\n    (check-within (candidate 7) (list 1 3 2 8 3 15 4 24) 0.001)\n    (check-within (candidate 8) (list 1 3 2 8 3 15 4 24 5) 0.001)\n    (check-within (candidate 9) (list 1 3 2 8 3 15 4 24 5 35) 0.001)\n    (check-within (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11) 0.001)\n    (check-within (candidate 0) (list 1) 0.001)\n    (check-within (candidate 1) (list 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef tri(n: int) -> List[int]:\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n\n### Explanation\n\nThe code is an implementation of  [Triangular numbers](https://en.wikipedia.org/wiki/Triangular_number). The function `tri` takes an integer `n` as input and returns a list of `n` triangular numbers. \n\n```python\n    if n == 0:\n        return [1]\n```\nIf `n` is zero, the function returns a list containing the integer 1.\n\n```python\n    my_tri = [1, 3]\n```\nA list `my_tri` is initialized with the first two triangular numbers, 1 and 3.\n\n```python\n    for i in range(2, n + 1):\n```\nA `for` loop is used to iterate over the range of integers from 2 to `n` (inclusive).\n\n```python\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n```\nIf `i` is even, the next triangular number is calculated by dividing `i` by 2 and adding 1. This is because every even number `n` is the sum of two consecutive triangular numbers, `n/2` and `n/2 + 1`.\n\n```python\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n```\nIf `i` is odd, the next triangular number is calculated by adding the previous two triangular numbers in the list, and adding `(i + 3) / 2`. This is because every odd number `n` is the sum of three consecutive triangular numbers, `n-1`, `n-2`, and `n-3`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (tri n)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (generate_integers a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate generate_integers))\n    (check-within (candidate 2 10) (list 2 4 6 8) 0.001)\n    (check-within (candidate 10 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 132 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 17 89) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n\n### Explanation\n\nThe first line of the code imports the `List` type from the `typing` module.\n\nThe second line defines the `generate_integers` function which takes two integer arguments `a` and `b` and returns a list of integers.\n\nThe third line sets the variable `lower` to the maximum of 2 and the minimum of `a` and `b`. This is done to ensure that the lower bound of the range is at least 2.\n\nThe fourth line sets the variable `upper` to the minimum of 8 and the maximum of `a` and `b`. This is done to ensure that the upper bound of the range is at most 8.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (generate_integers a b)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_closest_vowel word)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-within (candidate \"yogurt\") \"u\" 0.001)\n    (check-within (candidate \"full\") \"u\" 0.001)\n    (check-within (candidate \"easy\") \"\" 0.001)\n    (check-within (candidate \"eAsy\") \"\" 0.001)\n    (check-within (candidate \"ali\") \"\" 0.001)\n    (check-within (candidate \"bad\") \"a\" 0.001)\n    (check-within (candidate \"most\") \"o\" 0.001)\n    (check-within (candidate \"ab\") \"\" 0.001)\n    (check-within (candidate \"ba\") \"\" 0.001)\n    (check-within (candidate \"quick\") \"\" 0.001)\n    (check-within (candidate \"anime\") \"i\" 0.001)\n    (check-within (candidate \"Asia\") \"\" 0.001)\n    (check-within (candidate \"Above\") \"o\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef get_closest_vowel(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n\n### Explanation\n\nThe code is an implementation of  a function that takes a string as input and returns the closest vowel to the middle of the string. If there are no vowels, an empty string is returned. \n\n```python\n    if len(word) < 3:\n        return \"\"\n```\nIf the length of the word is less than 3, the function returns an empty string.\n\n```python\n    for i in range(len(word)-2, 0, -1):\n```\nA for loop is used to iterate over the indices of the string. The loop starts at the second to last index and ends at the first index. The loop decrements by 1.\n\n```python\n        if word[i] in vowels:\n```\nIf the current character is a vowel, the following code block is executed.\n\n```python\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n```\nIf the previous and next characters are not vowels, the current character is returned.\n\n```python\n    return \"\"\n```\nIf no vowels are found, an empty string is returned.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_closest_vowel word)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (greatest_common_divisor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n    (check-within (candidate 3 7) 1 0.001)\n    (check-within (candidate 10 15) 5 0.001)\n    (check-within (candidate 49 14) 7 0.001)\n    (check-within (candidate 144 60) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n\n### Explanation\n\nThe function `greatest_common_divisor` takes two integer arguments `a` and `b` and returns an integer. \n\nThe second line of the function definition is a `while` loop that continues to execute as long as the value of `b` is not zero. \n\nThe third line of the loop assigns the value of `b` to `a` and the value of `a % b` to `b`. The `%` operator returns the remainder of the division of `a` by `b`. \n\nThe fourth line of the function returns the value of `a` after the loop has completed. This value is the greatest common divisor of the original values of `a` and `b`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (greatest_common_divisor a b)\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (find_closest_elements numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n\n### Explanation\n\nThe code is an implementation of  a function that finds the closest pair of numbers in a list of numbers. \n\n```python\nfrom typing import List, Tuple\n```\nThis line imports the List and Tuple classes from the typing module. The List class is used to indicate that the function takes a list of numbers as input, while the Tuple class is used to indicate that the function returns a tuple of two numbers.\n\n```python\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n```\nThis line defines the function `find_closest_elements` which takes a list of floats as input and returns a tuple of two floats. \n\n```python\nclosest_pair = None\ndistance = None\n```\nThese lines initialize two variables, `closest_pair` and `distance`, to `None`. These variables will be used to keep track of the closest pair of numbers and the distance between them, respectively.\n\n```python\nif distance is None:\n    distance = abs(elem - elem2)\n    closest_pair = tuple(sorted([elem, elem2]))\nelse:\n    new_distance = abs(elem - elem2)\n    if new_distance < distance:\n        distance = new_distance\n        closest_pair = tuple(sorted([elem, elem2]))\n```\nThese lines calculate the distance between the two numbers being compared and update the `closest_pair` and `distance` variables if the new distance is smaller than the previous distance. The `sorted` function is used to ensure that the two numbers in `closest_pair` are in ascending order.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (find_closest_elements numbers)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (odd_count lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate odd_count))\n    (check-within (candidate (list \"1234567\")) (list \"the number of odd elements 4n the str4ng 4 of the 4nput.\") 0.001)\n    (check-within (candidate (list \"3\" \"11111111\")) (list \"the number of odd elements 1n the str1ng 1 of the 1nput.\" \"the number of odd elements 8n the str8ng 8 of the 8nput.\") 0.001)\n    (check-within (candidate (list \"271\" \"137\" \"314\")) (list \"the number of odd elements 2n the str2ng 2 of the 2nput.\" \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \"the number of odd elements 2n the str2ng 2 of the 2nput.\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n\n### Explanation\n\nThe first line of the code imports the `List` class from the `typing` module. This is used to specify the type of the input and output of the `odd_count` function.\n\nThe second line defines the `odd_count` function. The function takes in a list of strings `lst` as input and returns a list of strings as output. The `-> List[str]` specifies that the output is a list of strings.\n\nThe third line initializes an empty list `res` that will be used to store the output strings.\n\nThe fourth line starts a `for` loop that iterates over each string `arr` in the input list `lst`.\n\nThe fifth line initializes a variable `n` to 0. This variable will be used to store the number of odd elements in the current string `arr`.\n\nThe eighth line ends the `for` loop.\n\nThe ninth line returns the `res` list that contains the output strings.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (odd_count lst)\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (even_odd_palindrome n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_palindrome))\n    (check-within (candidate 123) (list 8 13) 0.001)\n    (check-within (candidate 12) (list 4 6) 0.001)\n    (check-within (candidate 3) (list 1 2) 0.001)\n    (check-within (candidate 63) (list 6 8) 0.001)\n    (check-within (candidate 25) (list 5 6) 0.001)\n    (check-within (candidate 19) (list 4 6) 0.001)\n    (check-within (candidate 9) (list 4 5) 0.001)\n    (check-within (candidate 1) (list 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThe code is an implementation of  a function `even_odd_palindrome` that takes an integer `n` and returns a tuple of two integers. The first integer is the count of even palindromes between 1 and `n` inclusive, and the second integer is the count of odd palindromes between 1 and `n` inclusive.\n\nThe function then loops through the range of integers from 1 to `n` inclusive using a `for` loop. For each integer `i`, the function checks whether it is odd or even using the modulo operator `%`. If `i` is odd and a palindrome, the `odd_palindrome_count` variable is incremented by 1. If `i` is even and a palindrome, the `even_palindrome_count` variable is incremented by 1.\n\nFinally, the function returns a tuple of the two counts.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (even_odd_palindrome n)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (prime_length string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n    (check-within (candidate \"Hello\") #t 0.001)\n    (check-within (candidate \"abcdcba\") #t 0.001)\n    (check-within (candidate \"kittens\") #t 0.001)\n    (check-within (candidate \"orange\") #f 0.001)\n    (check-within (candidate \"wow\") #t 0.001)\n    (check-within (candidate \"world\") #t 0.001)\n    (check-within (candidate \"MadaM\") #t 0.001)\n    (check-within (candidate \"Wow\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"HI\") #t 0.001)\n    (check-within (candidate \"go\") #t 0.001)\n    (check-within (candidate \"gogo\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaa\") #f 0.001)\n    (check-within (candidate \"Madam\") #t 0.001)\n    (check-within (candidate \"M\") #f 0.001)\n    (check-within (candidate \"0\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef prime_length(string: str) -> bool:\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of  a function that checks if the length of a string is a prime number. \n\n```python\ndef prime_length(string: str) -> bool:\n```\nThe function is called `prime_length` and accepts a string as input. The `-> bool` specifies that the function returns a boolean value.\n\n```python\nfor i in range(2, l):\n    if l % i == 0:\n        return False\n```\nThe function then checks if the length of the string is divisible by any number between 2 and the length of the string. If it is, the function returns `False` because a prime number is only divisible by 1 and itself.\n\n```python\nreturn True\n```\nIf the length of the string is not divisible by any number between 2 and the length of the string, the function returns `True` because the length of the string is a prime number.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prime_length string)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (change_base x base)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n    (check-within (candidate 8 3) \"22\" 0.001)\n    (check-within (candidate 9 3) \"100\" 0.001)\n    (check-within (candidate 234 2) \"11101010\" 0.001)\n    (check-within (candidate 16 2) \"10000\" 0.001)\n    (check-within (candidate 8 2) \"1000\" 0.001)\n    (check-within (candidate 7 2) \"111\" 0.001)\n    (check-within (candidate 2 3) \"2\" 0.001)\n    (check-within (candidate 3 4) \"3\" 0.001)\n    (check-within (candidate 4 5) \"4\" 0.001)\n    (check-within (candidate 5 6) \"5\" 0.001)\n    (check-within (candidate 6 7) \"6\" 0.001)\n    (check-within (candidate 7 8) \"7\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef change_base(x: int, base: int) -> str:\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\n### Explanation\n\nThe code is an implementation of  a function called `change_base` that takes two arguments, `x` and `base`. The function returns a string that represents the number `x` in the given `base`. \n\nThe function first initializes an empty string `ret` that will be used to store the result. \n\nThe function then enters a while loop that will continue running as long as `x` is greater than 0. \n\nInside the loop, the function calculates the remainder of `x` divided by `base` using the modulus operator `%`. This remainder is then converted to a string and concatenated with the current value of `ret`. \n\nThe loop continues until `x` is no longer greater than 0.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (change_base x base)\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (remove_vowels text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_vowels))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"abcdef\nghijklm\") \"bcdf\nghjklm\" 0.001)\n    (check-within (candidate \"fedcba\") \"fdcb\" 0.001)\n    (check-within (candidate \"eeeee\") \"\" 0.001)\n    (check-within (candidate \"acBAA\") \"cB\" 0.001)\n    (check-within (candidate \"EcBOO\") \"cB\" 0.001)\n    (check-within (candidate \"ybcd\") \"ybcd\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef remove_vowels(text: str) -> str:\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n\n### Explanation\n\n```python\ndef remove_vowels(text: str) -> str:\n```\nThe function is called `remove_vowels` and takes a string argument `text` and returns a string. \n\n```python\nreturn \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n```\nThe function returns a string that is the result of joining all the characters in the input string that are not vowels. The `join` method is called on an empty string `\"\"` and the argument passed to it is a list comprehension that iterates over each character `s` in the input string `text` and only adds it to the list if it is not a vowel. The list of characters is then joined together into a string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (remove_vowels text)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (below_zero operations)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_zero))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)\n    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)\n    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n\n### Explanation\n\nThe function starts by initializing a variable called `balance` to 0. \n\nIt then iterates through the list of integers using a for loop. For each integer in the list, it adds it to the `balance` variable. \n\nIf the `balance` variable is less than 0 at any point during the iteration, the function returns True. \n\nThe `typing` module is imported at the beginning of the code to allow for type annotations. The `List` type is used to indicate that the `operations` parameter is a list of integers. The `-> bool` syntax is used to indicate that the function returns a boolean value.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (below_zero operations)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (below_threshold l t)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_threshold))\n    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)\n    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef below_threshold(l: List[int], t: int) -> bool:\n    for e in l:\n        if e >= t:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of  a function `below_threshold` that takes a list of integers `l` and an integer `t` as input and returns `True` if all elements of `l` are less than `t`, and `False` otherwise.\n\n```python\nfrom typing import List\n```\nThis line imports the `List` type from the `typing` module. The `List` type is used to specify that the input parameter `l` is a list of integers.\n\n```python\ndef below_threshold(l: List[int], t: int) -> bool:\n```\nThis line defines the function `below_threshold` that takes two input parameters:\n- `l`: a list of integers\n- `t`: an integer\n\n```python\n        if e >= t:\n            return False\n```\nThis line checks if the current element `e` is greater than or equal to the threshold `t`. If it is, the function immediately returns `False`, indicating that not all elements in the list are below the threshold.\n\n```python\n    return True\n```\nThis line is reached only if the `for` loop completes without returning `False`. It returns `True`, indicating that all elements in the list are below the threshold.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (below_threshold l t)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (int_to_mini_roman number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n    (check-within (candidate 19) \"xix\" 0.001)\n    (check-within (candidate 152) \"clii\" 0.001)\n    (check-within (candidate 251) \"ccli\" 0.001)\n    (check-within (candidate 426) \"cdxxvi\" 0.001)\n    (check-within (candidate 500) \"d\" 0.001)\n    (check-within (candidate 1) \"i\" 0.001)\n    (check-within (candidate 4) \"iv\" 0.001)\n    (check-within (candidate 43) \"xliii\" 0.001)\n    (check-within (candidate 90) \"xc\" 0.001)\n    (check-within (candidate 94) \"xciv\" 0.001)\n    (check-within (candidate 532) \"dxxxii\" 0.001)\n    (check-within (candidate 900) \"cm\" 0.001)\n    (check-within (candidate 994) \"cmxciv\" 0.001)\n    (check-within (candidate 1000) \"m\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef int_to_mini_roman(number: int) -> str:\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n\n### Explanation\n\n2. `num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]` - This line defines a list called `num` which contains the numbers that correspond to the mini roman numerals.\n\n3. `sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]` - This line defines a list called `sym` which contains the mini roman numerals.\n\n4. `i = 12` - This line initializes a variable `i` to 12. This variable will be used to iterate through the `num` and `sym` lists.\n\n6. `while number:` - This line starts a while loop that will continue as long as `number` is not equal to 0.\n\n7. `div = number // num[i]` - This line calculates the integer division of `number` by the value at index `i` of the `num` list. The result is stored in a variable called `div`.\n\n8. `number %= num[i]` - This line calculates the modulus of `number` by the value at index `i` of the `num` list. The result is stored back in `number`.\n\n9. `while div:` - This line starts a while loop that will continue as long as `div` is not equal to 0.\n\n10. `res += sym[i]` - This line appends the mini roman numeral at index `i` of the `sym` list to the `res` string.\n\n11. `div -= 1` - This line decrements the value of `div` by 1.\n\n13. `return res.lower()` - This line returns the `res` string in lowercase. This is because mini roman numerals are typically written in lowercase.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (int_to_mini_roman number)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (double_the_difference lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate double_the_difference))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 5.0 4.0)) 25 0.001)\n    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)\n    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)\n    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)\n    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)\n    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n\n### Explanation\n\nThe code is an implementation of  `double_the_difference` function that takes a list of floating point numbers and returns the sum of the squares of the numbers that are positive, odd and have no decimal places.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. This is used to specify the type of the input parameter of the function.\n\n```python\nreturn sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n```\nThis line returns the sum of the squares of the numbers in the input list that are positive, odd and have no decimal places. The `sum` function is used to add up the squares of the numbers that meet the specified conditions. The `[]` syntax is used to create a list comprehension that generates a list of squares of the numbers that meet the specified conditions. The `for` keyword is used to iterate over the input list. The `if` keyword is used to filter out the numbers that do not meet the specified conditions. The `i**2` syntax is used to square the number. The `and` keyword is used to combine the conditions. The `not in` syntax is used to check if the decimal point is not in the string representation of the number.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (double_the_difference lst)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (words_in_sentence sentence)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_in_sentence))\n    (check-within (candidate \"This is a test\") \"is\" 0.001)\n    (check-within (candidate \"lets go for swimming\") \"go for\" 0.001)\n    (check-within (candidate \"there is no place available here\") \"there is no place\" 0.001)\n    (check-within (candidate \"Hi I am Hussein\") \"Hi am Hussein\" 0.001)\n    (check-within (candidate \"go for it\") \"go for it\" 0.001)\n    (check-within (candidate \"here\") \"\" 0.001)\n    (check-within (candidate \"here is\") \"is\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef words_in_sentence(sentence: str) -> str:\n    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n\n### Explanation\n\nThe code is an implementation of  a function called `words_in_sentence` that takes in a string called `sentence` and returns a string. The function returns a string that contains all the words in the input sentence that are either prime or have only one letter. \n\nHere is a line by line explanation of the code:\n\n```python\nnew_lst = []\n```\nThis line initializes an empty list called `new_lst`.\n\n```python\nfor word in sentence.split():\n```\nThis line starts a for loop that iterates over each word in the input sentence. The `split()` method is used to split the sentence into a list of words.\n\n```python\nflg = 0\n```\nThis line initializes a variable called `flg` to 0. This variable is used to keep track of whether a word is prime or not.\n\n```python\nfor i in range(2, len(word)):\n    if len(word)%i == 0:\n        flg = 1\n```\nThis line starts another for loop that iterates over each number from 2 to the length of the current word. For each number, it checks if the length of the word is divisible by that number. If it is, then the `flg` variable is set to 1. This is because a word that is divisible by any number other than 1 and itself is not prime.\n\n```python\nif flg == 0 or len(word) == 2:\n    new_lst.append(word)\n```\nThis line checks if the `flg` variable is equal to 0 or if the length of the current word is equal to 2. If either of these conditions is true, then the current word is added to the `new_lst` list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (words_in_sentence sentence)\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (same_chars s0 s1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabc\") #t 0.001)\n    (check-within (candidate \"dddddddabc\" \"abcd\") #t 0.001)\n    (check-within (candidate \"eabcd\" \"dddddddabc\") #f 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabcf\") #f 0.001)\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f 0.001)\n    (check-within (candidate \"aabb\" \"aaccc\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n\n### Explanation\n\nThe code is an implementation of  a function called `same_chars` that takes two strings `s0` and `s1` as input and returns a boolean value. The function returns `True` if the two strings contain the same characters, and `False` otherwise.\n\nThe function compares the sets of the two strings using the `==` operator. If the sets are equal, it means that the two strings contain the same characters, and the function returns `True`. Otherwise, it returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (same_chars s0 s1)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (compare_one a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare_one))\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 2.5) 2.5 0.001)\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 5 6) 6 0.001)\n    (check-within (candidate 1 \"2,3\") \"2,3\" 0.001)\n    (check-within (candidate \"5,1\" \"6\") \"6\" 0.001)\n    (check-within (candidate \"1\" \"2\") \"2\" 0.001)\n    (check-within (candidate \"1\" 1) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b\n\n### Explanation\n\nThe first two lines of the function create temporary variables `temp_a` and `temp_b` and assign them the values of `a` and `b`, respectively. This is done so that the original values of `a` and `b` are not modified.\n\nThe next two lines check if `temp_a` and `temp_b` are of type `str`. If they are, the `replace` method is used to replace any commas in the string with periods. This is done because the `float` function expects a period as the decimal separator, not a comma.\n\nThe next line converts `temp_a` and `temp_b` to `float` values and compares them. If they are equal, the function returns `None`. Otherwise, the function returns `a` if `temp_a` is greater than `temp_b`, and `b` otherwise.\n\n\n### Racket version\n\n#lang racket\n\n;; \n(define (compare_one a b)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (max_fill grid capacity)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_fill))\n    (check-within (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nimport math\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n\n### Explanation\n\nThe code is an implementation of 2D bin packing algorithm. The function `max_fill` takes two arguments, a 2D list of integers `grid` and an integer `capacity`. The function returns the maximum number of bins required to fill all the elements in the grid.\n\n```python\nimport math\nfrom typing import List\n```\n\nThe `max_fill` function takes two arguments, a 2D list of integers `grid` and an integer `capacity`. The function returns the maximum number of bins required to fill all the elements in the grid.\n\n```python\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n```\n\nThe function uses a list comprehension to calculate the number of bins required to fill each row of the grid. The `sum(arr)` function is used to calculate the total number of elements in each row, and `math.ceil()` is used to round up the result of the division by the `capacity` argument.\n\n```python\nreturn sum([math.ceil(sum(arr)/capacity) for arr in grid])\n```\n\nThe `sum()` function is used to calculate the total number of elements in each row of the grid, and `math.ceil()` is used to round up the result of the division by the `capacity` argument.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (max_fill grid capacity)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (solution lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solution))\n    (check-within (candidate (list 5 8 7 1)) 12 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 9 0.001)\n    (check-within (candidate (list 30 13 24 321)) 0 0.001)\n    (check-within (candidate (list 5 9)) 5 0.001)\n    (check-within (candidate (list 2 4 8)) 0 0.001)\n    (check-within (candidate (list 30 13 23 32)) 23 0.001)\n    (check-within (candidate (list 3 13 2 9)) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef solution(lst: List[int]) -> int:\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n\n### Explanation\n\nThe code is an implementation of  a function that takes in a list of integers and returns the sum of all odd numbers at even indices in the list.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. It is used to specify the type of the input parameter of the function.\n\n```python\ndef solution(lst: List[int]) -> int:\n```\nThis line defines the function `solution` which takes in a list of integers and returns an integer. The `-> int` specifies the return type of the function.\n\nThe `enumerate` function is used to get the index and value of each element in the list. \n\nThe list comprehension `[x for idx, x in enumerate(lst) if idx%2==0 and x%2==1]` creates a new list of all odd numbers at even indices in the list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solution lst)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (total_match lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate total_match))\n    (check-within (candidate (list ) (list )) (list ) 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\")) (list \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\" \"admin\" \"project\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list \"4\") (list \"1\" \"2\" \"3\" \"4\" \"5\")) (list \"4\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"Hi\")) (list \"hI\" \"Hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hi\")) (list \"hI\" \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hii\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list ) (list \"this\")) (list ) 0.001)\n    (check-within (candidate (list \"this\") (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n\n### Explanation\n\nThe code is an implementation of  `total_match` function that takes two lists of strings as input and returns the list with the total length of strings less than or equal to the other list. \n\n```python\nfrom typing import List\n```\nImporting List from the typing module. List is a generic type that represents a list of elements of a specific type.\n\n```python\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n```\nDeclaring a function `total_match` that takes two parameters `lst1` and `lst2` of type List of strings and returns a List of strings. \n\n```python\n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n```\nDeclaring a variable `l2` and initializing it to 0. Then iterating through the elements of `lst2` using a for loop and adding the length of each string to `l2`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (total_match lst1 lst2)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (vowels_count s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate vowels_count))\n    (check-within (candidate \"abcde\") 2 0.001)\n    (check-within (candidate \"Alone\") 3 0.001)\n    (check-within (candidate \"key\") 2 0.001)\n    (check-within (candidate \"bye\") 1 0.001)\n    (check-within (candidate \"keY\") 2 0.001)\n    (check-within (candidate \"bYe\") 1 0.001)\n    (check-within (candidate \"ACEDY\") 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef vowels_count(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n\n### Explanation\n\nThe code is an implementation of  a function called `vowels_count` that takes a string `s` as input and returns the number of vowels in the string. \n\n```python\ndef vowels_count(s: str) -> int:\n```\nThe function definition starts with the `def` keyword, followed by the function name `vowels_count`. The function takes a single argument `s` of type `str` and returns an integer. \n\n```python\nif s[-1] == 'y' or s[-1] == 'Y':\n    n_vowels += 1\n```\nThe next line checks if the last character of the input string `s` is either 'y' or 'Y'. If it is, then it is assumed to be a vowel and the `n_vowels` count is incremented by 1. \n\n```python\nreturn n_vowels\n```\nThe final line of the function returns the total count of vowels in the input string `s`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (vowels_count s)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (factorize n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate factorize))\n    (check-within (candidate 2) (list 2) 0.001)\n    (check-within (candidate 4) (list 2 2) 0.001)\n    (check-within (candidate 8) (list 2 2 2) 0.001)\n    (check-within (candidate 57) (list 3 19) 0.001)\n    (check-within (candidate 3249) (list 3 3 19 19) 0.001)\n    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)\n    (check-within (candidate 20577) (list 3 19 19 19) 0.001)\n    (check-within (candidate 18) (list 2 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n### Explanation\n\nThe code is an implementation of  a function that takes an integer and returns a list of its prime factors. \n\n```python\nfrom typing import List\n```\nThe `typing` module is imported to allow the use of type hints. `List` is a type hint for a list of integers.\n\n```python\nimport math\n```\nThe `math` module is imported to allow the use of the `sqrt` function.\n\n```python\nfact = []\n```\nAn empty list is created to store the prime factors of `n`.\n\n```python\nwhile i <= int(math.sqrt(n) + 1):\n```\nThe `while` loop continues as long as `i` is less than or equal to the square root of `n` plus 1. The `int` function is used to convert the result of `math.sqrt(n) + 1` to an integer.\n\n```python\nfact.append(i)\nn //= i\n```\nThe prime factor `i` is added to the `fact` list, and `n` is divided by `i` to reduce it for the next iteration of the loop.\n\n```python\nelse:\n    i += 1\n```\nIf `n` is not divisible by `i`, then `i` is incremented by 1 to check the next number.\n\n```python\nif n > 1:\n    fact.append(n)\n```\nIf `n` is greater than 1 after the loop has finished, then it is a prime factor of itself and is added to the `fact` list.\n\n```python\nreturn fact\n```\nThe `fact` list is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (factorize n)\n"
  },
  {
    "name": "HumanEval_108_count_nums",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_nums arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_108_count_nums.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_nums))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list -1 -2 0)) 0 0.001)\n    (check-within (candidate (list 1 1 2 -2 3 4 5)) 6 0.001)\n    (check-within (candidate (list 1 6 9 -6 0 1 5)) 5 0.001)\n    (check-within (candidate (list 1 100 98 -7 1 -1)) 4 0.001)\n    (check-within (candidate (list 12 23 34 -45 -56 0)) 5 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n\n### Explanation\n\n```python\nfrom typing import List\n```\nImporting List from typing module.\n\n```python\ndef count_nums(arr: List[int]) -> int:\n```\nDefining a function `count_nums` that takes a list of integers as input and returns an integer.\n\n```python\n    def digits_sum(n):\n```\nDefining a nested function `digits_sum` that takes an integer as input and returns the sum of its digits.\n\n```python\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n```\nIf the input integer is negative, it is converted to its absolute value and a flag `neg` is set to -1.\n\n```python\n        n[0] = n[0] * neg\n```\nIf the input integer was negative, the first element of the list is multiplied by -1 to make it negative.\n\n```python\n        return sum(n)\n```\nThe sum of the list is returned.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_nums arr)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (max_element l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_element))\n    (check-within (candidate (list 1 2 3)) 3 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef max_element(l: List[int]) -> int:\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n\n### Explanation\n\n```python\nfrom typing import List\n```\nThis line imports the List type from the typing module. The List type is a generic type that represents a list of elements of a specific type.\n\n```python\ndef max_element(l: List[int]) -> int:\n```\nThis line defines the `max_element` function that takes a list of integers as an argument and returns an integer. The function signature specifies the types of the input and output parameters.\n\n```python\nm = l[0]\n```\nThis line initializes the variable `m` to the first element of the input list `l`.\n\n```python\nfor e in l:\n    if e > m:\n        m = e\n```\nThis block of code iterates over the elements of the input list `l` and updates the value of `m` to the maximum element in the list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (max_element l)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (bf planet1 planet2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate bf))\n    (check-within (candidate \"Jupiter\" \"Neptune\") (list \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Mercury\") (list \"Venus\") 0.001)\n    (check-within (candidate \"Mercury\" \"Uranus\") (list \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\") 0.001)\n    (check-within (candidate \"Neptune\" \"Venus\") (list \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Mars\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Jupiter\" \"Makemake\") (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n\n### Explanation\n\nThe code is an implementation of 2 functions, `bf` and `bf2`. `bf` takes 2 arguments, `planet1` and `planet2`, both of type `str`, and returns a tuple of strings. `bf2` takes no arguments and returns a string.\n\nThe `typing` module is imported to allow type hints to be used. `Tuple` is imported to allow the return type of `bf` to be specified.\n\nThe `planet_names` variable is a tuple of strings containing the names of the planets in the solar system. \n\nThe `planet1_index` and `planet2_index` variables are set to the index of `planet1` and `planet2` in the `planet_names` tuple.\n\nThe second `if` statement checks if `planet1` comes before `planet2` in the `planet_names` tuple. If it does, a slice of the `planet_names` tuple is returned, containing all the planets between `planet1` and `planet2`, excluding `planet1` and `planet2`. If `planet2` comes before `planet1`, the same slice is returned, but with `planet2` coming before `planet1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (bf planet1 planet2)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (simplify x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate simplify))\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/6\" \"2/1\") #f 0.001)\n    (check-within (candidate \"5/1\" \"3/1\") #t 0.001)\n    (check-within (candidate \"7/10\" \"10/2\") #f 0.001)\n    (check-within (candidate \"2/10\" \"50/10\") #t 0.001)\n    (check-within (candidate \"7/2\" \"4/2\") #t 0.001)\n    (check-within (candidate \"11/6\" \"6/1\") #t 0.001)\n    (check-within (candidate \"2/3\" \"5/2\") #f 0.001)\n    (check-within (candidate \"5/2\" \"3/5\") #f 0.001)\n    (check-within (candidate \"2/4\" \"8/4\") #t 0.001)\n    (check-within (candidate \"2/4\" \"4/2\") #t 0.001)\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/5\" \"1/5\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef simplify(x: str, n: str) -> bool:\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n\n### Explanation\n\nThe code is an implementation of  a function called `simplify` that takes in two strings `x` and `n` and returns a boolean. \n\nThe function first splits the two strings `x` and `n` into two parts each, using the `/` character as the separator. The first part of `x` is assigned to the variable `a`, and the second part to the variable `b`. Similarly, the first part of `n` is assigned to the variable `c`, and the second part to the variable `d`.\n\nThe function then checks if the fraction represented by `x` and `n` is a simplified fraction. It does this by dividing the numerator by the denominator, and checking if the result is equal to the integer value of the result of the division. If it is, then the fraction is simplified, and the function returns `True`. Otherwise, the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (simplify x n)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (digits n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 54) 5 0.001)\n    (check-within (candidate 120) 1 0.001)\n    (check-within (candidate 5014) 5 0.001)\n    (check-within (candidate 98765) 315 0.001)\n    (check-within (candidate 5576543) 2625 0.001)\n    (check-within (candidate 2468) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef digits(n: int) -> int:\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n\n### Explanation\n\nThe code is an implementation of  a function named `digits` that takes an integer `n` as input and returns an integer as output. The function returns the product of all odd digits in `n`. If there are no odd digits in `n`, the function returns 0.\n\n```python\ndef digits(n: int) -> int:\n```\nThe function `digits` takes an integer `n` as input and returns an integer as output.\n\n```python\nproduct = 1\nodd_count = 0\n```\nThe variables `product` and `odd_count` are initialized to 1 and 0 respectively. `product` is used to store the product of all odd digits in `n`. `odd_count` is used to count the number of odd digits in `n`.\n\n```python\nif int_digit%2 == 1:\n    product= product*int_digit\n    odd_count+=1\n```\nIf `int_digit` is odd, the product of `product` and `int_digit` is stored in `product`, and `odd_count` is incremented by 1.\n\n```python\nif odd_count ==0:\n    return 0\nelse:\n    return product\n```\nIf `odd_count` is 0, the function returns 0. Otherwise, the function returns `product`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (digits n)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (encrypt s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n    (check-within (candidate \"hi\") \"lm\" 0.001)\n    (check-within (candidate \"asdfghjkl\") \"ewhjklnop\" 0.001)\n    (check-within (candidate \"gf\") \"kj\" 0.001)\n    (check-within (candidate \"et\") \"ix\" 0.001)\n    (check-within (candidate \"faewfawefaewg\") \"jeiajeaijeiak\" 0.001)\n    (check-within (candidate \"hellomyfriend\") \"lippsqcjvmirh\" 0.001)\n    (check-within (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" 0.001)\n    (check-within (candidate \"a\") \"e\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef encrypt(s: str) -> str:\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n\n### Explanation\n\nThe function `encrypt` takes a string `s` as input and returns an encrypted string. \n\nThe variable `d` is a string containing all the letters of the alphabet in lowercase. \n\nThe for loop iterates over each character `c` in the input string `s`. \n\nThe if statement checks if the character `c` is a letter in the alphabet. If it is, the character is encrypted by shifting it two places to the right. The expression `(d.index(c)+2*2) % 26` calculates the index of the encrypted character in the alphabet string `d`. \n\nThe else statement is executed if the character `c` is not a letter in the alphabet. In this case, the character is added to the output string `out` as is. \n\nFinally, the function returns the encrypted string `out`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (encrypt s)\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_simple_power x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n    (check-within (candidate 16 2) #t 0.001)\n    (check-within (candidate 143214 16) #f 0.001)\n    (check-within (candidate 4 2) #t 0.001)\n    (check-within (candidate 9 3) #t 0.001)\n    (check-within (candidate 16 4) #t 0.001)\n    (check-within (candidate 24 2) #f 0.001)\n    (check-within (candidate 128 4) #f 0.001)\n    (check-within (candidate 12 6) #f 0.001)\n    (check-within (candidate 1 1) #t 0.001)\n    (check-within (candidate 1 12) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_simple_power(x: int, n: int) -> bool:\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x)\n\n### Explanation\n\nThe function definition starts with the `def` keyword followed by the function name `is_simple_power`. The function takes two integer arguments `x` and `n` and returns a boolean value. The `-> bool` part of the function definition specifies the return type of the function.\n\n```python\n    if (n == 1): \n        return (x == 1) \n```\n\nThe first line of the function checks if `n` is equal to `1`. If `n` is equal to `1`, the function returns `True` if `x` is also equal to `1`, and `False` otherwise. This is because any number raised to the power of 1 is equal to itself.\n\n```python\n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x)\n```\n\nIf `n` is not equal to `1`, the function initializes a variable called `power` to `1`. The function then enters a `while` loop that continues to execute as long as `power` is less than `x`. In each iteration of the loop, `power` is multiplied by `n`. The loop stops when `power` is greater than or equal to `x`.\n\nAfter the loop, the function checks if `power` is equal to `x`. If `power` is equal to `x`, the function returns `True`, indicating that `x` is a power of `n`. If `power` is not equal to `x`, the function returns `False`, indicating that `x` is not a power of `n`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_simple_power x n)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fib4 n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib4))\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 28 0.001)\n    (check-within (candidate 10) 104 0.001)\n    (check-within (candidate 12) 386 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fib4(n: int) -> int:\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n\n### Explanation\n\nThe code is an implementation of 4-step Fibonacci sequence.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fib4 n)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (check_if_last_char_is_a_letter txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n    (check-within (candidate \"apple\") #f 0.001)\n    (check-within (candidate \"apple pi e\") #t 0.001)\n    (check-within (candidate \"eeeee\") #f 0.001)\n    (check-within (candidate \"A\") #t 0.001)\n    (check-within (candidate \"Pumpkin pie \") #f 0.001)\n    (check-within (candidate \"Pumpkin pie 1\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"eeeee e \") #f 0.001)\n    (check-within (candidate \"apple pie\") #f 0.001)\n    (check-within (candidate \"apple pi e \") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n\n### Explanation\n\nThe code is an implementation of  a function that checks if the last character of a string is a letter.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (check_if_last_char_is_a_letter txt)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (string_sequence n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n    (check-within (candidate 0) \"0\" 0.001)\n    (check-within (candidate 3) \"0 1 2 3\" 0.001)\n    (check-within (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])\n\n### Explanation\n\nThe function is implemented in one line of code. The `join` method is called on a string with a space as the separator. The argument to the `join` method is a list comprehension that generates a list of strings. The list comprehension generates a list of numbers from 0 to `n` using the `range` function. The `range` function generates a sequence of numbers from 0 to `n` (inclusive). Each number in the sequence is converted to a string using the `str` function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (string_sequence n)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (truncate_number number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n    (check-within (candidate 3.5) 0.5 0.001)\n    (check-within (candidate 1.25) 0.25 0.001)\n    (check-within (candidate 123.0) 0.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef truncate_number(number: float) -> float:\n    return number % 1.0\n\n### Explanation\n\nThe code is an implementation of  a function `truncate_number` that takes in a float as an argument and returns the decimal part of the float. \n\nThe function is defined with the `def` keyword and takes in a single argument `number` which is of type float. The `-> float` is a type hint that indicates that the function returns a float.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (truncate_number number)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (unique l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique))\n    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    return sorted(list(set(l)))\n\n### Explanation\n\nThe function is defined with the name `unique` and takes a list of integers `l` as an argument. The function returns a list of integers. \n\nThe `List` module from the `typing` library is imported to enable type hinting. \n\nThe `sorted` function is used to sort the list of unique integers in ascending order.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (unique l)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (filter_by_prefix strings prefix)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [x for x in strings if x.startswith(prefix)]\n\n### Explanation\n\nThe code is an implementation of  a function called `filter_by_prefix` which takes in two arguments, a list of strings called `strings` and a string called `prefix`. The function returns a list of strings that start with the `prefix` argument.\n\nThe first line of the code imports the `List` class from the `typing` module. This is used to specify the type of the `strings` argument and the return type of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (filter_by_prefix strings prefix)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_palindrome text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n    (check-within (candidate \"\") #t 0.001)\n    (check-within (candidate \"aba\") #t 0.001)\n    (check-within (candidate \"aaaaa\") #t 0.001)\n    (check-within (candidate \"zbcd\") #f 0.001)\n    (check-within (candidate \"xywyx\") #t 0.001)\n    (check-within (candidate \"xywyz\") #f 0.001)\n    (check-within (candidate \"xywzx\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_palindrome(text: str) -> bool:\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of  a function that checks if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward.\n\nThe function `is_palindrome` takes in a string `text` as an argument and returns a boolean value. \n\nThe next line starts a for loop that iterates over the indices of the string `text`. The `range` function creates a sequence of numbers from 0 to the length of the string `text` minus 1. \n\n```python\nfor i in range(len(text)):\n```\n\nInside the for loop, the code checks if the character at the current index `i` is equal to the character at the corresponding index from the end of the string `text`. If the characters are not equal, the function immediately returns `False`, indicating that the string is not a palindrome.\n\n```python\nif text[i] != text[len(text) - 1 - i]:\n    return False\n```\n\n```python\nreturn True\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_palindrome text)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (choose_num x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n    (check-within (candidate 12 15) 14 0.001)\n    (check-within (candidate 13 12) -1 0.001)\n    (check-within (candidate 33 12354) 12354 0.001)\n    (check-within (candidate 5234 5233) -1 0.001)\n    (check-within (candidate 6 29) 28 0.001)\n    (check-within (candidate 27 10) -1 0.001)\n    (check-within (candidate 7 7) -1 0.001)\n    (check-within (candidate 546 546) 546 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n\n### Explanation\n\nThe code is an implementation of  a function called `choose_num` that takes two integers `x` and `y` as input and returns an integer. \n\nIf `x` is not greater than `y`, the function checks if `y` is even. If it is, it returns `y`.\n\nIf `x` is not equal to `y`, the function returns `y - 1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (choose_num x y)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (add_elements arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)\n    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)\n    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)\n    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)\n    (check-within (candidate (list 1) 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n\n### Explanation\n\nThe code is an implementation of  a function that takes a list of integers and a number k as input and returns the sum of the first k elements of the list that have at most 2 digits.\n\nThe first line imports the List class from the typing module. This is used to specify the type of the arr parameter in the function signature.\n\nThe second line defines the function add_elements that takes two parameters: arr and k. arr is a list of integers and k is an integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (add_elements arr k)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (remove_duplicates numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_duplicates))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n\n### Explanation\n\nThe code is an implementation of  a function called `remove_duplicates` that takes in a list of integers and returns a new list with all duplicates removed. \n\n```python\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n```\nThis line defines the function `remove_duplicates` which takes in a list of integers as input and returns a list of integers as output. The `List[int]` specifies the type of the input and output.\n\n```python\nimport collections\nc = collections.Counter(numbers)\n```\nThis line imports the `collections` module and creates a `Counter` object `c` which counts the number of occurrences of each integer in the input list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (remove_duplicates numbers)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (parse_music music_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_music))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"o o o o\") (list 4 4 4 4) 0.001)\n    (check-within (candidate \".| .| .| .|\") (list 1 1 1 1) 0.001)\n    (check-within (candidate \"o| o| .| .| o o o o\") (list 2 2 1 1 4 4 4 4) 0.001)\n    (check-within (candidate \"o| .| o| .| o o| o o|\") (list 2 1 2 1 4 2 4 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n\n### Explanation\n\nThe function starts by defining a dictionary `note_map` that maps the music notes to their corresponding integer values. The keys of the dictionary are the music notes and the values are the corresponding integer values. \n\nThe function then returns a list comprehension that iterates over the music notes in the `music_string` argument. The list comprehension uses the `split` method to split the `music_string` argument into a list of music notes. The `if x` condition is used to filter out any empty strings in the list of music notes.\n\nFor each music note in the list of music notes, the list comprehension uses the `note_map` dictionary to map the music note to its corresponding integer value. The resulting list of integer values is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (parse_music music_string)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (rescale_to_unit numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)\n    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)\n    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n\n### Explanation\n\nThe function starts by finding the minimum and maximum values in the input list using the `min` and `max` functions. These values are used to rescale each element in the input list.\n\nThe function then uses a list comprehension to create a new list where each element is rescaled to be between 0 and 1. Specifically, it subtracts the minimum value from each element and divides the result by the difference between the maximum and minimum values. This ensures that the smallest value in the input list is mapped to 0 and the largest value is mapped to 1. \n\nFinally, the function returns the new list of rescaled values.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (rescale_to_unit numbers)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_product numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n    (check-within (candidate (list )) (list 0 1) 0.001)\n    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)\n    (check-within (candidate (list 100 0)) (list 100 0) 0.001)\n    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)\n    (check-within (candidate (list 10)) (list 10 10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n\n### Explanation\n\nThe code is an implementation of  a function that takes a list of integers as input and returns a tuple of two integers. The first integer is the sum of all the integers in the list and the second integer is the product of all the integers in the list.\n\n```python\nfrom typing import List, Tuple\n```\nThe `typing` module provides support for type hints. `List` and `Tuple` are types that can be used to specify the types of the elements in a list or tuple respectively.\n\n```python\nsum_value = 0\nprod_value = 1\n```\nThese lines initialize two variables `sum_value` and `prod_value` to 0 and 1 respectively.\n\n```python\nfor n in numbers:\n    sum_value += n\n    prod_value *= n\n```\nThis is a loop that iterates over each element in the `numbers` list. For each element, it adds the element to `sum_value` and multiplies the element with `prod_value`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_product numbers)\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (words_string s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_string))\n    (check-within (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\" \"is\" \"John\") 0.001)\n    (check-within (candidate \"One, two, three, four, five, six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\") 0.001)\n    (check-within (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n\n### Explanation\n\nThe code is an implementation of  a function `words_string` that takes a string `s` as input and returns a list of words in the string. \n\n```python\n    if not s:\n        return []\n```\nThis line checks if the input string `s` is empty. If it is, the function returns an empty list.\n\n```python\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n```\nThis block of code initializes an empty list `s_list` and iterates over each character in the input string `s`. If the character is a comma, it is replaced with a space and added to the `s_list`. Otherwise, the character is added to the `s_list` as is.\n\n```python\n    s_list = \"\".join(s_list)\n    return s_list.split()\n```\nThis block of code joins all the characters in the `s_list` into a single string and then splits the string into a list of words using the default whitespace separator. The resulting list of words is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (words_string s)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_prime n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 101) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 13441) #t 0.001)\n    (check-within (candidate 61) #t 0.001)\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 1) #f 0.001)\n    (check-within (candidate 5) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 17) #t 0.001)\n    (check-within (candidate 85) #f 0.001)\n    (check-within (candidate 77) #f 0.001)\n    (check-within (candidate 255379) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_prime(n:int) -> bool:\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of  a function that checks whether a given number is a prime number or not. \n\n```python\ndef is_prime(n:int) -> bool:\n```\nThe function is called `is_prime` and takes an integer `n` as input and returns a boolean value. \n\n```python\n    for k in range(2, n - 1):\n```\nThe next line is a for loop that iterates over a range of numbers from 2 to n-1. The range function returns a sequence of numbers starting from the first argument (inclusive) and ending at the second argument (exclusive). \n\n```python\n    return True\n```\nIf the function has not returned False by this point, then the input number is a prime number and the function returns True.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_prime n)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (right_angle_triangle a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n    (check-within (candidate 3 4 5) #t 0.001)\n    (check-within (candidate 1 2 3) #f 0.001)\n    (check-within (candidate 10 6 8) #t 0.001)\n    (check-within (candidate 2 2 2) #f 0.001)\n    (check-within (candidate 7 24 25) #t 0.001)\n    (check-within (candidate 10 5 7) #f 0.001)\n    (check-within (candidate 5 12 13) #t 0.001)\n    (check-within (candidate 15 8 17) #t 0.001)\n    (check-within (candidate 48 55 73) #t 0.001)\n    (check-within (candidate 1 1 1) #f 0.001)\n    (check-within (candidate 2 2 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef right_angle_triangle(a: int, b: int, c: int) -> bool:\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n\n### Explanation\n\nThe code is an implementation of  a function that takes 3 integer arguments and returns a boolean value. The function is called `right_angle_triangle`. \n\nThe function checks if the square of one of the sides of the triangle is equal to the sum of the squares of the other two sides. If this is true for any of the sides, then the function returns `True`, otherwise it returns `False`.\n\nThe function takes 3 integer arguments, `a`, `b`, and `c`, which represent the sides of the triangle. \n\nThe function returns `True` if any of the following conditions are met:\n\n- `a*a == b*b + c*c`\n- `b*b == a*a + c*c`\n- `c*c == a*a + b*b`\n\n### Racket version\n\n#lang racket\n\n;; \n(define (right_angle_triangle a b c)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (add lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate (list 4 88)) 88 0.001)\n    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)\n    (check-within (candidate (list 4 0 6 7)) 0 0.001)\n    (check-within (candidate (list 4 4 6 8)) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef add(lst: List[int]) -> int:\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n\n### Explanation\n\n- `from typing import List`: This line imports the List class from the typing module. The List class is used to represent a list of elements of a specific type.\n\n- `def add(lst: List[int]) -> int:`: This line defines a function called `add` that takes a list of integers as input and returns an integer. The function signature specifies that the input list is of type List[int] and the output is of type int.\n\n- `return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])`: This line returns the sum of all even numbers at odd indices in the input list. The expression inside the `sum` function is a list comprehension that iterates over the odd indices of the input list and selects only the even numbers. The `range` function is used to generate a sequence of odd indices, starting from 1 and ending at the length of the list. The `if` statement filters out the odd indices that do not contain even numbers. Finally, the `sum` function adds up all the even numbers selected by the list comprehension and returns the result.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (add lst)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fix_spaces text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fix_spaces))\n    (check-within (candidate \"Example\") \"Example\" 0.001)\n    (check-within (candidate \"Mudasir Hanif \") \"Mudasir_Hanif_\" 0.001)\n    (check-within (candidate \"Yellow Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\" 0.001)\n    (check-within (candidate \"Exa   mple\") \"Exa-mple\" 0.001)\n    (check-within (candidate \"   Exa 1 2 2 mple\") \"-Exa_1_2_2_mple\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fix_spaces(text: str) -> str:\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n\n### Explanation\n\nThe code is an implementation of  `fix_spaces` function which takes a string `text` as input and returns a string with spaces replaced by underscores and hyphens. The function is defined with a type hint for the input and output parameters.\n\n```python\ndef fix_spaces(text: str) -> str:\n```\n\nThe function initializes a new string `new_text` and two integer variables `i`, `start` and `end` to 0.\n\nThe function then enters a while loop that iterates through each character in the input string `text`.\n\n```python\n    while i < len(text):\n```\n\n```python\n        if text[i] == \" \":\n            end += 1\n```\n\nIf the current character is not a space, the function checks if there are more than two spaces between the current character and the previous non-space character. If so, the function adds a hyphen before the current character.\n\n```python\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n```\n\nIf there are no spaces between the current character and the previous non-space character, the function simply adds the current character to the new string.\n\nThe `start` and `end` variables are then updated to reflect the current position in the string.\n\n```python\n            start, end = i+1, i+1\n```\n\n```python\n        i+=1\n```\n\nAfter the loop has finished, the function checks if there are more than two spaces at the end of the string. If so, the function adds a hyphen to the end of the new string.\n\n```python\n    if end - start > 2:\n        new_text += \"-\"\n```\n\nIf there are one or two spaces at the end of the string, the function adds underscores to the end of the new string.\n\n```python\n    elif end - start > 0:\n        new_text += \"_\"\n```\n\nFinally, the function returns the new string.\n\n```python\n    return new_text\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fix_spaces text)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (unique_digits x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_digits))\n    (check-within (candidate (list 15 33 1422 1)) (list 1 15 33) 0.001)\n    (check-within (candidate (list 152 323 1422 10)) (list ) 0.001)\n    (check-within (candidate (list 12345 2033 111 151)) (list 111 151) 0.001)\n    (check-within (candidate (list 135 103 31)) (list 31 135) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n\n### Explanation\n\nThe first line of the code imports the `List` type from the `typing` module. This is used to specify the type of the input and output of the function.\n\n```python\nfrom typing import List\n```\n\nThe next line defines the function `unique_digits` which takes a single argument `x` of type `List[int]` and returns a list of integers. The function is defined using the `def` keyword.\n\nThe next line initializes an empty list called `odd_digit_elements`. This list will be used to store the integers that have only odd digits.\n\n```python\n    odd_digit_elements = []\n```\n\nThe next line starts a for loop that iterates over the elements of the input list `x`. The loop variable is `i`.\n\n```python\n    for i in x:\n```\n\n```python\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n```\n\nThe last line of the function returns the sorted list of integers that have only odd digits.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (unique_digits x)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (valid_date date)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_date))\n    (check-within (candidate \"03-11-2000\") #t 0.001)\n    (check-within (candidate \"15-01-2012\") #f 0.001)\n    (check-within (candidate \"04-0-2040\") #f 0.001)\n    (check-within (candidate \"06-04-2020\") #t 0.001)\n    (check-within (candidate \"01-01-2007\") #t 0.001)\n    (check-within (candidate \"03-32-2011\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"04-31-3000\") #f 0.001)\n    (check-within (candidate \"06-06-2005\") #t 0.001)\n    (check-within (candidate \"21-31-2000\") #f 0.001)\n    (check-within (candidate \"04-12-2003\") #t 0.001)\n    (check-within (candidate \"04122003\") #f 0.001)\n    (check-within (candidate \"20030412\") #f 0.001)\n    (check-within (candidate \"2003-04\") #f 0.001)\n    (check-within (candidate \"2003-04-12\") #f 0.001)\n    (check-within (candidate \"04-2003\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef valid_date(date: str) -> bool:\n    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n\n### Explanation\n\n1. `def valid_date(date: str) -> bool:` - This line defines the function `valid_date` that takes in a string `date` and returns a boolean value. The `-> bool` specifies the return type of the function.\n\n2. `try:` - This line starts a try block.\n\n4. `month, day, year = date.split('-')` - This line splits the input string into three parts using the '-' character as a separator. The three parts are assigned to the variables `month`, `day`, and `year`.\n\n5. `month, day, year = int(month), int(day), int(year)` - This line converts the three parts of the date into integers.\n\n7. `if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:` - This line checks if the day is a valid value for months with 31 days. If the month is one of January, March, May, July, August, October, or December, and the day is less than 1 or greater than 31, the function returns `False`.\n\n9. `if month == 2 and day < 1 or day > 29:` - This line checks if the day is a valid value for February. If the month is February, and the day is less than 1 or greater than 29, the function returns `False`.\n\n10. `except:` - This line starts an except block.\n\n11. `return False` - This line returns `False` if an exception occurs.\n\n12. `return True` - This line returns `True` if the input string is a valid date. If none of the conditions in the function are met, the function returns `True`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (valid_date date)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (filter_integers values)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9) 0.001)\n    (check-within (candidate (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]\n\n### Explanation\n\nThe function uses a list comprehension to iterate over the input list and filter out any values that are not integers. The `isinstance` function is used to check if each value is an integer. If the value is an integer, it is included in the output list.\n\nThe resulting list of integers is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (filter_integers values)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (anti_shuffle s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate anti_shuffle))\n    (check-within (candidate \"Hi\") \"Hi\" 0.001)\n    (check-within (candidate \"hello\") \"ehllo\" 0.001)\n    (check-within (candidate \"number\") \"bemnru\" 0.001)\n    (check-within (candidate \"abcd\") \"abcd\" 0.001)\n    (check-within (candidate \"Hello World!!!\") \"Hello !!!Wdlor\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst .Rboot How aer ?ouy\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef anti_shuffle(s: str) -> str:\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n\n### Explanation\n\nThe code is an implementation of  a function called `anti_shuffle` that takes a string `s` as input and returns a string. The function sorts the characters in each word of the input string and returns the sorted words separated by a space.\n\nFinally, the list of sorted words is joined into a single string using the `join()` method. The separator used is a space character. The resulting string is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (anti_shuffle s)\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate separate_paren_groups))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list \"(()())\" \"((()))\" \"()\" \"((())()())\") 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list \"()\" \"(())\" \"((()))\" \"(((())))\") 0.001)\n    (check-within (candidate \"(()(())((())))\") (list \"(()(())((())))\") 0.001)\n    (check-within (candidate \"( ) (( )) (( )( ))\") (list \"()\" \"(())\" \"(()())\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThe code is an implementation of  a function called `separate_paren_groups` which takes a string of parentheses and returns a list of strings where each string is a group of parentheses. \n\n```python\nfrom typing import List\n```\nThe `typing` module is imported to allow the use of type hints. \n\n```python\ndef separate_paren_groups(paren_string: str) -> List[str]:\n```\nThe function `separate_paren_groups` takes a string `paren_string` as input and returns a list of strings. The `-> List[str]` indicates that the function returns a list of strings.\n\n```python\n    result = []\n    current_string = []\n    current_depth = 0\n```\nThree variables are initialized: `result` is an empty list that will store the groups of parentheses, `current_string` is an empty list that will store the current group of parentheses, and `current_depth` is an integer that will keep track of the depth of the current group of parentheses.\n\n```python\n    for c in paren_string:\n```\nThe function iterates over each character `c` in the input string `paren_string`.\n\n```python\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (any_int x y z)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate any_int))\n    (check-within (candidate 2 3 1) #t 0.001)\n    (check-within (candidate 2.5 2 3) #f 0.001)\n    (check-within (candidate 1.5 5 3.5) #f 0.001)\n    (check-within (candidate 2 6 2) #f 0.001)\n    (check-within (candidate 4 2 2) #t 0.001)\n    (check-within (candidate 2.2 2.2 2.2) #f 0.001)\n    (check-within (candidate -4 6 2) #t 0.001)\n    (check-within (candidate 2 1 1) #t 0.001)\n    (check-within (candidate 3 4 7) #t 0.001)\n    (check-within (candidate 3.0 4 7) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef any_int(x: float, y: float, z: float) -> bool:\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n\n### Explanation\n\n- `def any_int(x: float, y: float, z: float) -> bool:` defines a function called `any_int` that takes three arguments `x`, `y`, and `z`. The function returns a boolean value.\n- `if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):` checks if all three arguments are integers.\n- `if (x+y==z) or (x+z==y) or (y+z==x):` checks if any two of the three arguments add up to the third argument.\n- `return True` returns `True` if any two of the three arguments add up to the third argument.\n- `return False` returns `False` if none of the two arguments add up to the third argument.\n- `return False` returns `False` if any of the arguments is not an integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (any_int x y z)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (starts_one_ends n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 2) 18 0.001)\n    (check-within (candidate 3) 180 0.001)\n    (check-within (candidate 4) 1800 0.001)\n    (check-within (candidate 5) 18000 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef starts_one_ends(n: int) -> int:\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n\n### Explanation\n\nThe code is an implementation of  a function called `starts_one_ends` that takes an integer `n` as input and returns an integer. The function calculates the number of integers that start with 1 and end with 1 in a range of integers that have `n` digits. \n\nThe calculation is done using the formula `18 * (10 ** (n - 2))`. This formula is derived from the fact that there are 9 digits that can be used to fill the remaining `n - 2` digits after the first and last digits are fixed to 1. The first digit can only be 1, and the last digit can only be 1. Therefore, there are 9 choices for each of the remaining `n - 2` digits. This gives a total of `9 ** (n - 2)` integers that start and end with any digit. However, we are only interested in integers that start and end with 1. There are 2 such integers (11 and 1), so the total number of integers that start and end with 1 is `2 * 9 ** (n - 2)`. This can be simplified to `18 * (10 ** (n - 2))`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (starts_one_ends n)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n    (check-within (candidate 10) 55 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 8) 21 0.001)\n    (check-within (candidate 11) 89 0.001)\n    (check-within (candidate 12) 144 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n### Explanation\n\nThe code is an implementation of  a recursive function to calculate the nth Fibonacci number. \n\nThe first two if statements are the base cases of the recursion. If n is 0, the function returns 0. If n is 1, the function returns 1. \n\nThe function continues to call itself recursively until it reaches one of the base cases.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fib n)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (can_arrange arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate can_arrange))\n    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)\n    (check-within (candidate (list 1 2 4 5)) -1 0.001)\n    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)\n    (check-within (candidate (list )) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef can_arrange(arr: List[int]) -> int:\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n\n### Explanation\n\nThe second line defines the function `can_arrange` which takes a single argument `arr` of type List[int] and returns an integer.\n\nThe third line initializes a variable `ind` to -1. This variable will be used to keep track of the index of the first element that is out of order.\n\nThe fourth line initializes a variable `i` to 1. This variable will be used to iterate over the elements of the input list.\n\nThe sixth line checks if the current element (`arr[i]`) is less than the previous element (`arr[i-1]`). If this is true, then the current element is out of order.\n\nThe seventh line updates the `ind` variable to the current value of `i`.\n\nThe eighth line increments `i` by 1 to move to the next element.\n\nThe ninth line returns the value of `ind`. If `ind` is still -1, then the input list is already sorted, so the function returns -1.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (can_arrange arr)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (skjkasdkd lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)\n    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)\n    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)\n    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)\n    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)\n    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)\n    (check-within (candidate (list 8191)) 19 0.001)\n    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)\n    (check-within (candidate (list 127 97 8192)) 10 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n### Explanation\n\nThe code is an implementation of  a function `skjkasdkd` that takes in a list of integers and returns the sum of digits of the largest prime number in the list.\n\n```python\ndef skjkasdkd(lst: List[int]) -> int:\n```\nThis line defines a function `skjkasdkd` that takes in a list of integers `lst` and returns an integer. The `-> int` is a type hint that specifies the return type of the function.\n\n        return True\n```\nThis is a nested function `isPrime` that takes in an integer `n` and returns a boolean value indicating whether `n` is a prime number or not. It does this by iterating over the range of numbers from 2 to the square root of `n` and checking if `n` is divisible by any of them. If it is, it returns `False`, otherwise it returns `True`.\n\n```python\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n```\nThis block of code initializes two variables `maxx` and `i` to 0. It then iterates over the list `lst` using a `while` loop and checks if each element in the list is greater than `maxx` and is a prime number using the `isPrime` function. If it is, it updates the value of `maxx` to be the current element. It then increments `i` by 1 and continues the loop until it has iterated over all the elements in the list.\n\n```python\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n```\nThis line initializes a variable `result` to the sum of the digits of the largest prime number `maxx`. It does this by converting `maxx` to a string using the `str` function, iterating over each character in the string using a generator expression, converting each character back to an integer using the `int` function, and then summing up all the integers using the `sum` function. Finally, it returns the value of `result`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (skjkasdkd lst)\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (reverse_delete s c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate reverse_delete))\n    (check-within (candidate \"abcde\" \"ae\") (list \"bcd\" #f) 0.001)\n    (check-within (candidate \"abcdef\" \"b\") (list \"acdef\" #f) 0.001)\n    (check-within (candidate \"abcdedcba\" \"ab\") (list \"cdedc\" #t) 0.001)\n    (check-within (candidate \"dwik\" \"w\") (list \"dik\" #f) 0.001)\n    (check-within (candidate \"a\" \"a\") (list \"\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"v\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"vabba\" \"v\") (list \"abba\" #t) 0.001)\n    (check-within (candidate \"mamma\" \"mia\") (list \"\" #t) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef reverse_delete(s: str,c: str) -> Tuple[str, bool]:\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n\n### Explanation\n\nThe first line of the function imports the `Tuple` class from the `typing` module. This is used to specify the type of the function's return value.\n\nThe second line defines the function signature. The function takes two arguments: a string `s` and a character `c`. The function returns a tuple containing a modified string `s` and a boolean value.\n\nThe third line of the function creates a new string by iterating over each character in the original string `s` and only including characters that are not equal to the character `c`. This is done using a list comprehension. The resulting string is assigned back to the variable `s`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (reverse_delete s c)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (pairs_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 30)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 31)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 30)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 31)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n\n### Explanation\n\nThe first line of the code imports the `List` type from the `typing` module. This is a type hint that tells us that the `l` argument is a list of integers.\n\nThe second line defines the `pairs_sum_to_zero` function. The function takes a single argument, `l`, which is a list of integers. The function returns a boolean value.\n\nThe function uses a nested loop to iterate over all possible pairs of integers in the list. The outer loop iterates over each integer in the list, while the inner loop iterates over all the integers that come after the current integer in the list.\n\nThe `enumerate` function is used to get the index of the current integer in the list. The `i` variable holds the index of the current integer, while the `l1` variable holds the value of the current integer.\n\nThe inner loop starts from the index of the current integer plus one, and iterates over all the integers that come after the current integer in the list. The `j` variable holds the index of the current integer in the inner loop.\n\nIf the function has not returned `True` by the time the loops have finished iterating, it means that there are no pairs of integers in the list that sum to zero. In this case, the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (pairs_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fruit_distribution s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fruit_distribution))\n    (check-within (candidate \"5 apples and 6 oranges\" 19) 8 0.001)\n    (check-within (candidate \"5 apples and 6 oranges\" 21) 10 0.001)\n    (check-within (candidate \"0 apples and 1 oranges\" 3) 2 0.001)\n    (check-within (candidate \"1 apples and 0 oranges\" 3) 2 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 100) 95 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 5) 0 0.001)\n    (check-within (candidate \"1 apples and 100 oranges\" 120) 19 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fruit_distribution(s: str, n: int) -> int:\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n\n### Explanation\n\nThe code is an implementation of  a function called `fruit_distribution` that takes two arguments: a string `s` and an integer `n`. The function returns an integer.\n\nThe function starts by creating an empty list called `lis`. It then loops through the string `s` after splitting it into a list of words using the space character as the delimiter. For each word in the list, it checks if the word is a digit using the `isdigit()` method. If the word is a digit, it is converted to an integer using the `int()` method and appended to the `lis` list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fruit_distribution s n)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (f n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate 5) (list 1 2 6 24 15) 0.001)\n    (check-within (candidate 7) (list 1 2 6 24 15 720 28) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n    (check-within (candidate 3) (list 1 2 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n\n### Explanation\n\n```python\nfrom typing import List\n```\nThis line imports the `List` class from the `typing` module. The `List` class is used to define a list of integers that the function will return.\n\n```python\nfor i in range(1,n+1):\n```\nThis line starts a loop that iterates over the integers from 1 to `n` (inclusive). The `range()` function returns a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and stops before a specified number.\n\n```python\nif i%2 == 0:\n```\nThis line checks if the current integer `i` is even. The `%` operator returns the remainder of the division of `i` by 2. If the remainder is 0, then `i` is even.\n\n```python\nx = 1\nfor j in range(1,i+1): x *= j\nret += [x]\n```\nThis block of code is executed if `i` is even. It initializes a variable `x` to 1 and then multiplies it by all the integers from 1 to `i` (inclusive) using a loop. The resulting value of `x` is then added to the `ret` list.\n\n```python\nelse:\n```\nThis line is executed if `i` is odd.\n\n```python\nx = 0\nfor j in range(1,i+1): x += j\nret += [x]\n```\nThis block of code is executed if `i` is odd. It initializes a variable `x` to 0 and then adds all the integers from 1 to `i` (inclusive) using a loop. The resulting value of `x` is then added to the `ret` list.\n\n```python\nreturn ret\n```\nThis line returns the `ret` list that contains all the integers computed by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (f n)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (next_smallest lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)\n    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list -35 34 12 -45)) -35 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n\n### Explanation\n\n```python\nfrom typing import List\nfrom typing import Optional\n```\nThe `typing` module is used to specify the type of the function arguments and return value. `List` and `Optional` are types that are used to specify that the argument is a list of integers and the return value is either an integer or `None`.\n\n```python\ndef next_smallest(lst: List[int]) -> Optional[int]:\n```\nThis line defines the function `next_smallest` that takes a list of integers as input and returns an integer or `None`. \n\n```python\nlst = sorted(set(lst))\n```\nThis line sorts the input list in ascending order and removes duplicates. The `set` function is used to remove duplicates and the `sorted` function is used to sort the list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (next_smallest lst)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (multiply a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate multiply))\n    (check-within (candidate 148 412) 16 0.001)\n    (check-within (candidate 19 28) 72 0.001)\n    (check-within (candidate 2020 1851) 0 0.001)\n    (check-within (candidate 14 -15) 20 0.001)\n    (check-within (candidate 76 67) 42 0.001)\n    (check-within (candidate 17 27) 49 0.001)\n    (check-within (candidate 0 1) 0 0.001)\n    (check-within (candidate 0 0) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef multiply(a: int, b: int) -> int:\n    return abs(a % 10) * abs(b % 10)\n\n### Explanation\n\nThe first line defines the function `multiply` and specifies the types of the arguments and the return type. \n\nThe second line returns the product of the absolute values of the last digits of `a` and `b`. \n\nThe `abs` function is used to ensure that the result is always positive, regardless of the sign of the input. The `%` operator is used to obtain the last digit of each argument.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (multiply a b)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (modp n p)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n    (check-within (candidate 3 5) 3 0.001)\n    (check-within (candidate 1101 101) 2 0.001)\n    (check-within (candidate 0 101) 1 0.001)\n    (check-within (candidate 3 11) 8 0.001)\n    (check-within (candidate 100 101) 1 0.001)\n    (check-within (candidate 30 5) 4 0.001)\n    (check-within (candidate 31 5) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef modp(n: int, p: int) -> int:\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n\n### Explanation\n\nThe code is an implementation of 2^n % p.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (modp n p)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (concatenate strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate concatenate))\n    (check-within (candidate (list )) \"\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"xyz\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\" \"w\" \"k\")) \"xyzwk\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n\n### Explanation\n\nThe code is an implementation of  a function called `concatenate` that takes a list of strings as input and returns a single string that is the concatenation of all the strings in the input list. \n\nThe first line of the code imports the `List` type from the `typing` module. The `List` type is a generic type that is used to represent a list of elements of a particular type. In this case, `List[str]` represents a list of strings.\n\nThe `-> str` syntax after the function definition is a type hint that specifies the return type of the function. It indicates that the function returns a string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (concatenate strings)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (triples_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -1)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 1 2 5 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 9 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -100)) #f 0.001)\n    (check-within (candidate (list 100 3 5 -100)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n### Explanation\n\nThe code is an implementation of 3SUM problem. The 3SUM problem is to find all the unique triplets in an array that sum up to zero. \n\nThe function `triples_sum_to_zero` takes a list of integers as input and returns a boolean value. The function returns `True` if there exists a triplet in the input list that sums up to zero, otherwise it returns `False`.\n\nThe if statement inside the innermost loop checks if the sum of the current triplet is equal to zero. If it is, the function returns `True` as soon as it finds the first triplet that sums up to zero. If no triplet is found that sums up to zero, the function returns `False` after all possible triplets have been checked.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (triples_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (triangle_area a h)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 5 3) 7.5 0.001)\n    (check-within (candidate 2 2) 2.0 0.001)\n    (check-within (candidate 10 8) 40.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef triangle_area(a: int, h: int) -> float:\n    return a * h / 2.0\n\n### Explanation\n\nThe code is an implementation of  a function that calculates the area of a triangle. \n\nThe function takes two arguments, `a` and `h`, which are the base and height of the triangle respectively. The function returns the area of the triangle, which is calculated by multiplying the base and height and then dividing the result by 2.0.\n\nThe function body consists of a single line of code that performs the calculation and returns the result using the `return` keyword.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (triangle_area a h)\n"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (largest_smallest_integers lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_136_largest_smallest_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)\n    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)\n    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)\n    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)\n    (check-within (candidate (list )) (list #f #f) 0.001)\n    (check-within (candidate (list 0)) (list #f #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\ndef largest_smallest_integers(lst: List[int]) -> Tuple[Optional[int], Optional[int]]:\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n\n### Explanation\n\nThe code is an implementation of  a function that takes a list of integers and returns a tuple containing the largest negative integer and the smallest positive integer in the list. If the list does not contain any negative or positive integers, the function returns None for the corresponding value in the tuple.\n\n```python\ndef largest_smallest_integers(lst: List[int]) -> Tuple[Optional[int], Optional[int]]:\n```\nThis line defines the function `largest_smallest_integers` which takes a single parameter `lst` of type `List[int]` and returns a tuple of two optional integers. The function signature specifies that the function returns a tuple of two optional integers, which means that either or both of the values in the tuple can be `None`.\n\n```python\nlargest = list(filter(lambda x: x > 0, lst))\n```\nThis line creates a new list `largest` by filtering the input list `lst` using a lambda function that returns `True` for all positive integers in the list. The `filter` function returns an iterator that produces the elements of the input list that satisfy the condition specified by the lambda function. The `list` function is used to convert the iterator to a list.\n\n```python\nreturn (max(smallest) if smallest else None, min(largest) if largest else None)\n```\nThis line returns a tuple containing the largest negative integer and the smallest positive integer in the input list. The `max` and `min` functions are used to find the largest and smallest values in the `smallest` and `largest` lists, respectively. The `if` statements are used to handle the case where either `smallest` or `largest` is an empty list, in which case the corresponding value in the tuple is set to `None`. The `return` statement returns the tuple.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_smallest_integers lst)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (cycpattern_check a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n    (check-within (candidate \"xyzw\" \"xyw\") #f 0.001)\n    (check-within (candidate \"yello\" \"ell\") #t 0.001)\n    (check-within (candidate \"whattup\" \"ptut\") #f 0.001)\n    (check-within (candidate \"efef\" \"fee\") #t 0.001)\n    (check-within (candidate \"abab\" \"aabb\") #f 0.001)\n    (check-within (candidate \"winemtt\" \"tinem\") #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef cycpattern_check(a: str , b: str) -> bool:\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n\n### Explanation\n\nThe code is an implementation of  a cyclic pattern check. It checks if a string `a` contains a cyclic pattern of string `b`. A cyclic pattern is a pattern that repeats itself after a certain number of characters. For example, the string `abab` is a cyclic pattern of `ab`. \n\nThe second line of the function calculates the length of string `b` and assigns it to variable `l`.\n\nThe third line of the function creates a new string `pat` by concatenating string `b` with itself. This creates a new string that contains two copies of string `b`. \n\nThe fifth line of the function starts a nested loop that iterates over the indices of string `pat`. The loop runs from 0 to the length of `b` plus one. This ensures that the loop checks all possible cyclic patterns of `b`. \n\nThe sixth line of the function checks if the substring of `a` starting at index `i` and ending at index `i+l` is equal to the substring of `pat` starting at index `j` and ending at index `j+l`. If the substrings are equal, it means that `a` contains a cyclic pattern of `b` and the function returns `True`.\n\nIf the function has not returned `True` after the loops have finished, it means that `a` does not contain a cyclic pattern of `b`, and the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (cycpattern_check a b)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (hex_key num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n    (check-within (candidate \"AB\") 1 0.001)\n    (check-within (candidate \"1077E\") 2 0.001)\n    (check-within (candidate \"ABED1A33\") 4 0.001)\n    (check-within (candidate \"2020\") 2 0.001)\n    (check-within (candidate \"123456789ABCDEF0\") 6 0.001)\n    (check-within (candidate \"112233445566778899AABBCCDDEEFF00\") 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef hex_key(num: str) -> int:\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n\n### Explanation\n\nThe code is an implementation of  a function called `hex_key` which takes in a string `num` and returns an integer. The function calculates the number of prime numbers in the string `num` which is represented in hexadecimal format.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (hex_key num)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (numerical_letter_grade grades)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numerical_letter_grade))\n    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list \"A+\" \"B\" \"C-\" \"C\" \"A-\") 0.001)\n    (check-within (candidate (list 1.2)) (list \"D+\") 0.001)\n    (check-within (candidate (list 0.5)) (list \"D-\") 0.001)\n    (check-within (candidate (list 0.0)) (list \"E\") 0.001)\n    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list \"D\" \"D-\" \"C-\" \"B\" \"B+\") 0.001)\n    (check-within (candidate (list 0.0 0.7)) (list \"E\" \"D-\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n\n### Explanation\n\nThe code is an implementation of  a function that takes a list of grades and returns a list of letter grades. The function is called `numerical_letter_grade` and it takes a single argument `grades` which is a list of floating point numbers. The function returns a list of strings.\n\nThe first line of the code imports the `List` class from the `typing` module. This is used to specify the type of the `grades` argument.\n\nThe second line defines the function `numerical_letter_grade` which takes a single argument `grades` of type `List[float]` and returns a list of strings.\n\nThe next few lines use a series of `if` and `elif` statements to determine the letter grade for each `gpa` value. If the `gpa` value is equal to 4.0, the letter grade is \"A+\". If the `gpa` value is greater than 3.7, the letter grade is \"A\". If the `gpa` value is greater than 3.3, the letter grade is \"A-\". And so on.\n\nThe final `else` statement is executed if the `gpa` value is less than or equal to 0.0. In this case, the letter grade is \"E\".\n\nThe letter grade for each `gpa` value is appended to the `letter_grade` list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (numerical_letter_grade grades)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (minSubArraySum nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSubArraySum))\n    (check-within (candidate (list 2 3 4 1 2 4)) 1 0.001)\n    (check-within (candidate (list -1 -2 -3)) -6 0.001)\n    (check-within (candidate (list -1 -2 -3 2 -10)) -14 0.001)\n    (check-within (candidate (list -9999999999999999)) -9999999999999999 0.001)\n    (check-within (candidate (list 0 10 20 1000000)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 100 -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 10 11 13 8 3 4)) 3 0.001)\n    (check-within (candidate (list 100 -33 32 -1 0 -2)) -33 0.001)\n    (check-within (candidate (list -10)) -10 0.001)\n    (check-within (candidate (list 7)) 7 0.001)\n    (check-within (candidate (list 1 -1)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n\n### Explanation\n\nThe code is an implementation of  [Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm) to find the minimum subarray sum of an array of integers. \n\n1. The first line imports the List class from the typing module. The List class is a generic class that represents a list of elements of a particular type. \n\n3. The third line initializes a variable called `max_sum` to 0. This variable will be used to keep track of the maximum subarray sum. \n\n4. The fourth line initializes a variable called `s` to 0. This variable will be used to keep track of the current subarray sum. \n\n6. The sixth line subtracts the current element from `s`. This is done to find the maximum subarray sum that ends at the current element. \n\n8. The eighth line updates `max_sum` to be the maximum of `s` and `max_sum`. This is done to keep track of the maximum subarray sum seen so far. \n\n9. The ninth line checks if `max_sum` is 0. If it is, then it means that all the elements in the input list are negative. In this case, `max_sum` is set to be the maximum of the absolute values of the elements in the input list. \n\n10. The tenth line initializes a variable called `min_sum` to be the negative of `max_sum`. This is done to find the minimum subarray sum. \n\n11. The eleventh line returns `min_sum`, which is the minimum subarray sum.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (minSubArraySum nums)\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (solve N)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate 1000) \"1\" 0.001)\n    (check-within (candidate 150) \"110\" 0.001)\n    (check-within (candidate 147) \"1100\" 0.001)\n    (check-within (candidate 333) \"1001\" 0.001)\n    (check-within (candidate 963) \"10010\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef solve(N: int) -> str:\n    return bin(sum(int(i) for i in str(N)))[2:]\n\n### Explanation\n\nThe code is an implementation of  a function `solve` that takes an integer `N` and returns its binary representation.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solve N)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (by_length arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate by_length))\n    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\") 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -1 55)) (list \"One\") 0.001)\n    (check-within (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\") 0.001)\n    (check-within (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef by_length(arr: List[int]) -> List[str]:\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n\n### Explanation\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is a generic type that represents a list of elements of a specific type.\n\n```python\ndef by_length(arr: List[int]) -> List[str]:\n```\nThis line defines a function called `by_length` that takes in a list of integers and returns a list of strings. The function is annotated with type hints to indicate the types of the input and output.\n\n```python\nsorted_arr = sorted(arr, reverse=True)\n```\nThis line sorts the input array in descending order and assigns the result to a new variable called `sorted_arr`.\n\n```python\nnew_arr = []\nfor var in sorted_arr:\n    try:\n        new_arr.append(dic[var])\n    except:\n        pass\n```\nThis block of code creates a new empty list called `new_arr` and iterates over each element in the sorted array. For each element, it attempts to look up its corresponding string value in the dictionary. If the lookup is successful, the string value is appended to the new array. If the lookup fails (i.e. the integer is not in the dictionary), the exception is caught and the loop continues to the next element.\n\n```python\nreturn new_arr\n```\nThis line returns the new array of string values.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (by_length arr)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (prod_signs arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-within (candidate (list 1 2 2 -4)) -9 0.001)\n    (check-within (candidate (list 0 1)) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 3 -1 1)) -10 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 2 4 1 2 -1 -1 9)) 20 0.001)\n    (check-within (candidate (list -1 1 -1 1)) 4 0.001)\n    (check-within (candidate (list -1 1 1 1)) -4 0.001)\n    (check-within (candidate (list -1 1 1 0)) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef prod_signs(arr: List[int]) -> Optional[int]:\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n\n### Explanation\n\nThe code is an implementation of  a function `prod_signs` that takes a list of integers `arr` and returns the product of the signs of the integers in the list multiplied by the sum of the absolute values of the integers in the list. The function returns `None` if the list is empty.\n\n```python\ndef prod_signs(arr: List[int]) -> Optional[int]:\n```\n\nThis line defines the function `prod_signs` that takes a list of integers `arr` as an argument and returns an optional integer. The `->` syntax is used to indicate the return type of the function.\n\n```python\nif not arr: return None\n```\n\nThis line checks if the list is empty. If it is, the function returns `None`.\n\n```python\nprod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n```\n\nThis line calculates the product of the signs of the integers in the list. If the list contains a `0`, the product is `0`. Otherwise, the product is `-1` raised to the power of the number of negative integers in the list. The `filter` function is used to create a list of negative integers in the list, and the `len` function is used to count the number of negative integers.\n\nThis line calculates the sum of the absolute values of the integers in the list and multiplies it by the product of the signs of the integers in the list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prod_signs arr)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (x_or_y n x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate x_or_y))\n    (check-within (candidate 7 34 12) 34 0.001)\n    (check-within (candidate 15 8 5) 5 0.001)\n    (check-within (candidate 3 33 5212) 33 0.001)\n    (check-within (candidate 1259 3 52) 3 0.001)\n    (check-within (candidate 7919 -1 12) -1 0.001)\n    (check-within (candidate 3609 1245 583) 583 0.001)\n    (check-within (candidate 91 56 129) 129 0.001)\n    (check-within (candidate 6 34 1234) 1234 0.001)\n    (check-within (candidate 1 2 0) 0 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef x_or_y(n: int, x: int, y: int) -> int:\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n\n### Explanation\n\n```python\ndef x_or_y(n: int, x: int, y: int) -> int:\n```\nThe function is defined with three arguments, `n`, `x`, and `y`. `n` is the number to be checked, `x` is the value to be returned if `n` is not divisible by any integer other than 1 and itself, and `y` is the value to be returned if `n` is divisible by any integer other than 1 and itself. The function returns an integer.\n\n```python\n    if n == 1:\n        return y\n```\nIf `n` is equal to 1, the function returns `y`.\n\n```python\n    else:\n        return x\n```\nIf the loop completes without finding a divisor of `n`, the function returns `x`. The `else` clause is associated with the `for` loop and is executed if the loop completes without encountering a `break` statement.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (x_or_y n x y)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (select_words s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n    (check-within (candidate \"Mary had a little lamb\" 4) (list \"little\") 0.001)\n    (check-within (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\") 0.001)\n    (check-within (candidate \"simple white space\" 2) (list ) 0.001)\n    (check-within (candidate \"Hello world\" 4) (list \"world\") 0.001)\n    (check-within (candidate \"Uncle sam\" 3) (list \"Uncle\") 0.001)\n    (check-within (candidate \"\" 4) (list ) 0.001)\n    (check-within (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"f\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n### Explanation\n\nThe code is an implementation of  a function `select_words` that takes two arguments: a string `s` and an integer `n`. The function returns a list of words from the string `s` that have `n` consonants. \n\nThe function first initializes an empty list `result` which will be used to store the words that meet the criteria. \n\nFor each word, the function initializes a variable `n_consonants` to zero. \n\nThe function then loops through each character in the word using the `range()` function and a `for` loop. \n\nFor each character, the function checks if the character is a consonant by comparing it to a list of vowels `[\"a\",\"e\",\"i\",\"o\",\"u\"]`. If the character is not a vowel, the function increments the `n_consonants` variable by 1. \n\nFinally, the function returns the `result` list containing all the words that have `n` consonants.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (select_words s n)\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_bored S)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n    (check-within (candidate \"Hello world\") 0 0.001)\n    (check-within (candidate \"Is the sky blue?\") 0 0.001)\n    (check-within (candidate \"I love It !\") 1 0.001)\n    (check-within (candidate \"bIt\") 0 0.001)\n    (check-within (candidate \"I feel good today. I will be productive. will kill It\") 2 0.001)\n    (check-within (candidate \"You and I are going for a walk\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_bored(S: str) -> int:\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n\n### Explanation\n\n1. `def is_bored(S: str) -> int:` defines a function `is_bored` that takes a string `S` as input and returns an integer.\n2. `import re` imports the regular expression module.\n3. `sentences = re.split(r'[.?!]\\s*', S)` splits the input string `S` into a list of sentences. The regular expression `[.?!]\\s*` matches any period, exclamation mark, or question mark followed by zero or more whitespace characters.\n4. `return sum(sentence[0:2] == 'I ' for sentence in sentences)` counts the number of sentences that start with \"I \" by iterating over each sentence in the list of sentences and checking if the first two characters of the sentence are \"I \". The `sum` function returns the total number of sentences that meet this condition.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_bored S)\n"
  },
  {
    "name": "HumanEval_160_do_algebra",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (do_algebra operator operand)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_160_do_algebra.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate do_algebra))\n    (check-within (candidate (list \"**\" \"*\" \"+\") (list 2 3 4 5)) 37 0.001)\n    (check-within (candidate (list \"+\" \"*\" \"-\") (list 2 3 4 5)) 9 0.001)\n    (check-within (candidate (list \"//\" \"*\") (list 7 3 4)) 8 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n\n### Explanation\n\nThe code is an implementation of  a function `do_algebra` that takes two lists as arguments: `operator` and `operand`. The function returns the result of the arithmetic expression formed by the two lists. \n\n```python\nfrom typing import List\n```\n\nThe function signature specifies that the function takes two lists as arguments: `operator` and `operand`. The `operator` list contains strings that represent arithmetic operators. The `operand` list contains integers that represent the operands of the arithmetic expression. The function returns an integer that represents the result of the arithmetic expression.\n\n```python\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n```\n\nThe function then iterates over the `operator` and `operand` lists using the `zip` function. The `zip` function returns an iterator that aggregates elements from each of the iterables passed as arguments. In this case, it aggregates the elements of the `operator` and `operand` lists into pairs of `(oprt, oprn)`.\n\n```python\n    for oprt, oprn in zip(operator, operand[1:]):\n```\n\n```python\n        expression+= oprt + str(oprn)\n```\n\nFinally, the function evaluates the `expression` string using the `eval` function and returns the result.\n\n```python\n    return eval(expression)\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (do_algebra operator operand)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (solve s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate \"AsDf\") \"aSdF\" 0.001)\n    (check-within (candidate \"1234\") \"4321\" 0.001)\n    (check-within (candidate \"ab\") \"AB\" 0.001)\n    (check-within (candidate \"#a@C\") \"#A@c\" 0.001)\n    (check-within (candidate \"#AsdfW^45\") \"#aSDFw^45\" 0.001)\n    (check-within (candidate \"#6@2\") \"2@6#\" 0.001)\n    (check-within (candidate \"#$a^D\") \"#$A^d\" 0.001)\n    (check-within (candidate \"#ccc\") \"#CCC\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef solve(s: str) -> str:\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n\n### Explanation\n\nThe code is an implementation of  a function `solve` that takes a string `s` and returns a string. The function first initializes two variables `flg` and `idx` to 0. It then creates a new list `new_str` from the input string `s`. \n\nThe function then loops through each character in the input string `s`. If the character is an alphabet, it swaps the case of the character and stores it in the corresponding index of the `new_str` list. It also sets the `flg` variable to 1. The `idx` variable is incremented by 1 after each iteration.\n\nIf the `flg` variable is still 0, it means that no alphabet was found in the input string. In this case, the function returns the reverse of the input string. Otherwise, it returns the `s` string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solve s)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (flip_case string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hello!\") \"hELLO!\" 0.001)\n    (check-within (candidate \"These violent delights have violent ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef flip_case(string: str) -> str:\n    return string.swapcase()\n\n### Explanation\n\nThe code is an implementation of  a function called `flip_case` which takes a string as an argument and returns the string with the case of each character flipped. \n\n```python\n    return string.swapcase()\n```\nThis line returns the string with the case of each character flipped. The `swapcase()` method is called on the `string` object which returns a new string with the case of each character flipped.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (flip_case string)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (rolling_max numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)\n    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n\n### Explanation\n\nThe code is an implementation of  a function `rolling_max` that takes a list of integers and returns a list of integers. The function returns a list of the maximum value seen so far in the input list. \n\n```python\nfrom typing import List, Tuple\n```\nThis line imports the List and Tuple classes from the typing module. The List class is used to define a list of integers, while the Tuple class is used to define a tuple of integers.\n\n```python\ndef rolling_max(numbers: List[int]) -> List[int]:\n```\nThis line defines the `rolling_max` function that takes a list of integers as input and returns a list of integers. The `-> List[int]` syntax specifies the return type of the function.\n\n```python\nfor n in numbers:\n```\nThis line starts a for loop that iterates over each element `n` in the `numbers` list.\n\n```python\nif running_max is None:\n    running_max = n\nelse:\n    running_max = max(running_max, n)\n```\nThis code block checks if `running_max` is `None`. If it is, `running_max` is set to the current element `n`. If `running_max` is not `None`, the maximum value between `running_max` and `n` is assigned to `running_max`.\n\n```python\nreturn result\n```\nThis line returns the `result` list containing the maximum value seen so far for each element in the input list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (rolling_max numbers)\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (decimal_to_binary decimal)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate decimal_to_binary))\n    (check-within (candidate 0) \"db0db\" 0.001)\n    (check-within (candidate 32) \"db100000db\" 0.001)\n    (check-within (candidate 103) \"db1100111db\" 0.001)\n    (check-within (candidate 15) \"db1111db\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef decimal_to_binary(decimal: int) -> str:\n    return \"db\" + bin(decimal)[2:] + \"db\"\n\n### Explanation\n\nThe code is an implementation of  a function that converts a decimal number to a binary number. The function takes in an integer as an argument and returns a string that represents the binary number.\n\n`return \"db\" + bin(decimal)[2:] + \"db\"`\n\nThe function returns a string that starts with \"db\" and then appends the binary representation of the decimal number. The `bin()` function is a built-in Python function that converts an integer to its binary representation. The `[2:]` is used to remove the first two characters of the binary representation, which are always \"0b\". Finally, the string \"db\" is appended to the end of the binary representation.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (decimal_to_binary decimal)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (how_many_times string substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n    (check-within (candidate \"\" \"x\") 0 0.001)\n    (check-within (candidate \"xyxyxyx\" \"x\") 4 0.001)\n    (check-within (candidate \"cacacacac\" \"cac\") 4 0.001)\n    (check-within (candidate \"john doe\" \"john\") 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef how_many_times(string: str, substring: str) -> int:\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n### Explanation\n\nThe function first initializes a variable called `times` to 0. \n\nThe loop then checks if the substring appears in the `string` at the current index. This is done by slicing the `string` from the current index to the current index plus the length of the `substring`. If the sliced string is equal to the `substring`, then the `times` variable is incremented by 1.\n\nFinally, the function returns the `times` variable, which represents the number of times the `substring` appears in the `string`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (how_many_times string substring)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (monotonic l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n    (check-within (candidate (list 1 2 4 10)) #t 0.001)\n    (check-within (candidate (list 1 2 4 20)) #t 0.001)\n    (check-within (candidate (list 1 20 4 10)) #f 0.001)\n    (check-within (candidate (list 4 1 0 -10)) #t 0.001)\n    (check-within (candidate (list 4 1 1 0)) #t 0.001)\n    (check-within (candidate (list 1 2 3 2 5 60)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 60)) #t 0.001)\n    (check-within (candidate (list 9 9 9 9)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef monotonic(l: List[int]) -> bool:\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n\n### Explanation\n\nThe function takes a list of integers as an argument and returns a boolean value. The `List` type is imported from the `typing` module. The `List` type is a generic type that is used to represent a list of elements of a particular type. \n\nThe `monotonic` function first checks if the list is sorted in ascending order or descending order. If the list is sorted in either of these orders, the function returns `True`, indicating that the list is monotonic. If the list is not sorted in either of these orders, the function returns `False`, indicating that the list is not monotonic.\n\nThe `sorted` function is used to sort the list in ascending order. The `sorted` function returns a new sorted list and does not modify the original list. The `reverse` parameter is used to sort the list in descending order.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (monotonic l)\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (smallest_change arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallest_change))\n    (check-within (candidate (list 1 2 3 5 4 7 9 6)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 3 2 2)) 1 0.001)\n    (check-within (candidate (list 1 4 2)) 1 0.001)\n    (check-within (candidate (list 1 4 4 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 3 1 1 3)) 0 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef smallest_change(arr: List[int]) -> int:\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n\n### Explanation\n\nThe function starts by initializing a variable `ans` to 0. This variable will be used to keep track of the number of changes that need to be made to the list.\n\nThe function then loops over the first half of the list using the `range` function. The `range` function generates a sequence of numbers from 0 to `len(arr) // 2 - 1`. The `//` operator is the floor division operator, which returns the largest integer less than or equal to the division of its operands. This ensures that the loop only iterates over the first half of the list.\n\nInside the loop, the function checks if the element at the current index `i` is equal to the element at the corresponding index in the second half of the list. The corresponding index is `len(arr) - i - 1`. If the two elements are not equal, it means that a change needs to be made to the list to make it a palindrome. The function increments the `ans` variable by 1.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (smallest_change arr)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (all_prefixes string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate all_prefixes))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"asdfgh\") (list \"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\") 0.001)\n    (check-within (candidate \"WWW\") (list \"W\" \"WW\" \"WWW\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n\n### Explanation\n\nThe code is an implementation of  a function called `all_prefixes` that takes a string as input and returns a list of all the prefixes of the string. \n\nThe function then loops over the range of the length of the input string. The `range` function returns a sequence of numbers from 0 to the length of the string minus 1. \n\nFor each number `i` in the sequence, the function appends a slice of the input string to the `result` list. The slice starts at the beginning of the string and ends at the index `i+1`. \n\nFinally, the function returns the `result` list containing all the prefixes of the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (all_prefixes string)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (encode message)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n    (check-within (candidate \"TEST\") \"tgst\" 0.001)\n    (check-within (candidate \"Mudasir\") \"mWDCSKR\" 0.001)\n    (check-within (candidate \"YES\") \"ygs\" 0.001)\n    (check-within (candidate \"This is a message\") \"tHKS KS C MGSSCGG\" 0.001)\n    (check-within (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef encode(message: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n\n### Explanation\n\nThe first line `def encode(message: str) -> str:` defines the function signature. It specifies that the function is called `encode`, takes in a string argument called `message` and returns a string. \n\nThe third line `vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])` creates a dictionary called `vowels_replace` that maps each vowel to the vowel that is two letters after it in the alphabet. For example, 'a' maps to 'c', 'e' maps to 'g', and so on. \n\nThe fourth line `message = message.swapcase()` swaps the case of all the letters in the `message` string. For example, if the `message` string is \"Hello, World!\", this line will change it to \"hELLO, wORLD!\". \n\nThe fifth line `return ''.join([vowels_replace[i] if i in vowels else i for i in message])` creates a new string by iterating through each character in the `message` string. If the character is a vowel, it replaces it with the vowel that is two letters after it in the alphabet (using the `vowels_replace` dictionary). If the character is not a vowel, it leaves it unchanged. Finally, it joins all the characters together into a single string and returns it.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (encode message)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_to_n n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_to_n))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 6) 21 0.001)\n    (check-within (candidate 11) 66 0.001)\n    (check-within (candidate 30) 465 0.001)\n    (check-within (candidate 100) 5050 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef sum_to_n(n: int) -> int:\n    return sum(range(n + 1))\n\n### Explanation\n\nThe code is an implementation of  a function that sums all the numbers from 0 to n. \n\nThe function returns the sum of all the numbers from 0 to `n`. \n\nThe `range` function creates a sequence of numbers from 0 to `n`. The `sum` function then adds up all the numbers in the sequence.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_to_n n)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (specialFilter nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)\n    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)\n    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)\n    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)\n    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count\n\n### Explanation\n\nThe code is an implementation of  `specialFilter` function that takes a list of integers and returns the count of integers that are greater than 10 and have odd digits at the first and last position.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (specialFilter nums)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (prime_fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 3) 5 0.001)\n    (check-within (candidate 4) 13 0.001)\n    (check-within (candidate 5) 89 0.001)\n    (check-within (candidate 6) 233 0.001)\n    (check-within (candidate 7) 1597 0.001)\n    (check-within (candidate 8) 28657 0.001)\n    (check-within (candidate 9) 514229 0.001)\n    (check-within (candidate 10) 433494437 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef prime_fib(n: int) -> int:\n    import math\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n\n### Explanation\n\nThe code is an implementation of  a function called `prime_fib` that takes an integer `n` as input and returns the `n`-th prime Fibonacci number. \n\n```python\ndef prime_fib(n: int) -> int:\n```\n\nThe function definition starts with the `def` keyword, followed by the function name `prime_fib`, which takes an integer `n` as input and returns an integer. The `->` symbol is used to indicate the return type of the function.\n\n```python\nimport math\n```\n\n```python\ndef is_prime(p):\n    if p < 2:\n        return False\n    for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n        if p % k == 0:\n            return False\n    return True\n```\n\nThe function first checks if `p` is less than 2, which is not a prime number. If `p` is greater than or equal to 2, the function checks if `p` is divisible by any number between 2 and the square root of `p`. If `p` is divisible by any of these numbers, it is not a prime number and the function returns `False`. If `p` is not divisible by any of these numbers, it is a prime number and the function returns `True`.\n\n```python\nf = [0, 1]\n```\n\nThe `f` list is initialized with the first two Fibonacci numbers, 0 and 1.\n\n```python\nwhile True:\n    f.append(f[-1] + f[-2])\n    if is_prime(f[-1]):\n        n -= 1\n    if n == 0:\n        return f[-1]\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prime_fib n)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_happy s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n    (check-within (candidate \"a\") #f 0.001)\n    (check-within (candidate \"aa\") #f 0.001)\n    (check-within (candidate \"abcd\") #t 0.001)\n    (check-within (candidate \"aabb\") #f 0.001)\n    (check-within (candidate \"adb\") #t 0.001)\n    (check-within (candidate \"xyy\") #f 0.001)\n    (check-within (candidate \"iopaxpoi\") #t 0.001)\n    (check-within (candidate \"iopaxioi\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef is_happy(s: str) -> bool:\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n\n### Explanation\n\nThe code is an implementation of  a function `is_happy` that takes a string `s` and returns a boolean value. The function returns `True` if the string `s` does not contain any consecutive characters that are the same. Otherwise, it returns `False`. \n\nThe function takes a single argument, `s`, which is of type `str`. The function returns a boolean value, which is of type `bool`.\n\nThe first line of the code imports the `List` type from the `typing` module. This is not used in the function and can be ignored.\n\nThe fourth line of the code starts a `for` loop that iterates over the indices of the string `s`. The loop starts at the first index and ends at the second-to-last index.\n\nThe fifth line of the code checks if any of the three consecutive characters at the current index and the two following indices are the same. If they are, the function returns `False`.\n\nThe sixth line of the code returns `True` if the loop completes without finding any consecutive characters that are the same. Otherwise, it returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_happy s)\n"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (file_name_check file_name)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_141_file_name_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate file_name_check))\n    (check-within (candidate \"example.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"1example.dll\") \"No\" 0.001)\n    (check-within (candidate \"s1sdf3.asd\") \"No\" 0.001)\n    (check-within (candidate \"K.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"MY16FILE3.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"His12FILE94.exe\") \"No\" 0.001)\n    (check-within (candidate \"_Y.txt\") \"No\" 0.001)\n    (check-within (candidate \"?aREYA.exe\") \"No\" 0.001)\n    (check-within (candidate \"/this_is_valid.dll\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.wow\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"this_is_valid.txtexe\") \"No\" 0.001)\n    (check-within (candidate \"#this2_i4s_5valid.ten\") \"No\" 0.001)\n    (check-within (candidate \"@this1_is6_valid.exe\") \"No\" 0.001)\n    (check-within (candidate \"this_is_12valid.6exe4.txt\") \"No\" 0.001)\n    (check-within (candidate \"all.exe.txt\") \"No\" 0.001)\n    (check-within (candidate \"I563_No.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"Is3youfault.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"no_one#knows.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"1I563_Yes3.exe\") \"No\" 0.001)\n    (check-within (candidate \"I563_Yes3.txtt\") \"No\" 0.001)\n    (check-within (candidate \"final..txt\") \"No\" 0.001)\n    (check-within (candidate \"final132\") \"No\" 0.001)\n    (check-within (candidate \"_f4indsartal132.\") \"No\" 0.001)\n    (check-within (candidate \".txt\") \"No\" 0.001)\n    (check-within (candidate \"s.\") \"No\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef file_name_check(file_name: str) -> str:\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n\n### Explanation\n\nThe code is an implementation of  a function called `file_name_check` which takes a string as input and returns a string as output. The input string is expected to be a file name with an extension. The output string is either 'Yes' or 'No' depending on whether the input string is a valid file name or not. \n\nThe function then checks if the length of `lst` is not equal to 2. If it is not, then the function returns 'No' because the input string is not a valid file name. \n\nThe function then checks if the extension is in the list of valid extensions `suf`. If it is not, then the function returns 'No' because the input string is not a valid file name. \n\nThe function then checks if the length of the file name is greater than 0. If it is not, then the function returns 'No' because the input string is not a valid file name. \n\nThe function then checks if the first character of the file name is an alphabetic character. If it is not, then the function returns 'No' because the input string is not a valid file name. \n\nIf all the above conditions are satisfied, then the function returns 'Yes' because the input string is a valid file name.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (file_name_check file_name)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (maximum arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)\n    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)\n    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)\n    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)\n    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)\n    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)\n    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)\n    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)\n    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)\n    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)\n    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n\n### Explanation\n\n```python\nfrom typing import List\n```\nImporting the List module from the typing package. This is used to specify the type of the input and output of the function.\n\n```python\ndef maximum(arr: List[int], k: int) -> List[int]:\n```\nDefining a function called `maximum` that takes two arguments, a list of integers and an integer `k`. The function returns a list of integers.\n\n```python\n    if k == 0:\n        return []\n```\nIf `k` is 0, return an empty list.\n\n```python\n    ans = arr[-k:]\n```\nSlice the last `k` elements of the sorted list and assign it to a variable `ans`.\n\n```python\n    return ans\n```\nReturn the variable `ans`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (maximum arr k)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (pluck arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n    (check-within (candidate (list 4 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5 0 3 0 4 2)) (list 0 1) 0.001)\n    (check-within (candidate (list 1 2 3 0 5 3)) (list 0 3) 0.001)\n    (check-within (candidate (list 5 4 8 4 8)) (list 4 1) 0.001)\n    (check-within (candidate (list 7 6 7 1)) (list 6 1) 0.001)\n    (check-within (candidate (list 7 9 7 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n\n### Explanation\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. This is used to specify the type of the input and output of the `pluck` function.\n\n```python\ndef pluck(arr: List[int]) -> List[int]:\n```\nThis line defines the `pluck` function that takes in a list of integers and returns a list of integers. The `arr` parameter is of type `List[int]` which means it is a list of integers. The `-> List[int]` specifies that the function returns a list of integers.\n\n```python\nevens = list(filter(lambda x: x%2 == 0, arr))\n```\nThis line creates a new list called `evens` that contains only the even numbers from the input list. The `filter` function is used to filter out the even numbers. The `lambda` function is used to define the condition for filtering. In this case, the condition is that the number is even (`x%2 == 0`).\n\n```python\nif(evens == []): return []\n```\nThis line checks if the `evens` list is empty. If it is, an empty list is returned.\n\n```python\nreturn [min(evens), arr.index(min(evens))]\n```\nThis line returns a list containing two integers. The first integer is the smallest even number in the `evens` list. The `min` function is used to find the smallest even number. The second integer is the index of the smallest even number in the input list. The `index` function is used to find the index of the smallest even number in the input list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (pluck arr)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_distinct_characters string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_distinct_characters))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abcde\") 5 0.001)\n    (check-within (candidate \"abcdecadeCADE\") 5 0.001)\n    (check-within (candidate \"aaaaAAAAaaaa\") 1 0.001)\n    (check-within (candidate \"Jerry jERRY JeRRRY\") 5 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n\n### Explanation\n\nThe code is an implementation of  a function that takes in a string and returns the number of distinct characters in the string. \n\n1. `def count_distinct_characters(string: str) -> int:` - This line defines a function called `count_distinct_characters` that takes in a string as an argument and returns an integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_distinct_characters string)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (make_palindrome string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"xyz\") \"xyzyx\" 0.001)\n    (check-within (candidate \"xyx\") \"xyx\" 0.001)\n    (check-within (candidate \"jerry\") \"jerryrrej\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while string[beginning_of_suffix:] != string[beginning_of_suffix:][::-1]:\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n\n### Explanation\n\nThe code is an implementation of  [Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) to find the longest palindrome in a string. The function takes a string as input and returns a palindrome of that string.\n\n```python\n    if not string:\n        return ''\n```\nIf the input string is empty, return an empty string.\n\n```python\n    while string[beginning_of_suffix:] != string[beginning_of_suffix:][::-1]:\n        beginning_of_suffix += 1\n```\nWhile the substring from the beginning of the suffix to the end of the string is not equal to the reverse of that substring, increment the beginning of the suffix by 1.\n\n```python\n    return string + string[:beginning_of_suffix][::-1]\n```\nReturn the original string concatenated with the reverse of the substring from the beginning of the string to the beginning of the suffix. This creates a palindrome of the original string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (make_palindrome string)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (check_dict_case dict)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f 0.001)\n    (check-within (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f 0.001)\n    (check-within (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t 0.001)\n    (check-within (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t 0.001)\n    (check-within (candidate #hash()) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                continue\n        return state == \"upper\" or state == \"lower\"\n\n### Explanation\n\n1. `from typing import Dict` - import the `Dict` class from the `typing` module.\n2. `def check_dict_case(dict: Dict[str, str]) -> bool:` - define the `check_dict_case` function which takes a dictionary as input and returns a boolean value.\n3. `if len(dict.keys()) == 0:` - check if the dictionary is empty. If it is, return `False`.\n4. `else:` - if the dictionary is not empty, continue with the function.\n5. `state = \"start\"` - initialize the `state` variable to `\"start\"`.\n6. `for key in dict.keys():` - iterate over the keys of the dictionary.\n7. `if isinstance(key, str) == False:` - check if the key is a string. If it is not, set the `state` variable to `\"mixed\"` and break out of the loop.\n8. `if state == \"start\":` - check if the `state` variable is `\"start\"`.\n9. `if key.isupper():` - check if the key is all uppercase.\n10. `state = \"upper\"` - set the `state` variable to `\"upper\"`.\n11. `elif key.islower():` - check if the key is all lowercase.\n12. `state = \"lower\"` - set the `state` variable to `\"lower\"`.\n13. `else:` - if the key is not all uppercase or all lowercase, break out of the loop.\n14. `elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):` - check if the `state` variable is `\"upper\"` and the key is not all uppercase, or if the `state` variable is `\"lower\"` and the key is not all lowercase.\n15. `state = \"mixed\"` - set the `state` variable to `\"mixed\"`.\n16. `break` - break out of the loop.\n17. `else:` - if none of the above conditions are met, continue with the loop.\n18. `continue` - continue with the loop.\n19. `return state == \"upper\" or state == \"lower\"` - return `True` if the `state` variable is `\"upper\"` or `\"lower\"`, `False` otherwise.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (check_dict_case dict)\n"
  },
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"()\") #t 0.001)\n    (check-within (candidate \"(()())\") #t 0.001)\n    (check-within (candidate \"()()(()())()\") #t 0.001)\n    (check-within (candidate \"()()((()()())())(()()(()))\") #t 0.001)\n    (check-within (candidate \"((()())))\") #f 0.001)\n    (check-within (candidate \")(()\") #f 0.001)\n    (check-within (candidate \"(\") #f 0.001)\n    (check-within (candidate \"((((\") #f 0.001)\n    (check-within (candidate \")\") #f 0.001)\n    (check-within (candidate \"(()\") #f 0.001)\n    (check-within (candidate \"()()(()())())(()\") #f 0.001)\n    (check-within (candidate \"()()(()())()))()\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Explanation\n\nThe code is an implementation of  a function called `correct_bracketing` that takes in a string of brackets and returns a boolean indicating whether the brackets are correctly balanced or not. \n\nThe function takes in a string of brackets as an argument and returns a boolean indicating whether the brackets are correctly balanced or not. \n\nFor each character, the function checks if it is an opening bracket (i.e. \"(\"). If it is, the function increments the `depth` variable by 1. \n\nIf the character is not an opening bracket, the function assumes it is a closing bracket and decrements the `depth` variable by 1. \n\nThe function then checks if the `depth` variable is less than 0. If it is, this means that there are more closing brackets than opening brackets, which is not allowed. In this case, the function returns `False` to indicate that the brackets are not correctly balanced. \n\nIf the `depth` variable is not less than 0 after processing all the characters in the string, the function checks if the `depth` variable is equal to 0. If it is, this means that the number of opening brackets is equal to the number of closing brackets, which is the definition of correctly balanced brackets. In this case, the function returns `True` to indicate that the brackets are correctly balanced.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (split_words txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n    (check-within (candidate \"Hello world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello,world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello world,!\") (list \"Hello\" \"world,!\") 0.001)\n    (check-within (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\" \"!\") 0.001)\n    (check-within (candidate \"abcdef\") 3 0.001)\n    (check-within (candidate \"aaabb\") 2 0.001)\n    (check-within (candidate \"aaaBb\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n\n### Explanation\n\n```python\nfrom typing import List\nfrom typing import Union\n```\nThe `typing` module is used to provide type hints for the function. `List` and `Union` are two of the types that are imported from the module. `List` is used to indicate that the function returns a list of strings, while `Union` is used to indicate that the function can return either a list or an integer.\n\n```python\ndef split_words(txt: str) -> Union[List[str], int]:\n```\nThis line defines the function `split_words` that takes a string `txt` as input and returns either a list of strings or an integer. The `->` symbol is used to indicate the return type of the function.\n\n```python\nif \" \" in txt:\n    return txt.split()\n```\nThis block of code checks if the string `txt` contains a space character. If it does, then the string is split into a list of words using the `split()` method and the resulting list is returned.\n\n```python\nelif \",\" in txt:\n    return txt.replace(',',' ').split()\n```\nThis block of code checks if the string `txt` contains a comma character. If it does, then the commas are replaced with spaces using the `replace()` method, and the resulting string is split into a list of words using the `split()` method. The resulting list is then returned.\n\n\n### Racket version\n\n#lang racket\n\n;; \n(define (split_words txt)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (strlen string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strlen))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"x\") 1 0.001)\n    (check-within (candidate \"asdasnakj\") 9 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef strlen(string: str) -> int:\n    return len(string)\n\n### Explanation\n\nThe code is an implementation of  a function called `strlen` that takes a string as an argument and returns the length of the string. \n\nThe `return` statement returns the length of the string using the `len` function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (strlen string)\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (car_race_collision n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate car_race_collision))\n    (check-within (candidate 2) 4 0.001)\n    (check-within (candidate 3) 9 0.001)\n    (check-within (candidate 4) 16 0.001)\n    (check-within (candidate 8) 64 0.001)\n    (check-within (candidate 10) 100 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef car_race_collision(n: int) -> int:\n    return n**2\n\n### Explanation\n\nThe code is an implementation of  a function named `car_race_collision` that takes an integer `n` as input and returns an integer. The function returns the square of the input integer `n`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (car_race_collision n)\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fibfib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 1) 0 0.001)\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 24 0.001)\n    (check-within (candidate 10) 81 0.001)\n    (check-within (candidate 12) 274 0.001)\n    (check-within (candidate 14) 927 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n\n### Explanation\n\nThe code is an implementation of 3-step Fibonacci sequence. The function `fibfib` takes an integer `n` as input and returns an integer as output. \n\nThe first three if statements are the base cases. If `n` is 0, the function returns 0. If `n` is 1, the function returns 0. If `n` is 2, the function returns 1.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fibfib n)\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (order_by_points nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n    (check-within (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11) 0.001)\n    (check-within (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -11 -32 43 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9) 0.001)\n    (check-within (candidate (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n\n### Explanation\n\nThe function `digits_sum` takes an integer `n` and returns the sum of its digits. If the integer is negative, it multiplies it by -1 to make it positive, then converts it to a string and splits it into a list of integers. It then multiplies the first digit by -1 if the original integer was negative, and returns the sum of the digits.\n\nThe `order_by_points` function takes a list of integers `nums` and sorts it using the `sorted` function. The `key` parameter of the `sorted` function is set to `digits_sum`, which means that the sorting will be based on the sum of the digits of each integer in the list. The sorted list is then returned.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (order_by_points nums)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (move_one_ball arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate move_one_ball))\n    (check-within (candidate (list 3 4 5 1 2)) #t 0.001)\n    (check-within (candidate (list 3 5 10 1 2)) #t 0.001)\n    (check-within (candidate (list 4 3 1 2)) #f 0.001)\n    (check-within (candidate (list 3 5 4 1 2)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n\n### Explanation\n\nThe function starts by importing the List class from the typing module. This is used to indicate that the input parameter is a list of integers.\n\n```python\nfrom typing import List\n```\n\nThe function definition starts with the `def` keyword, followed by the function name `move_one_ball`. The input parameter is a list of integers called `arr`. The function returns a boolean value.\n\n```python\ndef move_one_ball(arr: List[int]) -> bool:\n```\n\nThe first line of the function checks if the length of the input list is zero. If it is, the function returns True.\n\n```python\n    if len(arr)==0:\n      return True\n```\n\nThe next line sorts the input list in ascending order and assigns the sorted list to a new variable called `sorted_array`.\n\n```python\n    sorted_array=sorted(arr)\n```\n\n```python\n    my_arr=[]\n```\n\n```python\n    min_value=min(arr)\n    min_index=arr.index(min_value)\n```\n\n```python\n    my_arr=arr[min_index:]+arr[0:min_index]\n```\n\nThe next loop checks if the elements in `my_arr` are in the same order as the elements in `sorted_array`. If they are not, the function returns False.\n\nIf the loop completes without returning False, the function returns True.\n\n```python\n    return True\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (move_one_ball arr)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (closest_integer value)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-within (candidate \"10\") 10 0.001)\n    (check-within (candidate \"14.5\") 15 0.001)\n    (check-within (candidate \"-15.5\") -16 0.001)\n    (check-within (candidate \"15.3\") 15 0.001)\n    (check-within (candidate \"0\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef closest_integer(value: str) -> int:\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n### Explanation\n\n```python\ndef closest_integer(value: str) -> int:\n```\n\nThe function imports the `floor` and `ceil` functions from the `math` module.\n\n```python\n    from math import floor, ceil\n```\n\nThe function converts the string to a float.\n\n```python\n    num = float(value)\n```\n\nThe function checks if the input string ends with `.5`. If it does, it rounds up if the number is positive and rounds down if the number is negative.\n\n```python\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n```\n\n```python\n    elif len(value) > 0:\n        res = int(round(num))\n```\n\nIf the input string is empty, the function returns 0.\n\n```python\n    else:\n        res = 0\n```\n\nFinally, the function returns the closest integer as an integer.\n\n```python\n    return res\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (closest_integer value)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (special_factorial n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate special_factorial))\n    (check-within (candidate 4) 288 0.001)\n    (check-within (candidate 5) 34560 0.001)\n    (check-within (candidate 7) 125411328000 0.001)\n    (check-within (candidate 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef special_factorial(n: int) -> int:\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n### Explanation\n\n1. `fact_i = 1` - initialize a variable called `fact_i` to 1. This variable will be used to calculate the factorial of each number from 1 to `n`.\n2. `special_fact = 1` - initialize a variable called `special_fact` to 1. This variable will be used to calculate the special factorial of `n`.\n3. `for i in range(1, n+1):` - loop through each number from 1 to `n`.\n4. `fact_i *= i` - multiply `fact_i` by `i` to calculate the factorial of `i`.\n5. `special_fact *= fact_i` - multiply `special_fact` by `fact_i` to calculate the special factorial of `n`.\n6. `return special_fact` - return the special factorial of `n`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (special_factorial n)\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_nested string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n    (check-within (candidate \"[[]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]][[[[[]\") #f 0.001)\n    (check-within (candidate \"[][]\") #f 0.001)\n    (check-within (candidate \"[]\") #f 0.001)\n    (check-within (candidate \"[[[[]]]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]]]]]\") #f 0.001)\n    (check-within (candidate \"[][][[]]\") #t 0.001)\n    (check-within (candidate \"[[]\") #f 0.001)\n    (check-within (candidate \"[]]\") #f 0.001)\n    (check-within (candidate \"[[]][[\") #t 0.001)\n    (check-within (candidate \"[[][]]\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"[[[[[[[[\") #f 0.001)\n    (check-within (candidate \"]]]]]]]]\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_nested(string: str) -> bool:\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n### Explanation\n\nThe code is an implementation of  a function called `is_nested` that takes a string as input and returns a boolean value. The function checks if the string contains at least two nested square brackets.\n\n```python\ndef is_nested(string: str) -> bool:\n```\n\nThe function definition starts with the keyword `def` followed by the function name `is_nested`. The function takes a single argument `string` of type string and returns a boolean value. The `->` symbol is used to indicate the return type of the function.\n\n```python\n    opening_bracket_index = []\n    closing_bracket_index = []\n```\n\nTwo empty lists are created to store the indices of opening and closing square brackets.\n\n```python\n    closing_bracket_index.reverse()\n```\n\n```python\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n```\n\nTwo variables `cnt` and `i` are initialized to 0. The length of the `closing_bracket_index` list is stored in the variable `l`. A for loop is used to iterate over each index in the `opening_bracket_index` list. If the current index is less than the index of the corresponding closing square bracket, the `cnt` variable is incremented and the `i` variable is also incremented.\n\nThe function returns `True` if the `cnt` variable is greater than or equal to 2, indicating that there are at least two nested square brackets in the input string. Otherwise, it returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_nested string)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (even_odd_count num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n    (check-within (candidate 7) (list 0 1) 0.001)\n    (check-within (candidate -78) (list 1 1) 0.001)\n    (check-within (candidate 3452) (list 2 2) 0.001)\n    (check-within (candidate 346211) (list 3 3) 0.001)\n    (check-within (candidate -345821) (list 3 3) 0.001)\n    (check-within (candidate -2) (list 1 0) 0.001)\n    (check-within (candidate -45347) (list 2 3) 0.001)\n    (check-within (candidate 0) (list 1 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple \n\ndef even_odd_count(num: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n\n### Explanation\n\nThe code is an implementation of  a function that takes an integer as input and returns a tuple of two integers. The first integer in the tuple is the count of even digits in the input integer and the second integer in the tuple is the count of odd digits in the input integer.\n\nThe function `even_odd_count` takes an integer `num` as input and returns a tuple of two integers. The `Tuple` module is imported from the `typing` module to enable type hinting.\n\nTwo variables `even_count` and `odd_count` are initialized to 0. These variables will be used to keep track of the count of even and odd digits in the input integer.\n\nFinally, the function returns a tuple of the `even_count` and `odd_count` variables.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (even_odd_count num)\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (string_xor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n    (check-within (candidate \"111000\" \"101010\") \"010010\" 0.001)\n    (check-within (candidate \"1\" \"1\") \"0\" 0.001)\n    (check-within (candidate \"0101\" \"0000\") \"0101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n\n### Explanation\n\nThe function `string_xor` takes 2 strings as input and returns the XOR result of the 2 strings. \n\nThe `xor` function is a helper function that takes 2 characters as input and returns the XOR result of the 2 characters. If the 2 characters are the same, the function returns '0', otherwise it returns '1'.\n\nThe `string_xor` function uses the `zip` function to iterate over the 2 input strings character by character. It then applies the `xor` function to each pair of characters and concatenates the result into a single string using the `join` function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (string_xor a b)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (longest strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"x\" 0.001)\n    (check-within (candidate (list \"x\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\")) \"zzzz\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n### Explanation\n\nThe code is an implementation of  a function that takes a list of strings and returns the longest string in the list. \n\n```python\ndef longest(strings: List[str]) -> Optional[str]:\n```\nThis line defines the function `longest` which takes a list of strings as input and returns an optional string. The function name is `longest` and it takes one argument, a list of strings. The `-> Optional[str]` part of the line indicates that the function may return None if the input list is empty.\n\n```python\nif not strings:\n    return None\n```\nThis line checks if the input list is empty. If it is, the function returns None.\n\n```python\nmaxlen = max(len(x) for x in strings)\n```\nThis line calculates the length of the longest string in the input list. It does this by using a generator expression to create a list of the lengths of each string in the input list, and then passing that list to the `max` function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (longest strings)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (intersperse numbers delimeter)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersperse))\n    (check-within (candidate (list ) 7) (list ) 0.001)\n    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)\n    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n\n### Explanation\n\nThe code is an implementation of  a function called `intersperse` that takes in a list of integers and a delimiter integer and returns a new list with the delimiter integer inserted between each element of the original list. \n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. This is used to specify the type of the input and output of the `intersperse` function.\n\n```python\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n```\nThis line defines the `intersperse` function that takes in two arguments: a list of integers called `numbers` and an integer called `delimiter`. The function returns a list of integers.\n\n```python\n    if not numbers:\n        return []\n```\nThis line checks if the `numbers` list is empty. If it is, the function returns an empty list.\n\n```python\n    result = []\n```\nThis line initializes an empty list called `result`. This list will be used to store the new list with the delimiter inserted between each element of the original list.\n\n```python\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n```\nThis loop iterates through all elements of the `numbers` list except the last one. For each element, it appends the element to the `result` list, followed by the delimiter integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (intersperse numbers delimeter)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (histogram test)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate histogram))\n    (check-within (candidate \"a b b a\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c a b\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c d g\") #hash((\"a\" .  1) (\"b\" .  1) (\"c\" .  1) (\"d\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"b b b b a\") #hash((\"b\" .  4)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"\") #hash() 0.001)\n    (check-within (candidate \"a\") #hash((\"a\" .  1)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n\n### Explanation\n\n3. `dict1={}` - Creating an empty dictionary called dict1.\n\n4. `list1=test.split(\" \")` - Splitting the input string into a list of words using the space character as the delimiter.\n\n5. `t=0` - Initializing a variable called t to 0.\n\n6. `for i in list1:` - Starting a for loop that iterates over each word in the list.\n\n7. `if(list1.count(i)>t) and i!='':` - Checking if the count of the current word in the list is greater than the current value of t and if the current word is not an empty string.\n\n8. `t=list1.count(i)` - If the condition in step 7 is true, then set the value of t to the count of the current word in the list.\n\n9. `if t>0:` - Checking if the value of t is greater than 0.\n\n10. `for i in list1:` - Starting a for loop that iterates over each word in the list.\n\n11. `if(list1.count(i)==t):` - Checking if the count of the current word in the list is equal to the value of t.\n\n13. `return dict1` - Return the dictionary dict1 containing the frequency of each word in the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (histogram test)\n"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_array array)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5)) (list 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3 4 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0) 0.001)\n    (check-within (candidate (list 2 1)) (list 1 2) 0.001)\n    (check-within (candidate (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87) 0.001)\n    (check-within (candidate (list 21 14 23 11)) (list 23 21 14 11) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThe code is an implementation of  a function that sorts an array of integers. \n\nThe function `sort_array` takes an array of integers as input and returns a sorted array of integers. \n\nThe `List` type is imported from the `typing` module.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_array array)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (largest_divisor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_divisor))\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 10) 5 0.001)\n    (check-within (candidate 100) 50 0.001)\n    (check-within (candidate 49) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef largest_divisor(n: int) -> int:\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n\n### Explanation\n\nThe code is an implementation of  a function that takes an integer `n` and returns the largest divisor of `n`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_divisor n)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_up_to n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_up_to))\n    (check-within (candidate 5) (list 2 3) 0.001)\n    (check-within (candidate 6) (list 2 3 5) 0.001)\n    (check-within (candidate 7) (list 2 3 5) 0.001)\n    (check-within (candidate 10) (list 2 3 5 7) 0.001)\n    (check-within (candidate 0) (list ) 0.001)\n    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)\n    (check-within (candidate 1) (list ) 0.001)\n    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)\n    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)\n    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef count_up_to(n: int) -> List[int]:\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n### Explanation\n\nThe code is an implementation of  a function that returns a list of all prime numbers up to a given number `n`. \n\n```python\nfrom typing import List\n```\nImporting the `List` class from the `typing` module. \n\n```python\nprimes = []\n```\nInitializing an empty list `primes` to store the prime numbers. \n\n```python\nis_prime = True\n```\nInitializing a boolean variable `is_prime` to `True`. \n\n```python\nfor j in range(2, i):\n```\nIterating over all integers from `2` to `i-1`. \n\n```python\nif i % j == 0:\n    is_prime = False\n    break\n```\nIf `i` is divisible by `j`, then `i` is not a prime number. Set `is_prime` to `False` and break out of the inner loop. \n\n```python\nreturn primes\n```\nReturn the `primes` list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_up_to n)\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_even l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_even))\n    (check-within (candidate (list 1 2 3)) (list 1 2 3) 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123) 0.001)\n    (check-within (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_even(l: List[int]) -> List[int]:\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n\n### Explanation\n\n```python\nfrom typing import List\n```\nThis line imports the List type from the typing module. This is used to specify the type of the function argument and return value.\n\n```python\ndef sort_even(l: List[int]) -> List[int]:\n```\nThis line defines the function `sort_even` which takes a list of integers `l` as an argument and returns a new list of integers. The `-> List[int]` specifies the return type of the function.\n\n```python\nevens = l[::2]\nodds = l[1::2]\n```\nThese two lines create two new lists `evens` and `odds` by slicing the input list `l`. The `evens` list contains all even-indexed elements of `l`, while the `odds` list contains all odd-indexed elements of `l`.\n\n```python\nevens.sort()\n```\nThis line sorts the `evens` list in ascending order.\n\n```python\nans = []\nfor e, o in zip(evens, odds):\n    ans.extend([e, o])\n```\nThese lines create a new list `ans` by iterating over the `evens` and `odds` lists simultaneously using the `zip` function. For each pair of elements `(e, o)`, the elements are added to `ans` in the order `[e, o]` using the `extend` method.\n\n```python\nreturn ans\n```\nThis line returns the `ans` list, which contains all even numbers sorted in ascending order, but keeping the odd numbers in their original position.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_even l)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (add x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate 0 1) 1 0.001)\n    (check-within (candidate 1 0) 1 0.001)\n    (check-within (candidate 2 3) 5 0.001)\n    (check-within (candidate 5 7) 12 0.001)\n    (check-within (candidate 7 5) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef add(x: int, y: int) -> int:\n    return x + y\n\n### Explanation\n\nThe code is an implementation of  a function that takes two integer arguments and returns their sum. The function is called `add` and is defined using the `def` keyword. The function takes two arguments, `x` and `y`, both of which are of type `int`. The `->` symbol is used to indicate the return type of the function, which is also `int`. The function body consists of a single line that returns the sum of the two arguments using the `+` operator.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (add x y)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (circular_shift x shift)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n    (check-within (candidate 100 2) \"001\" 0.001)\n    (check-within (candidate 12 2) \"12\" 0.001)\n    (check-within (candidate 97 8) \"79\" 0.001)\n    (check-within (candidate 12 1) \"21\" 0.001)\n    (check-within (candidate 11 101) \"11\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n\n### Explanation\n\nThe code is an implementation of  a circular shift operation on an integer. The function takes two arguments, an integer `x` and an integer `shift`. The function returns a string.\n\n2. `s = str(x)` - This line converts the integer `x` to a string and assigns it to the variable `s`.\n\n3. `if shift > len(s):` - This line checks if the value of `shift` is greater than the length of the string `s`.\n\n4. `return s[::-1]` - This line returns the reverse of the string `s` if the value of `shift` is greater than the length of the string `s`.\n\n5. `else:` - This line starts an else block.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (circular_shift x shift)\n"
  }
]