[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"()\") #t 0.001)\n    (check-within (candidate \"(()())\") #t 0.001)\n    (check-within (candidate \"()()(()())()\") #t 0.001)\n    (check-within (candidate \"()()((()()())())(()()(()))\") #t 0.001)\n    (check-within (candidate \"((()())))\") #f 0.001)\n    (check-within (candidate \")(()\") #f 0.001)\n    (check-within (candidate \"(\") #f 0.001)\n    (check-within (candidate \"((((\") #f 0.001)\n    (check-within (candidate \")\") #f 0.001)\n    (check-within (candidate \"(()\") #f 0.001)\n    (check-within (candidate \"()()(()())())(()\") #f 0.001)\n    (check-within (candidate \"()()(()())()))()\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> bool:\n    VAR_1 = 0\n    for VAR_2 in VAR_0:\n        if (VAR_2 == '('):\n            VAR_1 += 1\n        else:\n            VAR_1 -= 1\n        if (VAR_1 < 0):\n            return False\n    return (VAR_1 == 0)\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes a string as input and returns a boolean. \n\nThe function first initializes a variable VAR_1 to 0. \n\nIt then enters a for loop that iterates over each character in the input string VAR_0. \n\nFor each character, the function checks if it is an opening parenthesis '('. If it is, it increments VAR_1 by 1. If it is not, it decrements VAR_1 by 1. \n\nIf at any point VAR_1 becomes negative, the function returns False. This is because if there are more closing parentheses ')' than opening parentheses '(', VAR_1 will become negative. \n\nFinally, the function checks if VAR_1 is equal to 0. If it is, it returns True. If it is not, it returns False. This is because if there are an equal number of opening and closing parentheses, VAR_1 will be 0. \n\nOverall, the function checks if the input string has a balanced number of opening and closing parentheses. If it does, it returns True. If it does not, it returns False.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5 3) 7.5 0.001)\n    (check-within (candidate 2 2) 2.0 0.001)\n    (check-within (candidate 10 8) 40.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> float:\n    return ((VAR_0 * VAR_1) / 2.0)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two integer arguments `VAR_0` and `VAR_1` and returns a float. \n\nThe function returns the result of the expression `(VAR_0 * VAR_1) / 2.0`. \n\n- `VAR_0 * VAR_1` multiplies the two integer arguments.\n- `2.0` is a float value of 2.\n- `(VAR_0 * VAR_1) / 2.0` divides the product of the two integer arguments by 2. \n\nThe resulting value is a float, which is returned by the function. \n\nIn summary, the function calculates the area of a triangle given the base and height of the triangle.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 4) 288 0.001)\n    (check-within (candidate 5) 34560 0.001)\n    (check-within (candidate 7) 125411328000 0.001)\n    (check-within (candidate 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    VAR_1 = 1\n    VAR_2 = 1\n    for VAR_3 in range(1, (VAR_0 + 1)):\n        VAR_1 *= VAR_3\n        VAR_2 *= VAR_1\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that calculates the factorial of a given number. \n\n`def FUNC_0(VAR_0: int) -> int:` defines a function named `FUNC_0` that takes an integer argument `VAR_0` and returns an integer. \n\n`VAR_1 = 1` initializes a variable `VAR_1` to 1.\n\n`VAR_2 = 1` initializes a variable `VAR_2` to 1.\n\n`for VAR_3 in range(1, (VAR_0 + 1)):` is a for loop that iterates over a range of numbers from 1 to `VAR_0` (inclusive) and assigns each value to the variable `VAR_3`.\n\n`VAR_1 *= VAR_3` multiplies `VAR_1` by `VAR_3` and assigns the result to `VAR_1`.\n\n`VAR_2 *= VAR_1` multiplies `VAR_2` by `VAR_1` and assigns the result to `VAR_2`.\n\n`return VAR_2` returns the value of `VAR_2` as the result of the function. \n\nIn summary, the function calculates the factorial of `VAR_0` by multiplying all the numbers from 1 to `VAR_0` together and returns the result.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_136_largest_smallest_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)\n    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)\n    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)\n    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)\n    (check-within (candidate (list )) (list #f #f) 0.001)\n    (check-within (candidate (list 0)) (list #f #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\n\ndef FUNC_0(VAR_0: List[int]) -> Tuple[(Optional[int], Optional[int])]:\n    VAR_1 = list(filter((lambda VAR_2: (VAR_2 < 0)), VAR_0))\n    VAR_3 = list(filter((lambda VAR_2: (VAR_2 > 0)), VAR_0))\n    return ((max(VAR_1) if VAR_1 else None), (min(VAR_3) if VAR_3 else None))\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a tuple of two values. The first value is the maximum negative integer in the list, and the second value is the minimum positive integer in the list. If there are no negative integers in the list, the first value in the tuple is None. If there are no positive integers in the list, the second value in the tuple is None.\n\nThe function takes a single argument, VAR_0, which is a list of integers. The function returns a tuple of two values, both of which are optional integers.\n\nThe first line of the function imports the List, Tuple, and Optional types from the typing module. These types are used to specify the types of the function's arguments and return value.\n\nThe second line of the function defines the function itself. The function is named FUNC_0 and takes a single argument, VAR_0, which is a list of integers. The function returns a tuple of two optional integers.\n\nThe third line of the function creates a new list, VAR_1, that contains only the negative integers from VAR_0. This is done using the filter() function, which takes a lambda function that returns True if the input is negative. The lambda function is defined inline as (lambda VAR_2: (VAR_2 < 0)).\n\nThe fourth line of the function creates a new list, VAR_3, that contains only the positive integers from VAR_0. This is done using the filter() function, which takes a lambda function that returns True if the input is positive. The lambda function is defined inline as (lambda VAR_2: (VAR_2 > 0)).\n\nThe fifth line of the function returns a tuple containing the maximum value in VAR_1 (i.e., the maximum negative integer) and the minimum value in VAR_3 (i.e., the minimum positive integer). If VAR_1 is empty, the first value in the tuple is None. If VAR_3 is empty, the second value in the tuple is None. The max() and min() functions are used to find the maximum and minimum values in the lists, respectively. The ternary operator is used to return None if the list is empty. The return statement returns a tuple of two optional integers.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 3 4 5 1 2)) #t 0.001)\n    (check-within (candidate (list 3 5 10 1 2)) #t 0.001)\n    (check-within (candidate (list 4 3 1 2)) #f 0.001)\n    (check-within (candidate (list 3 5 4 1 2)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> bool:\n    if (len(VAR_0) == 0):\n        return True\n    VAR_1 = sorted(VAR_0)\n    VAR_2 = []\n    VAR_3 = min(VAR_0)\n    VAR_4 = VAR_0.index(VAR_3)\n    VAR_2 = (VAR_0[VAR_4:] + VAR_0[0:VAR_4])\n    for VAR_5 in range(len(VAR_0)):\n        if (VAR_2[VAR_5] != VAR_1[VAR_5]):\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a given list is sorted in ascending order. \n\nThe function takes a list of integers as input and returns a boolean value. \n\nThe first line imports the List class from the typing module. \n\nThe second line defines a function named FUNC_0 that takes a list of integers as input and returns a boolean value. \n\nThe third line checks if the length of the input list is zero. If it is, the function returns True. \n\nThe fourth line sorts the input list in ascending order and assigns the sorted list to a new variable named VAR_1. \n\nThe fifth line initializes an empty list named VAR_2. \n\nThe sixth line finds the minimum value in the input list and assigns it to a new variable named VAR_3. \n\nThe seventh line finds the index of the minimum value in the input list and assigns it to a new variable named VAR_4. \n\nThe eighth line assigns a new list to VAR_2 that is created by concatenating the sublist of VAR_0 starting from VAR_4 to the end of the list, with the sublist of VAR_0 starting from the beginning of the list to VAR_4. This effectively rotates the list so that the minimum value is at the beginning. \n\nThe ninth line initializes a for loop that iterates over the range of values from 0 to the length of the input list. \n\nThe tenth line checks if the value at index VAR_5 in VAR_2 is not equal to the value at index VAR_5 in VAR_1. If they are not equal, the function returns False. \n\nThe eleventh line returns True if the function has not yet returned False. \n\nOverall, the function checks if the input list is sorted in ascending order by rotating the list so that the minimum value is at the beginning, and then comparing the rotated list to the sorted list. If the two lists are equal, the input list is sorted in ascending order. If not, the input list is not sorted in ascending order.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 54) 5 0.001)\n    (check-within (candidate 120) 1 0.001)\n    (check-within (candidate 5014) 5 0.001)\n    (check-within (candidate 98765) 315 0.001)\n    (check-within (candidate 5576543) 2625 0.001)\n    (check-within (candidate 2468) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    VAR_1 = 1\n    VAR_2 = 0\n    for VAR_3 in str(VAR_0):\n        VAR_4 = int(VAR_3)\n        if ((VAR_4 % 2) == 1):\n            VAR_1 = (VAR_1 * VAR_4)\n            VAR_2 += 1\n    if (VAR_2 == 0):\n        return 0\n    else:\n        return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns an integer as output. The function is named FUNC_0 and takes a single argument, VAR_0, which is an integer.\n\nThe first line of the function initializes a variable named VAR_1 to 1. \n\nThe second line initializes a variable named VAR_2 to 0.\n\nThe third line starts a for loop that iterates over each character in the string representation of VAR_0. \n\nThe fourth line initializes a variable named VAR_4 to the integer representation of the current character in the loop.\n\nThe fifth line checks if VAR_4 is odd by checking if the remainder of VAR_4 divided by 2 is equal to 1. If VAR_4 is odd, the code multiplies VAR_1 by VAR_4 and assigns the result to VAR_1. It also increments VAR_2 by 1.\n\nThe sixth line checks if VAR_2 is equal to 0. If VAR_2 is equal to 0, the function returns 0. Otherwise, the function returns VAR_1. \n\nOverall, the function multiplies together all the odd digits in the input integer and returns the result. If there are no odd digits in the input integer, the function returns 0.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 28 0.001)\n    (check-within (candidate 10) 104 0.001)\n    (check-within (candidate 12) 386 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    VAR_1 = [0, 0, 2, 0]\n    if (VAR_0 < 4):\n        return VAR_1[VAR_0]\n    for VAR_2 in range(4, (VAR_0 + 1)):\n        VAR_1.append((((VAR_1[(- 1)] + VAR_1[(- 2)]) + VAR_1[(- 3)]) + VAR_1[(- 4)]))\n        VAR_1.pop(0)\n    return VAR_1[(- 1)]\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. \n\n1. `def FUNC_0(VAR_0: int) -> int:` - This line defines a function named `FUNC_0` that takes an integer argument `VAR_0` and returns an integer. \n2. `VAR_1 = [0, 0, 2, 0]` - This line initializes a list `VAR_1` with four elements: 0, 0, 2, and 0.\n3. `if (VAR_0 < 4):` - This line checks if the input `VAR_0` is less than 4. If it is, the function returns the corresponding element from the `VAR_1` list.\n4. `return VAR_1[VAR_0]` - This line returns the `VAR_0`-th element from the `VAR_1` list.\n5. `for VAR_2 in range(4, (VAR_0 + 1)):` - This line starts a loop that iterates from 4 to `VAR_0 + 1`.\n6. `VAR_1.append((((VAR_1[(- 1)] + VAR_1[(- 2)]) + VAR_1[(- 3)]) + VAR_1[(- 4)]))` - This line appends a new element to the `VAR_1` list, which is the sum of the last four elements in the list.\n7. `VAR_1.pop(0)` - This line removes the first element from the `VAR_1` list.\n8. `return VAR_1[(- 1)]` - This line returns the last element from the `VAR_1` list, which is the `VAR_0`-th Fibonacci number.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3)) (list 1 2 3) 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123) 0.001)\n    (check-within (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    VAR_1 = VAR_0[::2]\n    VAR_2 = VAR_0[1::2]\n    VAR_1.sort()\n    VAR_3 = []\n    for (VAR_4, VAR_5) in zip(VAR_1, VAR_2):\n        VAR_3.extend([VAR_4, VAR_5])\n    if (len(VAR_1) > len(VAR_2)):\n        VAR_3.append(VAR_1[(- 1)])\n    return VAR_3\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a new list of integers. The function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of integers. The function returns a list of integers.\n\nThe first line of the function imports the List class from the typing module. This is used to specify the type of the input and output of the function.\n\nThe second line of the function creates a new list VAR_1 that contains every other element of the input list VAR_0, starting from the first element.\n\nThe third line of the function creates a new list VAR_2 that contains every other element of the input list VAR_0, starting from the second element.\n\nThe fourth line of the function sorts the list VAR_1 in ascending order.\n\nThe fifth line of the function creates an empty list VAR_3.\n\nThe sixth line of the function iterates over the elements of VAR_1 and VAR_2 in parallel using the zip function. For each pair of elements, it appends them to the list VAR_3.\n\nThe seventh line of the function checks if the length of VAR_1 is greater than the length of VAR_2. If it is, it appends the last element of VAR_1 to the list VAR_3.\n\nThe eighth line of the function returns the list VAR_3.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11) 0.001)\n    (check-within (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -11 -32 43 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9) 0.001)\n    (check-within (candidate (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n\n    def FUNC_1(VAR_1):\n        VAR_2 = 1\n        if (VAR_1 < 0):\n            (VAR_1, VAR_2) = (((- 1) * VAR_1), (- 1))\n        VAR_1 = [int(VAR_3) for VAR_3 in str(VAR_1)]\n        VAR_1[0] = (VAR_1[0] * VAR_2)\n        return sum(VAR_1)\n    return sorted(VAR_0, key=FUNC_1)\n\n### Explanation\n\nThe code is an implementation of a function that sorts a list of integers by their digit sum. \n\n1. The first line imports the List class from the typing module. This is used to specify the type of the input and output of the function.\n2. The second line defines a function called FUNC_0 that takes a list of integers as input and returns a list of integers as output.\n3. The third line defines another function called FUNC_1 that takes an integer as input and returns an integer as output.\n4. The fourth line initializes a variable VAR_2 to 1.\n5. The fifth line checks if the input integer VAR_1 is less than 0. If it is, it multiplies VAR_1 by -1 and sets VAR_2 to -1.\n6. The sixth line converts the input integer VAR_1 to a list of integers by converting it to a string and then converting each character back to an integer.\n7. The seventh line multiplies the first element of the list by VAR_2.\n8. The eighth line returns the sum of the elements in the list.\n9. The ninth line returns the input list sorted by the key function FUNC_1. This means that the list is sorted by the digit sum of each element. \n\nTo rewrite this program in Java, you would need to define the classes and methods, specify the input and output types, and translate the Python syntax to Java syntax. Here is an example implementation in Java:\n\n```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> input = new ArrayList<Integer>();\n        input.add(123);\n        input.add(45);\n        input.add(678);\n        List<Integer> output = sortListByDigitSum(input);\n        System.out.println(output);\n    }\n\n    public static List<Integer> sortListByDigitSum(List<Integer> input) {\n        return input.stream()\n                .sorted(Comparator.comparing(Main::digitSum))\n                .collect(Collectors.toList());\n    }\n\n    public static int digitSum(int n) {\n        int sign = 1;\n        if (n < 0) {\n            n *= -1;\n            sign = -1;\n        }\n        List<Integer> digits = new ArrayList<Integer>();\n        while (n > 0) {\n            digits.add(n % 10);\n            n /= 10;\n        }\n        digits.set(0, digits.get(0) * sign);\n        return digits.stream().mapToInt(Integer::intValue).sum();\n    }\n}\n```\n\n\nThe Java implementation uses the Java Collections framework to define the input and output types as List<Integer>. The sortListByDigitSum method uses the Java stream API to sort the input list by the digit sum of each element using the digitSum method as the key function. The digitSum method is a direct translation of the FUNC_1 method in Python. It uses a while loop to extract the digits of the input integer and a stream to calculate the digit sum. The rest of the code is standard Java syntax for defining classes and methods. \n\nNote that the Java implementation is longer and more verbose than the Python implementation, but the logic is the same. The key difference is the syntax and the use of external libraries.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"a\") #f 0.001)\n    (check-within (candidate \"aa\") #f 0.001)\n    (check-within (candidate \"abcd\") #t 0.001)\n    (check-within (candidate \"aabb\") #f 0.001)\n    (check-within (candidate \"adb\") #t 0.001)\n    (check-within (candidate \"xyy\") #f 0.001)\n    (check-within (candidate \"iopaxpoi\") #t 0.001)\n    (check-within (candidate \"iopaxioi\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str) -> bool:\n    if (len(VAR_0) < 3):\n        return False\n    for VAR_1 in range((len(VAR_0) - 2)):\n        if ((VAR_0[VAR_1] == VAR_0[(VAR_1 + 1)]) or (VAR_0[(VAR_1 + 1)] == VAR_0[(VAR_1 + 2)]) or (VAR_0[VAR_1] == VAR_0[(VAR_1 + 2)])):\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value. \n\nThe first line imports the `List` module from the `typing` library. This is not used in the function and can be ignored.\n\nThe second line defines the function `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value. \n\nThe third line checks if the length of the input string `VAR_0` is less than 3. If it is, the function returns `False`.\n\nThe fourth line starts a `for` loop that iterates over the range of indices from 0 to the length of the input string minus 2. This is because the loop checks for three consecutive characters in the string, so there is no need to check the last two characters.\n\nThe fifth line checks if any of the three consecutive characters are equal. If they are, the function returns `False`.\n\nThe sixth line returns `True` if none of the three consecutive characters are equal. \n\nOverall, the function checks if the input string has three consecutive characters that are not equal. If it does, the function returns `True`. If it does not, the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 100 2) \"001\" 0.001)\n    (check-within (candidate 12 2) \"12\" 0.001)\n    (check-within (candidate 97 8) \"79\" 0.001)\n    (check-within (candidate 12 1) \"21\" 0.001)\n    (check-within (candidate 11 101) \"11\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> str:\n    VAR_2 = str(VAR_0)\n    if (VAR_1 > len(VAR_2)):\n        return VAR_2[::(- 1)]\n    else:\n        return (VAR_2[(len(VAR_2) - VAR_1):] + VAR_2[:(len(VAR_2) - VAR_1)])\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes two integer arguments `VAR_0` and `VAR_1` and returns a string. The function reverses the order of the digits of `VAR_0` if `VAR_1` is greater than the length of `VAR_0`. Otherwise, it shifts the digits of `VAR_0` to the left by `VAR_1` positions.\n\n1. `def FUNC_0(VAR_0: int, VAR_1: int) -> str:` - defines a function named `FUNC_0` that takes two integer arguments `VAR_0` and `VAR_1` and returns a string.\n2. `VAR_2 = str(VAR_0)` - converts the integer `VAR_0` to a string and assigns it to the variable `VAR_2`.\n3. `if (VAR_1 > len(VAR_2)):` - checks if the length of `VAR_2` is less than `VAR_1`.\n4. `return VAR_2[::(- 1)]` - if the length of `VAR_2` is less than `VAR_1`, returns `VAR_2` reversed.\n5. `else:` - if the length of `VAR_2` is greater than or equal to `VAR_1`, executes the following line.\n6. `return (VAR_2[(len(VAR_2) - VAR_1):] + VAR_2[:(len(VAR_2) - VAR_1)])` - returns `VAR_2` shifted to the left by `VAR_1` positions. The first part of the expression `VAR_2[(len(VAR_2) - VAR_1):]` selects the last `VAR_1` digits of `VAR_2`, and the second part of the expression `VAR_2[:(len(VAR_2) - VAR_1)]` selects the remaining digits of `VAR_2`. These two parts are concatenated using the `+` operator and returned.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nimport math\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[List[int]], VAR_1: int) -> int:\n    return sum([math.ceil((sum(VAR_2) / VAR_1)) for VAR_2 in VAR_0])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of lists of integers and an integer as input and returns an integer. The function calculates the number of hours required to complete a set of tasks, given that each task takes a fixed amount of time and can be completed by one person. The input list of lists represents the time required to complete each task, and the integer input represents the number of people available to complete the tasks.\n\nThe first line imports the math module, which provides mathematical functions.\n\nThe second line imports the List type from the typing module, which is used to specify the type of the input variables.\n\nThe third line defines a function named FUNC_0 that takes two arguments: VAR_0, which is a list of lists of integers, and VAR_1, which is an integer. The function returns an integer.\n\nThe fourth line uses the sum function to calculate the sum of the ceiling of the division of the sum of each list in VAR_0 by VAR_1. The ceiling function rounds up to the nearest integer. This is done using a list comprehension that iterates over each list in VAR_0.\n\nThe fifth line returns the sum of the list comprehension calculated in the previous line.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[float], VAR_1: float) -> bool:\n    for (VAR_2, VAR_3) in enumerate(VAR_0):\n        for (VAR_4, VAR_5) in enumerate(VAR_0):\n            if (VAR_2 != VAR_4):\n                VAR_6 = abs((VAR_3 - VAR_5))\n                if (VAR_6 < VAR_1):\n                    return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes in two arguments, a list of floats called VAR_0 and a float called VAR_1. The function returns a boolean value.\n\nThe first line of the code imports the List class from the typing module.\n\nThe second line defines the function FUNC_0 that takes in two arguments, VAR_0 and VAR_1, both of which are typed. VAR_0 is a list of floats and VAR_1 is a float. The function returns a boolean value.\n\nThe third line starts a for loop that iterates over the elements of VAR_0. The enumerate function is used to get the index and value of each element in VAR_0. The index is assigned to VAR_2 and the value is assigned to VAR_3.\n\nThe fourth line starts another for loop that iterates over the elements of VAR_0. The enumerate function is used again to get the index and value of each element in VAR_0. The index is assigned to VAR_4 and the value is assigned to VAR_5.\n\nThe fifth line checks if VAR_2 is not equal to VAR_4. If VAR_2 is equal to VAR_4, then the loop continues to the next iteration.\n\nThe sixth line calculates the absolute difference between VAR_3 and VAR_5 and assigns it to VAR_6.\n\nThe seventh line checks if VAR_6 is less than VAR_1. If VAR_6 is less than VAR_1, then the function returns True.\n\nThe eighth line returns False if the function has not yet returned True.\n\nIn summary, the function checks if there are any two elements in VAR_0 whose absolute difference is less than VAR_1. If such elements exist, the function returns True. Otherwise, the function returns False.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list \"A+\" \"B\" \"C-\" \"C\" \"A-\") 0.001)\n    (check-within (candidate (list 1.2)) (list \"D+\") 0.001)\n    (check-within (candidate (list 0.5)) (list \"D-\") 0.001)\n    (check-within (candidate (list 0.0)) (list \"E\") 0.001)\n    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list \"D\" \"D-\" \"C-\" \"B\" \"B+\") 0.001)\n    (check-within (candidate (list 0.0 0.7)) (list \"E\" \"D-\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[float]) -> List[str]:\n    VAR_1 = []\n    for VAR_2 in VAR_0:\n        if (VAR_2 == 4.0):\n            VAR_1.append('A+')\n        elif (VAR_2 > 3.7):\n            VAR_1.append('A')\n        elif (VAR_2 > 3.3):\n            VAR_1.append('A-')\n        elif (VAR_2 > 3.0):\n            VAR_1.append('B+')\n        elif (VAR_2 > 2.7):\n            VAR_1.append('B')\n        elif (VAR_2 > 2.3):\n            VAR_1.append('B-')\n        elif (VAR_2 > 2.0):\n            VAR_1.append('C+')\n        elif (VAR_2 > 1.7):\n            VAR_1.append('C')\n        elif (VAR_2 > 1.3):\n            VAR_1.append('C-')\n        elif (VAR_2 > 1.0):\n            VAR_1.append('D+')\n        elif (VAR_2 > 0.7):\n            VAR_1.append('D')\n        elif (VAR_2 > 0.0):\n            VAR_1.append('D-')\n        else:\n            VAR_1.append('E')\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of floating-point numbers and returns a list of strings that represent the letter grades corresponding to the input grades. The function is defined with the name FUNC_0 and takes in a single argument, VAR_0, which is a list of floating-point numbers. The function returns a list of strings, which is assigned to the variable VAR_1.\n\nThe function starts by initializing an empty list, VAR_1, which will be used to store the letter grades. \n\nThe function then iterates over each element in the input list VAR_0 using a for loop. The current element is assigned to the variable VAR_2.\n\nThe function then checks the value of VAR_2 against a series of conditions using if-elif statements. If VAR_2 is equal to 4.0, the string 'A+' is appended to VAR_1. If VAR_2 is greater than 3.7, the string 'A' is appended to VAR_1. If VAR_2 is greater than 3.3, the string 'A-' is appended to VAR_1. This pattern continues for each letter grade, with the appropriate string being appended to VAR_1 based on the value of VAR_2.\n\nFinally, the function returns the list VAR_1, which contains the letter grades corresponding to the input grades.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 7 34 12) 34 0.001)\n    (check-within (candidate 15 8 5) 5 0.001)\n    (check-within (candidate 3 33 5212) 33 0.001)\n    (check-within (candidate 1259 3 52) 3 0.001)\n    (check-within (candidate 7919 -1 12) -1 0.001)\n    (check-within (candidate 3609 1245 583) 583 0.001)\n    (check-within (candidate 91 56 129) 129 0.001)\n    (check-within (candidate 6 34 1234) 1234 0.001)\n    (check-within (candidate 1 2 0) 0 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int, VAR_2: int) -> int:\n    if (VAR_0 == 1):\n        return VAR_2\n    for VAR_3 in range(2, VAR_0):\n        if ((VAR_0 % VAR_3) == 0):\n            return VAR_2\n            break\n    else:\n        return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes in three integer arguments `VAR_0`, `VAR_1`, and `VAR_2`. The function returns an integer.\n\nThe first line of the function definition specifies the function name, `FUNC_0`, and the types of the arguments it takes in. The `-> int` specifies that the function returns an integer.\n\nThe next line checks if `VAR_0` is equal to 1. If it is, the function returns `VAR_2`.\n\nIf `VAR_0` is not equal to 1, the function enters a for loop that iterates over the range of integers from 2 to `VAR_0` (exclusive). \n\nWithin the for loop, the function checks if `VAR_0` is divisible by the current integer `VAR_3`. If it is, the function returns `VAR_2` and exits the loop using the `break` statement.\n\nIf the for loop completes without finding a divisor of `VAR_0`, the function returns `VAR_1`. The `else` statement is executed when the for loop completes without encountering a `break` statement. \n\nOverall, the function checks if `VAR_0` is a prime number. If it is, the function returns `VAR_1`. If it is not, the function returns `VAR_2`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)\n    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)\n    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)\n    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)\n    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    VAR_1 = 0\n    for VAR_2 in VAR_0:\n        if (VAR_2 > 10):\n            VAR_3 = (1, 3, 5, 7, 9)\n            VAR_4 = str(VAR_2)\n            if ((int(VAR_4[0]) in VAR_3) and (int(VAR_4[(- 1)]) in VAR_3)):\n                VAR_1 += 1\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the number of integers that are greater than 10 and whose first and last digits are odd numbers. \n\n1. `from typing import List` - Importing the List class from the typing module. This is used to specify the type of the input parameter of the function.\n\n2. `def FUNC_0(VAR_0: List[int]) -> int:` - Defining a function called FUNC_0 that takes a list of integers as input and returns an integer. \n\n3. `VAR_1 = 0` - Initializing a variable called VAR_1 to 0. This variable will be used to keep track of the count of integers that meet the criteria.\n\n4. `for VAR_2 in VAR_0:` - Looping through each integer in the input list.\n\n5. `if (VAR_2 > 10):` - Checking if the integer is greater than 10.\n\n6. `VAR_3 = (1, 3, 5, 7, 9)` - Initializing a tuple called VAR_3 with odd numbers.\n\n7. `VAR_4 = str(VAR_2)` - Converting the integer to a string and storing it in a variable called VAR_4.\n\n8. `if ((int(VAR_4[0]) in VAR_3) and (int(VAR_4[(- 1)]) in VAR_3)):` - Checking if the first and last digits of the integer are odd numbers.\n\n9. `VAR_1 += 1` - Incrementing the count of integers that meet the criteria.\n\n10. `return VAR_1` - Returning the count of integers that meet the criteria.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"o o o o\") (list 4 4 4 4) 0.001)\n    (check-within (candidate \".| .| .| .|\") (list 1 1 1 1) 0.001)\n    (check-within (candidate \"o| o| .| .| o o o o\") (list 2 2 1 1 4 4 4 4) 0.001)\n    (check-within (candidate \"o| .| o| .| o o| o o|\") (list 2 1 2 1 4 2 4 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str) -> List[int]:\n    VAR_1 = {'o': 4, 'o|': 2, '.|': 1}\n    return [VAR_1[VAR_2] for VAR_2 in VAR_0.split(' ') if VAR_2]\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a list of integers. \n\nThe function is defined with the name `FUNC_0` and takes a single argument `VAR_0` of type string. The function returns a list of integers.\n\nThe function first creates a dictionary `VAR_1` with keys as strings and values as integers. The keys are 'o', 'o|', and '.|' and the corresponding values are 4, 2, and 1 respectively.\n\nThe function then returns a list comprehension that iterates over the words in the input string `VAR_0` that are separated by spaces. For each word, it checks if it is not an empty string (i.e., `if VAR_2`). If the word is not empty, it looks up the value of the word in the dictionary `VAR_1` and appends it to the list that is being constructed.\n\nThe list comprehension is equivalent to the following code:\n\n```\nresult = []\nfor VAR_2 in VAR_0.split(' '):\n    if VAR_2:\n        result.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Hello world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello,world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello world,!\") (list \"Hello\" \"world,!\") 0.001)\n    (check-within (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\" \"!\") 0.001)\n    (check-within (candidate \"abcdef\") 3 0.001)\n    (check-within (candidate \"aaabb\") 2 0.001)\n    (check-within (candidate \"aaaBb\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Union\n\ndef FUNC_0(VAR_0: str) -> Union[(List[str], int)]:\n    if (' ' in VAR_0):\n        return VAR_0.split()\n    elif (',' in VAR_0):\n        return VAR_0.replace(',', ' ').split()\n    else:\n        return len([VAR_1 for VAR_1 in VAR_0 if (VAR_1.islower() and ((ord(VAR_1) % 2) == 0))])\n\n### Explanation\n\nThe code is an implementation of{{{TOFILL}}}\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abcde\") 5 0.001)\n    (check-within (candidate \"abcdecadeCADE\") 5 0.001)\n    (check-within (candidate \"aaaaAAAAaaaa\") 1 0.001)\n    (check-within (candidate \"Jerry jERRY JeRRRY\") 5 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    return len(set(VAR_0.lower()))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns an integer. The function returns the number of unique characters in the input string, ignoring case.\n\n- `def FUNC_0(VAR_0: str) -> int:` defines the function `FUNC_0` that takes a string `VAR_0` as input and returns an integer. The `-> int` indicates that the function returns an integer.\n- `return len(set(VAR_0.lower()))` returns the length of a set of unique characters in the input string, ignoring case. The `lower()` method is used to convert the input string to lowercase before creating the set of unique characters. The `len()` function is used to return the length of the set.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Jupiter\" \"Neptune\") (list \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Mercury\") (list \"Venus\") 0.001)\n    (check-within (candidate \"Mercury\" \"Uranus\") (list \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\") 0.001)\n    (check-within (candidate \"Neptune\" \"Venus\") (list \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Mars\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Jupiter\" \"Makemake\") (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef FUNC_0(VAR_0: str, VAR_1: str) -> Tuple[(str, ...)]:\n    VAR_2 = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n    if ((VAR_0 not in VAR_2) or (VAR_1 not in VAR_2) or (VAR_0 == VAR_1)):\n        return ()\n    VAR_3 = VAR_2.index(VAR_0)\n    VAR_4 = VAR_2.index(VAR_1)\n    if (VAR_3 < VAR_4):\n        return VAR_2[(VAR_3 + 1):VAR_4]\n    else:\n        return VAR_2[(VAR_4 + 1):VAR_3]\n\n### Explanation\n\nThe code is an implementation of a function that takes two planet names as input and returns a tuple of the names of the planets that lie between them in the solar system. The function is defined with the name `FUNC_0` and takes two arguments, `VAR_0` and `VAR_1`, both of which are strings. The function returns a tuple of strings.\n\nThe first line of the code imports the `Tuple` class from the `typing` module. This is used to specify the return type of the function.\n\nThe second line defines the function `FUNC_0` with the arguments `VAR_0` and `VAR_1`. The `-> Tuple[(str, ...)]` specifies that the function returns a tuple of strings.\n\nThe third line defines a tuple `VAR_2` containing the names of the planets in the solar system.\n\nThe fourth line checks if either of the input planet names are not in the tuple `VAR_2` or if they are the same. If either of these conditions are true, the function returns an empty tuple.\n\nThe fifth line finds the index of the first planet name in the tuple `VAR_2` and assigns it to the variable `VAR_3`.\n\nThe sixth line finds the index of the second planet name in the tuple `VAR_2` and assigns it to the variable `VAR_4`.\n\nThe seventh line checks if the index of the first planet is less than the index of the second planet. If this is true, it returns a slice of the tuple `VAR_2` containing the planets between the two input planets. If this is false, it returns a slice of the tuple `VAR_2` containing the planets between the two input planets in reverse order.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abAB\") 131 0.001)\n    (check-within (candidate \"abcCd\") 67 0.001)\n    (check-within (candidate \"helloE\") 69 0.001)\n    (check-within (candidate \"woArBld\") 131 0.001)\n    (check-within (candidate \"aAaaaXa\") 153 0.001)\n    (check-within (candidate \" How are yOu?\") 151 0.001)\n    (check-within (candidate \"You arE Very Smart\") 327 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    if (VAR_0 == ''):\n        return 0\n    return sum(((ord(VAR_1) if VAR_1.isupper() else 0) for VAR_1 in VAR_0))\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a string as input and returns an integer. \n\n```python\ndef FUNC_0(VAR_0: str) -> int:\n```\nThe function definition starts with the `def` keyword, followed by the function name `FUNC_0`. The function takes one argument, `VAR_0`, which is a string. The `-> int` part of the function definition specifies that the function returns an integer.\n\n```python\nif (VAR_0 == ''):\n    return 0\n```\nThe first line of the function checks if the input string is empty. If it is, the function returns 0.\n\n```python\nreturn sum(((ord(VAR_1) if VAR_1.isupper() else 0) for VAR_1 in VAR_0))\n```\nThe second line of the function calculates the sum of the ASCII values of all uppercase letters in the input string. \n\nThe `sum()` function takes an iterable (in this case, a generator expression) and returns the sum of all the elements in the iterable.\n\nThe generator expression `((ord(VAR_1) if VAR_1.isupper() else 0) for VAR_1 in VAR_0)` generates a sequence of values, where each value is either the ASCII value of an uppercase letter in the input string, or 0 if the character is not uppercase.\n\nThe `ord()` function returns the ASCII value of a character. The `isupper()` method returns `True` if a character is uppercase, and `False` otherwise.\n\nIn summary, the function takes a string as input, and returns the sum of the ASCII values of all uppercase letters in the string. If the input string is empty, the function returns 0.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 1 4 9)) 14 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) 9 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1)) -3 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list -1 -5 2 -1 -5)) -126 0.001)\n    (check-within (candidate (list -56 -99 1 0 -2)) 3030 0.001)\n    (check-within (candidate (list -1 0 0 0 0 0 0 0 -1)) 0 0.001)\n    (check-within (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37)) -14196 0.001)\n    (check-within (candidate (list -1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10)) -1448 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    VAR_1 = []\n    for VAR_2 in range(len(VAR_0)):\n        if ((VAR_2 % 3) == 0):\n            VAR_1.append((VAR_0[VAR_2] ** 2))\n        elif (((VAR_2 % 4) == 0) and ((VAR_2 % 3) != 0)):\n            VAR_1.append((VAR_0[VAR_2] ** 3))\n        else:\n            VAR_1.append(VAR_0[VAR_2])\n    return sum(VAR_1)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns the sum of the list after applying a certain transformation to each element. \n\nThe function is defined with the name `FUNC_0` and takes a single argument `VAR_0` which is a list of integers. The function returns a single integer.\n\nThe first line of the function creates an empty list `VAR_1` which will be used to store the transformed elements.\n\nThe next line starts a loop that iterates over the indices of the input list `VAR_0`. The `range()` function is used to generate a sequence of integers from 0 to the length of `VAR_0` minus 1. The `for` loop assigns each integer in the sequence to the variable `VAR_2`.\n\nThe next line checks if the current index `VAR_2` is divisible by 3 using the modulo operator `%`. If the result is 0, then the current element is squared and the result is appended to the `VAR_1` list using the `append()` method. \n\nThe `elif` statement checks if the current index is divisible by 4 and not divisible by 3. If this condition is true, then the current element is cubed and the result is appended to the `VAR_1` list.\n\nIf neither of the above conditions are true, then the current element is simply appended to the `VAR_1` list.\n\nFinally, the function returns the sum of the elements in `VAR_1` using the `sum()` function. \n\nIn summary, the function applies a different transformation to each element of the input list depending on its index, and returns the sum of the transformed elements.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5) (list 2 3) 0.001)\n    (check-within (candidate 6) (list 2 3 5) 0.001)\n    (check-within (candidate 7) (list 2 3 5) 0.001)\n    (check-within (candidate 10) (list 2 3 5 7) 0.001)\n    (check-within (candidate 0) (list ) 0.001)\n    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)\n    (check-within (candidate 1) (list ) 0.001)\n    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)\n    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)\n    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int) -> List[int]:\n    VAR_1 = []\n    for VAR_2 in range(2, VAR_0):\n        VAR_3 = True\n        for VAR_4 in range(2, VAR_2):\n            if ((VAR_2 % VAR_4) == 0):\n                VAR_3 = False\n                break\n        if VAR_3:\n            VAR_1.append(VAR_2)\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of the Sieve of Eratosthenes algorithm, which finds all prime numbers up to a given limit. \n\nThe first line imports the List class from the typing module. This is used to specify the return type of the function.\n\nThe second line defines a function called FUNC_0, which takes an integer argument VAR_0 and returns a list of integers.\n\nThe third line initializes an empty list called VAR_1.\n\nThe fourth line starts a for loop that iterates over the range of integers from 2 to VAR_0 - 1. This range represents all possible prime numbers up to the limit VAR_0.\n\nThe fifth line initializes a boolean variable VAR_3 to True. This variable will be used to keep track of whether the current number VAR_2 is prime or not.\n\nThe sixth line starts another for loop that iterates over the range of integers from 2 to VAR_2 - 1. This range represents all possible divisors of VAR_2.\n\nThe seventh line checks if VAR_2 is divisible by VAR_4. If it is, then VAR_2 is not prime, so VAR_3 is set to False and the inner loop is broken.\n\nThe eighth line checks if VAR_3 is still True. If it is, then VAR_2 is prime, so it is added to the list VAR_1.\n\nThe ninth line returns the list VAR_1 containing all prime numbers up to the limit VAR_0.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)\n    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)\n    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)\n    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)\n    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)\n    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)\n    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)\n    (check-within (candidate (list 0.0)) 0 0.001)\n    (check-within (candidate (list -1.0)) 1 0.001)\n    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[float]) -> int:\n    import math\n    VAR_1 = 0\n    for VAR_2 in VAR_0:\n        VAR_1 += (math.ceil(VAR_2) ** 2)\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 which takes in a list of floating point numbers and returns an integer. \n\nThe first line of the code imports the math module which provides access to the mathematical functions defined by the C standard.\n\nThe second line defines a variable VAR_1 and initializes it to 0.\n\nThe third line starts a for loop that iterates through each element in the input list VAR_0.\n\nThe fourth line increments VAR_1 by the square of the ceiling of the current element VAR_2. The ceiling of a number is the smallest integer greater than or equal to that number. \n\nThe fifth line returns VAR_1 which is the sum of the squares of the ceiling of each element in the input list.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    return sorted(list(set(VAR_0)))\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a sorted list of unique integers. \n\n1. `from typing import List` - import the List class from the typing module\n2. `def FUNC_0(VAR_0: List[int]) -> List[int]:` - define a function named `FUNC_0` that takes a list of integers as an argument and returns a list of integers. \n3. `return sorted(list(set(VAR_0)))` - return a sorted list of unique integers. \n\nThe function works by first converting the input list into a set, which removes duplicates. The set is then converted back into a list and sorted. The sorted list is then returned.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 10) 55 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 8) 21 0.001)\n    (check-within (candidate 11) 89 0.001)\n    (check-within (candidate 12) 144 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    if (VAR_0 == 0):\n        return 0\n    if (VAR_0 == 1):\n        return 1\n    return (FUNC_0((VAR_0 - 1)) + FUNC_0((VAR_0 - 2)))\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding numbers. The sequence starts with 0 and 1, and the next number in the sequence is the sum of the previous two numbers. \n\nThe function `FUNC_0` takes an integer `VAR_0` as input and returns an integer. \n\nThe first line of the function definition specifies the input type and the output type. The input type is an integer and the output type is also an integer. \n\nThe next line checks if `VAR_0` is equal to 0. If it is, the function returns 0. \n\nThe next line checks if `VAR_0` is equal to 1. If it is, the function returns 1. \n\nIf `VAR_0` is neither 0 nor 1, the function returns the sum of the two preceding numbers in the sequence. This is done by calling the function recursively with `VAR_0 - 1` and `VAR_0 - 2` as inputs, and adding the results of those function calls. \n\nIn summary, the function `FUNC_0` takes an integer `VAR_0` as input and returns the `VAR_0`th number in the Fibonacci sequence. If `VAR_0` is 0, the function returns 0. If `VAR_0` is 1, the function returns 1. Otherwise, the function returns the sum of the two preceding numbers in the sequence.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 50) 0 0.001)\n    (check-within (candidate 78) 2 0.001)\n    (check-within (candidate 79) 3 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 200) 6 0.001)\n    (check-within (candidate 4000) 192 0.001)\n    (check-within (candidate 10000) 639 0.001)\n    (check-within (candidate 100000) 8026 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    VAR_1 = []\n    for VAR_2 in range(VAR_0):\n        if (((VAR_2 % 11) == 0) or ((VAR_2 % 13) == 0)):\n            VAR_1.append(VAR_2)\n    VAR_3 = ''.join(list(map(str, VAR_1)))\n    VAR_4 = 0\n    for VAR_5 in VAR_3:\n        VAR_4 += (VAR_5 == '7')\n    return VAR_4\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes an integer argument `VAR_0` and returns an integer. \n\nThe function first initializes an empty list `VAR_1` to store the numbers that are divisible by 11 or 13. \n\nIt then loops through all the numbers from 0 to `VAR_0` (exclusive) using the `range` function. \n\nFor each number `VAR_2` in the range, it checks if it is divisible by 11 or 13 using the modulo operator `%`. If the remainder of the division is 0, it means the number is divisible by 11 or 13, so it is added to the list `VAR_1` using the `append` method.\n\nThe list `VAR_1` is then converted to a string `VAR_3` using the `join` method. The `map` function is used to convert each number in `VAR_1` to a string using the `str` function before joining them together with an empty string as the separator.\n\nThe function then initializes a variable `VAR_4` to 0 and loops through each character `VAR_5` in the string `VAR_3`. \n\nFor each character, it checks if it is equal to the string '7' using the `==` operator. If it is, it increments the variable `VAR_4` by 1.\n\nFinally, the function returns the value of `VAR_4`, which represents the number of times the digit 7 appears in the string `VAR_3`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\")) \"Watashi.eIGHt8OKe\" 0.001)\n    (check-within (candidate \"Boku123\" (list \"nani\" \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\" 0.001)\n    (check-within (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\" \"123NoooneB321\")) \"__YESIMHERE.NuLl__\" 0.001)\n    (check-within (candidate \"K\" (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\" 0.001)\n    (check-within (candidate \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\" 0.001)\n    (check-within (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"-_-\")) \"YameRore.okIWILL123\" 0.001)\n    (check-within (candidate \"finNNalLLly\" (list \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\" 0.001)\n    (check-within (candidate \"_\" (list \"Bb\" \"91245\")) \"_.Bb\" 0.001)\n    (check-within (candidate \"Sp\" (list \"671235\" \"Bb\")) \"Sp.671235\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str, VAR_1: List[str]) -> str:\n    VAR_2 = VAR_1[0]\n    VAR_3 = (len([VAR_4 for VAR_4 in VAR_1[0] if (VAR_4.isalpha() and VAR_4.isupper())]) - len([VAR_4 for VAR_4 in VAR_1[0] if (VAR_4.isalpha() and VAR_4.islower())]))\n    for VAR_5 in VAR_1:\n        VAR_6 = (len([VAR_4 for VAR_4 in VAR_5 if (VAR_4.isalpha() and VAR_4.isupper())]) - len([VAR_4 for VAR_4 in VAR_5 if (VAR_4.isalpha() and VAR_4.islower())]))\n        if (VAR_6 > VAR_3):\n            VAR_2 = VAR_5\n            VAR_3 = VAR_6\n    VAR_7 = ((VAR_0 + '.') + VAR_2)\n    return VAR_7\n\n### Explanation\n\nThe code is an implementation of a function that takes in a string and a list of strings, and returns a new string that is the concatenation of the first argument and the string in the list that has the highest difference between the number of uppercase and lowercase letters. \n\n- `from typing import List`: import the List class from the typing module.\n\n- `def FUNC_0(VAR_0: str, VAR_1: List[str]) -> str:`: define a function named `FUNC_0` that takes in two arguments, a string `VAR_0` and a list of strings `VAR_1`, and returns a string. \n\n- `VAR_2 = VAR_1[0]`: set `VAR_2` to the first string in the list.\n\n- `VAR_3 = (len([VAR_4 for VAR_4 in VAR_1[0] if (VAR_4.isalpha() and VAR_4.isupper())]) - len([VAR_4 for VAR_4 in VAR_1[0] if (VAR_4.isalpha() and VAR_4.islower())]))`: set `VAR_3` to the difference between the number of uppercase and lowercase letters in the first string in the list.\n\n- `for VAR_5 in VAR_1:`: loop through each string in the list.\n\n- `VAR_6 = (len([VAR_4 for VAR_4 in VAR_5 if (VAR_4.isalpha() and VAR_4.isupper())]) - len([VAR_4 for VAR_4 in VAR_5 if (VAR_4.isalpha() and VAR_4.islower())]))`: set `VAR_6` to the difference between the number of uppercase and lowercase letters in the current string.\n\n- `if (VAR_6 > VAR_3):`: if the difference in the current string is greater than the difference in the previous string:\n\n- `VAR_2 = VAR_5`: set `VAR_2` to the current string.\n\n- `VAR_3 = VAR_6`: set `VAR_3` to the difference in the current string.\n\n- `VAR_7 = ((VAR_0 + '.') + VAR_2)`: concatenate the first argument, a period, and the string with the highest difference in uppercase and lowercase letters.\n\n- `return VAR_7`: return the concatenated string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\ndef FUNC_0(VAR_0: List[float]) -> Tuple[(float, float)]:\n    VAR_1 = None\n    VAR_2 = None\n    for (VAR_3, VAR_4) in enumerate(VAR_0):\n        for (VAR_5, VAR_6) in enumerate(VAR_0):\n            if (VAR_3 != VAR_5):\n                if (VAR_2 is None):\n                    VAR_2 = abs((VAR_4 - VAR_6))\n                    VAR_1 = tuple(sorted([VAR_4, VAR_6]))\n                else:\n                    VAR_7 = abs((VAR_4 - VAR_6))\n                    if (VAR_7 < VAR_2):\n                        VAR_2 = VAR_7\n                        VAR_1 = tuple(sorted([VAR_4, VAR_6]))\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of floating point numbers as input and returns a tuple of two floating point numbers. The function is defined using Python's type hinting syntax to indicate that it takes a list of floats as input and returns a tuple of two floats.\n\nThe function first initializes two variables `VAR_1` and `VAR_2` to `None`. It then iterates over each element in the input list using the `enumerate` function to get both the index and value of each element. It then iterates over each element in the input list again, using another `enumerate` function to get both the index and value of each element.\n\nIf the index of the first element is not equal to the index of the second element, the function calculates the absolute difference between the two values using the `abs` function. If `VAR_2` is `None`, it sets `VAR_2` to the absolute difference and `VAR_1` to a tuple of the two values sorted in ascending order. If `VAR_2` is not `None`, it compares the absolute difference to `VAR_2`. If the absolute difference is less than `VAR_2`, it updates `VAR_2` to the new absolute difference and `VAR_1` to a tuple of the two values sorted in ascending order.\n\nFinally, the function returns `VAR_1`, which is the tuple of two values with the smallest absolute difference. If there are multiple pairs of values with the same smallest absolute difference, the function returns the pair with the smallest value first.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"03-11-2000\") #t 0.001)\n    (check-within (candidate \"15-01-2012\") #f 0.001)\n    (check-within (candidate \"04-0-2040\") #f 0.001)\n    (check-within (candidate \"06-04-2020\") #t 0.001)\n    (check-within (candidate \"01-01-2007\") #t 0.001)\n    (check-within (candidate \"03-32-2011\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"04-31-3000\") #f 0.001)\n    (check-within (candidate \"06-06-2005\") #t 0.001)\n    (check-within (candidate \"21-31-2000\") #f 0.001)\n    (check-within (candidate \"04-12-2003\") #t 0.001)\n    (check-within (candidate \"04122003\") #f 0.001)\n    (check-within (candidate \"20030412\") #f 0.001)\n    (check-within (candidate \"2003-04\") #f 0.001)\n    (check-within (candidate \"2003-04-12\") #f 0.001)\n    (check-within (candidate \"04-2003\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> bool:\n    try:\n        VAR_0 = VAR_0.strip()\n        (VAR_1, VAR_2, VAR_3) = VAR_0.split('-')\n        (VAR_1, VAR_2, VAR_3) = (int(VAR_1), int(VAR_2), int(VAR_3))\n        if ((VAR_1 < 1) or (VAR_1 > 12)):\n            return False\n        if (((VAR_1 in [1, 3, 5, 7, 8, 10, 12]) and (VAR_2 < 1)) or (VAR_2 > 31)):\n            return False\n        if (((VAR_1 in [4, 6, 9, 11]) and (VAR_2 < 1)) or (VAR_2 > 30)):\n            return False\n        if (((VAR_1 == 2) and (VAR_2 < 1)) or (VAR_2 > 29)):\n            return False\n    except:\n        return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes a string as an argument and returns a boolean value. \n\nThe function first tries to execute the code inside the try block. If there is an error, it returns False. If there is no error, it returns True.\n\nInside the try block, the function first strips the input string of any leading or trailing white spaces.\n\nIt then splits the input string into three parts using the '-' character as a separator. The three parts are assigned to three variables VAR_1, VAR_2, and VAR_3.\n\nThe three variables are then converted to integers using the int() function.\n\nThe function then checks if VAR_1 is between 1 and 12 (inclusive). If VAR_1 is not between 1 and 12, the function returns False.\n\nThe function then checks if VAR_2 is a valid day for the month specified by VAR_1. If VAR_1 is one of the months with 31 days, VAR_2 must be between 1 and 31. If VAR_1 is one of the months with 30 days, VAR_2 must be between 1 and 30. If VAR_1 is February, VAR_2 must be between 1 and 29 if it is a leap year, and between 1 and 28 if it is not a leap year. If VAR_2 is not a valid day for the month specified by VAR_1, the function returns False.\n\nIf all the checks pass, the function returns True.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 0 1) 1 0.001)\n    (check-within (candidate 1 0) 1 0.001)\n    (check-within (candidate 2 3) 5 0.001)\n    (check-within (candidate 5 7) 12 0.001)\n    (check-within (candidate 7 5) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> int:\n    return (VAR_0 + VAR_1)\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns their sum. \n\n- `def FUNC_0(VAR_0: int, VAR_1: int) -> int:` defines a function named `FUNC_0` that takes two integer arguments `VAR_0` and `VAR_1` and returns an integer. \n- `return (VAR_0 + VAR_1)` returns the sum of `VAR_0` and `VAR_1`. \n\nTherefore, the function returns the sum of two integers.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -1)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 1 2 5 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 9 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -100)) #f 0.001)\n    (check-within (candidate (list 100 3 5 -100)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> bool:\n    for VAR_1 in range(len(VAR_0)):\n        for VAR_2 in range((VAR_1 + 1), len(VAR_0)):\n            for VAR_3 in range((VAR_2 + 1), len(VAR_0)):\n                if (((VAR_0[VAR_1] + VAR_0[VAR_2]) + VAR_0[VAR_3]) == 0):\n                    return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a boolean value. The function checks if there are three integers in the list whose sum is equal to zero. \n\nThe first line of the code imports the List class from the typing module. This is used to specify the type of the input parameter of the function.\n\nThe second line defines the function named FUNC_0 which takes a list of integers as input and returns a boolean value. \n\nThe third line starts a for loop that iterates over the indices of the input list. The loop variable VAR_1 is used to store the current index. \n\nThe fourth line starts another for loop that iterates over the indices of the input list starting from the next index after VAR_1. The loop variable VAR_2 is used to store the current index. \n\nThe fifth line starts another for loop that iterates over the indices of the input list starting from the next index after VAR_2. The loop variable VAR_3 is used to store the current index. \n\nThe sixth line checks if the sum of the integers at the indices VAR_1, VAR_2, and VAR_3 is equal to zero. If it is, the function returns True. \n\nThe seventh line returns False if the function has not returned True in the previous loop. \n\nOverall, the function checks all possible combinations of three integers in the input list and returns True if there is a combination whose sum is zero. Otherwise, it returns False.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 10) 5 0.001)\n    (check-within (candidate 100) 50 0.001)\n    (check-within (candidate 49) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    for VAR_1 in reversed(range(VAR_0)):\n        if ((VAR_0 % VAR_1) == 0):\n            return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns the largest integer that is a factor of the input integer. \n\n```python\ndef FUNC_0(VAR_0: int) -> int:\n```\nThe function is defined with the name `FUNC_0` and takes an integer input `VAR_0`. It returns an integer.\n\n```python\nfor VAR_1 in reversed(range(VAR_0)):\n```\nThe `for` loop iterates over a range of integers from `VAR_0-1` to `0` in reverse order. The loop variable is `VAR_1`.\n\n```python\nif ((VAR_0 % VAR_1) == 0):\n```\nThe `if` statement checks if `VAR_0` is divisible by `VAR_1` with no remainder. If it is, the code inside the `if` block is executed.\n\n```python\nreturn VAR_1\n```\nThe function returns the value of `VAR_1` if it is divisible by `VAR_0` with no remainder. This is the largest factor of `VAR_0`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"three\") \"three\" 0.001)\n    (check-within (candidate \"three five nine\") \"three five nine\" 0.001)\n    (check-within (candidate \"five zero four seven nine eight\") \"zero four five seven eight nine\" 0.001)\n    (check-within (candidate \"six five four three two one zero\") \"zero one two three four five six\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str) -> str:\n    VAR_1 = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    return ' '.join(sorted([VAR_2 for VAR_2 in VAR_0.split(' ') if VAR_2], key=(lambda VAR_2: VAR_1[VAR_2])))\n\n### Explanation\n\nThe code is an implementation of a function `FUNC_0` that takes a string as input and returns a string. The function sorts the input string based on the numerical value of the words in the string. \n\nThe first line imports the `List` type from the `typing` module. This is not used in the function.\n\nThe second line defines the function `FUNC_0` which takes a string `VAR_0` as input and returns a string. \n\nThe third line defines a dictionary `VAR_1` that maps the string representation of numbers to their numerical values. \n\nThe fourth line splits the input string `VAR_0` into a list of words, removes any empty strings, sorts the list based on the numerical value of the words, and then joins the sorted list back into a string separated by spaces. \n\nThe `sorted` function takes an iterable as input and returns a new sorted list. The `key` parameter is a function that takes an element of the iterable as input and returns a value that is used to sort the list. In this case, the `key` function is a lambda function that looks up the numerical value of the word in the `VAR_1` dictionary. \n\nThe `join` function takes an iterable as input and returns a string that is the concatenation of the elements of the iterable separated by the string that `join` is called on. In this case, the iterable is the sorted list of words and the separator is a space. \n\nOverall, the function sorts the input string based on the numerical value of the words in the string.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3 5 4 7 9 6)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 3 2 2)) 1 0.001)\n    (check-within (candidate (list 1 4 2)) 1 0.001)\n    (check-within (candidate (list 1 4 4 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 3 1 1 3)) 0 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    VAR_1 = 0\n    for VAR_2 in range((len(VAR_0) // 2)):\n        if (VAR_0[VAR_2] != VAR_0[((len(VAR_0) - VAR_2) - 1)]):\n            VAR_1 += 1\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the number of times the first half of the list does not match the second half of the list. \n\n1. `from typing import List` - Importing the List class from the typing module. This is used to specify the type of the input parameter to the function.\n\n2. `def FUNC_0(VAR_0: List[int]) -> int:` - Defining a function called FUNC_0 that takes a list of integers as input and returns an integer. The function name and parameter name are arbitrary and can be changed.\n\n3. `VAR_1 = 0` - Initializing a variable called VAR_1 to 0. This variable will be used to keep track of the number of times the first half of the list does not match the second half of the list.\n\n4. `for VAR_2 in range((len(VAR_0) // 2)):` - Starting a for loop that iterates over the first half of the input list. The loop iterates from 0 to half the length of the list, rounded down to the nearest integer.\n\n5. `if (VAR_0[VAR_2] != VAR_0[((len(VAR_0) - VAR_2) - 1)]):` - Checking if the current element in the first half of the list does not match the corresponding element in the second half of the list. The corresponding element is found by subtracting the current index from the length of the list and subtracting 1.\n\n6. `VAR_1 += 1` - If the elements do not match, increment the VAR_1 variable by 1.\n\n7. `return VAR_1` - Return the number of times the first half of the list does not match the second half of the list. This will be an integer.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)\n    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> bool:\n    for VAR_2 in VAR_0:\n        if (VAR_2 >= VAR_1):\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes two arguments, a list of integers `VAR_0` and an integer `VAR_1`, and returns a boolean value. \n\nThe first line of the code imports the `List` type from the `typing` module. This is used to specify the type of the `VAR_0` argument. \n\nThe second line defines the function `FUNC_0` that takes two arguments, `VAR_0` and `VAR_1`, and returns a boolean value. \n\nThe third line starts a `for` loop that iterates over each element in the `VAR_0` list. \n\nThe fourth line checks if the current element `VAR_2` is greater than or equal to the `VAR_1` argument. If it is, the function returns `False`.\n\nThe fifth line returns `True` if the loop completes without finding any elements in `VAR_0` that are greater than or equal to `VAR_1`. \n\nIn summary, the function checks if any element in the `VAR_0` list is greater than or equal to the `VAR_1` argument. If it finds such an element, it returns `False`. If it doesn't find any such element, it returns `True`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 2 -4)) -9 0.001)\n    (check-within (candidate (list 0 1)) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 3 -1 1)) -10 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 2 4 1 2 -1 -1 9)) 20 0.001)\n    (check-within (candidate (list -1 1 -1 1)) 4 0.001)\n    (check-within (candidate (list -1 1 1 1)) -4 0.001)\n    (check-within (candidate (list -1 1 1 0)) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef FUNC_0(VAR_0: List[int]) -> Optional[int]:\n    if (not VAR_0):\n        return None\n    VAR_1 = (0 if (0 in VAR_0) else ((- 1) ** len(list(filter((lambda VAR_2: (VAR_2 < 0)), VAR_0)))))\n    return (VAR_1 * sum([abs(VAR_3) for VAR_3 in VAR_0]))\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns an integer. The function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of integers. The function returns an integer or None if the input list is empty.\n\nThe first line of the code imports two types from the typing module, List and Optional. List is used to specify that the input argument is a list of integers, while Optional is used to specify that the output of the function can be either an integer or None.\n\nThe second line of the code defines the function with the name FUNC_0 and takes a single argument VAR_0, which is a list of integers. The function returns an integer or None if the input list is empty.\n\nThe third line of the code checks if the input list is empty. If the input list is empty, the function returns None.\n\nThe fourth line of the code initializes a variable VAR_1 to 0 if 0 is in the input list, otherwise it is initialized to (-1) raised to the power of the number of negative integers in the input list.\n\nThe fifth line of the code returns the product of VAR_1 and the sum of the absolute values of the integers in the input list. The sum is calculated using a list comprehension that iterates over the input list and calculates the absolute value of each integer. The product is calculated by multiplying VAR_1 and the sum of the absolute values of the integers in the input list.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3 5) 3 0.001)\n    (check-within (candidate 1101 101) 2 0.001)\n    (check-within (candidate 0 101) 1 0.001)\n    (check-within (candidate 3 11) 8 0.001)\n    (check-within (candidate 100 101) 1 0.001)\n    (check-within (candidate 30 5) 4 0.001)\n    (check-within (candidate 31 5) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> int:\n    VAR_2 = 1\n    for VAR_3 in range(VAR_0):\n        VAR_2 = ((2 * VAR_2) % VAR_1)\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns an integer. The function is called FUNC_0 and takes two arguments, VAR_0 and VAR_1. \n\nThe first line of the function initializes a variable VAR_2 to 1. \n\nThe second line of the function starts a for loop that iterates VAR_0 times. The range function generates a sequence of numbers from 0 to VAR_0 - 1. The loop variable VAR_3 takes on each value in the sequence. \n\nThe third line of the function updates VAR_2 by taking the result of 2 times VAR_2 modulo VAR_1. The modulo operator returns the remainder of the division of the left operand by the right operand. \n\nThe final line of the function returns VAR_2. \n\nThe function computes the result of raising 2 to the power of VAR_0 and then taking the result modulo VAR_1. This is a common operation in cryptography and is used to generate keys for encryption and decryption.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"aBCdEf\") 1 0.001)\n    (check-within (candidate \"abcdefg\") 0 0.001)\n    (check-within (candidate \"dBBE\") 0 0.001)\n    (check-within (candidate \"B\") 0 0.001)\n    (check-within (candidate \"U\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"EEEE\") 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    VAR_1 = 0\n    for VAR_2 in range(0, len(VAR_0), 2):\n        if (VAR_0[VAR_2] in 'AEIOU'):\n            VAR_1 += 1\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns the number of vowels in the string. \n\n- `def FUNC_0(VAR_0: str) -> int:` defines a function named `FUNC_0` that takes a string `VAR_0` as input and returns an integer. \n\n- `VAR_1 = 0` initializes a variable `VAR_1` to 0.\n\n- `for VAR_2 in range(0, len(VAR_0), 2):` iterates over the string `VAR_0` starting from the first character (index 0) and incrementing by 2 each time until the end of the string. \n\n- `if (VAR_0[VAR_2] in 'AEIOU'):` checks if the character at the current index `VAR_2` is a vowel. If it is, then the next line is executed.\n\n- `VAR_1 += 1` increments the variable `VAR_1` by 1 if the current character is a vowel.\n\n- `return VAR_1` returns the final value of `VAR_1`, which is the number of vowels in the input string.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 148 412) 16 0.001)\n    (check-within (candidate 19 28) 72 0.001)\n    (check-within (candidate 2020 1851) 0 0.001)\n    (check-within (candidate 14 -15) 20 0.001)\n    (check-within (candidate 76 67) 42 0.001)\n    (check-within (candidate 17 27) 49 0.001)\n    (check-within (candidate 0 1) 0 0.001)\n    (check-within (candidate 0 0) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> int:\n    return (abs((VAR_0 % 10)) * abs((VAR_1 % 10)))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two integer arguments `VAR_0` and `VAR_1` and returns an integer. \n\nThe function returns the product of the absolute values of the last digits of the two arguments. \n\nThe `abs()` function is used to get the absolute value of the last digit of each argument. The `%` operator is used to get the last digit of each argument by taking the remainder of the argument divided by 10. \n\nThe `return` statement is used to return the product of the two absolute values. \n\nOverall, the function calculates the product of the absolute values of the last digits of two integers.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 15 33 1422 1)) (list 1 15 33) 0.001)\n    (check-within (candidate (list 152 323 1422 10)) (list ) 0.001)\n    (check-within (candidate (list 12345 2033 111 151)) (list 111 151) 0.001)\n    (check-within (candidate (list 135 103 31)) (list 31 135) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    VAR_1 = []\n    for VAR_2 in VAR_0:\n        if all((((int(VAR_3) % 2) == 1) for VAR_3 in str(VAR_2))):\n            VAR_1.append(VAR_2)\n    return sorted(VAR_1)\n\n### Explanation\n\nThe code is an implementation of a function `FUNC_0` that takes in a list of integers `VAR_0` and returns a sorted list of integers `VAR_1` that contains only the odd digits of the integers in `VAR_0`. \n\n1. `from typing import List` - import the List class from the typing module\n2. `def FUNC_0(VAR_0: List[int]) -> List[int]:` - define a function `FUNC_0` that takes in a list of integers `VAR_0` and returns a list of integers. The function signature specifies that both the input and output lists are of type `int`.\n3. `VAR_1 = []` - initialize an empty list `VAR_1` that will be used to store the odd digit integers\n4. `for VAR_2 in VAR_0:` - loop through each integer `VAR_2` in the input list `VAR_0`\n5. `if all((((int(VAR_3) % 2) == 1) for VAR_3 in str(VAR_2))):` - check if all the digits in the integer `VAR_2` are odd. This is done by converting the integer to a string, looping through each character in the string, converting it back to an integer, taking the modulo 2, and checking if the result is equal to 1 (odd). The `all` function returns `True` if all the elements in the iterable are `True`.\n6. `VAR_1.append(VAR_2)` - if all the digits in the integer `VAR_2` are odd, append it to the `VAR_1` list\n7. `return sorted(VAR_1)` - return the sorted list of odd digit integers `VAR_1`\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 3 2 3) 9) #t 0.001)\n    (check-within (candidate (list 1 2) 5) #f 0.001)\n    (check-within (candidate (list 3) 5) #t 0.001)\n    (check-within (candidate (list 3 2 3) 1) #f 0.001)\n    (check-within (candidate (list 1 2 3) 6) #f 0.001)\n    (check-within (candidate (list 5) 5) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> bool:\n    if (sum(VAR_0) > VAR_1):\n        return False\n    (VAR_2, VAR_3) = (0, (len(VAR_0) - 1))\n    while (VAR_2 < VAR_3):\n        if (VAR_0[VAR_2] != VAR_0[VAR_3]):\n            return False\n        VAR_2 += 1\n        VAR_3 -= 1\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a list of integers is a palindrome and if the sum of the integers in the list is less than or equal to a given integer. \n\n* `from typing import List`: Importing the List class from the typing module.\n\n* `def FUNC_0(VAR_0: List[int], VAR_1: int) -> bool:`: Defining a function called FUNC_0 that takes two arguments, VAR_0 (a list of integers) and VAR_1 (an integer) and returns a boolean value.\n\n* `if (sum(VAR_0) > VAR_1):`: If the sum of the integers in VAR_0 is greater than VAR_1, return False.\n\n* `(VAR_2, VAR_3) = (0, (len(VAR_0) - 1))`: Assigning the values 0 and the length of VAR_0 minus 1 to VAR_2 and VAR_3 respectively.\n\n* `while (VAR_2 < VAR_3):`: While VAR_2 is less than VAR_3, do the following:\n\n* `if (VAR_0[VAR_2] != VAR_0[VAR_3]):`: If the element at index VAR_2 in VAR_0 is not equal to the element at index VAR_3 in VAR_0, return False.\n\n* `VAR_2 += 1`: Increment VAR_2 by 1.\n\n* `VAR_3 -= 1`: Decrement VAR_3 by 1.\n\n* `return True`: If the function has not yet returned False, return True.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #f 0.001)\n    (check-within (candidate 125) #t 0.001)\n    (check-within (candidate 105) #t 0.001)\n    (check-within (candidate 126) #f 0.001)\n    (check-within (candidate 729) #f 0.001)\n    (check-within (candidate 891) #f 0.001)\n    (check-within (candidate 1001) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> bool:\n\n    def FUNC_1(VAR_1):\n        for VAR_2 in range(2, VAR_1):\n            if ((VAR_1 % VAR_2) == 0):\n                return False\n        return True\n    for VAR_3 in range(2, 101):\n        if (not FUNC_1(VAR_3)):\n            continue\n        for VAR_4 in range(2, 101):\n            if (not FUNC_1(VAR_4)):\n                continue\n            for VAR_5 in range(2, 101):\n                if (not FUNC_1(VAR_5)):\n                    continue\n                if (((VAR_3 * VAR_4) * VAR_5) == VAR_0):\n                    return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer `VAR_0` as input and returns a boolean value. The function checks if there are three prime numbers between 2 and 100 inclusive whose product is equal to `VAR_0`. If such a combination exists, the function returns `True`, otherwise it returns `False`.\n\nThe function `FUNC_0` contains a nested function called `FUNC_1` that takes an integer `VAR_1` as input and returns a boolean value. The function `FUNC_1` checks if `VAR_1` is a prime number by iterating over all integers between 2 and `VAR_1` - 1 inclusive and checking if `VAR_1` is divisible by any of them. If `VAR_1` is divisible by any of them, the function returns `False`, otherwise it returns `True`.\n\nThe outer loop of `FUNC_0` iterates over all integers between 2 and 100 inclusive and checks if each integer is a prime number by calling the function `FUNC_1`. If an integer is not a prime number, the loop continues to the next integer. If an integer is a prime number, the function enters an inner loop that iterates over all integers between 2 and 100 inclusive and checks if each integer is a prime number. If an integer is not a prime number, the loop continues to the next integer. If an integer is a prime number, the function enters another inner loop that iterates over all integers between 2 and 100 inclusive and checks if each integer is a prime number. If an integer is not a prime number, the loop continues to the next integer. If an integer is a prime number, the function checks if the product of the three prime numbers is equal to `VAR_0`. If it is, the function returns `True`. If no combination of three prime numbers whose product is equal to `VAR_0` is found, the function returns `False`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)\n    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)\n    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)\n    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)\n    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)\n    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)\n    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)\n    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)\n    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)\n    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)\n    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> List[int]:\n    if (VAR_1 == 0):\n        return []\n    VAR_0.sort()\n    VAR_2 = VAR_0[(- VAR_1):]\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and an integer as input and returns a new list of integers. The function is defined with the name FUNC_0 and takes two arguments: VAR_0 and VAR_1. VAR_0 is a list of integers and VAR_1 is an integer.\n\nThe first line of the code imports the List class from the typing module. This is used to specify the type of the input and output of the function.\n\nThe second line defines the function with the name FUNC_0 and specifies the type of the input and output of the function. The function takes two arguments: VAR_0 and VAR_1. VAR_0 is a list of integers and VAR_1 is an integer. The function returns a list of integers.\n\nThe third line checks if VAR_1 is equal to 0. If VAR_1 is equal to 0, the function returns an empty list.\n\nThe fourth line sorts the list VAR_0 in ascending order.\n\nThe fifth line creates a new list VAR_2 that contains the last VAR_1 elements of VAR_0. The slice [- VAR_1:] is used to select the last VAR_1 elements of VAR_0.\n\nThe sixth line returns the new list VAR_2.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list \"(()())\" \"((()))\" \"()\" \"((())()())\") 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list \"()\" \"(())\" \"((()))\" \"(((())))\") 0.001)\n    (check-within (candidate \"(()(())((())))\") (list \"(()(())((())))\") 0.001)\n    (check-within (candidate \"( ) (( )) (( )( ))\") (list \"()\" \"(())\" \"(()())\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str) -> List[str]:\n    VAR_1 = []\n    VAR_2 = []\n    VAR_3 = 0\n    for VAR_4 in VAR_0:\n        if (VAR_4 == '('):\n            VAR_3 += 1\n            VAR_2.append(VAR_4)\n        elif (VAR_4 == ')'):\n            VAR_3 -= 1\n            VAR_2.append(VAR_4)\n            if (VAR_3 == 0):\n                VAR_1.append(''.join(VAR_2))\n                VAR_2.clear()\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a list of strings. The function is defined with the name `FUNC_0` and takes one argument, `VAR_0`, which is a string. The function returns a list of strings.\n\nThe first line of the code imports the `List` type from the `typing` module.\n\nThe second line defines the function `FUNC_0` with one argument `VAR_0` of type `str` and a return type of `List[str]`.\n\nThe third line initializes an empty list `VAR_1`.\n\nThe fourth line initializes an empty list `VAR_2`.\n\nThe fifth line initializes a variable `VAR_3` to 0.\n\nThe sixth line starts a `for` loop that iterates over each character in the input string `VAR_0`.\n\nThe seventh line checks if the current character is an opening parenthesis `(`. If it is, the variable `VAR_3` is incremented by 1, and the current character is appended to the list `VAR_2`.\n\nThe eighth line checks if the current character is a closing parenthesis `)`. If it is, the variable `VAR_3` is decremented by 1, and the current character is appended to the list `VAR_2`. If `VAR_3` is 0, it means that all opening parentheses have been matched with closing parentheses, and the contents of `VAR_2` are joined into a single string and appended to the list `VAR_1`. The contents of `VAR_2` are then cleared.\n\nThe ninth line returns the list `VAR_1`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9) 0.001)\n    (check-within (candidate (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Any\n\ndef FUNC_0(VAR_0: List[Any]) -> List[int]:\n    return [VAR_1 for VAR_1 in VAR_0 if isinstance(VAR_1, int)]\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of any type of variable as input and returns a list of integers. \n\nThe first line imports two types from the `typing` module: `List` and `Any`. `List` is a type hint that indicates that the input variable is a list, and `Any` is a type hint that indicates that the list can contain any type of variable.\n\nThe second line defines the function `FUNC_0` that takes a single argument `VAR_0`, which is a list of any type of variable, and returns a list of integers.\n\nThe third line is a list comprehension that iterates over each element `VAR_1` in the input list `VAR_0`. The `if` statement at the end of the line filters out any elements that are not integers, and only includes integers in the output list.\n\nThe fourth line returns the filtered list of integers.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)\n    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)\n    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)\n    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)\n    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)\n    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)\n    (check-within (candidate (list 8191)) 19 0.001)\n    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)\n    (check-within (candidate (list 127 97 8192)) 10 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n\n    def FUNC_1(VAR_1):\n        for VAR_2 in range(2, (int((VAR_1 ** 0.5)) + 1)):\n            if ((VAR_1 % VAR_2) == 0):\n                return False\n        return True\n    VAR_3 = 0\n    VAR_4 = 0\n    while (VAR_4 < len(VAR_0)):\n        if ((VAR_0[VAR_4] > VAR_3) and FUNC_1(VAR_0[VAR_4])):\n            VAR_3 = VAR_0[VAR_4]\n        VAR_4 += 1\n    VAR_5 = sum((int(VAR_6) for VAR_6 in str(VAR_3)))\n    return VAR_5\n\n### Explanation\n\nThe code is an implementation of a function that finds the largest prime number in a list of integers and returns the sum of its digits. \n\n* `from typing import List` - Importing the List class from the typing module. This is used to specify the type of the input parameter of the function.\n\n* `def FUNC_0(VAR_0: List[int]) -> int:` - Defining a function named `FUNC_0` that takes a list of integers as input and returns an integer. \n\n* `def FUNC_1(VAR_1):` - Defining a nested function named `FUNC_1` that takes an integer as input and returns a boolean value. \n\n* `for VAR_2 in range(2, (int((VAR_1 ** 0.5)) + 1)):` - A for loop that iterates over a range of integers from 2 to the square root of the input integer plus 1. \n\n* `if ((VAR_1 % VAR_2) == 0):` - An if statement that checks if the input integer is divisible by the current integer in the for loop. \n\n* `return False` - If the input integer is divisible by the current integer in the for loop, the function returns False.\n\n* `return True` - If the input integer is not divisible by any integer in the for loop, the function returns True.\n\n* `VAR_3 = 0` - Initializing a variable named `VAR_3` to 0. This variable will store the largest prime number found in the list.\n\n* `VAR_4 = 0` - Initializing a variable named `VAR_4` to 0. This variable will be used as an index to iterate over the list.\n\n* `while (VAR_4 < len(VAR_0)):` - A while loop that iterates over the list until the end is reached.\n\n* `if ((VAR_0[VAR_4] > VAR_3) and FUNC_1(VAR_0[VAR_4])):` - An if statement that checks if the current element in the list is greater than the current largest prime number and if it is a prime number. \n\n* `VAR_3 = VAR_0[VAR_4]` - If the current element in the list is greater than the current largest prime number and is a prime number, it is assigned to the `VAR_3` variable.\n\n* `VAR_4 += 1` - Incrementing the index variable by 1.\n\n* `VAR_5 = sum((int(VAR_6) for VAR_6 in str(VAR_3)))` - Converting the largest prime number to a string, iterating over each character in the string, converting it back to an integer, and summing all the integers. The result is assigned to the `VAR_5` variable.\n\n* `return VAR_5` - Returning the sum of the digits of the largest prime number found in the list.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list ) (list )) (list ) 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\")) (list \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\" \"admin\" \"project\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list \"4\") (list \"1\" \"2\" \"3\" \"4\" \"5\")) (list \"4\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"Hi\")) (list \"hI\" \"Hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hi\")) (list \"hI\" \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hii\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list ) (list \"this\")) (list ) 0.001)\n    (check-within (candidate (list \"this\") (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str], VAR_1: List[str]) -> List[str]:\n    VAR_2 = 0\n    for VAR_3 in VAR_0:\n        VAR_2 += len(VAR_3)\n    VAR_4 = 0\n    for VAR_3 in VAR_1:\n        VAR_4 += len(VAR_3)\n    if (VAR_2 <= VAR_4):\n        return VAR_0\n    else:\n        return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes two lists of strings as arguments and returns one of the lists based on the total length of the strings in each list. \n\nThe first line of the code imports the List class from the typing module. This is used to specify the type of the arguments and return value of the function.\n\nThe second line defines the function FUNC_0. It takes two arguments, VAR_0 and VAR_1, both of which are lists of strings. The function returns a list of strings.\n\nThe third line initializes a variable VAR_2 to 0.\n\nThe fourth line starts a for loop that iterates over each string in VAR_0. For each string, the length of the string is added to VAR_2.\n\nThe fifth line initializes a variable VAR_4 to 0.\n\nThe sixth line starts a for loop that iterates over each string in VAR_1. For each string, the length of the string is added to VAR_4.\n\nThe seventh line checks if VAR_2 is less than or equal to VAR_4. If it is, the function returns VAR_0. Otherwise, it returns VAR_1. \n\nOverall, the function returns the list of strings that has the greater total length of characters. If the total length of the strings in VAR_0 is less than or equal to the total length of the strings in VAR_1, then VAR_0 is returned. Otherwise, VAR_1 is returned.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_162_string_to_md5.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\" 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"A B C\") \"0ef78513b0cb8cef12743f5aeb35f888\" 0.001)\n    (check-within (candidate \"password\") \"5f4dcc3b5aa765d61d8327deb882cf99\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Optional\n\ndef FUNC_0(VAR_0: str) -> Optional[str]:\n    import hashlib\n    return (hashlib.md5(VAR_0.encode('ascii')).hexdigest() if VAR_0 else None)\n\n### Explanation\n\nThe code is an implementation of a Python function that takes a string as input and returns its MD5 hash. The function is defined using the `def` keyword, which is used to define functions in Python. The function is called `FUNC_0` and takes a single argument, `VAR_0`, which is a string. The function returns an optional string, which means that it can either return a string or `None`.\n\nThe first line of the function imports the `hashlib` module, which is a built-in Python module that provides a number of hash functions. The `hashlib.md5()` function is used to compute the MD5 hash of the input string. The `encode()` method is used to convert the input string to bytes, which is required by the `hashlib.md5()` function. The `hexdigest()` method is used to convert the binary hash value to a hexadecimal string.\n\nThe second line of the function is a conditional expression that checks if the input string is not empty. If the input string is not empty, the MD5 hash of the input string is returned. If the input string is empty, `None` is returned.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 2) 4 0.001)\n    (check-within (candidate 3) 9 0.001)\n    (check-within (candidate 4) 16 0.001)\n    (check-within (candidate 8) 64 0.001)\n    (check-within (candidate 10) 100 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    return (VAR_0 ** 2)\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns the square of the integer.\n\n`def FUNC_0(VAR_0: int) -> int:` defines a function named FUNC_0 that takes an integer as input and returns an integer. \n\n`return (VAR_0 ** 2)` returns the square of the input integer. \n\nThe `**` operator is the exponentiation operator in Python. It raises the first operand to the power of the second operand. In this case, the first operand is the input integer and the second operand is the integer 2. \n\nTherefore, the function takes an integer, squares it, and returns the result.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 16 2) #t 0.001)\n    (check-within (candidate 143214 16) #f 0.001)\n    (check-within (candidate 4 2) #t 0.001)\n    (check-within (candidate 9 3) #t 0.001)\n    (check-within (candidate 16 4) #t 0.001)\n    (check-within (candidate 24 2) #f 0.001)\n    (check-within (candidate 128 4) #f 0.001)\n    (check-within (candidate 12 6) #f 0.001)\n    (check-within (candidate 1 1) #t 0.001)\n    (check-within (candidate 1 12) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> bool:\n    if (VAR_1 == 1):\n        return (VAR_0 == 1)\n    VAR_2 = 1\n    while (VAR_2 < VAR_0):\n        VAR_2 = (VAR_2 * VAR_1)\n    return (VAR_2 == VAR_0)\n\n### Explanation\n\nThe code is an implementation of a function that checks if a number is a power of another number. \n\nThe function takes two integer arguments, VAR_0 and VAR_1. VAR_0 is the number to check if it is a power of VAR_1. VAR_1 is the base of the power.\n\nThe function returns a boolean value.\n\nThe first line of the function definition specifies the function name, FUNC_0, and the types of the arguments and return value.\n\nThe second line of the function definition checks if VAR_1 is equal to 1. If VAR_1 is 1, then VAR_0 can only be 1 to be a power of VAR_1. If VAR_1 is not 1, then the function continues to the next line.\n\nThe third line of the function definition initializes VAR_2 to 1. VAR_2 will be used to calculate the power of VAR_1.\n\nThe fourth line of the function definition starts a while loop that will continue until VAR_2 is greater than or equal to VAR_0. The loop multiplies VAR_2 by VAR_1 in each iteration.\n\nThe fifth line of the while loop updates the value of VAR_2 by multiplying it by VAR_1.\n\nThe last line of the function definition checks if VAR_2 is equal to VAR_0. If VAR_2 is equal to VAR_0, then VAR_0 is a power of VAR_1 and the function returns True. If VAR_2 is not equal to VAR_0, then VAR_0 is not a power of VAR_1 and the function returns False.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"TEST\") \"tgst\" 0.001)\n    (check-within (candidate \"Mudasir\") \"mWDCSKR\" 0.001)\n    (check-within (candidate \"YES\") \"ygs\" 0.001)\n    (check-within (candidate \"This is a VAR_0\") \"tHKS KS C MGSSCGG\" 0.001)\n    (check-within (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    VAR_1 = 'aeiouAEIOU'\n    VAR_2 = dict([(VAR_3, chr((ord(VAR_3) + 2))) for VAR_3 in VAR_1])\n    VAR_0 = VAR_0.swapcase()\n    return ''.join([(VAR_2[VAR_3] if (VAR_3 in VAR_1) else VAR_3) for VAR_3 in VAR_0])\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a string as output. The function is called `FUNC_0` and takes one argument, `VAR_0`, which is a string. The output of the function is also a string.\n\nThe function starts by defining a variable `VAR_1` which is a string containing all the vowels in both uppercase and lowercase. \n\n```python\nVAR_1 = 'aeiouAEIOU'\n```\n\nThe next line creates a dictionary `VAR_2` that maps each vowel in `VAR_1` to the corresponding letter two positions down in the ASCII table. \n\n```python\nVAR_2 = dict([(VAR_3, chr((ord(VAR_3) + 2))) for VAR_3 in VAR_1])\n```\n\nThe `dict()` function creates a dictionary from a list of key-value pairs. In this case, the list comprehension `[...]` generates a list of tuples, where each tuple contains a vowel from `VAR_1` and its corresponding letter two positions down in the ASCII table. The `ord()` function returns the ASCII code of a character, and the `chr()` function returns the character corresponding to an ASCII code. \n\nThe next line swaps the case of all the characters in the input string `VAR_0`. Uppercase letters become lowercase, and vice versa. \n\n```python\nVAR_0 = VAR_0.swapcase()\n```\n\nFinally, the function returns a new string that is obtained by iterating over each character in the input string `VAR_0`, and replacing each vowel with the corresponding letter two positions down in the ASCII table. If the character is not a vowel, it is left unchanged. \n\n```python\nreturn ''.join([(VAR_2[VAR_3] if (VAR_3 in VAR_1) else VAR_3) for VAR_3 in VAR_0])\n```\n\nThe `join()` method concatenates all the characters in a list of strings into a single string. In this case, the list comprehension `[...]` generates a list of characters, where each character is either a vowel replaced by the corresponding letter two positions down in the ASCII table, or a non-vowel character from the input string `VAR_0`. The `if` statement in the list comprehension is a conditional expression that checks if the current character is a vowel, and if so, replaces it with the corresponding letter two positions down in the ASCII table. Otherwise, it leaves the character unchanged.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)\n    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    return [(VAR_1 + 1) for VAR_1 in VAR_0]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a new list with each integer incremented by one.\n\n1. `from typing import List`: Importing the List class from the typing module.\n\n2. `def FUNC_0(VAR_0: List[int]) -> List[int]:` Defining a function named `FUNC_0` that takes a list of integers as input and returns a list of integers as output.\n\n3. `return [(VAR_1 + 1) for VAR_1 in VAR_0]`: The function returns a new list that is created using a list comprehension. For each integer `VAR_1` in the input list `VAR_0`, the expression `VAR_1 + 1` is evaluated and the result is added to the new list. The resulting list is then returned by the function.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hello!\") \"hELLO!\" 0.001)\n    (check-within (candidate \"These violent delights have violent ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    return VAR_0.swapcase()\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as an argument and returns the same string with the case of all characters swapped. \n\n1. `def FUNC_0(VAR_0: str) -> str:` defines a function named FUNC_0 that takes one argument, VAR_0, which is a string. The `-> str` indicates that the function returns a string.\n2. `return VAR_0.swapcase()` returns the string VAR_0 with the case of all characters swapped. The `swapcase()` method is a built-in method of the string class in Python that returns a new string with all uppercase characters converted to lowercase and all lowercase characters converted to uppercase.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"abcde\") 2 0.001)\n    (check-within (candidate \"Alone\") 3 0.001)\n    (check-within (candidate \"key\") 2 0.001)\n    (check-within (candidate \"bye\") 1 0.001)\n    (check-within (candidate \"keY\") 2 0.001)\n    (check-within (candidate \"bYe\") 1 0.001)\n    (check-within (candidate \"ACEDY\") 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    VAR_1 = 'aeiouAEIOU'\n    VAR_2 = sum(((VAR_3 in VAR_1) for VAR_3 in VAR_0))\n    if ((VAR_0[(- 1)] == 'y') or (VAR_0[(- 1)] == 'Y')):\n        VAR_2 += 1\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of vowels in a given string. \n\n`def FUNC_0(VAR_0: str) -> int:`\n\nThis line defines a function named `FUNC_0` that takes a string as input and returns an integer. The input string is represented by the variable `VAR_0`.\n\n`VAR_1 = 'aeiouAEIOU'`\n\nThis line defines a string variable `VAR_1` that contains all the vowels in both uppercase and lowercase.\n\n`VAR_2 = sum(((VAR_3 in VAR_1) for VAR_3 in VAR_0))`\n\nThis line counts the number of vowels in the input string `VAR_0`. It does this by iterating over each character in the input string and checking if it is a vowel. If the character is a vowel, the expression `(VAR_3 in VAR_1)` evaluates to `True`, otherwise it evaluates to `False`. The resulting sequence of `True` and `False` values is then passed to the `sum()` function which returns the total number of `True` values. This count is stored in the variable `VAR_2`.\n\n`if ((VAR_0[(- 1)] == 'y') or (VAR_0[(- 1)] == 'Y')):`\n\nThis line checks if the last character of the input string is either 'y' or 'Y'. If it is, then it means that the letter 'y' at the end of a word should be counted as a vowel. In this case, the variable `VAR_2` is incremented by 1.\n\n`return VAR_2`\n\nThis line returns the final count of vowels in the input string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list \"aa\" \"a\" \"aaa\")) (list \"aa\") 0.001)\n    (check-within (candidate (list \"school\" \"AI\" \"asdf\" \"b\")) (list \"AI\" \"asdf\" \"school\") 0.001)\n    (check-within (candidate (list \"d\" \"b\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"d\" \"dcba\" \"abcd\" \"a\")) (list \"abcd\" \"dcba\") 0.001)\n    (check-within (candidate (list \"AI\" \"ai\" \"au\")) (list \"AI\" \"ai\" \"au\") 0.001)\n    (check-within (candidate (list \"a\" \"b\" \"b\" \"c\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"aaaa\" \"bbbb\" \"dd\" \"cc\")) (list \"cc\" \"dd\" \"aaaa\" \"bbbb\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str]) -> List[str]:\n    VAR_0.sort()\n    VAR_1 = []\n    for VAR_2 in VAR_0:\n        if ((len(VAR_2) % 2) == 0):\n            VAR_1.append(VAR_2)\n    return sorted(VAR_1, key=len)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings and returns a sorted list of strings that have an even number of characters. The function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of strings. The function returns a list of strings.\n\nThe first line of the function imports the List class from the typing module. This is used to specify the type of the argument and return value of the function.\n\nThe second line of the function sorts the input list of strings in ascending order.\n\nThe third line of the function initializes an empty list VAR_1.\n\nThe fourth line of the function starts a loop that iterates over each string in VAR_0.\n\nThe fifth line of the function checks if the length of the current string VAR_2 is even by using the modulo operator (%). If the length of the string is even, the condition is true and the code inside the if statement is executed.\n\nThe sixth line of the function appends the current string VAR_2 to the list VAR_1.\n\nThe seventh line of the function returns the sorted list VAR_1, sorted by the length of the strings in ascending order.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\" \"is\" \"John\") 0.001)\n    (check-within (candidate \"One, two, three, four, five, six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\") 0.001)\n    (check-within (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str) -> List[str]:\n    if (not VAR_0):\n        return []\n    VAR_1 = []\n    for VAR_2 in VAR_0:\n        if (VAR_2 == ','):\n            VAR_1.append(' ')\n        else:\n            VAR_1.append(VAR_2)\n    VAR_1 = ''.join(VAR_1)\n    return VAR_1.split()\n\n### Explanation\n\nThe code is an implementation of a function that takes in a string and returns a list of strings. The function is defined with the name FUNC_0 and takes in a single argument VAR_0, which is a string. The function returns a list of strings.\n\nThe first line of the code imports the List class from the typing module. This is used to specify the return type of the function.\n\nThe second line defines the function FUNC_0 and specifies the input type and return type. The input type is a string and the return type is a list of strings.\n\nThe third line checks if the input string is empty. If it is, an empty list is returned.\n\nThe fourth line initializes an empty list called VAR_1.\n\nThe fifth line starts a for loop that iterates over each character in the input string.\n\nThe sixth line checks if the current character is a comma. If it is, a space is appended to the VAR_1 list. If it is not a comma, the character is appended to the VAR_1 list.\n\nThe seventh line joins the characters in the VAR_1 list into a single string.\n\nThe eighth line splits the string into a list of strings using whitespace as the delimiter.\n\nThe ninth line returns the list of strings.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 123) (list 8 13) 0.001)\n    (check-within (candidate 12) (list 4 6) 0.001)\n    (check-within (candidate 3) (list 1 2) 0.001)\n    (check-within (candidate 63) (list 6 8) 0.001)\n    (check-within (candidate 25) (list 5 6) 0.001)\n    (check-within (candidate 19) (list 4 6) 0.001)\n    (check-within (candidate 9) (list 4 5) 0.001)\n    (check-within (candidate 1) (list 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef FUNC_0(VAR_0: int) -> Tuple[(int, int)]:\n\n    def FUNC_1(VAR_1):\n        return (str(VAR_1) == str(VAR_1)[::(- 1)])\n    VAR_2 = 0\n    VAR_3 = 0\n    for VAR_4 in range(1, (VAR_0 + 1)):\n        if (((VAR_4 % 2) == 1) and FUNC_1(VAR_4)):\n            VAR_3 += 1\n        elif (((VAR_4 % 2) == 0) and FUNC_1(VAR_4)):\n            VAR_2 += 1\n    return (VAR_2, VAR_3)\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns a tuple of two integers. The function is defined with the name FUNC_0 and takes an integer argument VAR_0. The return type of the function is a tuple of two integers.\n\nThe function contains another function called FUNC_1. This function takes a single argument VAR_1 and returns a boolean value indicating whether the string representation of VAR_1 is a palindrome.\n\nThe variables VAR_2 and VAR_3 are initialized to 0. These variables will be used to count the number of even and odd palindromic numbers respectively.\n\nThe for loop iterates over the range of integers from 1 to VAR_0 (inclusive). For each integer VAR_4 in this range, the function checks whether VAR_4 is a palindrome and whether it is even or odd. If VAR_4 is a palindrome and odd, VAR_3 is incremented. If VAR_4 is a palindrome and even, VAR_2 is incremented.\n\nFinally, the function returns a tuple containing the counts of even and odd palindromic numbers.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3 4 5) 6.0 0.001)\n    (check-within (candidate 1 2 10) -1 0.001)\n    (check-within (candidate 4 8 5) 8.18 0.001)\n    (check-within (candidate 2 2 2) 1.73 0.001)\n    (check-within (candidate 1 2 3) -1 0.001)\n    (check-within (candidate 10 5 7) 16.25 0.001)\n    (check-within (candidate 2 6 3) -1 0.001)\n    (check-within (candidate 1 1 1) 0.43 0.001)\n    (check-within (candidate 2 2 10) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int, VAR_2: int) -> float:\n    if (((VAR_0 + VAR_1) <= VAR_2) or ((VAR_0 + VAR_2) <= VAR_1) or ((VAR_1 + VAR_2) <= VAR_0)):\n        return (- 1)\n    VAR_3 = (((VAR_0 + VAR_1) + VAR_2) / 2)\n    VAR_4 = ((((VAR_3 * (VAR_3 - VAR_0)) * (VAR_3 - VAR_1)) * (VAR_3 - VAR_2)) ** 0.5)\n    VAR_4 = round(VAR_4, 2)\n    return VAR_4\n\n### Explanation\n\nThe code is an implementation of Heron's formula, which is used to calculate the area of a triangle given the lengths of its sides. \n\n* `def FUNC_0(VAR_0: int, VAR_1: int, VAR_2: int) -> float:` defines a function called `FUNC_0` that takes three integer arguments (`VAR_0`, `VAR_1`, and `VAR_2`) and returns a float value. \n\n* `if (((VAR_0 + VAR_1) <= VAR_2) or ((VAR_0 + VAR_2) <= VAR_1) or ((VAR_1 + VAR_2) <= VAR_0)): return (- 1)` checks if the input values form a valid triangle. If the sum of any two sides is less than or equal to the third side, then the input values do not form a valid triangle and the function returns -1.\n\n* `VAR_3 = (((VAR_0 + VAR_1) + VAR_2) / 2)` calculates the semi-perimeter of the triangle.\n\n* `VAR_4 = ((((VAR_3 * (VAR_3 - VAR_0)) * (VAR_3 - VAR_1)) * (VAR_3 - VAR_2)) ** 0.5)` calculates the area of the triangle using Heron's formula.\n\n* `VAR_4 = round(VAR_4, 2)` rounds the area to two decimal places.\n\n* `return VAR_4` returns the area of the triangle.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f 0.001)\n    (check-within (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f 0.001)\n    (check-within (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t 0.001)\n    (check-within (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t 0.001)\n    (check-within (candidate #hash()) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Dict\n\ndef FUNC_0(VAR_0: Dict[(str, str)]) -> bool:\n    if (len(VAR_0.keys()) == 0):\n        return False\n    else:\n        VAR_1 = 'start'\n        for VAR_2 in VAR_0.keys():\n            if (isinstance(VAR_2, str) == False):\n                VAR_1 = 'mixed'\n                break\n            if (VAR_1 == 'start'):\n                if VAR_2.isupper():\n                    VAR_1 = 'upper'\n                elif VAR_2.islower():\n                    VAR_1 = 'lower'\n                else:\n                    break\n            elif (((VAR_1 == 'upper') and (not VAR_2.isupper())) or ((VAR_1 == 'lower') and (not VAR_2.islower()))):\n                VAR_1 = 'mixed'\n                break\n            else:\n                continue\n        return ((VAR_1 == 'upper') or (VAR_1 == 'lower'))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a dictionary as input and returns a boolean value. \n\nThe dictionary is defined as a mapping between two strings. The function checks if the dictionary is empty. If it is, it returns `False`. If it is not empty, it initializes a variable `VAR_1` to `'start'`. \n\nThe function then iterates over the keys of the dictionary. For each key, it checks if the key is a string. If it is not a string, it sets `VAR_1` to `'mixed'` and breaks out of the loop. If it is a string, it checks the value of `VAR_1`. If `VAR_1` is `'start'`, it checks if the key is uppercase or lowercase. If it is uppercase, it sets `VAR_1` to `'upper'`. If it is lowercase, it sets `VAR_1` to `'lower'`. If it is neither uppercase nor lowercase, it breaks out of the loop. \n\nIf `VAR_1` is not `'start'`, it checks if the current key is of the same case as the previous keys. If it is not, it sets `VAR_1` to `'mixed'` and breaks out of the loop. If it is of the same case, it continues to the next key. \n\nAfter iterating over all the keys, the function returns `True` if `VAR_1` is either `'upper'` or `'lower'`, and `False` otherwise.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_130_tri",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_130_tri.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3) (list 1 3 2 8) 0.001)\n    (check-within (candidate 4) (list 1 3 2 8 3) 0.001)\n    (check-within (candidate 5) (list 1 3 2 8 3 15) 0.001)\n    (check-within (candidate 6) (list 1 3 2 8 3 15 4) 0.001)\n    (check-within (candidate 7) (list 1 3 2 8 3 15 4 24) 0.001)\n    (check-within (candidate 8) (list 1 3 2 8 3 15 4 24 5) 0.001)\n    (check-within (candidate 9) (list 1 3 2 8 3 15 4 24 5 35) 0.001)\n    (check-within (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11) 0.001)\n    (check-within (candidate 0) (list 1) 0.001)\n    (check-within (candidate 1) (list 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int) -> List[int]:\n    if (VAR_0 == 0):\n        return [1]\n    VAR_1 = [1, 3]\n    for VAR_2 in range(2, (VAR_0 + 1)):\n        if ((VAR_2 % 2) == 0):\n            VAR_1.append(((VAR_2 / 2) + 1))\n        else:\n            VAR_1.append(((VAR_1[(VAR_2 - 1)] + VAR_1[(VAR_2 - 2)]) + ((VAR_2 + 3) / 2)))\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a mathematical function that returns a list of integers. \n\nThe function is called `FUNC_0` and takes one integer argument `VAR_0`. The function returns a list of integers.\n\n```python\nfrom typing import List\n```\nThe `typing` module is imported to allow type hints to be used in the function signature.\n\n```python\ndef FUNC_0(VAR_0: int) -> List[int]:\n```\nThe function definition starts with the `def` keyword, followed by the function name `FUNC_0`, and the argument list in parentheses. The argument list contains one argument `VAR_0` of type `int`. The `->` symbol is used to indicate the return type of the function, which is a list of integers.\n\n```python\n    if (VAR_0 == 0):\n        return [1]\n```\nThe first line of the function checks if the input argument `VAR_0` is equal to zero. If it is, the function returns a list containing the integer 1.\n\n```python\n    VAR_1 = [1, 3]\n```\nA new list `VAR_1` is created and initialized with two integers, 1 and 3.\n\n```python\n    for VAR_2 in range(2, (VAR_0 + 1)):\n```\nA `for` loop is used to iterate over a range of integers from 2 to `VAR_0 + 1`. The loop variable is named `VAR_2`.\n\n```python\n        if ((VAR_2 % 2) == 0):\n            VAR_1.append(((VAR_2 / 2) + 1))\n```\nInside the loop, an `if` statement is used to check if `VAR_2` is even. If it is, the expression `((VAR_2 / 2) + 1)` is evaluated and the result is appended to the list `VAR_1`.\n\n```python\n        else:\n            VAR_1.append(((VAR_1[(VAR_2 - 1)] + VAR_1[(VAR_2 - 2)]) + ((VAR_2 + 3) / 2)))\n```\nIf `VAR_2` is odd, the expression `((VAR_1[(VAR_2 - 1)] + VAR_1[(VAR_2 - 2)]) + ((VAR_2 + 3) / 2))` is evaluated and the result is appended to the list `VAR_1`. The expression `VAR_1[(VAR_2 - 1)]` retrieves the last element of the list `VAR_1`, and `VAR_1[(VAR_2 - 2)]` retrieves the second-to-last element of the list `VAR_1`.\n\n```python\n    return VAR_1\n```\nAfter the loop completes, the final list `VAR_1` is returned as the result of the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 3 1 2 4 5)) 3 0.001)\n    (check-within (candidate (list -10 4 6 1000 10 20)) 8.0 0.001)\n    (check-within (candidate (list 5)) 5 0.001)\n    (check-within (candidate (list 6 5)) 5.5 0.001)\n    (check-within (candidate (list 8 1 3 9 9 2 7)) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> float:\n    VAR_0 = sorted(VAR_0)\n    if ((len(VAR_0) % 2) == 1):\n        return VAR_0[(len(VAR_0) // 2)]\n    else:\n        return ((VAR_0[((len(VAR_0) // 2) - 1)] + VAR_0[(len(VAR_0) // 2)]) / 2.0)\n\n### Explanation\n\nThe code is an implementation of the median function. \n\n1. The first line imports the List class from the typing module. The List class is used to define the type of the input parameter of the function.\n\n2. The second line defines a function named FUNC_0 that takes a list of integers as input and returns a float. \n\n3. The third line sorts the input list in ascending order using the sorted() function. \n\n4. The fourth line checks if the length of the input list is odd or even. If it is odd, the function returns the middle element of the sorted list. If it is even, the function returns the average of the two middle elements of the sorted list.\n\n5. The fifth line is the return statement for the odd case.\n\n6. The sixth line is the return statement for the even case. It calculates the average of the two middle elements of the sorted list by adding them together and dividing by 2.0.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 8 3) \"22\" 0.001)\n    (check-within (candidate 9 3) \"100\" 0.001)\n    (check-within (candidate 234 2) \"11101010\" 0.001)\n    (check-within (candidate 16 2) \"10000\" 0.001)\n    (check-within (candidate 8 2) \"1000\" 0.001)\n    (check-within (candidate 7 2) \"111\" 0.001)\n    (check-within (candidate 2 3) \"2\" 0.001)\n    (check-within (candidate 3 4) \"3\" 0.001)\n    (check-within (candidate 4 5) \"4\" 0.001)\n    (check-within (candidate 5 6) \"5\" 0.001)\n    (check-within (candidate 6 7) \"6\" 0.001)\n    (check-within (candidate 7 8) \"7\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> str:\n    VAR_2 = ''\n    while (VAR_0 > 0):\n        VAR_2 = (str((VAR_0 % VAR_1)) + VAR_2)\n        VAR_0 //= VAR_1\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that converts a number from base 10 to any other base. \n\n1. `def FUNC_0(VAR_0: int, VAR_1: int) -> str:` defines a function named `FUNC_0` that takes two integer arguments `VAR_0` and `VAR_1` and returns a string. \n\n2. `VAR_2 = ''` initializes an empty string variable `VAR_2`.\n\n3. `while (VAR_0 > 0):` starts a while loop that runs as long as `VAR_0` is greater than 0.\n\n4. `VAR_2 = (str((VAR_0 % VAR_1)) + VAR_2)` takes the remainder of `VAR_0` divided by `VAR_1`, converts it to a string, and concatenates it with the current value of `VAR_2`. This is done to build the string representation of the number in the new base.\n\n5. `VAR_0 //= VAR_1` updates the value of `VAR_0` to be the result of integer division of `VAR_0` by `VAR_1`. This is done to move to the next digit of the number in the new base.\n\n6. `return VAR_2` returns the final string representation of the number in the new base. \n\nThe function works by repeatedly taking the remainder of the input number divided by the new base, and adding it to the beginning of the output string. It then updates the input number to be the result of integer division of the input number by the new base, and repeats the process until the input number is 0. The resulting string is the number in the new base, represented as a string.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list \"VAR_2\" \"y\" \"z\")) \"VAR_2\" 0.001)\n    (check-within (candidate (list \"VAR_2\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\")) \"zzzz\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Optional\n\ndef FUNC_0(VAR_0: List[str]) -> Optional[str]:\n    if (not VAR_0):\n        return None\n    VAR_1 = max((len(VAR_2) for VAR_2 in VAR_0))\n    for VAR_3 in VAR_0:\n        if (len(VAR_3) == VAR_1):\n            return VAR_3\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings and returns the longest string in the list. If the list is empty, the function returns None.\n\n- `from typing import List, Optional`: Importing List and Optional from the typing module. List is a generic type that represents a list of items of a specified type, and Optional is a generic type that represents an optional value of a specified type.\n- `def FUNC_0(VAR_0: List[str]) -> Optional[str]:`: Defining a function named FUNC_0 that takes a single argument, VAR_0, which is a list of strings. The function returns an optional string.\n- `if (not VAR_0):`: If VAR_0 is empty, return None.\n- `VAR_1 = max((len(VAR_2) for VAR_2 in VAR_0))`: Find the length of the longest string in VAR_0 and assign it to VAR_1.\n- `for VAR_3 in VAR_0:`: Loop through each string in VAR_0.\n- `if (len(VAR_3) == VAR_1):`: If the length of the current string is equal to VAR_1, return the current string. This will be the longest string in the list. If there are multiple strings with the same length, only the first one encountered will be returned.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5) 0.001)\n    (check-within (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3) 0.001)\n    (check-within (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77) 0.001)\n    (check-within (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    return sorted(sorted(VAR_0), key=(lambda VAR_1: bin(VAR_1)[2:].count('1')))\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the list sorted by the number of 1's in their binary representation.\n\n1. `from typing import List` - Importing the List class from the typing module. This is used to specify the type of the input and output of the function.\n\n2. `def FUNC_0(VAR_0: List[int]) -> List[int]:` - Defining a function named FUNC_0 that takes a list of integers as input and returns a list of integers as output. The input list is specified to be of type List[int] and the output list is also specified to be of type List[int].\n\n3. `return sorted(sorted(VAR_0), key=(lambda VAR_1: bin(VAR_1)[2:].count('1')))` - This line returns the sorted list of integers. The list is sorted twice, first in ascending order and then by the number of 1's in their binary representation. \n\n    - `sorted(VAR_0)` - Sorts the input list in ascending order.\n    \n    - `key=(lambda VAR_1: bin(VAR_1)[2:].count('1'))` - This is the key function used to sort the list by the number of 1's in their binary representation. It takes an integer VAR_1, converts it to binary using the `bin()` function, removes the first two characters (which are '0b' indicating that the number is in binary), and then counts the number of '1's in the binary representation using the `count()` function. This key function is used by the `sorted()` function to sort the list by the number of 1's in their binary representation.\n\n    - `sorted(sorted(VAR_0), key=(lambda VAR_1: bin(VAR_1)[2:].count('1')))` - The sorted list is returned as the output of the function. The outer `sorted()` function sorts the list in ascending order based on the key function specified in the `key` parameter. \n\nOverall, the function sorts the input list in ascending order and then sorts it again based on the number of 1's in their binary representation. The sorted list is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653) 0.001)\n    (check-within (candidate (list 5 3 2 8) (list 3 2)) (list 2 3) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: List[int]) -> List[int]:\n    VAR_2 = set()\n    for VAR_3 in VAR_0:\n        for VAR_4 in VAR_1:\n            if (VAR_3 == VAR_4):\n                VAR_2.add(VAR_3)\n    return sorted(list(VAR_2))\n\n### Explanation\n\nThe code is an implementation of a function that takes two lists of integers as input and returns a list of integers that are common to both input lists. \n\nThe first line imports the List class from the typing module. \n\nThe second line defines a function called FUNC_0 that takes two arguments, VAR_0 and VAR_1, both of which are lists of integers. The function returns a list of integers.\n\nThe third line creates an empty set called VAR_2.\n\nThe fourth line starts a nested loop that iterates over each element in VAR_0 and VAR_1, respectively. \n\nThe fifth line checks if the current element in VAR_0 is equal to the current element in VAR_1. If they are equal, the current element is added to VAR_2 using the add() method.\n\nThe sixth line returns a sorted list of the elements in VAR_2. \n\nOverall, the function finds the common elements between the two input lists and returns them in sorted order.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"xyzw\" \"xyw\") #f 0.001)\n    (check-within (candidate \"yello\" \"ell\") #t 0.001)\n    (check-within (candidate \"whattup\" \"ptut\") #f 0.001)\n    (check-within (candidate \"efef\" \"fee\") #t 0.001)\n    (check-within (candidate \"abab\" \"aabb\") #f 0.001)\n    (check-within (candidate \"winemtt\" \"tinem\") #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str, VAR_1: str) -> bool:\n    VAR_2 = len(VAR_1)\n    VAR_3 = (VAR_1 + VAR_1)\n    for VAR_4 in range(((len(VAR_0) - VAR_2) + 1)):\n        for VAR_5 in range((VAR_2 + 1)):\n            if (VAR_0[VAR_4:(VAR_4 + VAR_2)] == VAR_3[VAR_5:(VAR_5 + VAR_2)]):\n                return True\n    return False\n\n### Explanation\n\nThe code is an implementation of the Rabin-Karp algorithm for string matching. The algorithm is used to find a substring within a larger string. \n\nThe function `FUNC_0` takes two string arguments `VAR_0` and `VAR_1` and returns a boolean value. \n\nThe first line of the function defines the function signature. The function name is `FUNC_0` and it takes two string arguments `VAR_0` and `VAR_1`. The `-> bool` indicates that the function returns a boolean value.\n\nThe second line of the function calculates the length of the second argument `VAR_1` and assigns it to the variable `VAR_2`.\n\nThe third line of the function concatenates the second argument `VAR_1` with itself and assigns it to the variable `VAR_3`.\n\nThe fourth line of the function starts a nested loop. The outer loop iterates over the range of values from 0 to the difference between the length of the first argument `VAR_0` and the length of the second argument `VAR_1` plus 1. The inner loop iterates over the range of values from 0 to the length of the second argument `VAR_1` plus 1.\n\nThe fifth line of the function checks if a substring of the first argument `VAR_0` starting at index `VAR_4` and ending at index `VAR_4 + VAR_2` is equal to a substring of the concatenated second argument `VAR_3` starting at index `VAR_5` and ending at index `VAR_5 + VAR_2`. If the substrings are equal, the function returns `True`.\n\nThe sixth line of the function returns `False` if the function has not yet returned `True`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 2 3 4 1 2 4)) 1 0.001)\n    (check-within (candidate (list -1 -2 -3)) -6 0.001)\n    (check-within (candidate (list -1 -2 -3 2 -10)) -14 0.001)\n    (check-within (candidate (list -9999999999999999)) -9999999999999999 0.001)\n    (check-within (candidate (list 0 10 20 1000000)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 100 -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 10 11 13 8 3 4)) 3 0.001)\n    (check-within (candidate (list 100 -33 32 -1 0 -2)) -33 0.001)\n    (check-within (candidate (list -10)) -10 0.001)\n    (check-within (candidate (list 7)) 7 0.001)\n    (check-within (candidate (list 1 -1)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    VAR_1 = 0\n    VAR_2 = 0\n    for VAR_3 in VAR_0:\n        VAR_2 += (- VAR_3)\n        if (VAR_2 < 0):\n            VAR_2 = 0\n        VAR_1 = max(VAR_2, VAR_1)\n    if (VAR_1 == 0):\n        VAR_1 = max(((- VAR_4) for VAR_4 in VAR_0))\n    VAR_5 = (- VAR_1)\n    return VAR_5\n\n### Explanation\n\nThe code is an implementation of the Kadane's algorithm which is used to find the maximum subarray sum in an array of integers. \n\n1. `from typing import List` - Importing the List class from the typing module. This is used to specify the type of the input variable in the function definition.\n\n2. `def FUNC_0(VAR_0: List[int]) -> int:` - Defining a function named FUNC_0 which takes a list of integers as input and returns an integer. \n\n3. `VAR_1 = 0` - Initializing a variable VAR_1 to 0.\n\n4. `VAR_2 = 0` - Initializing a variable VAR_2 to 0.\n\n5. `for VAR_3 in VAR_0:` - Looping through each element VAR_3 in the input list VAR_0.\n\n6. `VAR_2 += (- VAR_3)` - Subtracting VAR_3 from VAR_2 and updating VAR_2.\n\n7. `if (VAR_2 < 0):` - Checking if VAR_2 is less than 0.\n\n8. `VAR_2 = 0` - If VAR_2 is less than 0, then setting VAR_2 to 0.\n\n9. `VAR_1 = max(VAR_2, VAR_1)` - Updating VAR_1 to the maximum value between VAR_2 and VAR_1.\n\n10. `if (VAR_1 == 0):` - Checking if VAR_1 is equal to 0.\n\n11. `VAR_1 = max(((- VAR_4) for VAR_4 in VAR_0))` - If VAR_1 is equal to 0, then updating VAR_1 to the maximum negative value in the input list VAR_0.\n\n12. `VAR_5 = (- VAR_1)` - Setting VAR_5 to the negative of VAR_1.\n\n13. `return VAR_5` - Returning VAR_5 as the output of the function. \n\nIn summary, the function takes a list of integers as input and returns the maximum subarray sum. It does this by looping through each element in the input list and keeping track of the maximum subarray sum seen so far using the variables VAR_1 and VAR_2. If VAR_2 becomes negative, it is reset to 0. If VAR_1 is 0, then it is updated to the maximum negative value in the input list. Finally, the negative of VAR_1 is returned as the maximum subarray sum.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5)) (list 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3 4 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0) 0.001)\n    (check-within (candidate (list 2 1)) (list 1 2) 0.001)\n    (check-within (candidate (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87) 0.001)\n    (check-within (candidate (list 21 14 23 11)) (list 23 21 14 11) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    return ([] if (len(VAR_0) == 0) else sorted(VAR_0, reverse=(((VAR_0[0] + VAR_0[(- 1)]) % 2) == 0)))\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a sorted list of integers. \n\n`from typing import List` imports the List class from the typing module.\n\n`def FUNC_0(VAR_0: List[int]) -> List[int]:` defines a function named FUNC_0 that takes in a list of integers and returns a list of integers. \n\n`return ([] if (len(VAR_0) == 0) else sorted(VAR_0, reverse=(((VAR_0[0] + VAR_0[(- 1)]) % 2) == 0)))` is the body of the function. It returns an empty list if the input list is empty, otherwise it returns the sorted input list in descending order if the sum of the first and last elements of the input list is even, otherwise it returns the sorted input list in ascending order. \n\nThe `sorted` function sorts the input list in ascending order by default. The `reverse` parameter is set to `True` to sort the list in descending order. \n\n`((VAR_0[0] + VAR_0[(- 1)]) % 2) == 0` checks if the sum of the first and last elements of the input list is even. The `%` operator returns the remainder of the division of the sum by 2. If the remainder is 0, then the sum is even. \n\n`[] if (len(VAR_0) == 0)` returns an empty list if the input list is empty. \n\nOverall, the function sorts the input list in ascending order if the sum of the first and last elements is odd, and in descending order if the sum is even. If the input list is empty, it returns an empty list.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"a b b a\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c a b\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c d g\") #hash((\"a\" .  1) (\"b\" .  1) (\"c\" .  1) (\"d\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"r VAR_3 g\") #hash((\"r\" .  1) (\"VAR_3\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"b b b b a\") #hash((\"b\" .  4)) 0.001)\n    (check-within (candidate \"r VAR_3 g\") #hash((\"r\" .  1) (\"VAR_3\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"\") #hash() 0.001)\n    (check-within (candidate \"a\") #hash((\"a\" .  1)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Dict\n\ndef FUNC_0(VAR_0: str) -> Dict[(str, int)]:\n    VAR_1 = {}\n    VAR_2 = VAR_0.split(' ')\n    VAR_3 = 0\n    for VAR_4 in VAR_2:\n        if ((VAR_2.count(VAR_4) > VAR_3) and (VAR_4 != '')):\n            VAR_3 = VAR_2.count(VAR_4)\n    if (VAR_3 > 0):\n        for VAR_4 in VAR_2:\n            if (VAR_2.count(VAR_4) == VAR_3):\n                VAR_1[VAR_4] = VAR_3\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as an argument and returns a dictionary with keys as strings and values as integers. The function is defined using Python's type hinting syntax to specify the types of the input and output parameters.\n\n```python\nfrom typing import Dict\n```\n\nThe `typing` module is imported to allow the use of type hints.\n\n```python\ndef FUNC_0(VAR_0: str) -> Dict[(str, int)]:\n```\n\nThe `FUNC_0` function is defined with a single argument `VAR_0` of type `str` and a return type of `Dict[(str, int)]`. The return type specifies that the function returns a dictionary with keys of type `str` and values of type `int`.\n\n```python\nVAR_1 = {}\nVAR_2 = VAR_0.split(' ')\nVAR_3 = 0\n```\n\nThree variables are initialized: `VAR_1` is an empty dictionary, `VAR_2` is a list of words obtained by splitting the input string `VAR_0` on whitespace, and `VAR_3` is initialized to zero.\n\n```python\nfor VAR_4 in VAR_2:\n    if ((VAR_2.count(VAR_4) > VAR_3) and (VAR_4 != '')):\n        VAR_3 = VAR_2.count(VAR_4)\n```\n\nA loop is used to iterate over each word in the list `VAR_2`. The `count` method is used to count the number of occurrences of the current word in the list. If the count is greater than the current maximum count `VAR_3` and the word is not an empty string, then the maximum count is updated to the current count.\n\n```python\nif (VAR_3 > 0):\n    for VAR_4 in VAR_2:\n        if (VAR_2.count(VAR_4) == VAR_3):\n            VAR_1[VAR_4] = VAR_3\n```\n\nIf the maximum count is greater than zero, another loop is used to iterate over each word in the list `VAR_2`. If the count of the current word is equal to the maximum count, then the word is added to the dictionary `VAR_1` with a value of the maximum count.\n\n```python\nreturn VAR_1\n```\n\nFinally, the dictionary `VAR_1` is returned as the output of the function. The function essentially finds the most frequently occurring word(s) in the input string and returns a dictionary with the word(s) as keys and their frequency as values.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 14) (list 1 5 7 11 13 17) 0.001)\n    (check-within (candidate 5) (list 1 5) 0.001)\n    (check-within (candidate 12) (list 1 3 5) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int) -> List[int]:\n    if ((VAR_0 % 2) == 0):\n        VAR_1 = []\n    else:\n        VAR_1 = [VAR_0]\n    while (VAR_0 > 1):\n        if ((VAR_0 % 2) == 0):\n            VAR_0 = (VAR_0 / 2)\n        else:\n            VAR_0 = ((VAR_0 * 3) + 1)\n        if ((VAR_0 % 2) == 1):\n            VAR_1.append(int(VAR_0))\n    return sorted(VAR_1)\n\n### Explanation\n\nThe code is an implementation of the Collatz conjecture, which is a conjecture in mathematics that states that for any positive integer n, the sequence obtained by repeatedly applying the following function to n will eventually reach 1:\n\n- If n is even, divide it by 2.\n- If n is odd, multiply it by 3 and add 1.\n\nThe function FUNC_0 takes an integer VAR_0 as input and returns a sorted list of integers. The function first checks if VAR_0 is even. If it is, an empty list VAR_1 is created. If VAR_0 is odd, VAR_1 is initialized with a single element VAR_0.\n\nThe function then enters a while loop that continues until VAR_0 is equal to 1. Within the loop, VAR_0 is checked to see if it is even. If it is, VAR_0 is divided by 2. If VAR_0 is odd, VAR_0 is multiplied by 3 and 1 is added to it. If VAR_0 is odd after this operation, VAR_0 is appended to VAR_1.\n\nFinally, the function returns VAR_1 sorted in ascending order.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 3 1 2 4 5)) (list 1 4 12 20) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 6) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 2 2) 0.001)\n    (check-within (candidate (list 3 2 1 0 4)) (list 2 2 0 16) 0.001)\n    (check-within (candidate (list 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    return [(VAR_1 * VAR_2) for (VAR_1, VAR_2) in enumerate(VAR_0)][1:]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a new list of integers. The new list is the result of multiplying each element of the input list with its index, except for the first element. \n\nThe function is defined with the name `FUNC_0` and takes a single argument `VAR_0` which is a list of integers. The function returns a list of integers.\n\nThe first line of the function uses the `enumerate` function to iterate over the input list `VAR_0` and returns a list of tuples. Each tuple contains two values: the index of the element and the element itself. \n\nThe second line of the function uses a list comprehension to create a new list of integers. For each tuple in the list returned by `enumerate`, the code multiplies the element with its index and adds the result to the new list. \n\nThe `[1:]` slice at the end of the line removes the first element of the new list, which corresponds to the multiplication of the first element of the input list with its index. \n\nThe `typing` module is imported at the beginning of the code to enable type hints. This is not strictly necessary for the code to work, but it helps with code readability and maintainability.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 1) 0 0.001)\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 24 0.001)\n    (check-within (candidate 10) 81 0.001)\n    (check-within (candidate 12) 274 0.001)\n    (check-within (candidate 14) 927 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    if (VAR_0 == 0):\n        return 0\n    if (VAR_0 == 1):\n        return 0\n    if (VAR_0 == 2):\n        return 1\n    return ((FUNC_0((VAR_0 - 1)) + FUNC_0((VAR_0 - 2))) + FUNC_0((VAR_0 - 3)))\n\n### Explanation\n\nThe code is an implementation of a recursive function that returns the nth number in a sequence. The sequence is defined as follows: \n\n- If n is 0 or 1, return 0\n- If n is 2, return 1\n- Otherwise, return the sum of the previous three numbers in the sequence.\n\nThe function takes an integer argument `VAR_0` and returns an integer. \n\nThe first line defines the function `FUNC_0` and specifies that it takes an integer argument `VAR_0` and returns an integer. \n\nThe second line checks if `VAR_0` is equal to 0. If it is, the function returns 0. \n\nThe third line checks if `VAR_0` is equal to 1. If it is, the function returns 0. \n\nThe fourth line checks if `VAR_0` is equal to 2. If it is, the function returns 1. \n\nThe fifth line is the recursive case. If none of the previous conditions are met, the function calls itself three times with `VAR_0` decremented by 1, 2, and 3 respectively. The results of these recursive calls are summed and returned.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3.5) 0.5 0.001)\n    (check-within (candidate 1.25) 0.25 0.001)\n    (check-within (candidate 123.0) 0.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: float) -> float:\n    return (VAR_0 % 1.0)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a single parameter `VAR_0` of type `float` and returns a value of type `float`. The function returns the remainder of `VAR_0` divided by `1.0`. \n\nThe `%` operator is the modulo operator, which returns the remainder of the division of the first operand by the second operand. In this case, `VAR_0 % 1.0` returns the remainder of `VAR_0` divided by `1.0`. Since `1.0` is a float, the result of the division is also a float. \n\nThe function is defined using the `def` keyword, followed by the function name `FUNC_0`, and the parameter list in parentheses. The parameter list consists of a single parameter `VAR_0` of type `float`, followed by the return type `-> float`. The function body is a single line that returns the result of the modulo operation. \n\nOverall, the function takes a float value as input, and returns the fractional part of that value. For example, `FUNC_0(3.14)` would return `0.14000000000000012`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3)) 3 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    VAR_1 = VAR_0[0]\n    for VAR_2 in VAR_0:\n        if (VAR_2 > VAR_1):\n            VAR_1 = VAR_2\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns the largest integer in the list. \n\nThe first line imports the List class from the typing module. This is used to specify the type of the input parameter of the function.\n\nThe second line defines a function called FUNC_0 that takes in a list of integers and returns an integer. \n\nThe third line creates a variable called VAR_1 and assigns it the value of the first element of the input list.\n\nThe fourth line starts a for loop that iterates over each element of the input list. \n\nThe fifth line checks if the current element of the list is greater than the current value of VAR_1. If it is, then the value of VAR_1 is updated to the current element.\n\nThe sixth line returns the final value of VAR_1, which is the largest integer in the input list.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"10\") 10 0.001)\n    (check-within (candidate \"14.5\") 15 0.001)\n    (check-within (candidate \"-15.5\") -16 0.001)\n    (check-within (candidate \"15.3\") 15 0.001)\n    (check-within (candidate \"0\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    from math import floor, ceil\n    if (VAR_0.count('.') == 1):\n        while (VAR_0[(- 1)] == '0'):\n            VAR_0 = VAR_0[:(- 1)]\n    VAR_1 = float(VAR_0)\n    if (VAR_0[(- 2):] == '.5'):\n        if (VAR_1 > 0):\n            VAR_2 = ceil(VAR_1)\n        else:\n            VAR_2 = floor(VAR_1)\n    elif (len(VAR_0) > 0):\n        VAR_2 = int(round(VAR_1))\n    else:\n        VAR_2 = 0\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in a string `VAR_0` and returns an integer. The function rounds the float representation of the string to the nearest integer. \n\n1. `def FUNC_0(VAR_0: str) -> int:` - This line defines the function `FUNC_0` that takes in a string `VAR_0` and returns an integer. The `-> int` specifies the return type of the function.\n\n2. `from math import floor, ceil` - This line imports the `floor` and `ceil` functions from the `math` module. `floor` returns the largest integer less than or equal to a given number, while `ceil` returns the smallest integer greater than or equal to a given number.\n\n3. `if (VAR_0.count('.') == 1):` - This line checks if the string `VAR_0` contains exactly one decimal point. If it does, the code removes any trailing zeros after the decimal point.\n\n4. `while (VAR_0[(- 1)] == '0'):` - This line creates a loop that removes trailing zeros after the decimal point until there are no more trailing zeros.\n\n5. `VAR_0 = VAR_0[:(- 1)]` - This line removes the last character of the string `VAR_0`.\n\n6. `VAR_1 = float(VAR_0)` - This line converts the string `VAR_0` to a float and assigns it to the variable `VAR_1`.\n\n7. `if (VAR_0[(- 2):] == '.5'):` - This line checks if the string `VAR_0` ends with the characters `.5`. If it does, the code rounds up if `VAR_1` is positive, and rounds down if `VAR_1` is negative.\n\n8. `VAR_2 = ceil(VAR_1)` - This line assigns the smallest integer greater than or equal to `VAR_1` to the variable `VAR_2`.\n\n9. `VAR_2 = floor(VAR_1)` - This line assigns the largest integer less than or equal to `VAR_1` to the variable `VAR_2`.\n\n10. `elif (len(VAR_0) > 0):` - This line checks if the length of the string `VAR_0` is greater than 0. If it is, the code rounds `VAR_1` to the nearest integer.\n\n11. `VAR_2 = int(round(VAR_1))` - This line assigns the rounded integer value of `VAR_1` to the variable `VAR_2`.\n\n12. `else:` - This line executes if the length of the string `VAR_0` is 0. If it is, the code assigns 0 to the variable `VAR_2`.\n\n13. `return VAR_2` - This line returns the integer value of `VAR_2`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 3) 5 0.001)\n    (check-within (candidate 4) 13 0.001)\n    (check-within (candidate 5) 89 0.001)\n    (check-within (candidate 6) 233 0.001)\n    (check-within (candidate 7) 1597 0.001)\n    (check-within (candidate 8) 28657 0.001)\n    (check-within (candidate 9) 514229 0.001)\n    (check-within (candidate 10) 433494437 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    import math\n\n    def FUNC_1(VAR_1):\n        if (VAR_1 < 2):\n            return False\n        for VAR_2 in range(2, min((int(math.sqrt(VAR_1)) + 1), (VAR_1 - 1))):\n            if ((VAR_1 % VAR_2) == 0):\n                return False\n        return True\n    VAR_3 = [0, 1]\n    while True:\n        VAR_3.append((VAR_3[(- 1)] + VAR_3[(- 2)]))\n        if FUNC_1(VAR_3[(- 1)]):\n            VAR_0 -= 1\n        if (VAR_0 == 0):\n            return VAR_3[(- 1)]\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence, where the nth number in the sequence is the sum of the (n-1)th and (n-2)th numbers in the sequence. The program returns the nth prime number in the Fibonacci sequence.\n\n* `def FUNC_0(VAR_0: int) -> int:` - Define a function called `FUNC_0` that takes an integer argument `VAR_0` and returns an integer.\n* `import math` - Import the `math` module.\n* `def FUNC_1(VAR_1):` - Define a nested function called `FUNC_1` that takes an argument `VAR_1`.\n* `if (VAR_1 < 2):` - If `VAR_1` is less than 2, return `False`.\n* `for VAR_2 in range(2, min((int(math.sqrt(VAR_1)) + 1), (VAR_1 - 1))):` - For each integer `VAR_2` in the range from 2 to the minimum of the square root of `VAR_1` plus 1 and `VAR_1` minus 1:\n    * `if ((VAR_1 % VAR_2) == 0):` - If `VAR_1` is divisible by `VAR_2`, return `False`.\n* `return True` - If `VAR_1` is not divisible by any integer in the range, return `True`.\n* `VAR_3 = [0, 1]` - Create a list called `VAR_3` with the values 0 and 1.\n* `while True:` - Loop indefinitely.\n    * `VAR_3.append((VAR_3[(- 1)] + VAR_3[(- 2)]))` - Add the sum of the last two elements in `VAR_3` to the end of the list.\n    * `if FUNC_1(VAR_3[(- 1)]):` - If the last element in `VAR_3` is prime:\n        * `VAR_0 -= 1` - Decrement `VAR_0` by 1.\n    * `if (VAR_0 == 0):` - If `VAR_0` is equal to 0:\n        * `return VAR_3[(- 1)]` - Return the last element in `VAR_3`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) (list 0 1) 0.001)\n    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)\n    (check-within (candidate (list 100 0)) (list 100 0) 0.001)\n    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)\n    (check-within (candidate (list 10)) (list 10 10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\ndef FUNC_0(VAR_0: List[int]) -> Tuple[(int, int)]:\n    VAR_1 = 0\n    VAR_2 = 1\n    for VAR_3 in VAR_0:\n        VAR_1 += VAR_3\n        VAR_2 *= VAR_3\n    return (VAR_1, VAR_2)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a tuple of two integers. \n\nThe first line imports the List and Tuple types from the typing module. \n\nThe second line defines a function called FUNC_0 that takes a list of integers as input and returns a tuple of two integers. \n\nThe third line initializes a variable called VAR_1 to 0. \n\nThe fourth line initializes a variable called VAR_2 to 1. \n\nThe fifth line starts a for loop that iterates over each element in the input list. \n\nThe sixth line adds the current element to VAR_1. \n\nThe seventh line multiplies the current element by VAR_2. \n\nThe eighth line returns a tuple containing VAR_1 and VAR_2. \n\nOverall, the function calculates the sum and product of all the integers in the input list and returns them as a tuple.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Mary had a little lamb\" 4) (list \"little\") 0.001)\n    (check-within (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\") 0.001)\n    (check-within (candidate \"simple white space\" 2) (list ) 0.001)\n    (check-within (candidate \"Hello world\" 4) (list \"world\") 0.001)\n    (check-within (candidate \"Uncle sam\" 3) (list \"Uncle\") 0.001)\n    (check-within (candidate \"\" 4) (list ) 0.001)\n    (check-within (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"f\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str, VAR_1: int) -> List[str]:\n    VAR_2 = []\n    for VAR_3 in VAR_0.split():\n        VAR_4 = 0\n        for VAR_5 in range(0, len(VAR_3)):\n            if (VAR_3[VAR_5].lower() not in ['a', 'e', 'i', 'o', 'u']):\n                VAR_4 += 1\n        if (VAR_4 == VAR_1):\n            VAR_2.append(VAR_3)\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that takes in two parameters, a string and an integer, and returns a list of strings. \n\nThe function is defined with the name FUNC_0 and takes in two parameters, VAR_0 and VAR_1, which are a string and an integer, respectively. The function returns a list of strings.\n\n```python\nfrom typing import List\n```\nThe typing module is imported to allow for type annotations in the function definition.\n\n```python\ndef FUNC_0(VAR_0: str, VAR_1: int) -> List[str]:\n```\nThe function definition begins with the keyword `def`, followed by the function name `FUNC_0`. The function takes in two parameters, `VAR_0` and `VAR_1`, which are annotated as a string and an integer, respectively. The `-> List[str]` annotation specifies that the function returns a list of strings.\n\n```python\nVAR_2 = []\n```\nAn empty list is created and assigned to the variable `VAR_2`.\n\n```python\nfor VAR_3 in VAR_0.split():\n```\nThe `for` loop iterates over each word in the string `VAR_0`, which is split into a list of words using the `split()` method.\n\n```python\nVAR_4 = 0\nfor VAR_5 in range(0, len(VAR_3)):\n    if (VAR_3[VAR_5].lower() not in ['a', 'e', 'i', 'o', 'u']):\n        VAR_4 += 1\n```\nFor each word in the list, another `for` loop iterates over each character in the word. The variable `VAR_4` is initialized to 0, and is incremented by 1 for each character that is not a vowel. The `if` statement checks if the lowercase version of the character is not in the list of vowels, and if so, increments `VAR_4`.\n\n```python\nif (VAR_4 == VAR_1):\n    VAR_2.append(VAR_3)\n```\nAfter the inner `for` loop has finished iterating over each character in the word, the `if` statement checks if `VAR_4` is equal to `VAR_1`. If so, the word is added to the list `VAR_2` using the `append()` method.\n\n```python\nreturn VAR_2\n```\nAfter all words in the string have been processed, the function returns the list `VAR_2`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)\n    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)\n    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)\n    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)\n    (check-within (candidate (list 1) 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> int:\n    return sum((VAR_2 for VAR_2 in VAR_0[:VAR_1] if (len(str(VAR_2)) <= 2)))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two arguments, a list of integers `VAR_0` and an integer `VAR_1`. The function returns the sum of the integers in `VAR_0` up to the first `VAR_1` integers that have at most two digits.\n\n- `from typing import List`: Importing the `List` class from the `typing` module. This is used to specify the type of the arguments and return value of the function.\n- `def FUNC_0(VAR_0: List[int], VAR_1: int) -> int:`: Defining the function `FUNC_0` that takes two arguments, a list of integers `VAR_0` and an integer `VAR_1`, and returns an integer. The `-> int` specifies the return type of the function.\n- `return sum((VAR_2 for VAR_2 in VAR_0[:VAR_1] if (len(str(VAR_2)) <= 2)))`: This line returns the sum of the integers in `VAR_0` up to the first `VAR_1` integers that have at most two digits. \n\n  - `VAR_2 for VAR_2 in VAR_0[:VAR_1]`: This is a generator expression that iterates over the first `VAR_1` integers in `VAR_0` and assigns each integer to the variable `VAR_2`.\n  - `if (len(str(VAR_2)) <= 2)`: This is a conditional statement that checks if the length of the string representation of `VAR_2` is less than or equal to 2. If it is, the integer is included in the sum.\n  - `sum((VAR_2 for VAR_2 in VAR_0[:VAR_1] if (len(str(VAR_2)) <= 2)))`: This is the sum of the integers that meet the condition specified in the generator expression. The `sum()` function adds up all the integers in the generator expression. The double parentheses are used to create a generator expression instead of a list comprehension, which is more memory efficient for large lists.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5 6 10) (list 11 4) 0.001)\n    (check-within (candidate 4 8 9) (list 12 1) 0.001)\n    (check-within (candidate 1 10 10) (list 11 0) 0.001)\n    (check-within (candidate 2 11 5) (list 7 0) 0.001)\n    (check-within (candidate 4 5 7) (list 9 2) 0.001)\n    (check-within (candidate 4 5 1) (list 5 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int, VAR_1: int, VAR_2: int) -> List[int]:\n    if (VAR_1 <= VAR_2):\n        return [(VAR_0 + VAR_1), (VAR_2 - VAR_1)]\n    else:\n        return [(VAR_0 + VAR_2), 0]\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes in three integer arguments, VAR_0, VAR_1, and VAR_2, and returns a list of integers. \n\nThe first line of the code imports the List class from the typing module. \n\nThe second line defines the function FUNC_0. The function takes in three integer arguments, VAR_0, VAR_1, and VAR_2, and returns a list of integers. \n\nThe third line checks if VAR_1 is less than or equal to VAR_2. If it is, the function returns a list containing the sum of VAR_0 and VAR_1, and the difference between VAR_2 and VAR_1. \n\nIf VAR_1 is greater than VAR_2, the function returns a list containing the sum of VAR_0 and VAR_2, and 0. \n\nOverall, the function takes in three integers and returns a list of two integers. The returned list contains the sum of two of the input integers and either the difference between the other two input integers or 0, depending on which of the two input integers is greater.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list \"1234567\")) (list \"the number of odd elements 4n the str4ng 4 of the 4nput.\") 0.001)\n    (check-within (candidate (list \"3\" \"11111111\")) (list \"the number of odd elements 1n the str1ng 1 of the 1nput.\" \"the number of odd elements 8n the str8ng 8 of the 8nput.\") 0.001)\n    (check-within (candidate (list \"271\" \"137\" \"314\")) (list \"the number of odd elements 2n the str2ng 2 of the 2nput.\" \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \"the number of odd elements 2n the str2ng 2 of the 2nput.\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str]) -> List[str]:\n    VAR_1 = []\n    for VAR_2 in VAR_0:\n        VAR_3 = sum((((int(VAR_4) % 2) == 1) for VAR_4 in VAR_2))\n        VAR_1.append((((((((('the number of odd elements ' + str(VAR_3)) + 'n the str') + str(VAR_3)) + 'ng ') + str(VAR_3)) + ' of the ') + str(VAR_3)) + 'nput.'))\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in a list of strings as input and returns a list of strings as output. \n\nThe first line of the code imports the `List` class from the `typing` module. This is used to specify the type of the input and output of the function. \n\nThe second line defines the function `FUNC_0` that takes in a list of strings called `VAR_0` as input and returns a list of strings as output. \n\nThe third line initializes an empty list called `VAR_1`. This list will be used to store the output strings for each input string. \n\nThe fourth line starts a `for` loop that iterates over each string in the input list `VAR_0`. \n\nThe fifth line initializes a variable called `VAR_3` to 0. This variable will be used to count the number of odd elements in the current input string. \n\nThe sixth line starts a nested `for` loop that iterates over each character in the current input string `VAR_2`. \n\nThe seventh line initializes a variable called `VAR_4` to the current character in the nested `for` loop. \n\nThe eighth line checks if the integer value of the current character `VAR_4` is odd by using the modulo operator `%` to check if the remainder of the integer division of `VAR_4` by 2 is equal to 1. If the remainder is 1, then the integer value of `VAR_4` is odd, and the expression `((int(VAR_4) % 2) == 1)` evaluates to `True`. Otherwise, the expression evaluates to `False`. \n\nThe ninth line uses a generator expression to create a sequence of `True` and `False` values that correspond to whether each character in the current input string is odd or even. The `sum` function is then used to add up the `True` values in the sequence, which gives the number of odd elements in the current input string. This value is assigned to the variable `VAR_3`. \n\nThe tenth line appends a string to the output list `VAR_1`. The string is constructed by concatenating several substrings together using the `+` operator. The first substring is `'the number of odd elements '`, the second substring is the string representation of the number of odd elements `VAR_3`, the third substring is `'n the str'`, the fourth substring is the string representation of the number of odd elements `VAR_3` again, the fifth substring is `'ng '`, the sixth substring is the string representation of the number of odd elements `VAR_3` again, the seventh substring is `' of the '`, and the eighth substring is the string representation of the length of the current input string `VAR_2`. \n\nThe eleventh line ends the `for` loop. \n\nThe twelfth line returns the output list `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)\n    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list -35 34 12 -45)) -35 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef FUNC_0(VAR_0: List[int]) -> Optional[int]:\n    VAR_0 = sorted(set(VAR_0))\n    return (None if (len(VAR_0) < 2) else VAR_0[1])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the second smallest integer in the list. \n\n1. The first line imports the List and Optional types from the typing module. The List type is used to specify that the input to the function is a list of integers, while the Optional type is used to specify that the output of the function is either an integer or None.\n\n2. The second line defines a function named FUNC_0 that takes a single argument VAR_0, which is a list of integers. \n\n3. The third line sorts the input list VAR_0 in ascending order and removes any duplicates using the set() function. The sorted() function returns a new sorted list, which is then assigned back to VAR_0.\n\n4. The fourth line returns None if the length of the sorted list VAR_0 is less than 2, which means there is no second smallest integer in the list. Otherwise, it returns the second element of the sorted list VAR_0, which is the second smallest integer in the list. \n\n5. The function definition ends.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 4) (list 1 0) (list 2 5) (list 2 0)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6)) 2) (list (list 0 1) (list 1 1) (list 2 1) (list 3 1) (list 4 1) (list 5 1)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 1 3 4 5 6) (list 1 2 1 4 5 6) (list 1 2 3 1 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 0) (list 2 1) (list 2 0) (list 3 2) (list 3 0) (list 4 3) (list 4 0) (list 5 4) (list 5 0) (list 6 5) (list 6 0)) 0.001)\n    (check-within (candidate (list ) 1) (list ) 0.001)\n    (check-within (candidate (list (list 1)) 2) (list ) 0.001)\n    (check-within (candidate (list (list ) (list 1) (list 1 2 3)) 3) (list (list 2 2)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\n\ndef FUNC_0(VAR_0: List[List[int]], VAR_1: int) -> List[Tuple[(int, int)]]:\n    VAR_2 = [(VAR_3, VAR_4) for VAR_3 in range(len(VAR_0)) for VAR_4 in range(len(VAR_0[VAR_3])) if (VAR_0[VAR_3][VAR_4] == VAR_1)]\n    return sorted(sorted(VAR_2, key=(lambda VAR_1: VAR_1[1]), reverse=True), key=(lambda VAR_1: VAR_1[0]))\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of lists of integers and an integer as input and returns a list of tuples of integers. The function is defined with the name FUNC_0 and takes two arguments: VAR_0, which is a list of lists of integers, and VAR_1, which is an integer. The function returns a list of tuples of integers.\n\nThe first line of the code imports the List and Tuple classes from the typing module.\n\nThe second line of the code defines the function FUNC_0. The function takes two arguments: VAR_0, which is a list of lists of integers, and VAR_1, which is an integer. The function returns a list of tuples of integers.\n\nThe third line of the code initializes a variable VAR_2 with a list comprehension. The list comprehension iterates over the indices of the rows and columns of VAR_0 and creates a tuple of the row index and column index if the value at that index is equal to VAR_1.\n\nThe fourth line of the code returns VAR_2 sorted first by the second element of each tuple in descending order and then by the first element of each tuple in ascending order. The sorting is done using the sorted function and two lambda functions that extract the second and first element of each tuple, respectively. The reverse parameter of the sorted function is set to True to sort the second element of each tuple in descending order. The result is a list of tuples of integers sorted by the second element of each tuple in descending order and then by the first element of each tuple in ascending order.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str], VAR_1: str) -> List[str]:\n    return [VAR_2 for VAR_2 in VAR_0 if VAR_2.startswith(VAR_1)]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings and a string as input, and returns a list of strings that start with the input string. \n\n- `from typing import List` imports the List class from the typing module. \n- `def FUNC_0(VAR_0: List[str], VAR_1: str) -> List[str]:` defines a function called FUNC_0 that takes two arguments: VAR_0, a list of strings, and VAR_1, a string. The function returns a list of strings. \n- `return [VAR_2 for VAR_2 in VAR_0 if VAR_2.startswith(VAR_1)]` returns a list comprehension that iterates over each string in VAR_0 and checks if it starts with VAR_1. If it does, the string is added to the list that is returned.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 12 15) 14 0.001)\n    (check-within (candidate 13 12) -1 0.001)\n    (check-within (candidate 33 12354) 12354 0.001)\n    (check-within (candidate 5234 5233) -1 0.001)\n    (check-within (candidate 6 29) 28 0.001)\n    (check-within (candidate 27 10) -1 0.001)\n    (check-within (candidate 7 7) -1 0.001)\n    (check-within (candidate 546 546) 546 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> int:\n    if (VAR_0 > VAR_1):\n        return (- 1)\n    if ((VAR_1 % 2) == 0):\n        return VAR_1\n    if (VAR_0 == VAR_1):\n        return (- 1)\n    return (VAR_1 - 1)\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns an integer. Here is a line-by-line explanation of what the code does:\n\n```python\ndef FUNC_0(VAR_0: int, VAR_1: int) -> int:\n```\nThis line defines a function named `FUNC_0` that takes two integer arguments, `VAR_0` and `VAR_1`, and returns an integer.\n\n```python\n    if (VAR_0 > VAR_1):\n        return (- 1)\n```\nThis line checks if `VAR_0` is greater than `VAR_1`. If it is, the function returns `-1`.\n\n```python\n    if ((VAR_1 % 2) == 0):\n        return VAR_1\n```\nThis line checks if `VAR_1` is even. If it is, the function returns `VAR_1`.\n\n```python\n    if (VAR_0 == VAR_1):\n        return (- 1)\n```\nThis line checks if `VAR_0` is equal to `VAR_1`. If it is, the function returns `-1`.\n\n```python\n    return (VAR_1 - 1)\n```\nThis line returns `VAR_1 - 1`. If none of the previous conditions were met, this is the value that the function returns.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Hello\") #t 0.001)\n    (check-within (candidate \"abcdcba\") #t 0.001)\n    (check-within (candidate \"kittens\") #t 0.001)\n    (check-within (candidate \"orange\") #f 0.001)\n    (check-within (candidate \"wow\") #t 0.001)\n    (check-within (candidate \"world\") #t 0.001)\n    (check-within (candidate \"MadaM\") #t 0.001)\n    (check-within (candidate \"Wow\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"HI\") #t 0.001)\n    (check-within (candidate \"go\") #t 0.001)\n    (check-within (candidate \"gogo\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaa\") #f 0.001)\n    (check-within (candidate \"Madam\") #t 0.001)\n    (check-within (candidate \"M\") #f 0.001)\n    (check-within (candidate \"0\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> bool:\n    VAR_1 = len(VAR_0)\n    if ((VAR_1 == 0) or (VAR_1 == 1)):\n        return False\n    for VAR_2 in range(2, VAR_1):\n        if ((VAR_1 % VAR_2) == 0):\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a given string is a prime number. \n\n```python\ndef FUNC_0(VAR_0: str) -> bool:\n```\nThis line defines a function called `FUNC_0` that takes a string as input and returns a boolean value. \n\n```python\nVAR_1 = len(VAR_0)\n```\nThis line calculates the length of the input string and assigns it to a variable called `VAR_1`.\n\n```python\nif ((VAR_1 == 0) or (VAR_1 == 1)):\n    return False\n```\nThis line checks if the length of the input string is either 0 or 1. If it is, then the function returns `False` because a string of length 0 or 1 cannot be a prime number.\n\n```python\nfor VAR_2 in range(2, VAR_1):\n    if ((VAR_1 % VAR_2) == 0):\n        return False\n```\nThis line starts a loop that iterates over all numbers from 2 to the length of the input string minus 1. For each number, it checks if the length of the input string is divisible by that number. If it is, then the function returns `False` because a prime number can only be divisible by 1 and itself.\n\n```python\nreturn True\n```\nIf the loop completes without finding any divisors of the length of the input string, then the function returns `True` because the input string is a prime number.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 6) 21 0.001)\n    (check-within (candidate 11) 66 0.001)\n    (check-within (candidate 30) 465 0.001)\n    (check-within (candidate 100) 5050 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    return sum(range((VAR_0 + 1)))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer `VAR_0` as input and returns an integer. \n\nThe function returns the sum of all integers from 0 to `VAR_0` (inclusive). \n\nThe `sum` function is a built-in Python function that returns the sum of all elements in an iterable. \n\nThe `range` function is a built-in Python function that returns a sequence of numbers from 0 to `VAR_0` (exclusive). \n\nThe `VAR_0 + 1` argument passed to the `range` function is used to ensure that the sequence includes the number `VAR_0`. \n\nTherefore, the `sum(range((VAR_0 + 1)))` expression calculates the sum of all integers from 0 to `VAR_0` (inclusive). \n\nThe `-> int` syntax in the function definition specifies that the function returns an integer. \n\nThe `: int` syntax in the function definition specifies that the `VAR_0` parameter is an integer. \n\nOverall, the function calculates the sum of all integers from 0 to `VAR_0` (inclusive) and returns the result as an integer.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Example\") \"Example\" 0.001)\n    (check-within (candidate \"Mudasir Hanif \") \"Mudasir_Hanif_\" 0.001)\n    (check-within (candidate \"Yellow Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\" 0.001)\n    (check-within (candidate \"Exa   mple\") \"Exa-mple\" 0.001)\n    (check-within (candidate \"   Exa 1 2 2 mple\") \"-Exa_1_2_2_mple\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    VAR_1 = ''\n    VAR_2 = 0\n    (VAR_3, VAR_4) = (0, 0)\n    while (VAR_2 < len(VAR_0)):\n        if (VAR_0[VAR_2] == ' '):\n            VAR_4 += 1\n        else:\n            if ((VAR_4 - VAR_3) > 2):\n                VAR_1 += ('-' + VAR_0[VAR_2])\n            elif ((VAR_4 - VAR_3) > 0):\n                VAR_1 += (('_' * (VAR_4 - VAR_3)) + VAR_0[VAR_2])\n            else:\n                VAR_1 += VAR_0[VAR_2]\n            (VAR_3, VAR_4) = ((VAR_2 + 1), (VAR_2 + 1))\n        VAR_2 += 1\n    if ((VAR_4 - VAR_3) > 2):\n        VAR_1 += '-'\n    elif ((VAR_4 - VAR_3) > 0):\n        VAR_1 += '_'\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes a string as input and returns a string as output. The function takes a string and converts it to a string that is formatted in a specific way. \n\nThe function starts by initializing three variables: VAR_1, VAR_2, VAR_3, and VAR_4. VAR_1 is an empty string, VAR_2 is set to 0, and VAR_3 and VAR_4 are both set to 0. \n\nThe function then enters a while loop that continues as long as VAR_2 is less than the length of the input string. \n\nInside the while loop, the function checks if the character at the current index of the input string is a space. If it is, VAR_4 is incremented by 1. If it is not, the function checks if the difference between VAR_4 and VAR_3 is greater than 2. If it is, the function adds a hyphen followed by the current character to VAR_1. If the difference between VAR_4 and VAR_3 is greater than 0 but less than or equal to 2, the function adds a number of underscores equal to the difference between VAR_4 and VAR_3, followed by the current character to VAR_1. If the difference between VAR_4 and VAR_3 is 0, the function simply adds the current character to VAR_1. After adding the character to VAR_1, VAR_3 and VAR_4 are both set to VAR_2 + 1.\n\nAfter the while loop has finished, the function checks if the difference between VAR_4 and VAR_3 is greater than 2. If it is, the function adds a hyphen to VAR_1. If the difference between VAR_4 and VAR_3 is greater than 0 but less than or equal to 2, the function adds a number of underscores equal to the difference between VAR_4 and VAR_3, followed by a hyphen to VAR_1. If the difference between VAR_4 and VAR_3 is 0, the function simply adds a hyphen to VAR_1.\n\nFinally, the function returns VAR_1. \n\nIn summary, the function takes a string and converts it to a string that is formatted in a specific way. The function replaces spaces with hyphens and underscores, with the number of underscores depending on the number of spaces between two non-space characters. The function also adds a hyphen or underscores at the end of the string, depending on the number of spaces between the last non-space character and the end of the string.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)\n    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    VAR_1 = None\n    VAR_2 = []\n    for VAR_3 in VAR_0:\n        if (VAR_1 is None):\n            VAR_1 = VAR_3\n        else:\n            VAR_1 = max(VAR_1, VAR_3)\n        VAR_2.append(VAR_1)\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a list of integers as output. The function is called `FUNC_0` and takes one argument, which is a list of integers called `VAR_0`. The function returns a list of integers called `VAR_2`.\n\nThe first line of the code imports two types from the `typing` module: `List` and `Tuple`. These types are used to specify the types of the input and output of the function.\n\nThe second line of the code defines the function `FUNC_0`. The function takes one argument, which is a list of integers called `VAR_0`, and returns a list of integers called `VAR_2`.\n\nThe third line of the code initializes a variable called `VAR_1` to `None`.\n\nThe fourth line of the code initializes an empty list called `VAR_2`.\n\nThe fifth line of the code starts a `for` loop that iterates over each element in the input list `VAR_0`. The loop variable is called `VAR_3`.\n\nThe sixth line of the code checks if the variable `VAR_1` is `None`. If it is, then the loop variable `VAR_3` is assigned to `VAR_1`.\n\nThe seventh line of the code is an `else` statement that executes if the variable `VAR_1` is not `None`. In this case, the maximum value between `VAR_1` and `VAR_3` is assigned to `VAR_1`.\n\nThe eighth line of the code appends the value of `VAR_1` to the list `VAR_2`.\n\nThe ninth line of the code returns the list `VAR_2`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"This is a test\") \"is\" 0.001)\n    (check-within (candidate \"lets go for swimming\") \"go for\" 0.001)\n    (check-within (candidate \"there is no place available here\") \"there is no place\" 0.001)\n    (check-within (candidate \"Hi I am Hussein\") \"Hi am Hussein\" 0.001)\n    (check-within (candidate \"go for it\") \"go for it\" 0.001)\n    (check-within (candidate \"here\") \"\" 0.001)\n    (check-within (candidate \"here is\") \"is\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    VAR_1 = []\n    for VAR_2 in VAR_0.split():\n        VAR_3 = 0\n        if (len(VAR_2) == 1):\n            VAR_3 = 1\n        for VAR_4 in range(2, len(VAR_2)):\n            if ((len(VAR_2) % VAR_4) == 0):\n                VAR_3 = 1\n        if ((VAR_3 == 0) or (len(VAR_2) == 2)):\n            VAR_1.append(VAR_2)\n    return ' '.join(VAR_1)\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a string. The function is named FUNC_0 and takes a single argument, VAR_0, which is a string. The function returns a string.\n\nThe function starts by initializing an empty list, VAR_1, which will be used to store the words in the input string that are prime numbers. \n\nThe function then enters a for loop that iterates over each word in the input string. The for loop splits the input string into a list of words using the split() method. The loop variable VAR_2 is assigned to each word in the list.\n\nThe function then initializes a variable VAR_3 to 0. This variable will be used to keep track of whether the current word is a prime number or not.\n\nThe function then enters another for loop that iterates over each number from 2 to the length of the current word. The loop variable VAR_4 is assigned to each number in the range.\n\nThe function then checks if the length of the current word is divisible by VAR_4. If it is, then VAR_3 is set to 1, indicating that the current word is not a prime number.\n\nAfter the second for loop, the function checks if VAR_3 is equal to 0 or if the length of the current word is equal to 2. If either of these conditions is true, then the current word is a prime number and it is appended to the VAR_1 list.\n\nFinally, the function returns a string that is created by joining the words in the VAR_1 list with a space character using the join() method.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_160_do_algebra",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_160_do_algebra.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list \"**\" \"*\" \"+\") (list 2 3 4 5)) 37 0.001)\n    (check-within (candidate (list \"+\" \"*\" \"-\") (list 2 3 4 5)) 9 0.001)\n    (check-within (candidate (list \"//\" \"*\") (list 7 3 4)) 8 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str], VAR_1: List[int]) -> int:\n    VAR_2 = str(VAR_1[0])\n    for (VAR_3, VAR_4) in zip(VAR_0, VAR_1[1:]):\n        VAR_2 += (VAR_3 + str(VAR_4))\n    return eval(VAR_2)\n\n### Explanation\n\nThe code is an implementation of a function that takes in two lists, one of strings and one of integers, and returns an integer. \n\nThe first line imports the List class from the typing module.\n\nThe second line defines a function called FUNC_0 that takes in two arguments: VAR_0, which is a list of strings, and VAR_1, which is a list of integers. The function returns an integer.\n\nThe third line creates a new variable called VAR_2 and sets it equal to the string representation of the first integer in VAR_1.\n\nThe fourth line starts a for loop that iterates over the two lists in parallel using the zip function. The loop variable VAR_3 represents the current string in VAR_0, and VAR_4 represents the current integer in VAR_1 starting from the second integer.\n\nThe fifth line concatenates VAR_3 and the string representation of VAR_4 to VAR_2.\n\nThe sixth line evaluates the resulting string as a Python expression and returns the result as an integer. \n\nOverall, the function concatenates the string representation of the first integer in VAR_1 with each string in VAR_0 followed by the string representation of the corresponding integer in VAR_1, and then evaluates the resulting string as a Python expression to obtain the final integer result.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"yogurt\") \"u\" 0.001)\n    (check-within (candidate \"full\") \"u\" 0.001)\n    (check-within (candidate \"easy\") \"\" 0.001)\n    (check-within (candidate \"eAsy\") \"\" 0.001)\n    (check-within (candidate \"ali\") \"\" 0.001)\n    (check-within (candidate \"bad\") \"a\" 0.001)\n    (check-within (candidate \"most\") \"o\" 0.001)\n    (check-within (candidate \"ab\") \"\" 0.001)\n    (check-within (candidate \"ba\") \"\" 0.001)\n    (check-within (candidate \"quick\") \"\" 0.001)\n    (check-within (candidate \"anime\") \"VAR_2\" 0.001)\n    (check-within (candidate \"Asia\") \"\" 0.001)\n    (check-within (candidate \"Above\") \"o\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    if (len(VAR_0) < 3):\n        return ''\n    VAR_1 = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'O', 'U', 'I'}\n    for VAR_2 in range((len(VAR_0) - 2), 0, (- 1)):\n        if (VAR_0[VAR_2] in VAR_1):\n            if ((VAR_0[(VAR_2 + 1)] not in VAR_1) and (VAR_0[(VAR_2 - 1)] not in VAR_1)):\n                return VAR_0[VAR_2]\n    return ''\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in a string `VAR_0` and returns a string. \n\n1. `def FUNC_0(VAR_0: str) -> str:` defines the function `FUNC_0` that takes in a string `VAR_0` and returns a string. \n\n2. `if (len(VAR_0) < 3):` checks if the length of the input string is less than 3. If it is, the function returns an empty string.\n\n3. `VAR_1 = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'O', 'U', 'I'}` creates a set of vowels.\n\n4. `for VAR_2 in range((len(VAR_0) - 2), 0, (- 1)):` iterates through the input string from the second to the last character to the second character in reverse order.\n\n5. `if (VAR_0[VAR_2] in VAR_1):` checks if the current character is a vowel.\n\n6. `if ((VAR_0[(VAR_2 + 1)] not in VAR_1) and (VAR_0[(VAR_2 - 1)] not in VAR_1)):` checks if the next and previous characters are not vowels.\n\n7. `return VAR_0[VAR_2]` returns the current character if it is a vowel and the next and previous characters are not vowels.\n\n8. `return ''` returns an empty string if no character is found that satisfies the conditions in the for loop. \n\nThe function essentially returns the last vowel in the input string that has two consonants on either side of it. If no such vowel exists, it returns an empty string.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)\n    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: List[int]) -> List[int]:\n    return [abs((VAR_2 - VAR_3)) for (VAR_2, VAR_3) in zip(VAR_0, VAR_1)]\n\n### Explanation\n\nThe code is an implementation of a function that takes two lists of integers as input and returns a list of integers as output. The function is defined with the name FUNC_0 and takes two arguments, VAR_0 and VAR_1, both of which are lists of integers. The function returns a list of integers. \n\nThe function uses a list comprehension to create a new list of integers. The list comprehension iterates over the two input lists in parallel using the zip function. The zip function returns an iterator that aggregates elements from each of the input lists. In this case, the iterator returns pairs of integers, one from each input list. \n\nThe list comprehension uses the pairs of integers to calculate the absolute difference between the two integers in each pair using the abs function. The result is a list of integers that represents the absolute difference between the corresponding elements of the two input lists. \n\nFinally, the list of integers is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    import collections\n    VAR_1 = collections.Counter(VAR_0)\n    return [VAR_2 for VAR_2 in VAR_0 if (VAR_1[VAR_2] <= 1)]\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of integers as input and returns a list of integers that only appear once in the input list. \n\n```python\nfrom typing import List\n```\nThis line imports the `List` type from the `typing` module. The `List` type is a generic type that represents a list of elements of a certain type. \n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nThis line defines a function called `FUNC_0` that takes a single argument `VAR_0`, which is a list of integers. The function returns a list of integers. \n\n```python\nimport collections\n```\nThis line imports the `collections` module, which provides a `Counter` class that can be used to count the occurrences of elements in a list. \n\n```python\nVAR_1 = collections.Counter(VAR_0)\n```\nThis line creates a `Counter` object called `VAR_1` that counts the occurrences of each element in the input list `VAR_0`. \n\n```python\nreturn [VAR_2 for VAR_2 in VAR_0 if (VAR_1[VAR_2] <= 1)]\n```\nThis line returns a list comprehension that iterates over each element `VAR_2` in the input list `VAR_0`. The list comprehension only includes elements that appear once or not at all in the input list. The condition `(VAR_1[VAR_2] <= 1)` checks if the count of the element `VAR_2` in the `VAR_1` counter is less than or equal to 1. If the count is less than or equal to 1, the element is included in the output list. Otherwise, it is excluded.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabc\") #t 0.001)\n    (check-within (candidate \"dddddddabc\" \"abcd\") #t 0.001)\n    (check-within (candidate \"eabcd\" \"dddddddabc\") #f 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabcf\") #f 0.001)\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f 0.001)\n    (check-within (candidate \"aabb\" \"aaccc\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str, VAR_1: str) -> bool:\n    return (set(VAR_0) == set(VAR_1))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` which takes in two string arguments `VAR_0` and `VAR_1` and returns a boolean value. \n\nThe function compares the two strings by converting them to sets and checking if the sets are equal. If the sets are equal, it means that the two strings have the same characters, regardless of the order in which they appear. If the sets are not equal, it means that the two strings have different characters.\n\nThe `set()` function is used to convert the strings to sets. A set is an unordered collection of unique elements. By converting the strings to sets, we can compare them without worrying about the order of the characters.\n\nThe `==` operator is used to check if the two sets are equal. If they are equal, the function returns `True`. If they are not equal, the function returns `False`.\n\nThe `-> bool` syntax at the end of the function definition specifies the return type of the function. In this case, the function returns a boolean value.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3) 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4) 0.001)\n    (check-within (candidate \"(()(())((())))\") (list 4) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str) -> List[int]:\n\n    def FUNC_1(VAR_1):\n        VAR_2 = 0\n        VAR_3 = 0\n        for VAR_4 in VAR_1:\n            if (VAR_4 == '('):\n                VAR_2 += 1\n                VAR_3 = max(VAR_2, VAR_3)\n            else:\n                VAR_2 -= 1\n        return VAR_3\n    return [FUNC_1(VAR_5) for VAR_5 in VAR_0.split(' ') if VAR_5]\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as an input and returns a list of integers. \n\n1. `from typing import List` - Importing the List module from the typing library. This is used to specify the type of the output of the function.\n\n2. `def FUNC_0(VAR_0: str) -> List[int]:` - Defining a function called FUNC_0 that takes a string as an input and returns a list of integers. \n\n3. `def FUNC_1(VAR_1):` - Defining a nested function called FUNC_1 that takes a list as an input.\n\n4. `VAR_2 = 0` - Initializing a variable called VAR_2 to 0.\n\n5. `VAR_3 = 0` - Initializing a variable called VAR_3 to 0.\n\n6. `for VAR_4 in VAR_1:` - Looping through each element in the input list.\n\n7. `if (VAR_4 == '('):` - Checking if the current element is an opening parenthesis.\n\n8. `VAR_2 += 1` - If the current element is an opening parenthesis, increment VAR_2 by 1.\n\n9. `VAR_3 = max(VAR_2, VAR_3)` - If VAR_2 is greater than VAR_3, set VAR_3 to VAR_2.\n\n10. `else:` - If the current element is not an opening parenthesis.\n\n11. `VAR_2 -= 1` - Decrement VAR_2 by 1.\n\n12. `return VAR_3` - Return the value of VAR_3.\n\n13. `return [FUNC_1(VAR_5) for VAR_5 in VAR_0.split(' ') if VAR_5]` - Return a list of integers generated by applying FUNC_1 to each element of the input string that is not an empty string. \n\nThe function FUNC_1 takes a list as an input and returns the maximum depth of nested parentheses in the list. The function FUNC_0 applies FUNC_1 to each element of the input string that is not an empty string and returns a list of integers.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 7) (list 0 1) 0.001)\n    (check-within (candidate -78) (list 1 1) 0.001)\n    (check-within (candidate 3452) (list 2 2) 0.001)\n    (check-within (candidate 346211) (list 3 3) 0.001)\n    (check-within (candidate -345821) (list 3 3) 0.001)\n    (check-within (candidate -2) (list 1 0) 0.001)\n    (check-within (candidate -45347) (list 2 3) 0.001)\n    (check-within (candidate 0) (list 1 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef FUNC_0(VAR_0: int) -> Tuple[(int, int)]:\n    VAR_1 = 0\n    VAR_2 = 0\n    for VAR_3 in str(abs(VAR_0)):\n        if ((int(VAR_3) % 2) == 0):\n            VAR_1 += 1\n        else:\n            VAR_2 += 1\n    return (VAR_1, VAR_2)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer `VAR_0` as input and returns a tuple of two integers. The function calculates the number of even and odd digits in the absolute value of `VAR_0` and returns them as a tuple.\n\nThe first line of the code imports the `Tuple` class from the `typing` module. This is used to specify the type of the return value of the function.\n\nThe second line defines the function `FUNC_0` that takes an integer `VAR_0` as input and returns a tuple of two integers. The `-> Tuple[(int, int)]` specifies the return type of the function.\n\nThe third line initializes two variables `VAR_1` and `VAR_2` to zero.\n\nThe fourth line starts a `for` loop that iterates over each character in the string representation of the absolute value of `VAR_0`. The `abs()` function is used to ensure that the absolute value of `VAR_0` is used.\n\nThe fifth line checks if the current character is an even digit. If it is, the value of `VAR_1` is incremented by 1. If it is not, the value of `VAR_2` is incremented by 1.\n\nThe sixth line returns a tuple of `VAR_1` and `VAR_2`. The parentheses around `VAR_1, VAR_2` are optional in Python, but are included here for clarity.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"5 apples and 6 oranges\" 19) 8 0.001)\n    (check-within (candidate \"5 apples and 6 oranges\" 21) 10 0.001)\n    (check-within (candidate \"0 apples and 1 oranges\" 3) 2 0.001)\n    (check-within (candidate \"1 apples and 0 oranges\" 3) 2 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 100) 95 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 5) 0 0.001)\n    (check-within (candidate \"1 apples and 100 oranges\" 120) 19 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str, VAR_1: int) -> int:\n    VAR_2 = list()\n    for VAR_3 in VAR_0.split(' '):\n        if VAR_3.isdigit():\n            VAR_2.append(int(VAR_3))\n    return (VAR_1 - sum(VAR_2))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two arguments, a string `VAR_0` and an integer `VAR_1`, and returns an integer. \n\nThe function first initializes an empty list called `VAR_2`. \n\nThen, it loops through each word in the string `VAR_0` that is separated by a space. \n\nFor each word, it checks if the word is a digit using the `isdigit()` method. If the word is a digit, it converts the word to an integer using the `int()` function and appends it to the list `VAR_2`.\n\nFinally, the function returns the result of subtracting the sum of the integers in `VAR_2` from `VAR_1`. \n\nIn summary, the function takes a string of words separated by spaces, extracts all the integers from the string, adds them up, and subtracts the sum from a given integer.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"111000\" \"101010\") \"010010\" 0.001)\n    (check-within (candidate \"1\" \"1\") \"0\" 0.001)\n    (check-within (candidate \"0101\" \"0000\") \"0101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str, VAR_1: str) -> str:\n\n    def FUNC_1(VAR_2, VAR_3):\n        if (VAR_2 == VAR_3):\n            return '0'\n        else:\n            return '1'\n    return ''.join((FUNC_1(VAR_4, VAR_5) for (VAR_4, VAR_5) in zip(VAR_0, VAR_1)))\n\n### Explanation\n\nThe code is an implementation of the XOR operation on two strings. The function takes in two strings as input and returns a string as output. The function is defined with the name FUNC_0 and takes in two arguments VAR_0 and VAR_1, both of which are strings. The function returns a string.\n\nThe function contains another function called FUNC_1. FUNC_1 takes in two arguments VAR_2 and VAR_3. The function checks if VAR_2 is equal to VAR_3. If VAR_2 is equal to VAR_3, the function returns '0'. If VAR_2 is not equal to VAR_3, the function returns '1'.\n\nThe function FUNC_0 returns a string that is the result of applying FUNC_1 to each pair of characters in the input strings. The function uses the zip function to iterate over the characters in the input strings in parallel. The join function is used to concatenate the results of the FUNC_1 function into a single string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"x\") 1 0.001)\n    (check-within (candidate \"asdasnakj\") 9 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    return len(VAR_0)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in a string argument `VAR_0` and returns an integer. The integer returned is the length of the string `VAR_0`. \n\nThe `def` keyword is used to define a function in Python. `FUNC_0` is the name of the function. `VAR_0` is the name of the argument passed to the function. `str` is the type annotation for the argument, which specifies that the argument should be a string. `-> int` is the type annotation for the return value, which specifies that the function should return an integer.\n\nThe `return` keyword is used to return a value from the function. `len(VAR_0)` is the value that is returned. `len()` is a built-in Python function that returns the length of a string. `VAR_0` is the argument passed to the `len()` function. \n\nIn summary, the function takes a string as input and returns the length of the string as an integer.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 0) \"0\" 0.001)\n    (check-within (candidate 3) \"0 1 2 3\" 0.001)\n    (check-within (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> str:\n    return ' '.join([str(VAR_1) for VAR_1 in range((VAR_0 + 1))])\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes an integer argument VAR_0 and returns a string. The string is a concatenation of all integers from 0 to VAR_0 (inclusive) separated by a space. \n\nThe function is defined using the `def` keyword, followed by the function name `FUNC_0`, and the argument `VAR_0` which is of type `int`. The `-> str` syntax specifies that the function returns a string. \n\nThe function body consists of a single line that uses a list comprehension to generate a list of integers from 0 to VAR_0 (inclusive). The `range` function is used to generate a sequence of integers from 0 to VAR_0 (inclusive). The `join` method is then called on the string ' ' (a space) to join the list of integers into a single string separated by spaces. The resulting string is then returned by the function. \n\nIn summary, the function takes an integer argument VAR_0, generates a string of all integers from 0 to VAR_0 (inclusive) separated by spaces, and returns the resulting string.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_141_file_name_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"example.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"1example.dll\") \"No\" 0.001)\n    (check-within (candidate \"s1sdf3.asd\") \"No\" 0.001)\n    (check-within (candidate \"K.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"MY16FILE3.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"His12FILE94.exe\") \"No\" 0.001)\n    (check-within (candidate \"_Y.txt\") \"No\" 0.001)\n    (check-within (candidate \"?aREYA.exe\") \"No\" 0.001)\n    (check-within (candidate \"/this_is_valid.dll\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.wow\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"this_is_valid.txtexe\") \"No\" 0.001)\n    (check-within (candidate \"#this2_i4s_5valid.ten\") \"No\" 0.001)\n    (check-within (candidate \"@this1_is6_valid.exe\") \"No\" 0.001)\n    (check-within (candidate \"this_is_12valid.6exe4.txt\") \"No\" 0.001)\n    (check-within (candidate \"all.exe.txt\") \"No\" 0.001)\n    (check-within (candidate \"I563_No.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"Is3youfault.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"no_one#knows.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"1I563_Yes3.exe\") \"No\" 0.001)\n    (check-within (candidate \"I563_Yes3.txtt\") \"No\" 0.001)\n    (check-within (candidate \"final..txt\") \"No\" 0.001)\n    (check-within (candidate \"final132\") \"No\" 0.001)\n    (check-within (candidate \"_f4indsartal132.\") \"No\" 0.001)\n    (check-within (candidate \".txt\") \"No\" 0.001)\n    (check-within (candidate \"s.\") \"No\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    VAR_1 = ['txt', 'exe', 'dll']\n    VAR_2 = VAR_0.split(sep='.')\n    if (len(VAR_2) != 2):\n        return 'No'\n    if (not (VAR_2[1] in VAR_1)):\n        return 'No'\n    if (len(VAR_2[0]) == 0):\n        return 'No'\n    if (not VAR_2[0][0].isalpha()):\n        return 'No'\n    VAR_3 = len([VAR_4 for VAR_4 in VAR_2[0] if VAR_4.isdigit()])\n    if (VAR_3 > 3):\n        return 'No'\n    return 'Yes'\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string argument `VAR_0` and returns a string. The function checks if the input string is a valid file name with the extension `.txt`, `.exe`, or `.dll`. If the input string is a valid file name, the function returns `'Yes'`, otherwise it returns `'No'`.\n\n1. `def FUNC_0(VAR_0: str) -> str:`\n\n    This line defines the function `FUNC_0` that takes a string argument `VAR_0` and returns a string. The `-> str` indicates that the function returns a string.\n\n2. `VAR_1 = ['txt', 'exe', 'dll']`\n\n    This line creates a list of valid file extensions called `VAR_1`. The list contains the strings `'txt'`, `'exe'`, and `'dll'`.\n\n3. `VAR_2 = VAR_0.split(sep='.')`\n\n    This line splits the input string `VAR_0` into two parts: the file name and the file extension. The `sep='.'` argument specifies that the string should be split at the period character.\n\n4. `if (len(VAR_2) != 2):`\n\n    This line checks if the input string has exactly one period character. If the length of `VAR_2` is not equal to 2, then the function returns `'No'`.\n\n5. `if (not (VAR_2[1] in VAR_1)):`\n\n    This line checks if the file extension is valid. If the second element of `VAR_2` (which is the file extension) is not in the list `VAR_1`, then the function returns `'No'`.\n\n6. `if (len(VAR_2[0]) == 0):`\n\n    This line checks if the file name is empty. If the length of the first element of `VAR_2` (which is the file name) is equal to 0, then the function returns `'No'`.\n\n7. `if (not VAR_2[0][0].isalpha()):`\n\n    This line checks if the first character of the file name is a letter. If the first character of the first element of `VAR_2` (which is the file name) is not a letter, then the function returns `'No'`.\n\n8. `VAR_3 = len([VAR_4 for VAR_4 in VAR_2[0] if VAR_4.isdigit()])`\n\n    This line counts the number of digits in the file name. It creates a list of all the characters in the first element of `VAR_2` that are digits, and then takes the length of that list.\n\n9. `if (VAR_3 > 3):`\n\n    This line checks if the number of digits in the file name is greater than 3. If `VAR_3` is greater than 3, then the function returns `'No'`.\n\n10. `return 'Yes'`\n\n    This line returns `'Yes'` if the input string is a valid file name. If any of the previous checks fail, then the function returns `'No'`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)\n    (check-within (candidate (list 1 2 4 5)) -1 0.001)\n    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)\n    (check-within (candidate (list )) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    VAR_1 = (- 1)\n    VAR_2 = 1\n    while (VAR_2 < len(VAR_0)):\n        if (VAR_0[VAR_2] < VAR_0[(VAR_2 - 1)]):\n            VAR_1 = VAR_2\n        VAR_2 += 1\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns the index of the first element in the list that is smaller than the previous element. \n\n1. `from typing import List` - import the List class from the typing module\n2. `def FUNC_0(VAR_0: List[int]) -> int:` - define a function named FUNC_0 that takes in a list of integers named VAR_0 as an argument and returns an integer\n3. `VAR_1 = (- 1)` - initialize a variable named VAR_1 to -1\n4. `VAR_2 = 1` - initialize a variable named VAR_2 to 1\n5. `while (VAR_2 < len(VAR_0)):` - while VAR_2 is less than the length of VAR_0, do the following:\n6. `if (VAR_0[VAR_2] < VAR_0[(VAR_2 - 1)]):` - if the current element in VAR_0 is less than the previous element in VAR_0, do the following:\n7. `VAR_1 = VAR_2` - set VAR_1 to VAR_2\n8. `VAR_2 += 1` - increment VAR_2 by 1\n9. `return VAR_1` - return VAR_1, which is the index of the first element in VAR_0 that is smaller than the previous element. \n\nThe function works by iterating through the list of integers and checking if the current element is smaller than the previous element. If it is, the index of the current element is stored in VAR_1. Once the loop is finished, VAR_1 is returned. If no element in the list is smaller than the previous element, VAR_1 will still be -1, which is the initial value assigned to it.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 4 88)) 88 0.001)\n    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)\n    (check-within (candidate (list 4 0 6 7)) 0 0.001)\n    (check-within (candidate (list 4 4 6 8)) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    return sum([VAR_0[VAR_1] for VAR_1 in range(1, len(VAR_0), 2) if ((VAR_0[VAR_1] % 2) == 0)])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns the sum of all even-indexed even integers in the list. \n\n1. The first line imports the List class from the typing module, which is used to define the type of the input parameter of the function. \n2. The second line defines a function named FUNC_0 that takes a list of integers as input and returns an integer. \n3. The third line uses a list comprehension to create a new list containing all even-indexed even integers in the input list. \n4. The list comprehension iterates over the range of indices in the input list, starting at index 1 and incrementing by 2, which selects only the even-indexed elements. \n5. The if statement inside the list comprehension checks if the selected element is even, using the modulo operator to check if the remainder of the element divided by 2 is 0. \n6. The selected elements are added together using the sum function, which returns the sum of all elements in the list. \n7. The result of the sum function is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list ) 7) (list ) 0.001)\n    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)\n    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> List[int]:\n    if (not VAR_0):\n        return []\n    VAR_2 = []\n    for VAR_3 in VAR_0[:(- 1)]:\n        VAR_2.append(VAR_3)\n        VAR_2.append(VAR_1)\n    VAR_2.append(VAR_0[(- 1)])\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and an integer as input and returns a new list of integers. The function is defined with the name FUNC_0 and takes two arguments VAR_0 and VAR_1. VAR_0 is a list of integers and VAR_1 is an integer.\n\nThe first line imports the List class from the typing module. This is used to define the type of the input and output of the function.\n\nThe second line defines the function FUNC_0. It takes two arguments VAR_0 and VAR_1, both of which are typed. The return type of the function is also defined as a List of integers.\n\nThe third line checks if the input list VAR_0 is empty. If it is, the function returns an empty list.\n\nThe fourth line initializes an empty list VAR_2.\n\nThe fifth line starts a for loop that iterates over all elements of the input list VAR_0 except the last one. The loop variable is named VAR_3.\n\nThe sixth and seventh lines append VAR_3 and VAR_1 to the list VAR_2.\n\nThe eighth line appends the last element of the input list VAR_0 to the list VAR_2.\n\nThe ninth line returns the new list VAR_2.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list \"()(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \")\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(())\" \"())())\")) \"No\" 0.001)\n    (check-within (candidate (list \")())\" \"(()()(\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"(())))\" \"(()())((\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"()\" \"())\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(\" \"()))()\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"((((\" \"((())\")) \"No\" 0.001)\n    (check-within (candidate (list \")(()\" \"(()(\")) \"No\" 0.001)\n    (check-within (candidate (list \")(\" \")(\")) \"No\" 0.001)\n    (check-within (candidate (list \"(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \"(\")) \"Yes\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str]) -> str:\n\n    def FUNC_1(VAR_1):\n        VAR_2 = 0\n        for VAR_3 in VAR_1:\n            if (VAR_3 == '('):\n                VAR_2 = (VAR_2 + 1)\n            else:\n                VAR_2 = (VAR_2 - 1)\n            if (VAR_2 < 0):\n                return False\n        return (True if (VAR_2 == 0) else False)\n    VAR_4 = (VAR_0[0] + VAR_0[1])\n    VAR_5 = (VAR_0[1] + VAR_0[0])\n    return ('Yes' if (FUNC_1(VAR_4) or FUNC_1(VAR_5)) else 'No')\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a string of parentheses is balanced. \n\n1. The first line imports the List class from the typing module. This is used to specify the type of the input argument to the function.\n2. The second line defines a function called FUNC_0 that takes a list of strings as input and returns a string as output.\n3. The third line defines another function called FUNC_1 that takes a string as input and returns a boolean value as output.\n4. The fourth line initializes a variable VAR_2 to 0.\n5. The fifth line starts a for loop that iterates over each character in the input string VAR_1.\n6. The sixth line checks if the current character is an opening parenthesis. If it is, VAR_2 is incremented by 1.\n7. The seventh line checks if the current character is a closing parenthesis. If it is, VAR_2 is decremented by 1.\n8. The eighth line checks if VAR_2 is less than 0. If it is, the function returns False, indicating that the string is not balanced.\n9. The ninth line returns True if VAR_2 is equal to 0, indicating that the string is balanced. Otherwise, it returns False.\n10. The tenth line concatenates the first two strings in the input list and assigns the result to VAR_4.\n11. The eleventh line concatenates the second and first strings in the input list and assigns the result to VAR_5.\n12. The twelfth line checks if either VAR_4 or VAR_5 is balanced using the FUNC_1 function. If either string is balanced, the function returns 'Yes'. Otherwise, it returns 'No'.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 2 3 1) #t 0.001)\n    (check-within (candidate 2.5 2 3) #f 0.001)\n    (check-within (candidate 1.5 5 3.5) #f 0.001)\n    (check-within (candidate 2 6 2) #f 0.001)\n    (check-within (candidate 4 2 2) #t 0.001)\n    (check-within (candidate 2.2 2.2 2.2) #f 0.001)\n    (check-within (candidate -4 6 2) #t 0.001)\n    (check-within (candidate 2 1 1) #t 0.001)\n    (check-within (candidate 3 4 7) #t 0.001)\n    (check-within (candidate 3.0 4 7) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: float, VAR_1: float, VAR_2: float) -> bool:\n    if (isinstance(VAR_0, int) and isinstance(VAR_1, int) and isinstance(VAR_2, int)):\n        if (((VAR_0 + VAR_1) == VAR_2) or ((VAR_0 + VAR_2) == VAR_1) or ((VAR_1 + VAR_2) == VAR_0)):\n            return True\n        return False\n    return False\n\n### Explanation\n\nThe code is an implementation of a function named FUNC_0 that takes three float arguments VAR_0, VAR_1, and VAR_2 and returns a boolean value. The function checks if the three arguments are integers and if they are, it checks if any two of them add up to the third. If any two of them add up to the third, the function returns True. If not, it returns False. If any of the arguments are not integers, the function returns False. \n\nThe function starts with a conditional statement that checks if all three arguments are integers. The isinstance() function is used to check if the arguments are instances of the int class. If all three arguments are integers, the code inside the if statement is executed. \n\nThe second conditional statement checks if any two of the three arguments add up to the third. The code inside the if statement checks if the sum of VAR_0 and VAR_1 is equal to VAR_2, or if the sum of VAR_0 and VAR_2 is equal to VAR_1, or if the sum of VAR_1 and VAR_2 is equal to VAR_0. If any of these conditions are true, the function returns True. If none of these conditions are true, the function returns False.\n\nIf any of the arguments are not integers, the function returns False without executing the code inside the first if statement. This ensures that the function only operates on integers. \n\nOverall, the function checks if the three arguments form a valid triangle, where the sum of any two sides is greater than the third side. If the arguments form a valid triangle, the function returns True. If not, it returns False.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"grunt\" \"trumpet\" \"prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str], VAR_1: str) -> List[str]:\n    return [VAR_2 for VAR_2 in VAR_0 if (VAR_1 in VAR_2)]\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, a list of strings and a string. The function returns a list of strings that contain the second argument. \n\n1. `from typing import List` - Importing the List class from the typing module. \n2. `def FUNC_0(VAR_0: List[str], VAR_1: str) -> List[str]:` - Defining a function named FUNC_0 that takes two arguments: VAR_0, a list of strings, and VAR_1, a string. The function returns a list of strings. \n3. `return [VAR_2 for VAR_2 in VAR_0 if (VAR_1 in VAR_2)]` - This line uses a list comprehension to create a new list containing only the elements of VAR_0 that contain VAR_1.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list \"name\" \"of\" \"string\")) \"string\" 0.001)\n    (check-within (candidate (list \"name\" \"enam\" \"game\")) \"enam\" 0.001)\n    (check-within (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\" 0.001)\n    (check-within (candidate (list \"abc\" \"cba\")) \"abc\" 0.001)\n    (check-within (candidate (list \"play\" \"this\" \"game\" \"of\" \"footbott\")) \"footbott\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\" 0.001)\n    (check-within (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\" 0.001)\n    (check-within (candidate (list \"b\")) \"b\" 0.001)\n    (check-within (candidate (list \"play\" \"play\" \"play\")) \"play\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str]) -> str:\n    return sorted(VAR_0, key=(lambda VAR_1: ((- len(set(VAR_1))), VAR_1)))[0]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings and returns the string with the most repeated characters. Here is a line by line explanation of the code:\n\n1. `from typing import List`: Importing the List class from the typing module.\n\n2. `def FUNC_0(VAR_0: List[str]) -> str:`: Defining a function named FUNC_0 that takes a list of strings as input and returns a string. The function is defined using the def keyword, followed by the function name, and the input parameter(s) in parentheses. The -> str specifies the return type of the function.\n\n3. `return sorted(VAR_0, key=(lambda VAR_1: ((- len(set(VAR_1))), VAR_1)))[0]`: This line is the implementation of the function. It sorts the input list of strings in descending order based on the number of unique characters in each string and then the string itself. The sorted function is called with two arguments: the first is the input list of strings, and the second is a key function that is used to determine the order of the sorting. The key function is defined using a lambda function that takes a string as input and returns a tuple of two values: the negative length of the set of unique characters in the string (to sort in descending order), and the string itself. Finally, the function returns the first element of the sorted list, which is the string with the most repeated characters.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 2 10) (list 2 4 6 8) 0.001)\n    (check-within (candidate 10 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 132 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 17 89) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> List[int]:\n    VAR_2 = max(2, min(VAR_0, VAR_1))\n    VAR_3 = min(8, max(VAR_0, VAR_1))\n    return [VAR_4 for VAR_4 in range(VAR_2, (VAR_3 + 1)) if ((VAR_4 % 2) == 0)]\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns a list of even numbers between the two arguments, inclusive. \n\nThe first line imports the List class from the typing module. This is used to specify the return type of the function.\n\nThe second line defines a function named FUNC_0 that takes two integer arguments, VAR_0 and VAR_1, and returns a list of integers. \n\nThe third line creates a new variable named VAR_2 that is set to the maximum of 2 and the minimum of VAR_0 and VAR_1. This ensures that VAR_2 is at least 2 and no greater than the smaller of VAR_0 and VAR_1.\n\nThe fourth line creates a new variable named VAR_3 that is set to the minimum of 8 and the maximum of VAR_0 and VAR_1. This ensures that VAR_3 is no greater than 8 and no less than the larger of VAR_0 and VAR_1.\n\nThe fifth line returns a list comprehension that generates a list of even numbers between VAR_2 and VAR_3, inclusive. The comprehension iterates over a range object that starts at VAR_2 and ends at VAR_3 + 1. For each number in the range, the comprehension checks if the number is even by using the modulo operator (%). If the number is even, it is added to the list. If the number is odd, it is skipped. \n\nThe return type of the function is specified as a List[int], which means that the function returns a list of integers.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) \"YES\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 4)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 3)) \"NO\" 0.001)\n    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) \"NO\" 0.001)\n    (check-within (candidate (list 100 200) (list 200 200)) \"YES\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int], VAR_1: List[int]) -> str:\n    VAR_2 = 0\n    VAR_3 = 0\n    for VAR_4 in VAR_0:\n        if ((VAR_4 % 2) == 1):\n            VAR_2 += 1\n    for VAR_4 in VAR_1:\n        if ((VAR_4 % 2) == 0):\n            VAR_3 += 1\n    if (VAR_3 >= VAR_2):\n        return 'YES'\n    return 'NO'\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two lists of integers as input and returns a string. The function checks if there are more even numbers in the second list than odd numbers in the first list. If there are, it returns 'YES', otherwise it returns 'NO'.\n\nThe first line imports the `List` type from the `typing` module. This is used to specify the type of the input variables.\n\nThe second line defines the function `FUNC_0` that takes two input variables `VAR_0` and `VAR_1`, both of which are lists of integers. The function returns a string.\n\nThe third line initializes two variables `VAR_2` and `VAR_3` to zero.\n\nThe fourth line starts a loop that iterates over each element `VAR_4` in the first input list `VAR_0`.\n\nThe fifth line checks if the current element `VAR_4` is odd by using the modulo operator `%` to check if the remainder of `VAR_4` divided by 2 is 1. If it is, the variable `VAR_2` is incremented by 1.\n\nThe sixth line starts another loop that iterates over each element `VAR_4` in the second input list `VAR_1`.\n\nThe seventh line checks if the current element `VAR_4` is even by using the modulo operator `%` to check if the remainder of `VAR_4` divided by 2 is 0. If it is, the variable `VAR_3` is incremented by 1.\n\nThe eighth line checks if the number of even numbers in `VAR_1` is greater than or equal to the number of odd numbers in `VAR_0`. If it is, the function returns 'YES'.\n\nThe ninth line returns 'NO' if the condition in the previous line is not met.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 19) \"xix\" 0.001)\n    (check-within (candidate 152) \"clii\" 0.001)\n    (check-within (candidate 251) \"ccli\" 0.001)\n    (check-within (candidate 426) \"cdxxvi\" 0.001)\n    (check-within (candidate 500) \"d\" 0.001)\n    (check-within (candidate 1) \"VAR_3\" 0.001)\n    (check-within (candidate 4) \"iv\" 0.001)\n    (check-within (candidate 43) \"xliii\" 0.001)\n    (check-within (candidate 90) \"xc\" 0.001)\n    (check-within (candidate 94) \"xciv\" 0.001)\n    (check-within (candidate 532) \"dxxxii\" 0.001)\n    (check-within (candidate 900) \"cm\" 0.001)\n    (check-within (candidate 994) \"cmxciv\" 0.001)\n    (check-within (candidate 1000) \"m\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> str:\n    VAR_1 = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    VAR_2 = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M']\n    VAR_3 = 12\n    VAR_4 = ''\n    while VAR_0:\n        VAR_5 = (VAR_0 // VAR_1[VAR_3])\n        VAR_0 %= VAR_1[VAR_3]\n        while VAR_5:\n            VAR_4 += VAR_2[VAR_3]\n            VAR_5 -= 1\n        VAR_3 -= 1\n    return VAR_4.lower()\n\n### Explanation\n\nThe code is an implementation of a function that converts an integer to a Roman numeral. \n\n1. `def FUNC_0(VAR_0: int) -> str:` defines a function named `FUNC_0` that takes an integer argument `VAR_0` and returns a string. \n\n2. `VAR_1 = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]` defines a list of integers that represent the values of Roman numerals. \n\n3. `VAR_2 = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M']` defines a list of strings that represent the symbols of Roman numerals. \n\n4. `VAR_3 = 12` initializes a variable `VAR_3` to the index of the highest value in `VAR_1`. \n\n5. `VAR_4 = ''` initializes a variable `VAR_4` to an empty string. \n\n6. `while VAR_0:` starts a loop that continues until `VAR_0` is zero. \n\n7. `VAR_5 = (VAR_0 // VAR_1[VAR_3])` calculates the number of times the current Roman numeral should be repeated by dividing `VAR_0` by the value of the current Roman numeral. \n\n8. `VAR_0 %= VAR_1[VAR_3]` updates `VAR_0` to the remainder of `VAR_0` divided by the value of the current Roman numeral. \n\n9. `while VAR_5:` starts a loop that repeats the current Roman numeral `VAR_5` times. \n\n10. `VAR_4 += VAR_2[VAR_3]` appends the current Roman numeral symbol to `VAR_4`. \n\n11. `VAR_5 -= 1` decrements `VAR_5` by 1. \n\n12. `VAR_3 -= 1` decrements `VAR_3` by 1 to move to the next Roman numeral. \n\n13. `return VAR_4.lower()` returns the Roman numeral string in lowercase. \n\nThe function works by iterating through the list of Roman numeral values in descending order and calculating the number of times each numeral should be repeated to represent the input integer. The Roman numeral symbols are appended to a string in the correct order, and the resulting string is returned in lowercase.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #t 0.001)\n    (check-within (candidate 11) #f 0.001)\n    (check-within (candidate 12) #t 0.001)\n    (check-within (candidate 13) #f 0.001)\n    (check-within (candidate 16) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> bool:\n    return (((VAR_0 % 2) == 0) and (VAR_0 >= 8))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in an integer `VAR_0` and returns a boolean value. \n\nThe function checks if the integer is even and greater than or equal to 8. If both conditions are true, the function returns `True`. Otherwise, it returns `False`.\n\nThe function is implemented in a single line. The line first checks if the remainder of `VAR_0` divided by 2 is equal to 0, which indicates that `VAR_0` is even. The `and` operator is then used to check if `VAR_0` is greater than or equal to 8. The result of this expression is then returned as a boolean value. \n\nOverall, the function checks if `VAR_0` is an even integer that is greater than or equal to 8. If so, it returns `True`. Otherwise, it returns `False`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 0) \"db0db\" 0.001)\n    (check-within (candidate 32) \"db100000db\" 0.001)\n    (check-within (candidate 103) \"db1100111db\" 0.001)\n    (check-within (candidate 15) \"db1111db\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> str:\n    return (('db' + bin(VAR_0)[2:]) + 'db')\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns a string. \n\n`def FUNC_0(VAR_0: int) -> str:` defines a function called `FUNC_0` that takes one argument `VAR_0` of type `int` and returns a value of type `str`.\n\n`bin(VAR_0)` converts the integer `VAR_0` to its binary representation.\n\n`bin(VAR_0)[2:]` returns the binary representation of `VAR_0` without the first two characters, which are `0b`.\n\n`'db' + bin(VAR_0)[2:]` concatenates the string `'db'` with the binary representation of `VAR_0`.\n\n`(('db' + bin(VAR_0)[2:]) + 'db')` concatenates the result of the previous step with the string `'db'` again.\n\n`return (('db' + bin(VAR_0)[2:]) + 'db')` returns the final concatenated string. \n\nTherefore, the function takes an integer, converts it to binary, and returns a string that consists of the binary representation of the integer surrounded by the string `'db'`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5) 0.001)\n    (check-within (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5) 0.001)\n    (check-within (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5) 0.001)\n    (check-within (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    VAR_0 = list(VAR_0)\n    VAR_0[::3] = sorted(VAR_0[::3])\n    return VAR_0\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a sorted list of integers. The function is defined with the name `FUNC_0` and takes a single argument `VAR_0` which is a list of integers. The function returns a list of integers.\n\nThe first line of the function imports the `List` class from the `typing` module. This is used to specify the type of the input and output of the function.\n\nThe second line of the function creates a copy of the input list by calling the `list()` constructor on the input list. This is done to avoid modifying the original list.\n\nThe third line of the function sorts every third element of the list. This is done by slicing the list with the syntax `VAR_0[::3]` which returns every third element of the list. The `sorted()` function is then called on this slice to sort it. The sorted slice is then assigned back to the original slice using the syntax `VAR_0[::3] = sorted(VAR_0[::3])`.\n\nThe fourth line of the function returns the modified list.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/6\" \"2/1\") #f 0.001)\n    (check-within (candidate \"5/1\" \"3/1\") #t 0.001)\n    (check-within (candidate \"7/10\" \"10/2\") #f 0.001)\n    (check-within (candidate \"2/10\" \"50/10\") #t 0.001)\n    (check-within (candidate \"7/2\" \"4/2\") #t 0.001)\n    (check-within (candidate \"11/6\" \"6/1\") #t 0.001)\n    (check-within (candidate \"2/3\" \"5/2\") #f 0.001)\n    (check-within (candidate \"5/2\" \"3/5\") #f 0.001)\n    (check-within (candidate \"2/4\" \"8/4\") #t 0.001)\n    (check-within (candidate \"2/4\" \"4/2\") #t 0.001)\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/5\" \"1/5\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str, VAR_1: str) -> bool:\n    (VAR_2, VAR_3) = VAR_0.split('/')\n    (VAR_4, VAR_5) = VAR_1.split('/')\n    VAR_6 = (int(VAR_2) * int(VAR_4))\n    VAR_7 = (int(VAR_3) * int(VAR_5))\n    if ((VAR_6 / VAR_7) == int((VAR_6 / VAR_7))):\n        return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes two string arguments VAR_0 and VAR_1 and returns a boolean value. \n\n1. `def FUNC_0(VAR_0: str, VAR_1: str) -> bool:` - This line defines the function FUNC_0 that takes two string arguments VAR_0 and VAR_1 and returns a boolean value.\n\n2. `(VAR_2, VAR_3) = VAR_0.split('/')` - This line splits the string VAR_0 into two parts using the '/' character as a separator and assigns the two parts to the variables VAR_2 and VAR_3 respectively.\n\n3. `(VAR_4, VAR_5) = VAR_1.split('/')` - This line splits the string VAR_1 into two parts using the '/' character as a separator and assigns the two parts to the variables VAR_4 and VAR_5 respectively.\n\n4. `VAR_6 = (int(VAR_2) * int(VAR_4))` - This line multiplies the integer value of VAR_2 with the integer value of VAR_4 and assigns the result to the variable VAR_6.\n\n5. `VAR_7 = (int(VAR_3) * int(VAR_5))` - This line multiplies the integer value of VAR_3 with the integer value of VAR_5 and assigns the result to the variable VAR_7.\n\n6. `if ((VAR_6 / VAR_7) == int((VAR_6 / VAR_7))):` - This line checks if the result of dividing VAR_6 by VAR_7 is an integer. If it is, the function returns True. Otherwise, it returns False.\n\n7. `return True` - This line returns True if the result of dividing VAR_6 by VAR_7 is an integer.\n\n8. `return False` - This line returns False if the result of dividing VAR_6 by VAR_7 is not an integer.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"AsDf\") \"aSdF\" 0.001)\n    (check-within (candidate \"1234\") \"4321\" 0.001)\n    (check-within (candidate \"ab\") \"AB\" 0.001)\n    (check-within (candidate \"#a@C\") \"#A@c\" 0.001)\n    (check-within (candidate \"#AsdfW^45\") \"#aSDFw^45\" 0.001)\n    (check-within (candidate \"#6@2\") \"2@6#\" 0.001)\n    (check-within (candidate \"#$a^D\") \"#$A^d\" 0.001)\n    (check-within (candidate \"#ccc\") \"#CCC\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    VAR_1 = 0\n    VAR_2 = 0\n    VAR_3 = list(VAR_0)\n    for VAR_4 in VAR_0:\n        if VAR_4.isalpha():\n            VAR_3[VAR_2] = VAR_4.swapcase()\n            VAR_1 = 1\n        VAR_2 += 1\n    VAR_0 = ''\n    for VAR_4 in VAR_3:\n        VAR_0 += VAR_4\n    if (VAR_1 == 0):\n        return VAR_0[len(VAR_0)::(- 1)]\n    return VAR_0\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a string as output. The function is defined with the name FUNC_0 and takes a single argument VAR_0 of type string. The return type of the function is also a string.\n\n```python\ndef FUNC_0(VAR_0: str) -> str:\n```\n\nThe next three lines initialize three variables VAR_1, VAR_2, and VAR_3. VAR_1 and VAR_2 are initialized to 0, while VAR_3 is initialized to a list of characters in VAR_0.\n\n```python\n    VAR_1 = 0\n    VAR_2 = 0\n    VAR_3 = list(VAR_0)\n```\n\nThe next block of code is a for loop that iterates over each character in VAR_0. For each character, it checks if it is an alphabet character using the isalpha() method. If it is, it swaps the case of the character using the swapcase() method and stores it back in VAR_3. It also sets VAR_1 to 1 to indicate that at least one character was swapped.\n\n```python\n    for VAR_4 in VAR_0:\n        if VAR_4.isalpha():\n            VAR_3[VAR_2] = VAR_4.swapcase()\n            VAR_1 = 1\n        VAR_2 += 1\n```\n\nThe next block of code initializes VAR_0 to an empty string and then iterates over each character in VAR_3 and appends it to VAR_0.\n\n```python\n    VAR_0 = ''\n    for VAR_4 in VAR_3:\n        VAR_0 += VAR_4\n```\n\nThe final block of code checks if VAR_1 is 0, which means that no characters were swapped. If VAR_1 is 0, it returns VAR_0 in reverse order. Otherwise, it returns VAR_0 as is.\n\n```python\n    if (VAR_1 == 0):\n        return VAR_0[len(VAR_0)::(- 1)]\n    return VAR_0\n```\n\nOverall, the function takes a string as input, swaps the case of all alphabet characters in the string, and returns the modified string. If no characters were swapped, it returns the string in reverse order. The function is written in Python.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3 4 5) #t 0.001)\n    (check-within (candidate 1 2 3) #f 0.001)\n    (check-within (candidate 10 6 8) #t 0.001)\n    (check-within (candidate 2 2 2) #f 0.001)\n    (check-within (candidate 7 24 25) #t 0.001)\n    (check-within (candidate 10 5 7) #f 0.001)\n    (check-within (candidate 5 12 13) #t 0.001)\n    (check-within (candidate 15 8 17) #t 0.001)\n    (check-within (candidate 48 55 73) #t 0.001)\n    (check-within (candidate 1 1 1) #f 0.001)\n    (check-within (candidate 2 2 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int, VAR_2: int) -> bool:\n    return (((VAR_0 * VAR_0) == ((VAR_1 * VAR_1) + (VAR_2 * VAR_2))) or ((VAR_1 * VAR_1) == ((VAR_0 * VAR_0) + (VAR_2 * VAR_2))) or ((VAR_2 * VAR_2) == ((VAR_0 * VAR_0) + (VAR_1 * VAR_1))))\n\n### Explanation\n\nThe code is an implementation of the Pythagorean theorem. The theorem states that in a right-angled triangle, the square of the length of the hypotenuse is equal to the sum of the squares of the lengths of the other two sides. The function takes three integer arguments, VAR_0, VAR_1, and VAR_2, which represent the lengths of the sides of a triangle. The function returns a boolean value indicating whether the triangle is a right-angled triangle or not.\n\nThe function first checks if the square of VAR_0 is equal to the sum of the squares of VAR_1 and VAR_2. If this is true, it returns True, indicating that the triangle is a right-angled triangle. If this is not true, the function checks if the square of VAR_1 is equal to the sum of the squares of VAR_0 and VAR_2. If this is true, it returns True. If this is not true, the function checks if the square of VAR_2 is equal to the sum of the squares of VAR_0 and VAR_1. If this is true, it returns True. If none of these conditions are true, the function returns False, indicating that the triangle is not a right-angled triangle. \n\nIn summary, the function checks if the triangle is a right-angled triangle by checking if any of the three sides satisfy the Pythagorean theorem. If any of the sides satisfy the theorem, the function returns True, otherwise it returns False. \n\nThe function is defined with the def keyword, followed by the function name FUNC_0. The function takes three arguments, VAR_0, VAR_1, and VAR_2, which are integers. The -> bool specifies that the function returns a boolean value. The body of the function is a single return statement that checks if any of the three conditions are true and returns True or False accordingly. \n\nOverall, the function is a concise implementation of the Pythagorean theorem that can be easily understood and used in other programs.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1 VAR_2)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 5.0 4.0)) 25 0.001)\n    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)\n    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)\n    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)\n    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)\n    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[float]) -> int:\n    return sum([(VAR_1 ** 2) for VAR_1 in VAR_0 if ((VAR_1 > 0) and ((VAR_1 % 2) != 0) and ('.' not in str(VAR_1)))])\n\n### Explanation\n\nThe code is an implementation of a Python function that takes a list of floating point numbers as input and returns an integer. The function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of floats. The function returns the sum of the squares of all the odd positive integers in the input list that do not have a decimal point in their string representation.\n\nThe function is defined using the \"def\" keyword, followed by the function name, the input parameter(s) in parentheses, and a colon. The \"->\" symbol is used to indicate the return type of the function.\n\nThe \"sum\" function is called with a list comprehension as its argument. The list comprehension iterates over each element VAR_1 in the input list VAR_0, and checks if the element is greater than 0, odd, and does not contain a decimal point in its string representation. If all of these conditions are true, the square of the element is added to the list. The resulting list of squares is then summed and returned as the output of the function. \n\nThe \"List\" type is imported from the \"typing\" module at the beginning of the code, and is used to specify the type of the input parameter VAR_0 as a list of floats. This is not strictly necessary, but can be helpful for code readability and debugging. \n\nOverall, the function takes a list of floats as input, filters out any non-positive or even numbers, and returns the sum of the squares of the remaining odd positive integers that do not have a decimal point in their string representation.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 2.5) 2.5 0.001)\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 5 6) 6 0.001)\n    (check-within (candidate 1 \"2,3\") \"2,3\" 0.001)\n    (check-within (candidate \"5,1\" \"6\") \"6\" 0.001)\n    (check-within (candidate \"1\" \"2\") \"2\" 0.001)\n    (check-within (candidate \"1\" 1) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Union\n\ndef FUNC_0(VAR_0: Union[(int, float, str)], VAR_1: Union[(int, float, str)]) -> Union[(int, float, str, None)]:\n    (VAR_2, VAR_3) = (VAR_0, VAR_1)\n    if isinstance(VAR_2, str):\n        VAR_2 = VAR_2.replace(',', '.')\n    if isinstance(VAR_3, str):\n        VAR_3 = VAR_3.replace(',', '.')\n    if (float(VAR_2) == float(VAR_3)):\n        return None\n    return (VAR_0 if (float(VAR_2) > float(VAR_3)) else VAR_1)\n\n### Explanation\n\nThe code is an implementation of{{{TOFILL}}}\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)\n    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)\n    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> bool:\n    VAR_1 = 0\n    for VAR_2 in VAR_0:\n        VAR_1 += VAR_2\n        if (VAR_1 < 0):\n            return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a boolean value. The function is defined with the name FUNC_0 and takes in a single argument VAR_0, which is a list of integers. The function returns a boolean value.\n\nThe first line of the code imports the List module from the typing library. This module is used to define the type of the input argument of the function.\n\nThe second line of the code defines the function FUNC_0 and takes in a single argument VAR_0, which is a list of integers. The function returns a boolean value.\n\nThe third line of the code initializes a variable VAR_1 to 0.\n\nThe fourth line of the code starts a for loop that iterates over each element VAR_2 in the input list VAR_0.\n\nThe fifth line of the code adds the value of VAR_2 to VAR_1.\n\nThe sixth line of the code checks if VAR_1 is less than 0. If it is, the function returns True.\n\nThe seventh line of the code returns False if the for loop completes without returning True.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_103_rounded_avg",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_103_rounded_avg.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 1 5) \"0b11\" 0.001)\n    (check-within (candidate 7 13) \"0b1010\" 0.001)\n    (check-within (candidate 964 977) \"0b1111001010\" 0.001)\n    (check-within (candidate 996 997) \"0b1111100100\" 0.001)\n    (check-within (candidate 560 851) \"0b1011000010\" 0.001)\n    (check-within (candidate 185 546) \"0b101101110\" 0.001)\n    (check-within (candidate 362 496) \"0b110101101\" 0.001)\n    (check-within (candidate 350 902) \"0b1001110010\" 0.001)\n    (check-within (candidate 197 233) \"0b11010111\" 0.001)\n    (check-within (candidate 7 5) -1 0.001)\n    (check-within (candidate 5 1) -1 0.001)\n    (check-within (candidate 5 5) \"0b101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Union\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> Union[(str, int)]:\n    if (VAR_1 < VAR_0):\n        return (- 1)\n    VAR_2 = 0\n    for VAR_3 in range(VAR_0, (VAR_1 + 1)):\n        VAR_2 += VAR_3\n    return bin(round((VAR_2 / ((VAR_1 - VAR_0) + 1))))\n\n### Explanation\n\nThe code is an implementation of{{{TOFILL}}}\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3 7) 1 0.001)\n    (check-within (candidate 10 15) 5 0.001)\n    (check-within (candidate 49 14) 7 0.001)\n    (check-within (candidate 144 60) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int, VAR_1: int) -> int:\n    while VAR_1:\n        (VAR_0, VAR_1) = (VAR_1, (VAR_0 % VAR_1))\n    return VAR_0\n\n### Explanation\n\nThe code is an implementation of the Euclidean algorithm for finding the greatest common divisor (GCD) of two numbers. \n\nThe function is called `FUNC_0` and takes two integer arguments `VAR_0` and `VAR_1`. It returns an integer which is the GCD of `VAR_0` and `VAR_1`. \n\nThe `while` loop runs as long as `VAR_1` is not zero. The loop contains a tuple assignment which swaps the values of `VAR_0` and `VAR_1`, and assigns the value of `VAR_0 % VAR_1` to `VAR_1`. \n\nThe `%` operator returns the remainder of the division of `VAR_0` by `VAR_1`. The loop continues until `VAR_1` becomes zero, at which point the GCD is `VAR_0`, which is returned by the function. \n\nIn summary, the function `FUNC_0` calculates the GCD of two integers using the Euclidean algorithm.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5) (list 1 2 6 24 15) 0.001)\n    (check-within (candidate 7) (list 1 2 6 24 15 720 28) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n    (check-within (candidate 3) (list 1 2 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int) -> List[int]:\n    VAR_1 = []\n    for VAR_2 in range(1, (VAR_0 + 1)):\n        if ((VAR_2 % 2) == 0):\n            VAR_3 = 1\n            for VAR_4 in range(1, (VAR_2 + 1)):\n                VAR_3 *= VAR_4\n            VAR_1 += [VAR_3]\n        else:\n            VAR_3 = 0\n            for VAR_4 in range(1, (VAR_2 + 1)):\n                VAR_3 += VAR_4\n            VAR_1 += [VAR_3]\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer argument `VAR_0` and returns a list of integers. The function is defined with the `def` keyword, followed by the function name, `FUNC_0`, and the argument `VAR_0` with its type annotation `int`. The return type of the function is also annotated as `List[int]`.\n\n```python\nfrom typing import List\n```\n\nThe `typing` module is imported to allow the use of type annotations.\n\n```python\nVAR_1 = []\n```\n\nAn empty list is created and assigned to the variable `VAR_1`.\n\n```python\nfor VAR_2 in range(1, (VAR_0 + 1)):\n```\n\nA `for` loop is used to iterate over a range of integers from 1 to `VAR_0`, inclusive. The loop variable is `VAR_2`.\n\n```python\nif ((VAR_2 % 2) == 0):\n```\n\nAn `if` statement is used to check if `VAR_2` is even. The condition is `(VAR_2 % 2) == 0`, which checks if the remainder of `VAR_2` divided by 2 is equal to 0.\n\n```python\nVAR_3 = 1\nfor VAR_4 in range(1, (VAR_2 + 1)):\n    VAR_3 *= VAR_4\nVAR_1 += [VAR_3]\n```\n\nIf `VAR_2` is even, a new variable `VAR_3` is assigned the value 1, and a nested `for` loop is used to calculate the factorial of `VAR_2`. The loop variable is `VAR_4`, and it iterates over a range of integers from 1 to `VAR_2`, inclusive. The factorial is calculated by multiplying `VAR_3` by `VAR_4` in each iteration of the loop. After the loop completes, the factorial is appended to the list `VAR_1` using the `+=` operator.\n\n```python\nelse:\n```\n\nIf `VAR_2` is odd, the `else` block is executed.\n\n```python\nVAR_3 = 0\nfor VAR_4 in range(1, (VAR_2 + 1)):\n    VAR_3 += VAR_4\nVAR_1 += [VAR_3]\n```\n\nA new variable `VAR_3` is assigned the value 0, and a nested `for` loop is used to calculate the sum of integers from 1 to `VAR_2`. The loop variable is `VAR_4`, and it iterates over a range of integers from 1 to `VAR_2`, inclusive. The sum is calculated by adding `VAR_4` to `VAR_3` in each iteration of the loop. After the loop completes, the sum is appended to the list `VAR_1` using the `+=` operator.\n\n```python\nreturn VAR_1\n```\n\nThe function returns the list `VAR_1`. This is the final output of the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 4 10)) #t 0.001)\n    (check-within (candidate (list 1 2 4 20)) #t 0.001)\n    (check-within (candidate (list 1 20 4 10)) #f 0.001)\n    (check-within (candidate (list 4 1 0 -10)) #t 0.001)\n    (check-within (candidate (list 4 1 1 0)) #t 0.001)\n    (check-within (candidate (list 1 2 3 2 5 60)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 60)) #t 0.001)\n    (check-within (candidate (list 9 9 9 9)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> bool:\n    if ((VAR_0 == sorted(VAR_0)) or (VAR_0 == sorted(VAR_0, reverse=True))):\n        return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that checks if a list of integers is sorted in either ascending or descending order. \n\n1. `from typing import List` - Importing the List class from the typing module. This is used to specify the type of the input parameter of the function.\n\n2. `def FUNC_0(VAR_0: List[int]) -> bool:` - Defining a function named FUNC_0 that takes a list of integers as input and returns a boolean value. \n\n3. `if ((VAR_0 == sorted(VAR_0)) or (VAR_0 == sorted(VAR_0, reverse=True))):` - If the input list is equal to the list sorted in ascending order or the list sorted in descending order, then return True.\n\n4. `return False` - If the input list is not sorted in either ascending or descending order, then return False.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\") 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -1 55)) (list \"One\") 0.001)\n    (check-within (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\") 0.001)\n    (check-within (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[str]:\n    VAR_1 = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    VAR_2 = sorted(VAR_0, reverse=True)\n    VAR_3 = []\n    for VAR_4 in VAR_2:\n        try:\n            VAR_3.append(VAR_1[VAR_4])\n        except:\n            pass\n    return VAR_3\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a list of strings. The strings are the English names of the integers in the list, sorted in descending order. \n\n- `from typing import List`: This line imports the List class from the typing module. This is used to specify the type of the input and output of the function.\n\n- `def FUNC_0(VAR_0: List[int]) -> List[str]:`: This line defines a function called `FUNC_0` that takes in a list of integers and returns a list of strings. The input list is specified to be of type `List[int]` and the output list is specified to be of type `List[str]`.\n\n- `VAR_1 = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}`: This line creates a dictionary called `VAR_1` that maps integers to their English names.\n\n- `VAR_2 = sorted(VAR_0, reverse=True)`: This line creates a new list called `VAR_2` that is a sorted copy of the input list `VAR_0`. The `reverse=True` argument sorts the list in descending order.\n\n- `VAR_3 = []`: This line creates an empty list called `VAR_3`.\n\n- `for VAR_4 in VAR_2:`: This line starts a loop that iterates over each element in the sorted list `VAR_2`. The loop variable is called `VAR_4`.\n\n- `try: VAR_3.append(VAR_1[VAR_4]) except: pass`: This line tries to append the English name of `VAR_4` to the list `VAR_3`. If `VAR_4` is not a key in the dictionary `VAR_1`, the `except` block is executed and the loop moves on to the next element.\n\n- `return VAR_3`: This line returns the list `VAR_3` containing the English names of the integers in the input list, sorted in descending order.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"abcdef\nghijklm\") \"bcdf\nghjklm\" 0.001)\n    (check-within (candidate \"fedcba\") \"fdcb\" 0.001)\n    (check-within (candidate \"eeeee\") \"\" 0.001)\n    (check-within (candidate \"acBAA\") \"cB\" 0.001)\n    (check-within (candidate \"EcBOO\") \"cB\" 0.001)\n    (check-within (candidate \"ybcd\") \"ybcd\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    return ''.join([VAR_1 for VAR_1 in VAR_0 if (VAR_1.lower() not in ['a', 'e', 'i', 'o', 'u'])])\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes in a string argument called VAR_0 and returns a string. \n\nThe function returns a new string that is created by joining together all the characters in VAR_0 that are not vowels. \n\nThe join method is used to concatenate the characters together into a single string. \n\nThe list comprehension is used to iterate over each character in VAR_0 and only include the character in the new string if it is not a vowel. \n\nThe condition inside the list comprehension checks if the lowercase version of the character is not in the list of vowels. \n\nThe list of vowels is hardcoded as ['a', 'e', 'i', 'o', 'u']. \n\nThe function definition specifies that the input argument VAR_0 is a string and the output of the function is also a string. \n\nThe function does not modify the input string, but instead returns a new string with the vowels removed. \n\nOverall, the function takes a string as input and returns a new string with all the vowels removed.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"apple\") #f 0.001)\n    (check-within (candidate \"apple pi e\") #t 0.001)\n    (check-within (candidate \"eeeee\") #f 0.001)\n    (check-within (candidate \"A\") #t 0.001)\n    (check-within (candidate \"Pumpkin pie \") #f 0.001)\n    (check-within (candidate \"Pumpkin pie 1\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"eeeee e \") #f 0.001)\n    (check-within (candidate \"apple pie\") #f 0.001)\n    (check-within (candidate \"apple pi e \") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> bool:\n    VAR_1 = VAR_0.split(' ')[(- 1)]\n    return (True if ((len(VAR_1) == 1) and (97 <= ord(VAR_1.lower()) <= 122)) else False)\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value. The function checks if the last word in the input string is a single alphabetical character. If it is, the function returns `True`, otherwise it returns `False`.\n\n- `def FUNC_0(VAR_0: str) -> bool:` defines the function `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value.\n- `VAR_1 = VAR_0.split(' ')[(- 1)]` splits the input string `VAR_0` into a list of words using the space character as the separator, and assigns the last word in the list to the variable `VAR_1`.\n- `return (True if ((len(VAR_1) == 1) and (97 <= ord(VAR_1.lower()) <= 122)) else False)` returns `True` if the length of `VAR_1` is 1 and its ASCII code falls within the range of lowercase alphabetical characters (97 to 122), otherwise it returns `False`. The `if` statement is written in a ternary form.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate -1) #t 0.001)\n    (check-within (candidate 64) #t 0.001)\n    (check-within (candidate 180) #f 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 0) #t 0.001)\n    (check-within (candidate 1729) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> bool:\n    VAR_0 = abs(VAR_0)\n    return ((int(round((VAR_0 ** (1.0 / 3)))) ** 3) == VAR_0)\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes an integer argument VAR_0 and returns a boolean. \n\n1. `VAR_0 = abs(VAR_0)` - The absolute value of VAR_0 is assigned to VAR_0. This ensures that the input is always positive.\n\n2. `int(round((VAR_0 ** (1.0 / 3))))` - VAR_0 is raised to the power of 1/3, which is the same as finding the cube root of VAR_0. The result is then rounded to the nearest integer and cast to an integer.\n\n3. `int(round((VAR_0 ** (1.0 / 3)))) ** 3` - The integer result from step 2 is raised to the power of 3, which is the same as cubing the integer.\n\n4. `((int(round((VAR_0 ** (1.0 / 3)))) ** 3) == VAR_0)` - The result from step 3 is compared to VAR_0. If they are equal, the function returns True, otherwise it returns False. This checks if VAR_0 is a perfect cube. \n\nIn summary, the function checks if the input integer is a perfect cube.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"abcde\" \"ae\") (list \"bcd\" #f) 0.001)\n    (check-within (candidate \"abcdef\" \"b\") (list \"acdef\" #f) 0.001)\n    (check-within (candidate \"abcdedcba\" \"ab\") (list \"cdedc\" #t) 0.001)\n    (check-within (candidate \"dwik\" \"w\") (list \"dik\" #f) 0.001)\n    (check-within (candidate \"a\" \"a\") (list \"\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"v\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"vabba\" \"v\") (list \"abba\" #t) 0.001)\n    (check-within (candidate \"mamma\" \"mia\") (list \"\" #t) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef FUNC_0(VAR_0: str, VAR_1: str) -> Tuple[(str, bool)]:\n    VAR_0 = ''.join([VAR_2 for VAR_2 in VAR_0 if (VAR_2 not in VAR_1)])\n    return (VAR_0, (VAR_0[::(- 1)] == VAR_0))\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two string arguments `VAR_0` and `VAR_1` and returns a tuple containing a string and a boolean. The function removes all characters in `VAR_0` that are also in `VAR_1` and assigns the result to `VAR_0`. It then checks if the reversed string of `VAR_0` is equal to `VAR_0` and returns a tuple containing `VAR_0` and the result of the check.\n\nHere's a line-by-line breakdown of the code:\n\n1. `from typing import Tuple` - Importing the `Tuple` type from the `typing` module.\n\n2. `def FUNC_0(VAR_0: str, VAR_1: str) -> Tuple[(str, bool)]:` - Defining a function called `FUNC_0` that takes two string arguments `VAR_0` and `VAR_1` and returns a tuple containing a string and a boolean.\n\n3. `VAR_0 = ''.join([VAR_2 for VAR_2 in VAR_0 if (VAR_2 not in VAR_1)])` - Assigning to `VAR_0` a new string that is the result of joining all characters in `VAR_0` that are not in `VAR_1`.\n\n4. `return (VAR_0, (VAR_0[::(- 1)] == VAR_0))` - Returning a tuple containing `VAR_0` and a boolean that is `True` if the reversed string of `VAR_0` is equal to `VAR_0`, and `False` otherwise. The `[::-1]` syntax is used to reverse the string.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[float]) -> float:\n    VAR_1 = (sum(VAR_0) / len(VAR_0))\n    return (sum((abs((VAR_2 - VAR_1)) for VAR_2 in VAR_0)) / len(VAR_0))\n\n### Explanation\n\nThe code is an implementation of a function that calculates the mean absolute deviation of a list of numbers. \n\nThe function is called `FUNC_0` and takes a single argument `VAR_0`, which is a list of floats. The function returns a float.\n\nThe first line of the function calculates the mean of the list of numbers. It does this by summing all the numbers in the list and dividing the result by the length of the list. The result is stored in a variable called `VAR_1`.\n\nThe second line of the function calculates the mean absolute deviation of the list of numbers. It does this by iterating over each number in the list, subtracting the mean from the number, taking the absolute value of the result, and then summing all the absolute values. The result is then divided by the length of the list. The final result is returned by the function. \n\nNote that the second line of the function is a bit more complicated than the first line. It uses a list comprehension to iterate over each number in the list and calculate the absolute deviation. The list comprehension is enclosed in parentheses, which means that the result is a list. The `sum` function is then used to sum all the values in the list, and the result is divided by the length of the list to get the mean absolute deviation. \n\nOverall, the function is a simple and concise implementation of a common statistical calculation.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"<>\") #t 0.001)\n    (check-within (candidate \"<<><>>\") #t 0.001)\n    (check-within (candidate \"<><><<><>><>\") #t 0.001)\n    (check-within (candidate \"<><><<<><><>><>><<><><<>>>\") #t 0.001)\n    (check-within (candidate \"<<<><>>>>\") #f 0.001)\n    (check-within (candidate \"><<>\") #f 0.001)\n    (check-within (candidate \"<\") #f 0.001)\n    (check-within (candidate \"<<<<\") #f 0.001)\n    (check-within (candidate \">\") #f 0.001)\n    (check-within (candidate \"<<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>><<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>>><>\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> bool:\n    VAR_1 = 0\n    for VAR_2 in VAR_0:\n        if (VAR_2 == '<'):\n            VAR_1 += 1\n        else:\n            VAR_1 -= 1\n        if (VAR_1 < 0):\n            return False\n    return (VAR_1 == 0)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns a boolean value. \n\nThe function checks whether the input string is a valid string of balanced angle brackets. A string of balanced angle brackets is a string that contains only angle brackets `<` and `>` and where each opening angle bracket `<` has a corresponding closing angle bracket `>`.\n\nThe function works as follows:\n\n1. Initialize a variable `VAR_1` to 0.\n2. Loop through each character `VAR_2` in the input string `VAR_0`.\n3. If the character is an opening angle bracket `<`, increment `VAR_1` by 1.\n4. If the character is a closing angle bracket `>`, decrement `VAR_1` by 1.\n5. If `VAR_1` becomes negative at any point, return `False` because this means there is a closing angle bracket `>` without a corresponding opening angle bracket `<`.\n6. After the loop, if `VAR_1` is 0, return `True` because this means that all opening angle brackets `<` have a corresponding closing angle bracket `>`.\n7. Otherwise, return `False` because this means that there are more opening angle brackets `<` than closing angle brackets `>`.\n\nIn summary, the function checks whether a string of angle brackets is balanced by counting the number of opening and closing angle brackets and ensuring that they match. If there are more closing angle brackets than opening angle brackets, the function returns `False`. If there are more opening angle brackets than closing angle brackets, the function returns `False`. Otherwise, the function returns `True`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)\n    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)\n    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[float]) -> List[float]:\n    VAR_1 = min(VAR_0)\n    VAR_2 = max(VAR_0)\n    return [((VAR_3 - VAR_1) / (VAR_2 - VAR_1)) for VAR_3 in VAR_0]\n\n### Explanation\n\nThe code is an implementation of a normalization function. The function takes in a list of floats, and returns a list of floats. The returned list is the normalized version of the input list. \n\nThe function is defined with the name FUNC_0, and takes in a single argument VAR_0, which is a list of floats. The function returns a list of floats.\n\nThe first line of the function finds the minimum value of the input list and assigns it to the variable VAR_1.\n\nThe second line of the function finds the maximum value of the input list and assigns it to the variable VAR_2.\n\nThe third line of the function is a list comprehension. It iterates over each element VAR_3 in the input list VAR_0. For each element, it calculates the normalized value using the formula ((VAR_3 - VAR_1) / (VAR_2 - VAR_1)). The normalized value is then added to the list that is returned by the function.\n\nThe function returns the list of normalized values.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2) (list 2 3)) \"NO\" 0.001)\n    (check-within (candidate (list -1 1) (list 0 4)) \"NO\" 0.001)\n    (check-within (candidate (list -3 -1) (list -5 5)) \"YES\" 0.001)\n    (check-within (candidate (list -2 2) (list -4 0)) \"YES\" 0.001)\n    (check-within (candidate (list -11 2) (list -1 -1)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 3 5)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 1 2)) \"NO\" 0.001)\n    (check-within (candidate (list -2 -2) (list -3 -2)) \"NO\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef FUNC_0(VAR_0: Tuple[(int, int)], VAR_1: Tuple[(int, int)]) -> str:\n\n    def FUNC_1(VAR_2):\n        if ((VAR_2 == 1) or (VAR_2 == 0)):\n            return False\n        if (VAR_2 == 2):\n            return True\n        for VAR_3 in range(2, VAR_2):\n            if ((VAR_2 % VAR_3) == 0):\n                return False\n        return True\n    VAR_4 = max(VAR_0[0], VAR_1[0])\n    VAR_5 = min(VAR_0[1], VAR_1[1])\n    VAR_6 = (VAR_5 - VAR_4)\n    if ((VAR_6 > 0) and FUNC_1(VAR_6)):\n        return 'YES'\n    return 'NO'\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two tuples of two integers each as input and returns a string. The function first defines another function called `FUNC_1` that takes an integer as input and returns a boolean value. The purpose of `FUNC_1` is to determine whether an integer is a prime number or not.\n\nThe first line of the code imports the `Tuple` class from the `typing` module. This is used to specify the type of the input arguments and return value of the function.\n\nThe second line defines the `FUNC_0` function and specifies the types of its input arguments and return value. The function takes two tuples of two integers each as input and returns a string.\n\nThe third line defines the `FUNC_1` function and specifies its input argument and return value types. The function takes an integer as input and returns a boolean value.\n\nThe fourth line checks if the input integer is equal to 1 or 0, and returns `False` if it is. If the input integer is equal to 2, it returns `True`. Otherwise, it checks if the input integer is divisible by any integer between 2 and the input integer (exclusive). If it is, it returns `False`. Otherwise, it returns `True`.\n\nThe seventh line finds the maximum value of the first element of the two input tuples and assigns it to the variable `VAR_4`. The eighth line finds the minimum value of the second element of the two input tuples and assigns it to the variable `VAR_5`.\n\nThe ninth line calculates the difference between `VAR_5` and `VAR_4` and assigns it to the variable `VAR_6`.\n\nThe tenth line checks if `VAR_6` is greater than 0 and if `FUNC_1` returns `True` when called with `VAR_6` as input. If both conditions are true, it returns the string 'YES'. Otherwise, it returns the string 'NO'.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"AB\") 1 0.001)\n    (check-within (candidate \"1077E\") 2 0.001)\n    (check-within (candidate \"ABED1A33\") 4 0.001)\n    (check-within (candidate \"2020\") 2 0.001)\n    (check-within (candidate \"123456789ABCDEF0\") 6 0.001)\n    (check-within (candidate \"112233445566778899AABBCCDDEEFF00\") 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    VAR_1 = ('2', '3', '5', '7', 'B', 'D')\n    VAR_2 = 0\n    for VAR_3 in range(0, len(VAR_0)):\n        if (VAR_0[VAR_3] in VAR_1):\n            VAR_2 += 1\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns an integer. \n\nThe function starts by defining a tuple of characters called `VAR_1` that contains the values '2', '3', '5', '7', 'B', and 'D'. \n\nIt then initializes an integer variable `VAR_2` to 0. \n\nThe function then enters a `for` loop that iterates over the range of indices from 0 to the length of the input string `VAR_0`. \n\nFor each index `VAR_3` in this range, the function checks if the character at that index in the input string is in the `VAR_1` tuple. If it is, the function increments the `VAR_2` variable by 1. \n\nFinally, the function returns the value of `VAR_2`. \n\nIn summary, the function counts the number of characters in the input string that are either '2', '3', '5', '7', 'B', or 'D', and returns that count as an integer.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 2 3 4)) (list 1 4 2 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7) 0.001)\n    (check-within (candidate (list 5 5 5 5)) (list 5 5 5 5) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5) 0.001)\n    (check-within (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2) 0.001)\n    (check-within (candidate (list 111111)) (list 111111) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    (VAR_1, VAR_2) = ([], True)\n    while VAR_0:\n        VAR_1.append((min(VAR_0) if VAR_2 else max(VAR_0)))\n        VAR_0.remove(VAR_1[(- 1)])\n        VAR_2 = (not VAR_2)\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of the \"wiggle sort\" algorithm. The function `FUNC_0` takes a list of integers as input and returns a list of integers. \n\nThe first line imports the `List` class from the `typing` module. This is used to specify the type of the input and output of the function.\n\nThe second line defines the function `FUNC_0` which takes a list of integers as input and returns a list of integers. \n\nThe third line initializes two variables `VAR_1` and `VAR_2`. `VAR_1` is an empty list and `VAR_2` is a boolean set to `True`.\n\nThe fourth line starts a while loop that continues until the input list `VAR_0` is empty. \n\nThe fifth line appends either the minimum or maximum value of `VAR_0` to `VAR_1` depending on the value of `VAR_2`. If `VAR_2` is `True`, the minimum value is appended, otherwise the maximum value is appended.\n\nThe sixth line removes the last element of `VAR_1` from `VAR_0`.\n\nThe seventh line toggles the value of `VAR_2` from `True` to `False` or vice versa.\n\nThe eighth line returns the sorted list `VAR_1`. \n\nThe wiggle sort algorithm sorts the input list in such a way that the first element is less than or equal to the second element, the second element is greater than or equal to the third element, the third element is less than or equal to the fourth element, and so on. The algorithm achieves this by sorting the list in ascending order, and then alternating between taking the minimum and maximum values from the sorted list and appending them to a new list. The resulting list satisfies the wiggle sort condition.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Hello world\") 0 0.001)\n    (check-within (candidate \"Is the sky blue?\") 0 0.001)\n    (check-within (candidate \"I love It !\") 1 0.001)\n    (check-within (candidate \"bIt\") 0 0.001)\n    (check-within (candidate \"I feel good today. I will be productive. will kill It\") 2 0.001)\n    (check-within (candidate \"You and I are going for a walk\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> int:\n    import re\n    VAR_1 = re.split('[.?!]\\\\s*', VAR_0)\n    return sum(((VAR_2[0:2] == 'I ') for VAR_2 in VAR_1))\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a string argument `VAR_0` and returns an integer. \n\nThe first line of the function imports the `re` module, which provides support for regular expressions. \n\nThe second line of the function uses the `re.split()` method to split the input string into a list of sentences. The regular expression `[.?!]\\\\s*` matches any period, exclamation point, or question mark followed by zero or more whitespace characters. This is used to split the input string into sentences. The resulting list of sentences is stored in the variable `VAR_1`.\n\nThe third line of the function uses a list comprehension to count the number of sentences that start with the phrase \"I \". The list comprehension iterates over each sentence in `VAR_1` and checks if the first two characters of the sentence are \"I \". If they are, the expression `True` is returned, which is then converted to an integer value of 1. If they are not, the expression `False` is returned, which is then converted to an integer value of 0. The `sum()` function is then used to add up all of the 1's and 0's in the list, giving the total number of sentences that start with \"I \". This value is then returned by the function. \n\nIn summary, the function takes a string argument, splits it into a list of sentences, and counts the number of sentences that start with the phrase \"I \". The resulting count is returned as an integer value.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"asdfgh\") (list \"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\") 0.001)\n    (check-within (candidate \"WWW\") (list \"W\" \"WW\" \"WWW\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: str) -> List[str]:\n    VAR_1 = []\n    for VAR_2 in range(len(VAR_0)):\n        VAR_1.append(VAR_0[:(VAR_2 + 1)])\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a list of all substrings of the input string. \n\n`from typing import List` - This line imports the List type from the typing module. This is used to specify the return type of the function.\n\n`def FUNC_0(VAR_0: str) -> List[str]:` - This line defines a function called FUNC_0 that takes a string as input and returns a list of strings. \n\n`VAR_1 = []` - This line initializes an empty list called VAR_1.\n\n`for VAR_2 in range(len(VAR_0)):` - This line starts a for loop that iterates over the range of the length of the input string.\n\n`VAR_1.append(VAR_0[:(VAR_2 + 1)])` - This line appends a substring of the input string to VAR_1. The substring is created using slicing notation and includes all characters from the beginning of the string up to the current index of the for loop.\n\n`return VAR_1` - This line returns the list of substrings.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\" \"x\") 0 0.001)\n    (check-within (candidate \"xyxyxyx\" \"x\") 4 0.001)\n    (check-within (candidate \"cacacacac\" \"cac\") 4 0.001)\n    (check-within (candidate \"john doe\" \"john\") 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str, VAR_1: str) -> int:\n    VAR_2 = 0\n    for VAR_3 in range(((len(VAR_0) - len(VAR_1)) + 1)):\n        if (VAR_0[VAR_3:(VAR_3 + len(VAR_1))] == VAR_1):\n            VAR_2 += 1\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes two string arguments `VAR_0` and `VAR_1` and returns an integer. The function counts the number of times `VAR_1` appears in `VAR_0`. \n\n* `def FUNC_0(VAR_0: str, VAR_1: str) -> int:` defines the function `FUNC_0` that takes two string arguments `VAR_0` and `VAR_1` and returns an integer. \n* `VAR_2 = 0` initializes a variable `VAR_2` to zero.\n* `for VAR_3 in range(((len(VAR_0) - len(VAR_1)) + 1)):` loops through a range of integers from 0 to the length of `VAR_0` minus the length of `VAR_1` plus one. This is because the maximum number of times `VAR_1` can appear in `VAR_0` is the length of `VAR_0` minus the length of `VAR_1` plus one. \n* `if (VAR_0[VAR_3:(VAR_3 + len(VAR_1))] == VAR_1):` checks if the substring of `VAR_0` starting from index `VAR_3` and ending at index `VAR_3 + len(VAR_1)` is equal to `VAR_1`. If it is, then `VAR_2` is incremented by one.\n* `return VAR_2` returns the final count of the number of times `VAR_1` appears in `VAR_0`. \n\nThe function essentially loops through all possible substrings of `VAR_0` that have the same length as `VAR_1` and checks if they are equal to `VAR_1`. If they are, then the count is incremented. The final count is returned.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 5 8 7 1)) 12 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 9 0.001)\n    (check-within (candidate (list 30 13 24 321)) 0 0.001)\n    (check-within (candidate (list 5 9)) 5 0.001)\n    (check-within (candidate (list 2 4 8)) 0 0.001)\n    (check-within (candidate (list 30 13 23 32)) 23 0.001)\n    (check-within (candidate (list 3 13 2 9)) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    return sum([VAR_2 for (VAR_1, VAR_2) in enumerate(VAR_0) if (((VAR_1 % 2) == 0) and ((VAR_2 % 2) == 1))])\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of integers as input and returns an integer. \n\nThe first line imports the `List` type from the `typing` module.\n\nThe second line defines the function `FUNC_0` that takes a list of integers `VAR_0` as input and returns an integer. \n\nThe third line uses a list comprehension to create a new list that contains only the odd numbers at even indices of the input list. \n\nThe `enumerate` function is used to iterate over the input list and return a tuple of the index and the value at that index. \n\nThe `if` statement filters out the even indices and even numbers, leaving only the odd numbers at even indices. \n\nThe `sum` function is then used to add up all the odd numbers at even indices in the input list. \n\nFinally, the function returns the sum of the odd numbers at even indices.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 5)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 7)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n    (check-within (candidate (list 1)) #t 0.001)\n    (check-within (candidate (list 3 2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 2 2 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 3 3 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 2 3 3 4)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> bool:\n    VAR_1 = dict([(VAR_2, 0) for VAR_2 in VAR_0])\n    for VAR_2 in VAR_0:\n        VAR_1[VAR_2] += 1\n    if any(((VAR_1[VAR_2] > 2) for VAR_2 in VAR_0)):\n        return False\n    if all(((VAR_0[(VAR_2 - 1)] <= VAR_0[VAR_2]) for VAR_2 in range(1, len(VAR_0)))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns True if the list is sorted in non-descending order and no integer appears more than twice in the list. Otherwise, it returns False.\n\n- `from typing import List`: Importing the List type from the typing module. This is used to specify the type of the input parameter of the function.\n- `def FUNC_0(VAR_0: List[int]) -> bool:`: Defining a function named FUNC_0 that takes a list of integers as input and returns a boolean value. The function is defined using type annotations, which specify the types of the input and output parameters.\n- `VAR_1 = dict([(VAR_2, 0) for VAR_2 in VAR_0])`: Creating a dictionary named VAR_1 that maps each integer in the input list to 0. This is done using a dictionary comprehension that iterates over the input list and creates a key-value pair for each integer.\n- `for VAR_2 in VAR_0:`: Iterating over the input list.\n- `VAR_1[VAR_2] += 1`: Incrementing the value of the key VAR_2 in the dictionary VAR_1 by 1. This counts the number of occurrences of each integer in the input list.\n- `if any(((VAR_1[VAR_2] > 2) for VAR_2 in VAR_0)):`: Checking if any integer in the input list appears more than twice. This is done using the any function, which returns True if any element of the iterable is True. The iterable is a generator expression that iterates over the input list and checks if the value of the key VAR_2 in the dictionary VAR_1 is greater than 2.\n- `return False`: Returning False if any integer appears more than twice.\n- `if all(((VAR_0[(VAR_2 - 1)] <= VAR_0[VAR_2]) for VAR_2 in range(1, len(VAR_0)))):`: Checking if the input list is sorted in non-descending order. This is done using the all function, which returns True if all elements of the iterable are True. The iterable is a generator expression that iterates over a range of indices from 1 to the length of the input list and checks if the element at the current index is greater than or equal to the element at the previous index.\n- `return True`: Returning True if the input list is sorted in non-descending order and no integer appears more than twice.\n- `else:`: If the input list is not sorted in non-descending order, return False.\n- `return False`: Returning False if the input list is not sorted in non-descending order.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 5 5 5 5 1)) 1 0.001)\n    (check-within (candidate (list 4 1 4 1 4 4)) 4 0.001)\n    (check-within (candidate (list 3 3)) -1 0.001)\n    (check-within (candidate (list 8 8 8 8 8 8 8 8)) 8 0.001)\n    (check-within (candidate (list 2 3 3 2 2)) 2 0.001)\n    (check-within (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1 0.001)\n    (check-within (candidate (list 3 2 8 2)) 2 0.001)\n    (check-within (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1 0.001)\n    (check-within (candidate (list 8 8 3 6 5 6 4)) -1 0.001)\n    (check-within (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1 0.001)\n    (check-within (candidate (list 1 9 10 1 3)) 1 0.001)\n    (check-within (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n    (check-within (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4 0.001)\n    (check-within (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2 0.001)\n    (check-within (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1 0.001)\n    (check-within (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4 0.001)\n    (check-within (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4 0.001)\n    (check-within (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2 0.001)\n    (check-within (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1 0.001)\n    (check-within (candidate (list 10)) -1 0.001)\n    (check-within (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2 0.001)\n    (check-within (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1 0.001)\n    (check-within (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1 0.001)\n    (check-within (candidate (list 3 10 10 9 2)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n    VAR_1 = ([0] * (max(VAR_0) + 1))\n    for VAR_2 in VAR_0:\n        VAR_1[VAR_2] += 1\n    VAR_3 = (- 1)\n    for VAR_2 in range(1, len(VAR_1)):\n        if (VAR_1[VAR_2] >= VAR_2):\n            VAR_3 = VAR_2\n    return VAR_3\n\n### Explanation\n\nThe code is an implementation of the Pigeonhole principle. It takes a list of integers as input and returns the largest integer that appears at least as many times as its value in the list.\n\n1. `from typing import List`: Importing the List class from the typing module. This is used to specify the type of the input parameter and the return value of the function.\n\n2. `def FUNC_0(VAR_0: List[int]) -> int:`: Defining a function named FUNC_0 that takes a list of integers as input and returns an integer. The function signature specifies the type of the input parameter and the return value.\n\n3. `VAR_1 = ([0] * (max(VAR_0) + 1))`: Initializing a list of zeros with a length of one more than the maximum value in the input list. This list will be used to count the occurrences of each integer in the input list.\n\n4. `for VAR_2 in VAR_0:`: Looping through each integer in the input list.\n\n5. `VAR_1[VAR_2] += 1`: Incrementing the count of the current integer in the count list.\n\n6. `VAR_3 = (- 1)`: Initializing a variable to store the result. The initial value is -1, which will be returned if no integer appears at least as many times as its value in the input list.\n\n7. `for VAR_2 in range(1, len(VAR_1)):`: Looping through each index in the count list, starting from 1.\n\n8. `if (VAR_1[VAR_2] >= VAR_2):`: Checking if the count of the current integer is greater than or equal to its value.\n\n9. `VAR_3 = VAR_2`: If the condition is true, set the result variable to the current integer.\n\n10. `return VAR_3`: Return the result variable.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 4 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5 0 3 0 4 2)) (list 0 1) 0.001)\n    (check-within (candidate (list 1 2 3 0 5 3)) (list 0 3) 0.001)\n    (check-within (candidate (list 5 4 8 4 8)) (list 4 1) 0.001)\n    (check-within (candidate (list 7 6 7 1)) (list 6 1) 0.001)\n    (check-within (candidate (list 7 9 7 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    if (len(VAR_0) == 0):\n        return []\n    VAR_1 = list(filter((lambda VAR_2: ((VAR_2 % 2) == 0)), VAR_0))\n    if (VAR_1 == []):\n        return []\n    return [min(VAR_1), VAR_0.index(min(VAR_1))]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a list containing the minimum even integer in the input list and its index in the input list. If there are no even integers in the input list, the function returns an empty list.\n\n* `from typing import List`: Importing the List class from the typing module.\n\n* `def FUNC_0(VAR_0: List[int]) -> List[int]:`: Defining a function named `FUNC_0` that takes a list of integers as input and returns a list of integers. The function signature specifies that the input list is of type `List[int]` and the output list is of type `List[int]`.\n\n* `if (len(VAR_0) == 0):`: If the length of the input list is 0, return an empty list.\n\n* `return []`: Return an empty list.\n\n* `VAR_1 = list(filter((lambda VAR_2: ((VAR_2 % 2) == 0)), VAR_0))`: Create a new list `VAR_1` that contains only the even integers from the input list `VAR_0`. The `filter` function is used to filter the input list based on a condition. In this case, the condition is that the integer is even (`(VAR_2 % 2) == 0`). The `lambda` function is used to define the condition.\n\n* `if (VAR_1 == []):`: If the new list `VAR_1` is empty, return an empty list.\n\n* `return [min(VAR_1), VAR_0.index(min(VAR_1))]`: Return a list containing the minimum even integer in the input list and its index in the input list. The `min` function is used to find the minimum even integer in the new list `VAR_1`. The `index` function is used to find the index of the minimum even integer in the original input list `VAR_0`. The two values are returned as a list.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 30)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 31)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 30)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 31)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> bool:\n    for (VAR_1, VAR_2) in enumerate(VAR_0):\n        for VAR_3 in range((VAR_1 + 1), len(VAR_0)):\n            if ((VAR_2 + VAR_0[VAR_3]) == 0):\n                return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a boolean value. The function is defined with the name `FUNC_0` and takes a single argument `VAR_0` which is a list of integers. The function returns a boolean value indicating whether there are two elements in the input list whose sum is zero.\n\nThe first line of the code imports the `List` type from the `typing` module. This is used to specify the type of the input argument `VAR_0` as a list of integers.\n\nThe second line of the code defines the function `FUNC_0`. The function takes a single argument `VAR_0` which is a list of integers and returns a boolean value.\n\nThe third line of the code starts a `for` loop that iterates over each element of the input list `VAR_0`. The `enumerate` function is used to get the index and value of each element of the list. The index is assigned to the variable `VAR_1` and the value is assigned to the variable `VAR_2`.\n\nThe fourth line of the code starts another `for` loop that iterates over each element of the input list `VAR_0` starting from the element after the current element being iterated over in the outer loop. The `range` function is used to generate a sequence of integers starting from `VAR_1 + 1` and ending at the length of the input list `VAR_0`. The current element being iterated over in the outer loop is skipped by starting the range from `VAR_1 + 1`.\n\nThe fifth line of the code checks if the sum of the current element being iterated over in the outer loop (`VAR_2`) and the current element being iterated over in the inner loop (`VAR_0[VAR_3]`) is equal to zero. If the sum is zero, the function returns `True`.\n\nThe sixth line of the code returns `False` if the function has not returned `True` in the previous step. This indicates that there are no two elements in the input list whose sum is zero.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"xyz\") \"xyzyx\" 0.001)\n    (check-within (candidate \"xyx\") \"xyx\" 0.001)\n    (check-within (candidate \"jerry\") \"jerryrrej\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    if (not VAR_0):\n        return ''\n    VAR_1 = 0\n    while (VAR_0[VAR_1:] != VAR_0[VAR_1:][::(- 1)]):\n        VAR_1 += 1\n    return (VAR_0 + VAR_0[:VAR_1][::(- 1)])\n\n### Explanation\n\nThe code is an implementation of a function that takes in a string and returns a new string that is the original string concatenated with the reverse of the substring of the original string that starts from the beginning and ends at the index of the first character that makes the original string a palindrome.\n\n1. `def FUNC_0(VAR_0: str) -> str:` - This line defines a function named `FUNC_0` that takes in a string argument `VAR_0` and returns a string. The `-> str` indicates that the function returns a string.\n\n2. `if (not VAR_0):` - This line checks if the input string is empty. If it is, the function returns an empty string.\n\n3. `VAR_1 = 0` - This line initializes a variable `VAR_1` to 0. This variable will be used to keep track of the index of the first character that makes the original string a palindrome.\n\n4. `while (VAR_0[VAR_1:] != VAR_0[VAR_1:][::(- 1)]):` - This line starts a while loop that continues until the substring of the original string starting from the index `VAR_1` is equal to the reverse of that substring. The `VAR_0[VAR_1:]` syntax is used to get a substring of `VAR_0` starting from index `VAR_1`. The `VAR_0[VAR_1:][::(- 1)]` syntax is used to get the reverse of that substring.\n\n5. `VAR_1 += 1` - This line increments the `VAR_1` variable by 1, so that the next iteration of the loop checks the next character in the string.\n\n6. `return (VAR_0 + VAR_0[:VAR_1][::(- 1)])` - This line returns the original string concatenated with the reverse of the substring of the original string that starts from the beginning and ends at the index of the first character that makes the original string a palindrome. The `VAR_0[:VAR_1]` syntax is used to get the substring of `VAR_0` starting from the beginning and ending at index `VAR_1`. The `[::(- 1)]` syntax is used to get the reverse of that substring. The `+` operator is used to concatenate the original string with the reversed substring. The result is returned by the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 2) 18 0.001)\n    (check-within (candidate 3) 180 0.001)\n    (check-within (candidate 4) 1800 0.001)\n    (check-within (candidate 5) 18000 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    if (VAR_0 == 1):\n        return 1\n    return (18 * (10 ** (VAR_0 - 2)))\n\n### Explanation\n\nThe code is an implementation of a function that returns a number based on the input. \n\nThe function is named `FUNC_0` and takes an integer argument named `VAR_0`. It returns an integer.\n\nThe first line of the function is an `if` statement that checks if `VAR_0` is equal to 1. If it is, the function returns 1.\n\nIf `VAR_0` is not equal to 1, the function returns the result of a mathematical expression. The expression is `18 * (10 ** (VAR_0 - 2))`. \n\nThe `**` operator is the exponentiation operator in Python. It raises the number on the left to the power of the number on the right. \n\nSo `(10 ** (VAR_0 - 2))` raises 10 to the power of `VAR_0 - 2`. \n\nThe result of that expression is then multiplied by 18 and returned as the result of the function. \n\nIn summary, the function returns 1 if the input is 1, and otherwise returns 18 times 10 to the power of the input minus 2.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)\n    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)\n    (check-within (candidate (list -1 -2)) (list ) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n    return [VAR_1 for VAR_1 in VAR_0 if (VAR_1 > 0)]\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a new list of integers that only contains positive integers. \n\n1. `from typing import List` - import the List class from the typing module\n2. `def FUNC_0(VAR_0: List[int]) -> List[int]:` - define a function named FUNC_0 that takes in a list of integers named VAR_0 and returns a list of integers. \n3. `return [VAR_1 for VAR_1 in VAR_0 if (VAR_1 > 0)]` - return a new list that contains all the elements in VAR_0 that are greater than 0. This is done using a list comprehension.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) \"\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"xyz\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\" \"w\" \"k\")) \"xyzwk\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[str]) -> str:\n    return ''.join(VAR_0)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings and returns a single string that is the concatenation of all the strings in the list. \n\n- `from typing import List`: Importing the List class from the typing module.\n\n- `def FUNC_0(VAR_0: List[str]) -> str:`: Defining a function called FUNC_0 that takes a single argument VAR_0, which is a list of strings. The function returns a single string.\n\n- `return ''.join(VAR_0)`: The function returns the concatenation of all the strings in the list VAR_0. The `join()` method is called on an empty string, which means that the strings in the list are joined together with no separator between them.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"[[]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]][[[[[]\") #f 0.001)\n    (check-within (candidate \"[][]\") #f 0.001)\n    (check-within (candidate \"[]\") #f 0.001)\n    (check-within (candidate \"[[[[]]]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]]]]]\") #f 0.001)\n    (check-within (candidate \"[][][[]]\") #t 0.001)\n    (check-within (candidate \"[[]\") #f 0.001)\n    (check-within (candidate \"[]]\") #f 0.001)\n    (check-within (candidate \"[[]][[\") #t 0.001)\n    (check-within (candidate \"[[][]]\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"[[[[[[[[\") #f 0.001)\n    (check-within (candidate \"]]]]]]]]\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> bool:\n    VAR_1 = []\n    VAR_2 = []\n    for VAR_3 in range(len(VAR_0)):\n        if (VAR_0[VAR_3] == '['):\n            VAR_1.append(VAR_3)\n        else:\n            VAR_2.append(VAR_3)\n    VAR_2.reverse()\n    VAR_4 = 0\n    VAR_3 = 0\n    VAR_5 = len(VAR_2)\n    for VAR_6 in VAR_1:\n        if ((VAR_3 < VAR_5) and (VAR_6 < VAR_2[VAR_3])):\n            VAR_4 += 1\n            VAR_3 += 1\n    return (VAR_4 >= 2)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value. The function checks if there are at least two pairs of square brackets in the string, where each pair is properly nested (i.e., the opening bracket `[` comes before the closing bracket `]`).\n\n- `def FUNC_0(VAR_0: str) -> bool:` defines the function `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value.\n- `VAR_1 = []` initializes an empty list `VAR_1`.\n- `VAR_2 = []` initializes another empty list `VAR_2`.\n- `for VAR_3 in range(len(VAR_0)):` loops over the indices of the characters in the input string `VAR_0`.\n- `if (VAR_0[VAR_3] == '['):` checks if the character at index `VAR_3` in the input string `VAR_0` is an opening bracket `[`.\n- `VAR_1.append(VAR_3)` appends the index `VAR_3` to the list `VAR_1`.\n- `else:` executes if the character at index `VAR_3` in the input string `VAR_0` is not an opening bracket `[`.\n- `VAR_2.append(VAR_3)` appends the index `VAR_3` to the list `VAR_2`.\n- `VAR_2.reverse()` reverses the order of the elements in the list `VAR_2`.\n- `VAR_4 = 0` initializes a variable `VAR_4` to zero.\n- `VAR_3 = 0` initializes another variable `VAR_3` to zero.\n- `VAR_5 = len(VAR_2)` sets the variable `VAR_5` to the length of the list `VAR_2`.\n- `for VAR_6 in VAR_1:` loops over the elements in the list `VAR_1`.\n- `if ((VAR_3 < VAR_5) and (VAR_6 < VAR_2[VAR_3])):` checks if the index `VAR_6` in the input string `VAR_0` is less than the index `VAR_2[VAR_3]` in the reversed list `VAR_2`, and if the variable `VAR_3` is less than the length of the list `VAR_2`.\n- `VAR_4 += 1` increments the variable `VAR_4` by one.\n- `VAR_3 += 1` increments the variable `VAR_3` by one.\n- `return (VAR_4 >= 2)` returns `True` if the variable `VAR_4` is greater than or equal to 2, and `False` otherwise.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"\") #t 0.001)\n    (check-within (candidate \"aba\") #t 0.001)\n    (check-within (candidate \"aaaaa\") #t 0.001)\n    (check-within (candidate \"zbcd\") #f 0.001)\n    (check-within (candidate \"xywyx\") #t 0.001)\n    (check-within (candidate \"xywyz\") #f 0.001)\n    (check-within (candidate \"xywzx\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> bool:\n    for VAR_1 in range(len(VAR_0)):\n        if (VAR_0[VAR_1] != VAR_0[((len(VAR_0) - 1) - VAR_1)]):\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a string is a palindrome. \n\n1. Define a function named `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value.\n2. For each index `VAR_1` in the range of the length of the input string `VAR_0`, do the following:\n    1. If the character at index `VAR_1` is not equal to the character at the corresponding index from the end of the string, return `False`.\n3. If the loop completes without returning `False`, return `True`.\n\nThe function works by iterating through the string from the beginning and the end at the same time, comparing the characters at each index. If any pair of characters is not equal, the function returns `False`. If all pairs of characters are equal, the function returns `True`. \n\nNote: `VAR_0[((len(VAR_0) - 1) - VAR_1)]` is used to get the corresponding character from the end of the string. `(len(VAR_0) - 1)` gives the index of the last character in the string, and subtracting `VAR_1` from that gives the corresponding index from the end of the string. For example, if `VAR_1` is 0 (the first character in the string), then the corresponding index from the end of the string is `len(VAR_0) - 1 - 0`, which is `len(VAR_0) - 1`. If `VAR_1` is `len(VAR_0) - 1` (the last character in the string), then the corresponding index from the end of the string is `len(VAR_0) - 1 - (len(VAR_0) - 1)`, which is 0 (the first character in the string).<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_108_count_nums",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_108_count_nums.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list -1 -2 0)) 0 0.001)\n    (check-within (candidate (list 1 1 2 -2 3 4 5)) 6 0.001)\n    (check-within (candidate (list 1 6 9 -6 0 1 5)) 5 0.001)\n    (check-within (candidate (list 1 100 98 -7 1 -1)) 4 0.001)\n    (check-within (candidate (list 12 23 34 -45 -56 0)) 5 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n\n    def FUNC_1(VAR_1):\n        VAR_2 = 1\n        if (VAR_1 < 0):\n            (VAR_1, VAR_2) = (((- 1) * VAR_1), (- 1))\n        VAR_1 = [int(VAR_3) for VAR_3 in str(VAR_1)]\n        VAR_1[0] = (VAR_1[0] * VAR_2)\n        return sum(VAR_1)\n    return len(list(filter((lambda VAR_4: (VAR_4 > 0)), [FUNC_1(VAR_5) for VAR_5 in VAR_0])))\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns the number of integers in the list that have a positive digit sum. \n\n1. `from typing import List` - Importing the List class from the typing module. This is used to define the type of the input parameter of the function.\n\n2. `def FUNC_0(VAR_0: List[int]) -> int:` - Defining a function named FUNC_0 that takes in a list of integers and returns an integer. The input parameter is named VAR_0.\n\n3. `def FUNC_1(VAR_1):` - Defining a nested function named FUNC_1 that takes in an integer and returns an integer. The input parameter is named VAR_1.\n\n4. `VAR_2 = 1` - Initializing a variable named VAR_2 to 1.\n\n5. `if (VAR_1 < 0):` - Checking if the input integer is negative.\n\n6. `(VAR_1, VAR_2) = (((- 1) * VAR_1), (- 1))` - If the input integer is negative, multiply it by -1 and set VAR_2 to -1.\n\n7. `VAR_1 = [int(VAR_3) for VAR_3 in str(VAR_1)]` - Convert the input integer to a list of integers by converting each digit to an integer.\n\n8. `VAR_1[0] = (VAR_1[0] * VAR_2)` - Multiply the first digit of the list by VAR_2.\n\n9. `return sum(VAR_1)` - Return the sum of the digits in the list.\n\n10. `return len(list(filter((lambda VAR_4: (VAR_4 > 0)), [FUNC_1(VAR_5) for VAR_5 in VAR_0])))` - Return the length of a list of integers that have a positive digit sum. This is done by filtering the list of integers in VAR_0 through the nested function FUNC_1, which returns the digit sum of each integer. The lambda function checks if the digit sum is greater than 0. The resulting list is then converted to a list and its length is returned.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 2) (list 2) 0.001)\n    (check-within (candidate 4) (list 2 2) 0.001)\n    (check-within (candidate 8) (list 2 2 2) 0.001)\n    (check-within (candidate 57) (list 3 19) 0.001)\n    (check-within (candidate 3249) (list 3 3 19 19) 0.001)\n    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)\n    (check-within (candidate 20577) (list 3 19 19 19) 0.001)\n    (check-within (candidate 18) (list 2 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int) -> List[int]:\n    import math\n    VAR_1 = []\n    VAR_2 = 2\n    while (VAR_2 <= int((math.sqrt(VAR_0) + 1))):\n        if ((VAR_0 % VAR_2) == 0):\n            VAR_1.append(VAR_2)\n            VAR_0 //= VAR_2\n        else:\n            VAR_2 += 1\n    if (VAR_0 > 1):\n        VAR_1.append(VAR_0)\n    return VAR_1\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer `VAR_0` as input and returns a list of integers. \n\nThe function is defined with the name `FUNC_0` and takes a single argument `VAR_0` of type `int`. The function returns a list of integers. The `List` type is imported from the `typing` module.\n\n```python\nfrom typing import List\ndef FUNC_0(VAR_0: int) -> List[int]:\n```\n\nThe `math` module is imported.\n\n```python\n    import math\n```\n\nAn empty list is created and assigned to the variable `VAR_1`.\n\n```python\n    VAR_1 = []\n```\n\nThe variable `VAR_2` is assigned the value `2`.\n\n```python\n    VAR_2 = 2\n```\n\nA while loop is started. The loop continues as long as `VAR_2` is less than or equal to the square root of `VAR_0` plus 1. The `int` function is used to round down the square root of `VAR_0` to an integer.\n\n```python\n    while (VAR_2 <= int((math.sqrt(VAR_0) + 1))):\n```\n\nAn if statement is used to check if `VAR_0` is divisible by `VAR_2`. If it is, `VAR_2` is appended to the list `VAR_1` and `VAR_0` is divided by `VAR_2`. If `VAR_0` is not divisible by `VAR_2`, `VAR_2` is incremented by 1.\n\n```python\n        if ((VAR_0 % VAR_2) == 0):\n            VAR_1.append(VAR_2)\n            VAR_0 //= VAR_2\n        else:\n            VAR_2 += 1\n```\n\nIf `VAR_0` is greater than 1, it is appended to the list `VAR_1`.\n\n```python\n    if (VAR_0 > 1):\n        VAR_1.append(VAR_0)\n```\n\nThe function returns the list `VAR_1`.\n\n```python\n    return VAR_1\n```\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 15) 5 0.001)\n    (check-within (candidate 27) 3 0.001)\n    (check-within (candidate 63) 7 0.001)\n    (check-within (candidate 330) 11 0.001)\n    (check-within (candidate 13195) 29 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n\n    def FUNC_1(VAR_1):\n        if (VAR_1 < 2):\n            return False\n        for VAR_2 in range(2, (VAR_1 - 1)):\n            if ((VAR_1 % VAR_2) == 0):\n                return False\n        return True\n    VAR_3 = 1\n    for VAR_4 in range(2, (VAR_0 + 1)):\n        if (((VAR_0 % VAR_4) == 0) and FUNC_1(VAR_4)):\n            VAR_3 = max(VAR_3, VAR_4)\n    return VAR_3\n\n### Explanation\n\nThe code is an implementation of a function that finds the largest prime factor of a given number. \n\n1. `def FUNC_0(VAR_0: int) -> int:` defines a function called `FUNC_0` that takes an integer `VAR_0` as input and returns an integer. \n\n2. `def FUNC_1(VAR_1):` defines a nested function called `FUNC_1` that takes a variable `VAR_1` as input. \n\n3. `if (VAR_1 < 2):` checks if `VAR_1` is less than 2. If it is, the function returns `False`.\n\n4. `for VAR_2 in range(2, (VAR_1 - 1)):` iterates through a range of numbers from 2 to `VAR_1 - 1`.\n\n5. `if ((VAR_1 % VAR_2) == 0):` checks if `VAR_1` is divisible by `VAR_2`. If it is, the function returns `False`.\n\n6. `return True` returns `True` if the function has not yet returned `False`.\n\n7. `VAR_3 = 1` initializes a variable `VAR_3` to 1.\n\n8. `for VAR_4 in range(2, (VAR_0 + 1)):` iterates through a range of numbers from 2 to `VAR_0 + 1`.\n\n9. `if (((VAR_0 % VAR_4) == 0) and FUNC_1(VAR_4)):` checks if `VAR_0` is divisible by `VAR_4` and if `VAR_4` is a prime number (using the `FUNC_1` function). If both conditions are true, the code executes the next line.\n\n10. `VAR_3 = max(VAR_3, VAR_4)` updates `VAR_3` to be the maximum value between `VAR_3` and `VAR_4`.\n\n11. `return VAR_3` returns the final value of `VAR_3`, which is the largest prime factor of `VAR_0`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 10) 36 0.001)\n    (check-within (candidate 100) 53361 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> int:\n    VAR_1 = [(((VAR_2 * VAR_2) - VAR_2) + 1) for VAR_2 in range(1, (VAR_0 + 1))]\n    VAR_3 = []\n    for VAR_2 in range(VAR_0):\n        for VAR_4 in range((VAR_2 + 1), VAR_0):\n            for VAR_5 in range((VAR_4 + 1), VAR_0):\n                if ((((VAR_1[VAR_2] + VAR_1[VAR_4]) + VAR_1[VAR_5]) % 3) == 0):\n                    VAR_3 += [(VAR_1[VAR_2], VAR_1[VAR_4], VAR_1[VAR_5])]\n    return len(VAR_3)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer argument `VAR_0` and returns an integer. \n\n1. `VAR_1 = [(((VAR_2 * VAR_2) - VAR_2) + 1) for VAR_2 in range(1, (VAR_0 + 1))]` creates a list of integers `VAR_1` with length `VAR_0` where each element is calculated as `((VAR_2 * VAR_2) - VAR_2) + 1` for `VAR_2` in the range from 1 to `VAR_0` inclusive. \n\n2. `VAR_3 = []` creates an empty list `VAR_3`.\n\n3. `for VAR_2 in range(VAR_0):` loops through the range from 0 to `VAR_0` exclusive and assigns each value to `VAR_2`.\n\n4. `for VAR_4 in range((VAR_2 + 1), VAR_0):` loops through the range from `VAR_2 + 1` to `VAR_0` exclusive and assigns each value to `VAR_4`.\n\n5. `for VAR_5 in range((VAR_4 + 1), VAR_0):` loops through the range from `VAR_4 + 1` to `VAR_0` exclusive and assigns each value to `VAR_5`.\n\n6. `if ((((VAR_1[VAR_2] + VAR_1[VAR_4]) + VAR_1[VAR_5]) % 3) == 0):` checks if the sum of the elements in `VAR_1` at indices `VAR_2`, `VAR_4`, and `VAR_5` is divisible by 3.\n\n7. `VAR_3 += [(VAR_1[VAR_2], VAR_1[VAR_4], VAR_1[VAR_5])]` appends a tuple of the elements in `VAR_1` at indices `VAR_2`, `VAR_4`, and `VAR_5` to the list `VAR_3` if the condition in step 6 is true.\n\n8. `return len(VAR_3)` returns the length of the list `VAR_3`. \n\nThe function `FUNC_0` generates all possible combinations of three integers from the list `VAR_1` and returns the number of combinations where the sum of the three integers is divisible by 3.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"Hi\") \"Hi\" 0.001)\n    (check-within (candidate \"hello\") \"ehllo\" 0.001)\n    (check-within (candidate \"number\") \"bemnru\" 0.001)\n    (check-within (candidate \"abcd\") \"abcd\" 0.001)\n    (check-within (candidate \"Hello World!!!\") \"Hello !!!Wdlor\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst .Rboot How aer ?ouy\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    return ' '.join([''.join(sorted(list(VAR_1))) for VAR_1 in VAR_0.split(' ')])\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a string as an argument and returns a string. \n\nThe function takes the input string and splits it into a list of words using the space character as a delimiter. It then sorts each word in the list and joins the sorted characters of each word back into a string. Finally, it joins the list of sorted words back into a single string using the space character as a delimiter.\n\nHere is a line-by-line breakdown of the code:\n\n```python\ndef FUNC_0(VAR_0: str) -> str:\n```\n\nThis line defines a function named `FUNC_0` that takes a single argument `VAR_0` of type `str` and returns a value of type `str`.\n\n```python\nreturn ' '.join([''.join(sorted(list(VAR_1))) for VAR_1 in VAR_0.split(' ')])\n```\n\nThis line sorts each word in the input string and joins the sorted characters of each word back into a string. Finally, it joins the list of sorted words back into a single string using the space character as a delimiter.\n\nHere is a breakdown of the line:\n\n- `VAR_0.split(' ')`: This splits the input string into a list of words using the space character as a delimiter.\n- `sorted(list(VAR_1))`: This sorts the characters of each word in the list.\n- `''.join(sorted(list(VAR_1)))`: This joins the sorted characters of each word back into a string.\n- `[''.join(sorted(list(VAR_1))) for VAR_1 in VAR_0.split(' ')]`: This is a list comprehension that applies the previous two steps to each word in the input string.\n- `' '.join([''.join(sorted(list(VAR_1))) for VAR_1 in VAR_0.split(' ')])`: This joins the list of sorted words back into a single string using the space character as a delimiter.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 1000) \"1\" 0.001)\n    (check-within (candidate 150) \"110\" 0.001)\n    (check-within (candidate 147) \"1100\" 0.001)\n    (check-within (candidate 333) \"1001\" 0.001)\n    (check-within (candidate 963) \"10010\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> str:\n    return bin(sum((int(VAR_1) for VAR_1 in str(VAR_0))))[2:]\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns a binary string that represents the sum of the digits of the input integer.\n\n1. `def FUNC_0(VAR_0: int) -> str:` - This line defines a function named `FUNC_0` that takes an integer as input and returns a string. The `-> str` part specifies the return type of the function.\n\n2. `return bin(sum((int(VAR_1) for VAR_1 in str(VAR_0))))[2:]` - This line returns a binary string that represents the sum of the digits of the input integer. \n\n    a. `str(VAR_0)` - This converts the input integer to a string so that we can iterate over its digits.\n    \n    b. `(int(VAR_1) for VAR_1 in str(VAR_0))` - This is a generator expression that converts each digit of the input integer to an integer.\n    \n    c. `sum((int(VAR_1) for VAR_1 in str(VAR_0)))` - This calculates the sum of the digits of the input integer.\n    \n    d. `bin(sum((int(VAR_1) for VAR_1 in str(VAR_0))))` - This converts the sum of the digits to a binary string.\n    \n    e. `[2:]` - This slices the binary string to remove the first two characters, which are '0b'. This is because the `bin()` function in Python returns a string that starts with '0b' to indicate that it is a binary string. We don't need these characters in the final output.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)\n    (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)\n    (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)\n    (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)\n    (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)\n    (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)\n    (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[List[int]], VAR_1: int) -> List[int]:\n    VAR_2 = len(VAR_0)\n    VAR_3 = ((VAR_2 * VAR_2) + 1)\n    for VAR_4 in range(VAR_2):\n        for VAR_5 in range(VAR_2):\n            if (VAR_0[VAR_4][VAR_5] == 1):\n                VAR_6 = []\n                if (VAR_4 != 0):\n                    VAR_6.append(VAR_0[(VAR_4 - 1)][VAR_5])\n                if (VAR_5 != 0):\n                    VAR_6.append(VAR_0[VAR_4][(VAR_5 - 1)])\n                if (VAR_4 != (VAR_2 - 1)):\n                    VAR_6.append(VAR_0[(VAR_4 + 1)][VAR_5])\n                if (VAR_5 != (VAR_2 - 1)):\n                    VAR_6.append(VAR_0[VAR_4][(VAR_5 + 1)])\n                VAR_3 = min(VAR_6)\n    VAR_7 = []\n    for VAR_4 in range(VAR_1):\n        if ((VAR_4 % 2) == 0):\n            VAR_7.append(1)\n        else:\n            VAR_7.append(VAR_3)\n    return VAR_7\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two arguments: `VAR_0` and `VAR_1`. `VAR_0` is a list of lists of integers, and `VAR_1` is an integer. The function returns a list of integers.\n\nThe first line of the code imports the `List` class from the `typing` module.\n\nThe second line defines the `FUNC_0` function. It takes two arguments: `VAR_0` and `VAR_1`. `VAR_0` is a list of lists of integers, and `VAR_1` is an integer. The function returns a list of integers.\n\nThe third line initializes a variable `VAR_2` to the length of `VAR_0`.\n\nThe fourth line initializes a variable `VAR_3` to the square of `VAR_2` plus one.\n\nThe fifth line starts a `for` loop that iterates over the range of `VAR_2`. The loop variable is `VAR_4`.\n\nThe sixth line starts another `for` loop that iterates over the range of `VAR_2`. The loop variable is `VAR_5`.\n\nThe seventh line checks if the value of `VAR_0[VAR_4][VAR_5]` is equal to 1.\n\nThe eighth line initializes an empty list `VAR_6`.\n\nThe ninth line checks if `VAR_4` is not equal to 0. If it is not, it appends the value of `VAR_0[(VAR_4 - 1)][VAR_5]` to `VAR_6`.\n\nThe tenth line checks if `VAR_5` is not equal to 0. If it is not, it appends the value of `VAR_0[VAR_4][(VAR_5 - 1)]` to `VAR_6`.\n\nThe eleventh line checks if `VAR_4` is not equal to `VAR_2 - 1`. If it is not, it appends the value of `VAR_0[(VAR_4 + 1)][VAR_5]` to `VAR_6`.\n\nThe twelfth line checks if `VAR_5` is not equal to `VAR_2 - 1`. If it is not, it appends the value of `VAR_0[VAR_4][(VAR_5 + 1)]` to `VAR_6`.\n\nThe thirteenth line sets `VAR_3` to the minimum value in `VAR_6`.\n\nThe fourteenth line initializes an empty list `VAR_7`.\n\nThe fifteenth line starts a `for` loop that iterates over the range of `VAR_1`. The loop variable is `VAR_4`.\n\nThe sixteenth line checks if `VAR_4` is even. If it is, it appends the value 1 to `VAR_7`. If it is not, it appends the value of `VAR_3` to `VAR_7`.\n\nThe seventeenth line returns `VAR_7`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0 VAR_1)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate \"hi\") \"lm\" 0.001)\n    (check-within (candidate \"asdfghjkl\") \"ewhjklnop\" 0.001)\n    (check-within (candidate \"gf\") \"kj\" 0.001)\n    (check-within (candidate \"et\") \"ix\" 0.001)\n    (check-within (candidate \"faewfawefaewg\") \"jeiajeaijeiak\" 0.001)\n    (check-within (candidate \"hellomyfriend\") \"lippsqcjvmirh\" 0.001)\n    (check-within (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" 0.001)\n    (check-within (candidate \"a\") \"e\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: str) -> str:\n    VAR_1 = 'abcdefghijklmnopqrstuvwxyz'\n    VAR_2 = ''\n    for VAR_3 in VAR_0:\n        if (VAR_3 in VAR_1):\n            VAR_2 += VAR_1[((VAR_1.index(VAR_3) + (2 * 2)) % 26)]\n        else:\n            VAR_2 += VAR_3\n    return VAR_2\n\n### Explanation\n\nThe code is an implementation of a Caesar cipher, which is a simple encryption technique that shifts the letters of a message by a certain number of places down the alphabet. The number of places shifted is called the key. In this implementation, the key is 4.\n\n* `def FUNC_0(VAR_0: str) -> str:` - This line defines a function called `FUNC_0` that takes a string argument `VAR_0` and returns a string. The `-> str` specifies the return type of the function.\n\n* `VAR_1 = 'abcdefghijklmnopqrstuvwxyz'` - This line initializes a string variable `VAR_1` with all the lowercase letters of the English alphabet.\n\n* `VAR_2 = ''` - This line initializes an empty string variable `VAR_2`.\n\n* `for VAR_3 in VAR_0:` - This line starts a loop that iterates over each character in the input string `VAR_0`.\n\n* `if (VAR_3 in VAR_1):` - This line checks if the current character `VAR_3` is a lowercase letter.\n\n* `VAR_2 += VAR_1[((VAR_1.index(VAR_3) + (2 * 2)) % 26)]` - This line appends the encrypted character to the output string `VAR_2`. The encrypted character is obtained by finding the index of the current character in the alphabet string `VAR_1`, adding 4 to it (the key is 4), and wrapping around to the beginning of the alphabet if necessary (using the modulo operator `%`). The resulting index is used to get the corresponding letter from the alphabet string.\n\n* `else:` - This line executes if the current character is not a lowercase letter.\n\n* `VAR_2 += VAR_3` - This line appends the current character to the output string `VAR_2` as is.\n\n* `return VAR_2` - This line returns the encrypted string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 3) (list 3 5 7) 0.001)\n    (check-within (candidate 4) (list 4 6 8 10) 0.001)\n    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)\n    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)\n    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef FUNC_0(VAR_0: int) -> List[int]:\n    return [(VAR_0 + (2 * VAR_1)) for VAR_1 in range(VAR_0)]\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer argument `VAR_0` and returns a list of integers. \n\nThe function returns a list of integers that are generated by iterating over a range of integers from 0 to `VAR_0 - 1` and performing an operation on each integer. The operation is `(VAR_0 + (2 * VAR_1))` where `VAR_1` is the current integer in the iteration.\n\nThe function is defined using the `def` keyword, followed by the function name `FUNC_0`, and the argument `VAR_0` with type annotation `int`. The function returns a list of integers, which is indicated by the `-> List[int]` type annotation.\n\nThe `range` function is used to generate a sequence of integers from 0 to `VAR_0 - 1`. The `for` loop iterates over this sequence, with each iteration assigning the current integer to the variable `VAR_1`.\n\nThe list comprehension syntax is used to generate a list of integers by applying the operation `(VAR_0 + (2 * VAR_1))` to each integer in the range. The resulting list is returned by the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (FUNC_0 VAR_0)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate FUNC_0))\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 101) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 13441) #t 0.001)\n    (check-within (candidate 61) #t 0.001)\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 1) #f 0.001)\n    (check-within (candidate 5) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 17) #t 0.001)\n    (check-within (candidate 85) #f 0.001)\n    (check-within (candidate 77) #f 0.001)\n    (check-within (candidate 255379) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef FUNC_0(VAR_0: int) -> bool:\n    if (VAR_0 < 2):\n        return False\n    for VAR_1 in range(2, (VAR_0 - 1)):\n        if ((VAR_0 % VAR_1) == 0):\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a number is prime. \n\n`def FUNC_0(VAR_0: int) -> bool:` defines a function named `FUNC_0` that takes an integer argument `VAR_0` and returns a boolean value.\n\n`if (VAR_0 < 2):` checks if the input number is less than 2. If it is, the function returns `False` because 1 and 0 are not prime numbers.\n\n`for VAR_1 in range(2, (VAR_0 - 1)):` loops through all numbers from 2 to the input number minus 1. This is because any number greater than or equal to the input number will not be a factor of the input number.\n\n`if ((VAR_0 % VAR_1) == 0):` checks if the input number is divisible by the current number in the loop. If it is, the function returns `False` because the input number is not prime.\n\n`return True` is executed if the input number is not divisible by any number in the loop, which means the input number is prime. The function returns `True`.\n\n### Racket version\n\n#lang racket\n\n(define (FUNC_0 VAR_0)\n"
  }
]