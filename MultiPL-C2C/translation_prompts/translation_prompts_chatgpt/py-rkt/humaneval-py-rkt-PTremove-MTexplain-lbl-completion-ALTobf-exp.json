[
  {
    "name": "HumanEval_30_get_positive",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_positive l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)\n    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)\n    (check-within (candidate (list -1 -2)) (list ) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n    return [e for e in l if e > 0]\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a new list containing only the positive integers. \n\nThe function is defined on line 2 with the name `FUNC_0`. It takes in a list of integers `VAR_0` and returns a list of integers. \n\nThe function body is a list comprehension that iterates over each element `VAR_1` in `VAR_0`. For each element, it checks if the element is greater than 0. If it is, it adds the element to a new list. The new list is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_positive l)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (parse_nested_parens paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3) 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4) 0.001)\n    (check-within (candidate \"(()(())((())))\") (list 4) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns a list of integers. The function is defined using Python's type annotations to specify the types of the input and output parameters.\n\nThe function contains another function called `FUNC_1`, which takes a string as input and returns an integer. This function is used to calculate the maximum depth of nested parentheses in the input string.\n\nThe `FUNC_1` function initializes two variables, `VAR_2` and `VAR_3`, to 0. It then iterates over each character in the input string using a for loop. If the character is an opening parenthesis, `VAR_2` is incremented by 1 and `VAR_3` is updated to the maximum value of `VAR_2` and `VAR_3`. If the character is a closing parenthesis, `VAR_2` is decremented by 1.\n\nThe `FUNC_0` function splits the input string into a list of strings using the space character as a delimiter. It then applies the `FUNC_1` function to each string in the list using a list comprehension. The list comprehension also filters out any empty strings in the list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (parse_nested_parens paren_string)\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_row lst x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_row))\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 4) (list 1 0) (list 2 5) (list 2 0)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6)) 2) (list (list 0 1) (list 1 1) (list 2 1) (list 3 1) (list 4 1) (list 5 1)) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 1 3 4 5 6) (list 1 2 1 4 5 6) (list 1 2 3 1 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 0) (list 2 1) (list 2 0) (list 3 2) (list 3 0) (list 4 3) (list 4 0) (list 5 4) (list 5 0) (list 6 5) (list 6 0)) 0.001)\n    (check-within (candidate (list ) 1) (list ) 0.001)\n    (check-within (candidate (list (list 1)) 2) (list ) 0.001)\n    (check-within (candidate (list (list ) (list 1) (list 1 2 3)) 3) (list (list 2 2)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of lists of integers and an integer and returns a list of tuples of integers. The function is defined with the name FUNC_0 and takes two arguments: VAR_0 and VAR_1. VAR_0 is a list of lists of integers and VAR_1 is an integer. The function returns a list of tuples of integers.\n\nThe first line of the code imports two types from the typing module: List and Tuple. List is used to specify the type of VAR_0, which is a list of lists of integers. Tuple is used to specify the type of the elements in the list that the function returns, which are tuples of integers.\n\nThe second line of the code defines the function FUNC_0. The function takes two arguments: VAR_0 and VAR_1. VAR_0 is a list of lists of integers and VAR_1 is an integer. The function returns a list of tuples of integers.\n\nThe third line of the code creates a list comprehension that iterates over the rows and columns of VAR_0 and creates a tuple of the row and column indices for each element in VAR_0 that is equal to VAR_1. The resulting list of tuples is assigned to the variable VAR_2.\n\nThe fourth line of the code sorts the list of tuples VAR_2 first by the second element of each tuple (the column index) in descending order and then by the first element of each tuple (the row index) in ascending order. The sorted function is used twice, with the second sort being the primary sort and the first sort being the secondary sort.\n\nThe function returns the sorted list of tuples VAR_2.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_row lst x)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)\n    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)\n    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)\n    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)\n    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)\n    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)\n    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)\n    (check-within (candidate (list 0.0)) 0 0.001)\n    (check-within (candidate (list -1.0)) 1 0.001)\n    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of floats and returns an integer. The function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of floats. The function returns an integer.\n\nThe first line of the code imports the math module. This module provides access to the mathematical functions defined by the C standard. \n\nThe second line of the code initializes a variable VAR_1 to 0.\n\nThe third line of the code starts a for loop that iterates over each element in the list VAR_0. The loop variable is named VAR_2.\n\nThe fourth line of the code adds the square of the ceiling of VAR_2 to VAR_1. The ceil() function is a method of the math module that returns the smallest integer greater than or equal to the input value. The ** operator is the exponentiation operator in Python.\n\nThe fifth line of the code returns VAR_1, which is the sum of the squares of the ceiling of each element in VAR_0.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (derivative xs)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate derivative))\n    (check-within (candidate (list 3 1 2 4 5)) (list 1 4 12 20) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 6) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 2 2) 0.001)\n    (check-within (candidate (list 3 2 1 0 4)) (list 2 2 0 16) 0.001)\n    (check-within (candidate (list 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef derivative(xs: List[int]) -> List[int]:\n    return [(i * x) for i, x in enumerate(xs)][1:]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a list of integers. The function takes a list of integers as input and returns a new list of integers that is the result of multiplying each element of the input list by its index in the list.\n\nThe function is defined using the `def` keyword, followed by the function name `FUNC_0`. The function takes a single argument, which is a list of integers named `VAR_0`. The function returns a list of integers.\n\nThe first line of the function body uses a list comprehension to create a new list of integers. The list comprehension iterates over the input list `VAR_0` using the `enumerate` function, which returns a tuple containing the index of the current element and the element itself. The list comprehension multiplies each element of the input list by its index, and returns a new list of the results.\n\nThe second line of the function body slices the new list to remove the first element, which is the result of multiplying the first element of the input list by its index (which is always 0).\n\n### Racket version\n\n#lang racket\n\n;; \n(define (derivative xs)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_multiply_prime a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_multiply_prime))\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #f 0.001)\n    (check-within (candidate 125) #t 0.001)\n    (check-within (candidate 105) #t 0.001)\n    (check-within (candidate 126) #f 0.001)\n    (check-within (candidate 729) #f 0.001)\n    (check-within (candidate 891) #f 0.001)\n    (check-within (candidate 1001) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_multiply_prime(a: int) -> bool:\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer `VAR_0` as input and returns a boolean value. \n\nThe function contains another function called `FUNC_1` that takes an integer `VAR_1` as input and returns a boolean value. This function checks if the input integer is a prime number by iterating over all integers from 2 to the input integer - 1 and checking if the input integer is divisible by any of them. If it is, the function returns `False`, otherwise it returns `True`.\n\nThe main function `FUNC_0` then iterates over all integers from 2 to 100 (inclusive) three times using nested for loops. For each iteration, it checks if the current integer is a prime number by calling the `FUNC_1` function. If it is not, it continues to the next iteration. If all three integers are prime numbers and their product is equal to the input integer `VAR_0`, the function returns `True`. If no combination of three prime numbers results in the input integer, the function returns `False`. \n\nIn summary, the function checks if there are three prime numbers whose product is equal to the input integer. If there are, it returns `True`, otherwise it returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_multiply_prime a)\n"
  },
  {
    "name": "HumanEval_103_rounded_avg",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (rounded_avg n m)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_103_rounded_avg.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rounded_avg))\n    (check-within (candidate 1 5) \"0b11\" 0.001)\n    (check-within (candidate 7 13) \"0b1010\" 0.001)\n    (check-within (candidate 964 977) \"0b1111001010\" 0.001)\n    (check-within (candidate 996 997) \"0b1111100100\" 0.001)\n    (check-within (candidate 560 851) \"0b1011000010\" 0.001)\n    (check-within (candidate 185 546) \"0b101101110\" 0.001)\n    (check-within (candidate 362 496) \"0b110101101\" 0.001)\n    (check-within (candidate 350 902) \"0b1001110010\" 0.001)\n    (check-within (candidate 197 233) \"0b11010111\" 0.001)\n    (check-within (candidate 7 5) -1 0.001)\n    (check-within (candidate 5 1) -1 0.001)\n    (check-within (candidate 5 5) \"0b101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Union\n\ndef rounded_avg(n: int, m: int) -> Union[str, int]:\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, VAR_0 and VAR_1, both integers. The function returns a binary string that represents the average of all integers between VAR_0 and VAR_1, inclusive. If VAR_1 is less than VAR_0, the function returns -1.\n\nThe first line of the code imports the Union class from the typing module. The Union class is used to specify that the function can return either a string or an integer.\n\nThe second line defines the function FUNC_0, which takes two arguments, VAR_0 and VAR_1, both of type int, and returns a Union of str and int. \n\nThe third line checks if VAR_1 is less than VAR_0. If it is, the function returns -1.\n\nThe fourth line initializes a variable VAR_2 to 0.\n\nThe fifth line starts a for loop that iterates over all integers between VAR_0 and VAR_1, inclusive. For each integer VAR_3 in the range, VAR_2 is incremented by VAR_3.\n\nThe sixth line calculates the average of all integers between VAR_0 and VAR_1, inclusive, and rounds it to the nearest integer. The result is then converted to a binary string using the built-in bin() function.\n\nThe seventh line returns the binary string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (rounded_avg n m)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (eat number need remaining)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate eat))\n    (check-within (candidate 5 6 10) (list 11 4) 0.001)\n    (check-within (candidate 4 8 9) (list 12 1) 0.001)\n    (check-within (candidate 1 10 10) (list 11 0) 0.001)\n    (check-within (candidate 2 11 5) (list 7 0) 0.001)\n    (check-within (candidate 4 5 7) (list 9 2) 0.001)\n    (check-within (candidate 4 5 1) (list 5 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef eat(number: int, need: int, remaining: int) -> List[int]:\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n\n### Explanation\n\nThe code is an implementation of a function that takes three integer arguments and returns a list of two integers. The function is defined with the name `FUNC_0` and takes three arguments: `VAR_0`, `VAR_1`, and `VAR_2`. The function returns a list of two integers.\n\nThe first line of the code imports the `List` type from the `typing` module. This is used to specify the type of the return value of the function.\n\nThe second line of the code defines the function `FUNC_0` with the three arguments `VAR_0`, `VAR_1`, and `VAR_2`. The function returns a list of two integers.\n\nThe third line of the code checks if `VAR_1` is less than or equal to `VAR_2`. If it is, the function returns a list containing two integers: the sum of `VAR_0` and `VAR_1`, and the difference between `VAR_2` and `VAR_1`. If `VAR_1` is greater than `VAR_2`, the function returns a list containing two integers: the sum of `VAR_0` and `VAR_2`, and `0`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (eat number need remaining)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (find_max words)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n    (check-within (candidate (list \"name\" \"of\" \"string\")) \"string\" 0.001)\n    (check-within (candidate (list \"name\" \"enam\" \"game\")) \"enam\" 0.001)\n    (check-within (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\" 0.001)\n    (check-within (candidate (list \"abc\" \"cba\")) \"abc\" 0.001)\n    (check-within (candidate (list \"play\" \"this\" \"game\" \"of\" \"footbott\")) \"footbott\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\" 0.001)\n    (check-within (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\" 0.001)\n    (check-within (candidate (list \"b\")) \"b\" 0.001)\n    (check-within (candidate (list \"play\" \"play\" \"play\")) \"play\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef find_max(words: List[str]) -> str:\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings and returns the string with the most repeated characters. The function is defined with the name FUNC_0 and takes a list of strings as input. The output of the function is a string. \n\nThe first line of the code imports the List class from the typing module. This is used to specify the type of the input variable VAR_0. \n\nThe second line defines the function FUNC_0. The function takes a list of strings as input and returns a string. \n\nThe third line of the code returns the first element of a sorted list. The list is sorted using the sorted() function. The sorted() function takes two arguments: the first argument is the list to be sorted, and the second argument is a key function that is used to determine the order of the elements in the sorted list. \n\nThe key function is defined using a lambda function. The lambda function takes one argument, VAR_1, which represents a string in the input list. The lambda function returns a tuple with two elements. The first element is the negative length of the set of characters in the string. The second element is the string itself. \n\nThe negative length of the set of characters in the string is used to sort the list in descending order of the number of unique characters in the string. The string itself is used to sort the list in ascending order of the string value. \n\nThe [0] at the end of the line returns the first element of the sorted list, which is the string with the most repeated characters.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (find_max words)\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_sorted lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_sorted))\n    (check-within (candidate (list 5)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 7)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n    (check-within (candidate (list 1)) #t 0.001)\n    (check-within (candidate (list 3 2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 2 2 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 3 3 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 2 3 3 4)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a boolean value. The function is called FUNC_0 and it takes in one argument, VAR_0, which is a list of integers. The function returns a boolean value.\n\nThe first line of the code imports the List class from the typing module. This is used to specify the type of the input argument to the function.\n\nThe second line defines the function FUNC_0. The function takes in one argument, VAR_0, which is a list of integers. The function returns a boolean value.\n\nThe third line creates a dictionary called VAR_1. The dictionary is created using a list comprehension that iterates over the elements of VAR_0 and creates a key-value pair for each element. The key is the element itself and the value is set to 0.\n\nThe fourth line starts a for loop that iterates over the elements of VAR_0. For each element, the value of the corresponding key in VAR_1 is incremented by 1.\n\nThe fifth line checks if any of the values in VAR_1 are greater than 2. If any value is greater than 2, the function returns False.\n\nThe sixth line checks if all the elements in VAR_0 are in non-descending order. If all the elements are in non-descending order, the function returns True. Otherwise, it returns False. The check is done using a list comprehension that iterates over the indices of VAR_0 and checks if the element at the current index is greater than or equal to the element at the previous index. The range function is used to generate the indices to iterate over.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_sorted lst)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (match_parens lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate match_parens))\n    (check-within (candidate (list \"()(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \")\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(())\" \"())())\")) \"No\" 0.001)\n    (check-within (candidate (list \")())\" \"(()()(\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"(())))\" \"(()())((\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"()\" \"())\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(\" \"()))()\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"((((\" \"((())\")) \"No\" 0.001)\n    (check-within (candidate (list \")(()\" \"(()(\")) \"No\" 0.001)\n    (check-within (candidate (list \")(\" \")(\")) \"No\" 0.001)\n    (check-within (candidate (list \"(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \"(\")) \"Yes\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n\n### Explanation\n\nThe code is an implementation of a function that checks if two strings can be combined to form a valid parenthesis sequence. The function takes a list of two strings as input and returns 'Yes' if the two strings can be combined to form a valid parenthesis sequence, and 'No' otherwise.\n\nThe function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of strings. The function returns a string.\n\nThe function contains a nested function called FUNC_1. FUNC_1 takes a single argument VAR_1 and returns a boolean value. FUNC_1 checks if the input string VAR_1 can be combined to form a valid parenthesis sequence. FUNC_1 returns True if VAR_1 can be combined to form a valid parenthesis sequence, and False otherwise.\n\nFUNC_1 works by iterating through each character in the input string VAR_1. If the character is '(', the function increments a counter VAR_2. If the character is ')', the function decrements VAR_2. If VAR_2 becomes negative at any point, the function returns False. If VAR_2 is zero at the end of the iteration, the function returns True. Otherwise, the function returns False.\n\nThe main body of the function creates two new strings VAR_4 and VAR_5 by concatenating the input strings in different orders. The function then checks if either VAR_4 or VAR_5 can be combined to form a valid parenthesis sequence by calling FUNC_1. If either VAR_4 or VAR_5 can be combined to form a valid parenthesis sequence, the function returns 'Yes'. Otherwise, the function returns 'No'.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (match_parens lst)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (triangle_area a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 3 4 5) 6.0 0.001)\n    (check-within (candidate 1 2 10) -1 0.001)\n    (check-within (candidate 4 8 5) 8.18 0.001)\n    (check-within (candidate 2 2 2) 1.73 0.001)\n    (check-within (candidate 1 2 3) -1 0.001)\n    (check-within (candidate 10 5 7) 16.25 0.001)\n    (check-within (candidate 2 6 3) -1 0.001)\n    (check-within (candidate 1 1 1) 0.43 0.001)\n    (check-within (candidate 2 2 10) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef triangle_area(a: int, b: int, c: int) -> float:\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n\n### Explanation\n\nThe code is an implementation of Heron's formula for calculating the area of a triangle given the lengths of its sides. \n\n```python\ndef FUNC_0(VAR_0: int, VAR_1: int, VAR_2: int) -> float:\n```\nThe function takes three integer arguments and returns a float. \n\n```python\nif (((VAR_0 + VAR_1) <= VAR_2) or ((VAR_0 + VAR_2) <= VAR_1) or ((VAR_1 + VAR_2) <= VAR_0)):\n    return (- 1)\n```\nThe function checks if the input values form a valid triangle. If the sum of any two sides is less than or equal to the third side, then the values do not form a valid triangle and the function returns -1. \n\n```python\nVAR_3 = (((VAR_0 + VAR_1) + VAR_2) / 2)\n```\nIf the input values form a valid triangle, the function calculates the semi-perimeter of the triangle. \n\n```python\nVAR_4 = ((((VAR_3 * (VAR_3 - VAR_0)) * (VAR_3 - VAR_1)) * (VAR_3 - VAR_2)) ** 0.5)\n```\nUsing the semi-perimeter, the function calculates the area of the triangle using Heron's formula. \n\n```python\nVAR_4 = round(VAR_4, 2)\n```\nThe area is then rounded to two decimal places. \n\n```python\nreturn VAR_4\n```\nThe function returns the area of the triangle.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (triangle_area a b c)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"<>\") #t 0.001)\n    (check-within (candidate \"<<><>>\") #t 0.001)\n    (check-within (candidate \"<><><<><>><>\") #t 0.001)\n    (check-within (candidate \"<><><<<><><>><>><<><><<>>>\") #t 0.001)\n    (check-within (candidate \"<<<><>>>>\") #f 0.001)\n    (check-within (candidate \"><<>\") #f 0.001)\n    (check-within (candidate \"<\") #f 0.001)\n    (check-within (candidate \"<<<<\") #f 0.001)\n    (check-within (candidate \">\") #f 0.001)\n    (check-within (candidate \"<<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>><<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>>><>\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns a boolean value. The function checks whether the string is a valid sequence of angle brackets. \n\nThe function starts by initializing a variable `VAR_1` to 0. \n\nIt then iterates over each character in the input string `VAR_0` using a `for` loop. \n\nFor each character, it checks if it is an opening angle bracket (`<`). If it is, it increments the value of `VAR_1` by 1. If it is not, it decrements the value of `VAR_1` by 1. \n\nIf at any point the value of `VAR_1` becomes negative, it means that there are more closing angle brackets (`>`) than opening angle brackets, and the function returns `False`. \n\nIf the loop completes without returning `False`, it means that the string is a valid sequence of angle brackets, and the function returns `True` if the value of `VAR_1` is 0 (i.e., there are an equal number of opening and closing angle brackets), and `False` otherwise.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (incr_list l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate incr_list))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)\n    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef incr_list(l: List[int]) -> List[int]:\n    return [(e + 1) for e in l]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a new list with each integer incremented by one.\n\nThe function is defined with the name `FUNC_0` and takes a single argument `VAR_0`, which is a list of integers. The function returns a new list that is constructed using a list comprehension. The list comprehension iterates over each element `VAR_1` in the input list `VAR_0` and constructs a new list with each element incremented by one.\n\nThe function signature specifies that the input list is of type `List[int]` and the output list is also of type `List[int]`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (incr_list l)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (filter_by_substring strings substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"grunt\" \"trumpet\" \"prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]\n\n### Explanation\n\nThe code is an implementation of a function that filters a list of strings based on a given string. The function takes two arguments, a list of strings and a string to filter by. The function returns a new list of strings that contain the filter string.\n\nThe first line imports the List class from the typing module. This is used to specify the type of the arguments and return value of the function.\n\nThe second line defines the function named FUNC_0. It takes two arguments, VAR_0 and VAR_1, both of which are typed as List[str] and str, respectively. The function returns a List[str].\n\nThe third line uses a list comprehension to create a new list of strings that contain the filter string. The list comprehension iterates over each string in the input list, VAR_0, and checks if the filter string, VAR_1, is in the string. If it is, the string is added to the new list.\n\nThe fourth line returns the new list of strings.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (filter_by_substring strings substring)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (median l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n    (check-within (candidate (list 3 1 2 4 5)) 3 0.001)\n    (check-within (candidate (list -10 4 6 1000 10 20)) 8.0 0.001)\n    (check-within (candidate (list 5)) 5 0.001)\n    (check-within (candidate (list 6 5)) 5.5 0.001)\n    (check-within (candidate (list 8 1 3 9 9 2 7)) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef median(l: List[int]) -> float:\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n\n### Explanation\n\nThe code is an implementation of the median function. The function takes in a list of integers and returns the median value of the list. \n\nThe first line imports the List class from the typing module. This is used to define the type of the input parameter of the function.\n\nThe second line defines the function FUNC_0 which takes in a list of integers and returns a float. \n\nThe third line sorts the input list in ascending order using the sorted function. \n\nThe fourth line checks if the length of the list is odd or even. If it is odd, it returns the middle element of the sorted list. If it is even, it returns the average of the two middle elements of the sorted list. \n\nThe fifth and sixth lines are the return statements for the two cases.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (median l)\n"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (string_to_md5 text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_162_string_to_md5.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_to_md5))\n    (check-within (candidate \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\" 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"A B C\") \"0ef78513b0cb8cef12743f5aeb35f888\" 0.001)\n    (check-within (candidate \"password\") \"5f4dcc3b5aa765d61d8327deb882cf99\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Optional\n\ndef string_to_md5(text: str) -> Optional[str]:\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n\n### Explanation\n\nThe code is an implementation of a function that takes in a string and returns its MD5 hash. The function is defined using the `def` keyword, followed by the function name, `FUNC_0`, and the input parameter, `VAR_0`. The function also has a return type of `Optional[str]`, which means that it can either return a string or `None`.\n\nThe `from typing import Optional` statement at the beginning of the code is used to import the `Optional` type from the `typing` module. This is used to specify that the function can return `None`.\n\nThe `import hashlib` statement is used to import the `hashlib` module, which provides a way to generate secure hash functions. The `hashlib.md5()` function is then used to generate the MD5 hash of the input string. The `encode()` method is used to convert the string to bytes, which is required by the `hashlib.md5()` function. The `hexdigest()` method is then used to convert the hash to a hexadecimal string.\n\nThe `if VAR_0 else None` part of the return statement is used to check if the input string is empty or not. If it is empty, the function returns `None`. Otherwise, it returns the MD5 hash of the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (string_to_md5 text)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (strange_sort_list lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n    (check-within (candidate (list 1 2 3 4)) (list 1 4 2 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7) 0.001)\n    (check-within (candidate (list 5 5 5 5)) (list 5 5 5 5) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5) 0.001)\n    (check-within (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2) 0.001)\n    (check-within (candidate (list 111111)) (list 111111) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n\n### Explanation\n\nThe code is an implementation of the \"wiggle sort\" algorithm. It takes in a list of integers, sorts them in ascending order, and then rearranges them such that the first element is the smallest, the second element is the largest, the third element is the second smallest, the fourth element is the second largest, and so on. \n\nHere is a line-by-line explanation of the code:\n\n```python\nfrom typing import List\n```\nThis line imports the List type from the typing module. This is used to specify that the input and output of the function are lists of integers.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nThis line defines a function called FUNC_0 that takes in a list of integers and returns a list of integers. The input list is specified as VAR_0, and the output list is specified using the \"->\" notation.\n\n```python\n(VAR_1, VAR_2) = ([], True)\n```\nThis line initializes two variables, VAR_1 and VAR_2. VAR_1 is initialized as an empty list, and VAR_2 is initialized as True.\n\n```python\nwhile VAR_0:\n```\nThis line starts a while loop that continues as long as VAR_0 is not empty.\n\n```python\nVAR_1.append((min(VAR_0) if VAR_2 else max(VAR_0)))\n```\nThis line appends either the minimum or maximum value of VAR_0 to VAR_1, depending on the value of VAR_2. If VAR_2 is True, it appends the minimum value, otherwise it appends the maximum value.\n\n```python\nVAR_0.remove(VAR_1[(- 1)])\n```\nThis line removes the last element of VAR_1 from VAR_0. This ensures that the same element is not used twice in a row.\n\n```python\nVAR_2 = (not VAR_2)\n```\nThis line toggles the value of VAR_2 between True and False. This ensures that the next element appended to VAR_1 is the opposite of the previous element.\n\n```python\nreturn VAR_1\n```\nThis line returns the final sorted and rearranged list.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (strange_sort_list lst)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_upper s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n    (check-within (candidate \"aBCdEf\") 1 0.001)\n    (check-within (candidate \"abcdefg\") 0 0.001)\n    (check-within (candidate \"dBBE\") 0 0.001)\n    (check-within (candidate \"B\") 0 0.001)\n    (check-within (candidate \"U\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"EEEE\") 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef count_upper(s: str) -> int:\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns an integer. Here is a line-by-line explanation of the code:\n\n```python\ndef FUNC_0(VAR_0: str) -> int:\n```\n\nThis line defines a function called `FUNC_0` that takes a single argument, `VAR_0`, which is expected to be a string. The `-> int` syntax indicates that the function returns an integer.\n\n```python\nVAR_1 = 0\n```\n\nThis line initializes a variable called `VAR_1` to zero.\n\n```python\nfor VAR_2 in range(0, len(VAR_0), 2):\n```\n\nThis line starts a loop that iterates over every other character in the input string, starting from the first character (index 0). The `range` function generates a sequence of numbers from 0 to the length of the input string, incrementing by 2 at each step.\n\n```python\nif (VAR_0[VAR_2] in 'AEIOU'):\n```\n\nThis line checks if the current character (at index `VAR_2`) is a vowel. The `in` operator checks if the character is contained in the string `'AEIOU'`, which represents the set of uppercase vowels.\n\n```python\nVAR_1 += 1\n```\n\nIf the current character is a vowel, this line increments the `VAR_1` counter by 1.\n\n```python\nreturn VAR_1\n```\n\nFinally, this line returns the total count of vowels found in the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_upper s)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_odd_collatz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_odd_collatz))\n    (check-within (candidate 14) (list 1 5 7 11 13 17) 0.001)\n    (check-within (candidate 5) (list 1 5) 0.001)\n    (check-within (candidate 12) (list 1 3 5) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef get_odd_collatz(n: int) -> List[int]:\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n\n### Explanation\n\nThe code is an implementation of the Collatz conjecture. The conjecture is that the sequence generated by the following rules will always reach 1:\n\n- If the number is even, divide it by 2.\n- If the number is odd, multiply it by 3 and add 1.\n\nThe function `FUNC_0` takes an integer `VAR_0` as input and returns a sorted list of integers. The list contains the sequence generated by applying the Collatz rules to `VAR_0`. If `VAR_0` is even, the list starts with an empty list. If `VAR_0` is odd, the list starts with `[VAR_0]`.\n\nThe function uses a while loop to generate the sequence. The loop continues as long as `VAR_0` is greater than 1. Inside the loop, the function applies the Collatz rules to `VAR_0` and appends the result to `VAR_1` if it is odd. The loop ends when `VAR_0` becomes 1.\n\nThe function returns `VAR_1` sorted in ascending order.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_odd_collatz n)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (minPath grid k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minPath))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)\n    (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)\n    (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)\n    (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)\n    (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)\n    (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)\n    (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n\n### Explanation\n\nThe code is an implementation of a function that takes in a 2D list of integers and an integer, and returns a list of integers. The function is defined with the name `FUNC_0`, and takes in two arguments: `VAR_0` and `VAR_1`. `VAR_0` is a 2D list of integers, and `VAR_1` is an integer.\n\nThe first line of the function imports the `List` class from the `typing` module. This is used to specify the type of the `VAR_0` argument as a list of lists of integers.\n\n```python\nfrom typing import List\n```\n\nThe next line defines the function with the name `FUNC_0`, and specifies the types of the arguments and the return value. `VAR_0` is a list of lists of integers, `VAR_1` is an integer, and the return value is a list of integers.\n\n```python\ndef FUNC_0(VAR_0: List[List[int]], VAR_1: int) -> List[int]:\n```\n\nThe next line initializes a variable `VAR_2` to the length of the input 2D list `VAR_0`.\n\n```python\n    VAR_2 = len(VAR_0)\n```\n\nThe next line initializes a variable `VAR_3` to the value of `VAR_2` squared plus 1.\n\n```python\n    VAR_3 = ((VAR_2 * VAR_2) + 1)\n```\n\nThe next two lines define a nested loop that iterates over each element of the input 2D list `VAR_0`. The outer loop iterates over each row of the list, and the inner loop iterates over each element in the row.\n\n```python\n    for VAR_4 in range(VAR_2):\n        for VAR_5 in range(VAR_2):\n```\n\nThe next line checks if the current element of `VAR_0` is equal to 1.\n\n```python\n            if (VAR_0[VAR_4][VAR_5] == 1):\n```\n\nIf the current element is equal to 1, a new empty list `VAR_6` is initialized.\n\n```python\n                VAR_6 = []\n```\n\nThe next four lines check if the current element is at the edge of the 2D list, and if not, append the value of the adjacent element to `VAR_6`.\n\n```python\n                if (VAR_4 != 0):\n                    VAR_6.append(VAR_0[(VAR_4 - 1)][VAR_5])\n                if (VAR_5 != 0):\n                    VAR_6.append(VAR_0[VAR_4][(VAR_5 - 1)])\n                if (VAR_4 != (VAR_2 - 1)):\n                    VAR_6.append(VAR_0[(VAR_4 + 1)][VAR_5])\n                if (VAR_5 != (VAR_2 - 1)):\n                    VAR_6.append(VAR_0[VAR_4][(VAR_5 + 1)])\n```\n\nThe next line updates the value of `VAR_3` to be the minimum value in `VAR_6`.\n\n```python\n                VAR_3 = min(VAR_6)\n```\n\nThe next line initializes an empty list `VAR_7`.\n\n```python\n    VAR_7 = []\n```\n\nThe next loop iterates over the range of `VAR_1`.\n\n```python\n    for VAR_4 in range(VAR_1):\n```\n\nThe next line checks if the current index is even, and if so, appends the value\n\n### Racket version\n\n#lang racket\n\n;; \n(define (minPath grid k)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (compare game guess)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)\n    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef compare(game: List[int],guess: List[int]) -> List[int]:\n    return [abs(x-y) for x,y in zip(game,guess)]\n\n### Explanation\n\nThe code is an implementation of a function that takes two lists of integers, `VAR_0` and `VAR_1`, and returns a list of integers. The function is defined with the name `FUNC_0` and takes two arguments, `VAR_0` and `VAR_1`, both of which are of type `List[int]`. The function returns a list of integers, which is also of type `List[int]`.\n\nThe function returns a list of absolute differences between the corresponding elements of the two input lists. The `zip` function is used to iterate over the two lists simultaneously and create a tuple of the corresponding elements from each list. The `abs` function is used to calculate the absolute difference between the two elements in each tuple.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (compare game guess)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 1 4 9)) 14 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) 9 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1)) -3 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list -1 -5 2 -1 -5)) -126 0.001)\n    (check-within (candidate (list -56 -99 1 0 -2)) 3030 0.001)\n    (check-within (candidate (list -1 0 0 0 0 0 0 0 -1)) 0 0.001)\n    (check-within (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37)) -14196 0.001)\n    (check-within (candidate (list -1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10)) -1448 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[int]) -> int:\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the sum of the list after applying a specific transformation to each element of the list. \n\nThe function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of integers. The function returns an integer.\n\n```\nfrom typing import List\n\ndef FUNC_0(VAR_0: List[int]) -> int:\n```\n\nThe next line creates an empty list VAR_1, which will be used to store the transformed elements of VAR_0.\n\n```\n    VAR_1 = []\n```\n\nThe next block of code iterates over each element of VAR_0 using the range function and the length of VAR_0. The variable VAR_2 is used to store the index of the current element being processed.\n\n```\n    for VAR_2 in range(len(VAR_0)):\n```\n\nThe next line checks if the index VAR_2 is divisible by 3. If it is, the current element of VAR_0 is squared and the result is appended to VAR_1.\n\n```\n        if ((VAR_2 % 3) == 0):\n            VAR_1.append((VAR_0[VAR_2] ** 2))\n```\n\nThe next line checks if the index VAR_2 is divisible by 4 but not divisible by 3. If it is, the current element of VAR_0 is cubed and the result is appended to VAR_1.\n\n```\n        elif (((VAR_2 % 4) == 0) and ((VAR_2 % 3) != 0)):\n            VAR_1.append((VAR_0[VAR_2] ** 3))\n```\n\nIf neither of the above conditions are true, the current element of VAR_0 is appended to VAR_1 without any transformation.\n\n```\n        else:\n            VAR_1.append(VAR_0[VAR_2])\n```\n\nFinally, the sum of VAR_1 is returned as the result of the function.\n\n```\n    return sum(VAR_1)\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (digitSum s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abAB\") 131 0.001)\n    (check-within (candidate \"abcCd\") 67 0.001)\n    (check-within (candidate \"helloE\") 69 0.001)\n    (check-within (candidate \"woArBld\") 131 0.001)\n    (check-within (candidate \"aAaaaXa\") 153 0.001)\n    (check-within (candidate \" How are yOu?\") 151 0.001)\n    (check-within (candidate \"You arE Very Smart\") 327 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef digitSum(s: str) -> int:\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a string `VAR_0` as input and returns an integer. The function calculates the sum of the ASCII values of all uppercase characters in the input string.\n\n- `def FUNC_0(VAR_0: str) -> int:`: This line defines a function named `FUNC_0` that takes a string `VAR_0` as input and returns an integer. The `-> int` specifies the return type of the function.\n\n- `if (VAR_0 == ''):`: This line checks if the input string is empty. If it is, the function returns 0.\n\n- `return sum(((ord(VAR_1) if VAR_1.isupper() else 0) for VAR_1 in VAR_0))`: This line calculates the sum of the ASCII values of all uppercase characters in the input string. The `ord()` function returns the ASCII value of a character, and the `isupper()` method checks if a character is uppercase. The `sum()` function adds up all the ASCII values of the uppercase characters. If a character is not uppercase, its ASCII value is 0. The `for` loop iterates over each character in the input string. Finally, the sum of the ASCII values is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (digitSum s)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_third l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_third))\n    (check-within (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5) 0.001)\n    (check-within (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5) 0.001)\n    (check-within (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5) 0.001)\n    (check-within (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n\n### Explanation\n\nThe code is an implementation of a function `FUNC_0` that takes a list of integers as input and returns a list of integers. \n\nThe function takes a list of integers as input and creates a copy of the list. It then sorts every third element of the list in ascending order. Finally, it returns the sorted list.\n\nHere is a line-by-line explanation of the code:\n\n1. `from typing import List`: This line imports the `List` type from the `typing` module. This is used to specify the type of the input and output of the function.\n\n2. `def FUNC_0(VAR_0: List[int]) -> List[int]:` This line defines the function `FUNC_0` that takes a list of integers as input and returns a list of integers. The `-> List[int]` specifies the return type of the function.\n\n3. `VAR_0 = list(VAR_0)`: This line creates a copy of the input list `VAR_0` by converting it to a list.\n\n4. `VAR_0[::3] = sorted(VAR_0[::3])`: This line sorts every third element of the list in ascending order. The `::3` slice notation is used to select every third element of the list. The `sorted` function is used to sort the selected elements in ascending order. The sorted elements are then assigned back to the original list.\n\n5. `return VAR_0`: This line returns the sorted list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_third l)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fizz_buzz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n    (check-within (candidate 50) 0 0.001)\n    (check-within (candidate 78) 2 0.001)\n    (check-within (candidate 79) 3 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 200) 6 0.001)\n    (check-within (candidate 4000) 192 0.001)\n    (check-within (candidate 10000) 639 0.001)\n    (check-within (candidate 100000) 8026 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fizz_buzz(n: int) -> int:\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns the number of times the digit '7' appears in the concatenation of all numbers from 0 to the input integer that are divisible by 11 or 13.\n\n```python\ndef FUNC_0(VAR_0: int) -> int:\n```\nThis line defines a function named `FUNC_0` that takes an integer `VAR_0` as input and returns an integer.\n\n```python\nVAR_1 = []\n```\nThis line initializes an empty list `VAR_1`.\n\n```python\nfor VAR_2 in range(VAR_0):\n```\nThis line starts a loop that iterates over all numbers from 0 to `VAR_0` - 1. The loop variable is named `VAR_2`.\n\n```python\nif (((VAR_2 % 11) == 0) or ((VAR_2 % 13) == 0)):\n```\nThis line checks if `VAR_2` is divisible by 11 or 13. If it is, the code inside the `if` block is executed.\n\n```python\nVAR_1.append(VAR_2)\n```\nThis line adds `VAR_2` to the list `VAR_1`.\n\n```python\nVAR_3 = ''.join(list(map(str, VAR_1)))\n```\nThis line converts the list `VAR_1` to a string by mapping each element to a string and joining them together. The resulting string is stored in `VAR_3`.\n\n```python\nVAR_4 = 0\n```\nThis line initializes a variable `VAR_4` to 0.\n\n```python\nfor VAR_5 in VAR_3:\n```\nThis line starts a loop that iterates over each character in the string `VAR_3`. The loop variable is named `VAR_5`.\n\n```python\nVAR_4 += (VAR_5 == '7')\n```\nThis line adds 1 to `VAR_4` if `VAR_5` is equal to the character '7'. This is a shorthand way of writing `if VAR_5 == '7': VAR_4 += 1`.\n\n```python\nreturn VAR_4\n```\nThis line returns the value of `VAR_4` as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fizz_buzz n)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (intersection interval1 interval2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersection))\n    (check-within (candidate (list 1 2) (list 2 3)) \"NO\" 0.001)\n    (check-within (candidate (list -1 1) (list 0 4)) \"NO\" 0.001)\n    (check-within (candidate (list -3 -1) (list -5 5)) \"YES\" 0.001)\n    (check-within (candidate (list -2 2) (list -4 0)) \"YES\" 0.001)\n    (check-within (candidate (list -11 2) (list -1 -1)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 3 5)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 1 2)) \"NO\" 0.001)\n    (check-within (candidate (list -2 -2) (list -3 -2)) \"NO\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two tuples of two integers each as input, and returns a string. The function is defined using Python's type hinting syntax, which specifies the types of the input and output variables.\n\nThe function starts by defining another function called `FUNC_1` that takes an integer as input and returns a boolean value. This function checks if the input integer is a prime number, by iterating over all integers from 2 to the input integer - 1, and checking if the input integer is divisible by any of them. If it is, the function returns False, otherwise it returns True. Note that the function returns False for the values 0 and 1, which are not prime.\n\nThe main function then proceeds to extract the maximum value of the first element of the input tuples, and the minimum value of the second element of the input tuples, and assigns them to the variables `VAR_4` and `VAR_5`, respectively. These variables represent the range of integers that will be checked for primality.\n\nThe variable `VAR_6` is then defined as the difference between `VAR_5` and `VAR_4`. If `VAR_6` is greater than 0, and `FUNC_1` returns True when called with `VAR_6` as input, the function returns the string 'YES'. Otherwise, it returns the string 'NO'.\n\nIn summary, the function checks if there is at least one prime number in the range of integers defined by the input tuples, and returns 'YES' if there is, and 'NO' otherwise.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (intersection interval1 interval2)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_numbers numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"three\") \"three\" 0.001)\n    (check-within (candidate \"three five nine\") \"three five nine\" 0.001)\n    (check-within (candidate \"five zero four seven nine eight\") \"zero four five seven eight nine\" 0.001)\n    (check-within (candidate \"six five four three two one zero\") \"zero one two three four five six\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n\n### Explanation\n\nThe code is an implementation of a function that takes a string of space-separated words, where each word is a number spelled out in English, and returns the same string, but with the words sorted in ascending order based on their numerical value.\n\nThe function is defined on the first line with the name `FUNC_0` and takes one argument, `VAR_0`, which is a string. The `-> str` after the argument list indicates that the function returns a string.\n\nThe second line defines a dictionary `VAR_1` that maps English number words to their numerical values. The keys are the words and the values are integers.\n\nThe third line returns a string that is the result of joining together the sorted list of words in `VAR_0`. The list is generated using a list comprehension that iterates over the words in `VAR_0` that are not empty strings (i.e., `if VAR_2`), and sorts them based on their numerical value using the `key` argument of the `sorted` function. The `key` argument is a lambda function that takes a word `VAR_2` and returns its numerical value from the `VAR_1` dictionary. The `join` method is then used to concatenate the sorted words into a single string separated by spaces.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_numbers numbers)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (make_a_pile n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_a_pile))\n    (check-within (candidate 3) (list 3 5 7) 0.001)\n    (check-within (candidate 4) (list 4 6 8 10) 0.001)\n    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)\n    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)\n    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2*i for i in range(n)]\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns a list of integers. The function is defined with the name `FUNC_0` and takes one argument `VAR_0` of type `int`. The function returns a list of integers.\n\nThe function returns a list of integers that is created using a list comprehension. The list comprehension creates a list of integers by iterating over a range of integers from 0 to `VAR_0 - 1`. For each integer in the range, the list comprehension calculates the value `(VAR_0 + (2 * VAR_1))` and adds it to the list.\n\nThe value `(VAR_0 + (2 * VAR_1))` is calculated by adding `VAR_0` to the product of `2` and `VAR_1`. `VAR_1` is the integer value that is being iterated over in the range.\n\nThe function returns the list of integers created by the list comprehension.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (make_a_pile n)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (iscube a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate iscube))\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate -1) #t 0.001)\n    (check-within (candidate 64) #t 0.001)\n    (check-within (candidate 180) #f 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 0) #t 0.001)\n    (check-within (candidate 1729) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef iscube(a: int) -> bool:\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a given integer is a perfect cube. \n\nThe function is called `FUNC_0` and takes an integer argument `VAR_0`. The function returns a boolean value, `True` if the input integer is a perfect cube, and `False` otherwise.\n\nThe first line of the function, `VAR_0 = abs(VAR_0)`, takes the absolute value of the input integer. This is done to ensure that the function works correctly for negative integers as well.\n\nThe second line of the function, `return ((int(round((VAR_0 ** (1.0 / 3)))) ** 3) == VAR_0)`, is the main logic of the function. \n\nThe expression `VAR_0 ** (1.0 / 3)` calculates the cube root of the input integer. The `round` function is used to round the result to the nearest integer, and the `int` function is used to convert the result to an integer. This is done to ensure that the result is an integer, as the `**` operator can return a float in some cases.\n\nThe resulting integer is then cubed using the `**` operator, and compared to the original input integer using the `==` operator. If the two values are equal, the function returns `True`, indicating that the input integer is a perfect cube. Otherwise, the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (iscube a)\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (will_it_fly q w)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate will_it_fly))\n    (check-within (candidate (list 3 2 3) 9) #t 0.001)\n    (check-within (candidate (list 1 2) 5) #f 0.001)\n    (check-within (candidate (list 3) 5) #t 0.001)\n    (check-within (candidate (list 3 2 3) 1) #f 0.001)\n    (check-within (candidate (list 1 2 3) 6) #f 0.001)\n    (check-within (candidate (list 5) 5) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef will_it_fly(q: List[int], w: int) -> bool:\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a list of integers is a palindrome and the sum of the integers is less than or equal to a given integer.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is used to define a list of integers.\n\n```python\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> bool:\n```\nThis line defines a function named FUNC_0 that takes two arguments: a list of integers named VAR_0 and an integer named VAR_1. The function returns a boolean value.\n\n```python\nif (sum(VAR_0) > VAR_1):\n    return False\n```\nThis line checks if the sum of the integers in VAR_0 is greater than VAR_1. If it is, the function returns False.\n\n```python\n(VAR_2, VAR_3) = (0, (len(VAR_0) - 1))\n```\nThis line initializes two variables, VAR_2 and VAR_3, to 0 and the length of VAR_0 minus 1, respectively. These variables will be used to iterate through the list from both ends.\n\n```python\nwhile (VAR_2 < VAR_3):\n    if (VAR_0[VAR_2] != VAR_0[VAR_3]):\n        return False\n    VAR_2 += 1\n    VAR_3 -= 1\n```\nThis line starts a while loop that iterates through the list from both ends. If the value at VAR_2 is not equal to the value at VAR_3, the function returns False. The loop continues until VAR_2 is greater than or equal to VAR_3.\n\n```python\nreturn True\n```\nThis line returns True if the function has not yet returned False. This means that the list is a palindrome and the sum of the integers is less than or equal to VAR_1.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (will_it_fly q w)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_equal_to_sum_even n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #t 0.001)\n    (check-within (candidate 11) #f 0.001)\n    (check-within (candidate 12) #t 0.001)\n    (check-within (candidate 13) #f 0.001)\n    (check-within (candidate 16) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_equal_to_sum_even(n: int) -> bool:\n    return n%2 == 0 and n >= 8\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes an integer argument `VAR_0` and returns a boolean value. \n\nThe function returns `True` if the integer is even and greater than or equal to 8, and `False` otherwise. \n\nThe first line of the function definition specifies the input type of the argument `VAR_0` as an integer. The `-> bool` part of the definition specifies that the function returns a boolean value. \n\nThe second line of the function definition contains the return statement. The return statement consists of a boolean expression that checks if the remainder of `VAR_0` divided by 2 is equal to 0 (i.e., if `VAR_0` is even) and if `VAR_0` is greater than or equal to 8.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_equal_to_sum_even n)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (largest_prime_factor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n    (check-within (candidate 15) 5 0.001)\n    (check-within (candidate 27) 3 0.001)\n    (check-within (candidate 63) 7 0.001)\n    (check-within (candidate 330) 11 0.001)\n    (check-within (candidate 13195) 29 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef largest_prime_factor(n: int) -> int:\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n\n### Explanation\n\nThe code is an implementation of a function that finds the largest prime factor of a given integer. \n\nThe function is called FUNC_0 and takes an integer argument VAR_0 and returns an integer. \n\nThe function defines another function called FUNC_1 which takes an integer argument VAR_1 and returns a boolean. \n\nFUNC_1 checks if VAR_1 is less than 2, if it is, it returns False. If VAR_1 is greater than or equal to 2, it loops through all integers from 2 to VAR_1 - 1 (exclusive). If VAR_1 is divisible by any of these integers, it returns False. If VAR_1 is not divisible by any of these integers, it returns True.\n\nIn FUNC_0, VAR_3 is initialized to 1. The function then loops through all integers from 2 to VAR_0 + 1 (exclusive). For each integer VAR_4 in this range, it checks if VAR_0 is divisible by VAR_4 and if FUNC_1 returns True when called with VAR_4 as an argument. If both conditions are met, VAR_3 is set to the maximum of VAR_3 and VAR_4. \n\nFinally, the function returns VAR_3, which is the largest prime factor of VAR_0.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_prime_factor n)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (has_close_elements numbers threshold)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two arguments, a list of floats called `VAR_0` and a float called `VAR_1`, and returns a boolean value. \n\nThe function iterates over the list `VAR_0` twice, comparing each element to every other element in the list. If the absolute difference between two elements is less than `VAR_1`, the function returns `True`. If no such pair of elements is found, the function returns `False`. \n\nHere is a line-by-line explanation of the code:\n\n```python\nfrom typing import List\n```\nThis line imports the `List` type from the `typing` module, which is used to specify the type of the `VAR_0` argument.\n\n```python\ndef FUNC_0(VAR_0: List[float], VAR_1: float) -> bool:\n```\nThis line defines the function `FUNC_0` with two arguments, `VAR_0` and `VAR_1`, both of which are typed. `VAR_0` is a list of floats, and `VAR_1` is a float. The function returns a boolean value.\n\n```python\nfor (VAR_2, VAR_3) in enumerate(VAR_0):\n    for (VAR_4, VAR_5) in enumerate(VAR_0):\n```\nThese two lines define nested `for` loops that iterate over the elements of `VAR_0`. The `enumerate` function is used to get both the index and value of each element.\n\n```python\nif (VAR_2 != VAR_4):\n```\nThis line checks if the indices of the two elements being compared are different. If they are the same, the elements are the same, and we don't want to compare them.\n\n```python\nVAR_6 = abs((VAR_3 - VAR_5))\n```\nThis line calculates the absolute difference between the two elements being compared.\n\n```python\nif (VAR_6 < VAR_1):\n    return True\n```\nThis line checks if the absolute difference is less than `VAR_1`. If it is, the function returns `True`.\n\n```python\nreturn False\n```\nIf no pair of elements is found that satisfies the condition, the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (has_close_elements numbers threshold)\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sorted_list_sum lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sorted_list_sum))\n    (check-within (candidate (list \"aa\" \"a\" \"aaa\")) (list \"aa\") 0.001)\n    (check-within (candidate (list \"school\" \"AI\" \"asdf\" \"b\")) (list \"AI\" \"asdf\" \"school\") 0.001)\n    (check-within (candidate (list \"d\" \"b\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"d\" \"dcba\" \"abcd\" \"a\")) (list \"abcd\" \"dcba\") 0.001)\n    (check-within (candidate (list \"AI\" \"ai\" \"au\")) (list \"AI\" \"ai\" \"au\") 0.001)\n    (check-within (candidate (list \"a\" \"b\" \"b\" \"c\" \"c\" \"a\")) (list ) 0.001)\n    (check-within (candidate (list \"aaaa\" \"bbbb\" \"dd\" \"cc\")) (list \"cc\" \"dd\" \"aaaa\" \"bbbb\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sorted_list_sum(lst: List[str]) -> List[str]:\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a list of strings as input and returns a list of strings as output. The function sorts the input list in ascending order, then filters out all strings with odd length, and finally sorts the remaining strings by length in ascending order.\n\n```python\nfrom typing import List\n```\n\nThis line imports the `List` class from the `typing` module. The `List` class is used to specify the type of the input and output parameters of the `FUNC_0` function.\n\n```python\ndef FUNC_0(VAR_0: List[str]) -> List[str]:\n```\n\nThis line defines the `FUNC_0` function that takes a list of strings as input and returns a list of strings as output. The input parameter is named `VAR_0` and its type is specified as `List[str]`. The output parameter is specified as `List[str]`.\n\n```python\nVAR_0.sort()\n```\n\nThis line sorts the input list `VAR_0` in ascending order.\n\n```python\nVAR_1 = []\nfor VAR_2 in VAR_0:\n    if ((len(VAR_2) % 2) == 0):\n        VAR_1.append(VAR_2)\n```\n\nThese lines create an empty list `VAR_1` and iterate over each string `VAR_2` in the sorted input list `VAR_0`. For each string, the code checks if its length is even by computing the remainder of the length divided by 2. If the remainder is 0, the string is appended to the `VAR_1` list.\n\n```python\nreturn sorted(VAR_1, key=len)\n```\n\nThis line returns the `VAR_1` list sorted by length in ascending order. The `key` parameter is used to specify the sorting criterion, which is the length of each string. Since the length of each string is an integer, the `len` function is used as the key function. The `sorted` function returns a new sorted list and does not modify the original list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sorted_list_sum lst)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (mean_absolute_deviation numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mean_absolute_deviation))\n    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n### Explanation\n\nThe code is an implementation of the Mean Absolute Deviation (MAD) algorithm. The algorithm takes a list of numbers as input and returns the average distance between each number in the list and the mean of the list. \n\nThe function takes a single argument, VAR_0, which is a list of floats. The function returns a float.\n\nThe first line imports the List class from the typing module. This is used to specify the type of the input argument.\n\nThe second line defines a function named FUNC_0 that takes a single argument VAR_0, which is a list of floats. The function returns a float.\n\nThe third line calculates the mean of the list VAR_0 by summing all the values in the list and dividing by the length of the list. The result is stored in VAR_1.\n\nThe fourth line calculates the average distance between each number in the list and the mean of the list. It does this by iterating over each number in the list VAR_0, subtracting the mean VAR_1 from the number, taking the absolute value of the result, and then summing all the absolute values. The sum is then divided by the length of the list to get the average. The result is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (mean_absolute_deviation numbers)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (common l1 l2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n    (check-within (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653) 0.001)\n    (check-within (candidate (list 5 3 2 8) (list 3 2)) (list 2 3) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n\n### Explanation\n\nThe code is an implementation of a function that takes two lists of integers as input and returns a sorted list of the common elements between the two lists.\n\n```python\nfrom typing import List\n```\nThe `typing` module is imported to allow for type hints in the function signature.\n\n```python\ndef FUNC_0(VAR_0: List[int], VAR_1: List[int]) -> List[int]:\n```\nA function named `FUNC_0` is defined that takes two arguments, both of which are lists of integers. The function returns a list of integers.\n\n```python\nVAR_2 = set()\n```\nA new empty set is created and assigned to the variable `VAR_2`.\n\n```python\nfor VAR_3 in VAR_0:\n    for VAR_4 in VAR_1:\n        if (VAR_3 == VAR_4):\n            VAR_2.add(VAR_3)\n```\nTwo nested loops iterate over each element in `VAR_0` and `VAR_1`, respectively. If an element in `VAR_0` is equal to an element in `VAR_1`, the element is added to the set `VAR_2`.\n\n```python\nreturn sorted(list(VAR_2))\n```\nThe set `VAR_2` is converted to a list, sorted, and returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (common l1 l2)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (search lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate search))\n    (check-within (candidate (list 5 5 5 5 1)) 1 0.001)\n    (check-within (candidate (list 4 1 4 1 4 4)) 4 0.001)\n    (check-within (candidate (list 3 3)) -1 0.001)\n    (check-within (candidate (list 8 8 8 8 8 8 8 8)) 8 0.001)\n    (check-within (candidate (list 2 3 3 2 2)) 2 0.001)\n    (check-within (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1 0.001)\n    (check-within (candidate (list 3 2 8 2)) 2 0.001)\n    (check-within (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1 0.001)\n    (check-within (candidate (list 8 8 3 6 5 6 4)) -1 0.001)\n    (check-within (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1 0.001)\n    (check-within (candidate (list 1 9 10 1 3)) 1 0.001)\n    (check-within (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n    (check-within (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4 0.001)\n    (check-within (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2 0.001)\n    (check-within (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1 0.001)\n    (check-within (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4 0.001)\n    (check-within (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4 0.001)\n    (check-within (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2 0.001)\n    (check-within (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1 0.001)\n    (check-within (candidate (list 10)) -1 0.001)\n    (check-within (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2 0.001)\n    (check-within (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1 0.001)\n    (check-within (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1 0.001)\n    (check-within (candidate (list 3 10 10 9 2)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef search(lst: List[int]) -> int:\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n\n### Explanation\n\nThe code is an implementation of the Pigeonhole Sort algorithm. It takes in a list of integers and returns the largest integer in the list that occurs at least as many times as its value.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is used to define a list of integers.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> int:\n```\nThis line defines a function named FUNC_0 that takes a list of integers as input and returns an integer. The input list is defined as VAR_0 and the output integer is defined as VAR_3.\n\n```python\nVAR_1 = ([0] * (max(VAR_0) + 1))\n```\nThis line initializes a list of integers named VAR_1 with a length of the maximum value in VAR_0 plus one. Each element in VAR_1 is initialized to zero.\n\n```python\nfor VAR_2 in VAR_0:\n    VAR_1[VAR_2] += 1\n```\nThis loop iterates over each element in VAR_0 and increments the corresponding element in VAR_1 by one.\n\n```python\nVAR_3 = (- 1)\nfor VAR_2 in range(1, len(VAR_1)):\n    if (VAR_1[VAR_2] >= VAR_2):\n        VAR_3 = VAR_2\n```\nThis loop iterates over each element in VAR_1 starting from index 1. If the value of an element in VAR_1 is greater than or equal to its index, VAR_3 is set to the index. This means that VAR_3 will be set to the largest integer in VAR_0 that occurs at least as many times as its value.\n\n```python\nreturn VAR_3\n```\nThis line returns the value of VAR_3, which is the largest integer in VAR_0 that occurs at least as many times as its value.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (search lst)\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_array arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5) 0.001)\n    (check-within (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3) 0.001)\n    (check-within (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77) 0.001)\n    (check-within (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n    (check-within (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the list sorted by the number of 1's in the binary representation of each integer.\n\n```python\nfrom typing import List\n```\nImporting List from the typing module to use it as a type hint for the function parameter and return value.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nDefining a function named FUNC_0 that takes a list of integers as input and returns a list of integers as output.\n\n```python\nreturn sorted(sorted(VAR_0), key=(lambda VAR_1: bin(VAR_1)[2:].count('1')))\n```\nThe function returns the sorted list of integers. The list is sorted twice, first in ascending order and then by the number of 1's in the binary representation of each integer. The key parameter of the sorted function is a lambda function that takes an integer, converts it to binary representation, removes the '0b' prefix, and counts the number of '1's in the binary string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_array arr)\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (Strongest_Extension class_name extensions)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n    (check-within (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\")) \"Watashi.eIGHt8OKe\" 0.001)\n    (check-within (candidate \"Boku123\" (list \"nani\" \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\" 0.001)\n    (check-within (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\" \"123NoooneB321\")) \"__YESIMHERE.NuLl__\" 0.001)\n    (check-within (candidate \"K\" (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\" 0.001)\n    (check-within (candidate \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\" 0.001)\n    (check-within (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"-_-\")) \"YameRore.okIWILL123\" 0.001)\n    (check-within (candidate \"finNNalLLly\" (list \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\" 0.001)\n    (check-within (candidate \"_\" (list \"Bb\" \"91245\")) \"_.Bb\" 0.001)\n    (check-within (candidate \"Sp\" (list \"671235\" \"Bb\")) \"Sp.671235\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, a string and a list of strings, and returns a string. The function is defined with the `def` keyword, and it is called `FUNC_0`. The first argument is named `VAR_0` and is of type `str`, and the second argument is named `VAR_1` and is of type `List[str]`. The function returns a string, which is the concatenation of the first argument, a period, and the string in the list that has the highest difference between the number of uppercase and lowercase letters.\n\nThe first line of the function assigns the first string in the list to a variable named `VAR_2`. The second line calculates the difference between the number of uppercase and lowercase letters in the first string in the list. This is done by using a list comprehension to create a list of all uppercase letters in the string, and then subtracting the length of a list comprehension that creates a list of all lowercase letters in the string. The result is assigned to a variable named `VAR_3`.\n\nThe next block of code is a `for` loop that iterates over all the strings in the list. For each string, it calculates the difference between the number of uppercase and lowercase letters in the same way as before, and assigns the result to a variable named `VAR_6`. If `VAR_6` is greater than `VAR_3`, it assigns the current string to `VAR_2` and updates `VAR_3` to be equal to `VAR_6`.\n\nFinally, the function creates a new string by concatenating the first argument, a period, and the string in the list with the highest difference between the number of uppercase and lowercase letters. This string is assigned to a variable named `VAR_7`, which is then returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (Strongest_Extension class_name extensions)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_max_triples n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 10) 36 0.001)\n    (check-within (candidate 100) 53361 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef get_max_triples(n: int) -> int:\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n\n### Explanation\n\nThe code is an implementation of a brute force algorithm to solve a problem in combinatorics. The problem is to find all the combinations of three integers between 1 and n (inclusive) such that the sum of the squares of any two of them is divisible by 3. The function FUNC_0 takes an integer n as input and returns the number of such combinations.\n\n```python\ndef FUNC_0(VAR_0: int) -> int:\n```\n\nThe function definition starts with the keyword \"def\" followed by the function name \"FUNC_0\". The function takes an integer input \"VAR_0\" and returns an integer output. The \"-> int\" after the input parameter specifies the output type.\n\n```python\nVAR_1 = [(((VAR_2 * VAR_2) - VAR_2) + 1) for VAR_2 in range(1, (VAR_0 + 1))]\n```\n\nThis line creates a list \"VAR_1\" of length \"VAR_0\" containing integers that satisfy the condition that the sum of the squares of any two of them is divisible by 3. The list is created using a list comprehension that iterates over the range of integers from 1 to \"VAR_0\" (inclusive) and applies the formula \"((VAR_2 * VAR_2) - VAR_2) + 1\" to each integer. This formula generates a sequence of integers that satisfy the condition.\n\n```python\nVAR_3 = []\n```\n\nThis line creates an empty list \"VAR_3\" that will be used to store the combinations of three integers that satisfy the condition.\n\n```python\nfor VAR_2 in range(VAR_0):\n    for VAR_4 in range((VAR_2 + 1), VAR_0):\n        for VAR_5 in range((VAR_4 + 1), VAR_0):\n            if ((((VAR_1[VAR_2] + VAR_1[VAR_4]) + VAR_1[VAR_5]) % 3) == 0):\n                VAR_3 += [(VAR_1[VAR_2], VAR_1[VAR_4], VAR_1[VAR_5])]\n```\n\nThese nested loops iterate over all possible combinations of three integers between 1 and \"VAR_0\" (inclusive) and check if the sum of the squares of any two of them is divisible by 3. If the condition is satisfied, the combination is added to the list \"VAR_3\". The loops use the list \"VAR_1\" created earlier to generate the integers.\n\n```python\nreturn len(VAR_3)\n```\n\nThis line returns the length of the list \"VAR_3\", which is the number of combinations of three integers that satisfy the condition.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_max_triples n)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (exchange lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate exchange))\n    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) \"YES\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 4)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 3)) \"NO\" 0.001)\n    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) \"NO\" 0.001)\n    (check-within (candidate (list 100 200) (list 200 200)) \"YES\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two lists of integers as input and returns a string. The function first defines two variables `VAR_2` and `VAR_3` and initializes them to 0. It then loops through each element in the first list `VAR_0` and checks if the element is odd by using the modulo operator `%`. If the element is odd, it increments `VAR_2` by 1. It then loops through each element in the second list `VAR_1` and checks if the element is even by using the modulo operator `%`. If the element is even, it increments `VAR_3` by 1. Finally, it compares `VAR_3` and `VAR_2` and returns 'YES' if `VAR_3` is greater than or equal to `VAR_2`, otherwise it returns 'NO'.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (exchange lst1 lst2)\n"
  },
  {
    "name": "HumanEval_130_tri",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (tri n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_130_tri.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate tri))\n    (check-within (candidate 3) (list 1 3 2 8) 0.001)\n    (check-within (candidate 4) (list 1 3 2 8 3) 0.001)\n    (check-within (candidate 5) (list 1 3 2 8 3 15) 0.001)\n    (check-within (candidate 6) (list 1 3 2 8 3 15 4) 0.001)\n    (check-within (candidate 7) (list 1 3 2 8 3 15 4 24) 0.001)\n    (check-within (candidate 8) (list 1 3 2 8 3 15 4 24 5) 0.001)\n    (check-within (candidate 9) (list 1 3 2 8 3 15 4 24 5 35) 0.001)\n    (check-within (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11) 0.001)\n    (check-within (candidate 0) (list 1) 0.001)\n    (check-within (candidate 1) (list 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef tri(n: int) -> List[int]:\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n\n### Explanation\n\nThe code is an implementation of the Hofstadter Q sequence. The function FUNC_0 takes an integer VAR_0 as input and returns a list of integers. The list contains the first VAR_0 + 1 numbers of the Hofstadter Q sequence.\n\nThe Hofstadter Q sequence is defined as follows:\n\nQ(0) = 1\nQ(1) = 1\nQ(n) = Q(n - Q(n - 1)) + Q(n - Q(n - 2)) for n > 1\n\nThe first two elements of the sequence are 1. The third element is Q(2) = Q(2 - 1) + Q(2 - 2) = Q(1) + Q(0) = 1 + 1 = 2. The fourth element is Q(3) = Q(3 - 1) + Q(3 - 2) = Q(2) + Q(1) = 2 + 1 = 3. The fifth element is Q(4) = Q(4 - 1) + Q(4 - 2) = Q(3) + Q(2) = 3 + 2 = 5. And so on.\n\nThe implementation of the sequence in the code is slightly different from the definition above. The sequence is computed iteratively instead of recursively. The first element of the sequence is always 1, so if VAR_0 is 0, the function returns [1]. Otherwise, the function initializes VAR_1 to [1, 3], which are the first two elements of the sequence. Then, the function iterates over the range from 2 to VAR_0 + 1. For each value of VAR_2 in this range, the function computes the corresponding element of the sequence and appends it to VAR_1.\n\nTo compute the element of the sequence corresponding to VAR_2, the function uses the following formula:\n\n- If VAR_2 is even, the element is (VAR_2 / 2) + 1.\n- If VAR_2 is odd, the element is the sum of the two previous elements of VAR_1, plus (VAR_2 + 3) / 2.\n\nThe reason for the different formulas for even and odd values of VAR_2 is that the recurrence relation for the Hofstadter Q sequence alternates between adding and subtracting the previous elements of the sequence. The formula for even values of VAR_2 corresponds to the addition case, while the formula for odd values of VAR_2 corresponds to the subtraction case.\n\nFinally, the function returns VAR_1, which contains the first VAR_0 + 1 elements of the Hofstadter Q sequence.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (tri n)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (generate_integers a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate generate_integers))\n    (check-within (candidate 2 10) (list 2 4 6 8) 0.001)\n    (check-within (candidate 10 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 132 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 17 89) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns a list of even integers between them, inclusive. The function is defined with the `def` keyword and named `FUNC_0`. It takes two integer arguments, `VAR_0` and `VAR_1`, and returns a list of integers. The return type is specified with the `->` syntax and the `List[int]` type hint.\n\nThe first line of the function calculates the minimum of `VAR_0` and `VAR_1` using the `min` function, and then takes the maximum of that value and 2 using the `max` function. This ensures that the lower bound of the range is at least 2 and no greater than the larger of the two input values.\n\nThe second line of the function calculates the maximum of `VAR_0` and `VAR_1` using the `max` function, and then takes the minimum of that value and 8 using the `min` function. This ensures that the upper bound of the range is at most 8 and no less than the smaller of the two input values.\n\nThe final line of the function returns a list comprehension that generates a list of even integers between the lower and upper bounds, inclusive. The `range` function is used to generate a sequence of integers between the lower and upper bounds, and the `if` statement filters out any odd integers by checking if the remainder of the integer divided by 2 is 0. The resulting list is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (generate_integers a b)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (get_closest_vowel word)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-within (candidate \"yogurt\") \"u\" 0.001)\n    (check-within (candidate \"full\") \"u\" 0.001)\n    (check-within (candidate \"easy\") \"\" 0.001)\n    (check-within (candidate \"eAsy\") \"\" 0.001)\n    (check-within (candidate \"ali\") \"\" 0.001)\n    (check-within (candidate \"bad\") \"a\" 0.001)\n    (check-within (candidate \"most\") \"o\" 0.001)\n    (check-within (candidate \"ab\") \"\" 0.001)\n    (check-within (candidate \"ba\") \"\" 0.001)\n    (check-within (candidate \"quick\") \"\" 0.001)\n    (check-within (candidate \"anime\") \"i\" 0.001)\n    (check-within (candidate \"Asia\") \"\" 0.001)\n    (check-within (candidate \"Above\") \"o\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef get_closest_vowel(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a string. The function is called `FUNC_0` and takes one argument, `VAR_0`, which is a string. The function returns a string.\n\n```python\ndef FUNC_0(VAR_0: str) -> str:\n```\n\nThe first line of the function checks if the length of the input string is less than 3. If it is, the function returns an empty string.\n\n```python\n    if (len(VAR_0) < 3):\n        return ''\n```\n\nThe next line creates a set of vowels. The set contains lowercase and uppercase vowels.\n\n```python\n    VAR_1 = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'O', 'U', 'I'}\n```\n\nThe next line starts a loop that iterates over the input string. The loop starts at the second to last character of the string and ends at the second character of the string. The loop decrements by 1 each iteration.\n\n```python\n    for VAR_2 in range((len(VAR_0) - 2), 0, (- 1)):\n```\n\nThe next line checks if the current character is a vowel.\n\n```python\n        if (VAR_0[VAR_2] in VAR_1):\n```\n\nIf the current character is a vowel, the next line checks if the character before and after the current character are not vowels.\n\n```python\n            if ((VAR_0[(VAR_2 + 1)] not in VAR_1) and (VAR_0[(VAR_2 - 1)] not in VAR_1)):\n```\n\nIf the character before and after the current character are not vowels, the function returns the current character.\n\n```python\n                return VAR_0[VAR_2]\n```\n\nIf the loop completes without finding a character that meets the conditions, the function returns an empty string.\n\n```python\n    return ''\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_closest_vowel word)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (greatest_common_divisor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n    (check-within (candidate 3 7) 1 0.001)\n    (check-within (candidate 10 15) 5 0.001)\n    (check-within (candidate 49 14) 7 0.001)\n    (check-within (candidate 144 60) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n\n### Explanation\n\nThe code is an implementation of the Euclidean algorithm for finding the greatest common divisor (GCD) of two integers. \n\nThe function is named `FUNC_0` and takes two integer arguments, `VAR_0` and `VAR_1`. The function returns an integer, which is the GCD of `VAR_0` and `VAR_1`.\n\nThe algorithm works by repeatedly dividing the larger number by the smaller number and replacing the larger number with the remainder until the remainder is zero. At this point, the GCD is the last non-zero remainder.\n\nThe first line of the function definition specifies the function name, `FUNC_0`, and the types of the two arguments, `VAR_0` and `VAR_1`, as integers. The `-> int` specifies that the function returns an integer.\n\nThe second line starts a while loop that continues as long as `VAR_1` is not zero. \n\nThe third line is a tuple assignment that swaps the values of `VAR_0` and `VAR_1`, and sets `VAR_1` to the remainder of `VAR_0` divided by `VAR_1`.\n\nThe fourth line returns the value of `VAR_0`, which is the GCD of the original `VAR_0` and `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (greatest_common_divisor a b)\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (find_closest_elements numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of floats and returns a tuple of two floats. The function finds the two closest numbers in the list and returns them in a tuple, sorted in ascending order.\n\nThe function is defined with the name FUNC_0 and takes one argument, VAR_0, which is a list of floats. The function returns a tuple of two floats.\n\nThe first line of the function imports the List and Tuple types from the typing module.\n\nThe second line of the function initializes two variables, VAR_1 and VAR_2, to None.\n\nThe third line of the function starts a nested loop that iterates over each pair of numbers in the list. The outer loop iterates over each number in the list, and the inner loop iterates over each number in the list again.\n\nThe fourth line of the function checks if the two numbers being compared are not the same. If they are the same, the loop continues to the next pair of numbers.\n\nThe fifth line of the function checks if VAR_2 is None. If it is, then this is the first pair of numbers being compared, so VAR_2 is set to the absolute value of the difference between the two numbers, and VAR_1 is set to a tuple of the two numbers sorted in ascending order.\n\nThe sixth line of the function is an else statement that is executed if VAR_2 is not None. This means that there has already been a pair of numbers compared, so VAR_7 is set to the absolute value of the difference between the two numbers being compared. If VAR_7 is less than VAR_2, then VAR_2 is set to VAR_7, and VAR_1 is set to a tuple of the two numbers sorted in ascending order.\n\nThe seventh line of the function returns VAR_1, which is the tuple of the two closest numbers in the list, sorted in ascending order.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (find_closest_elements numbers)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (odd_count lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate odd_count))\n    (check-within (candidate (list \"1234567\")) (list \"the number of odd elements 4n the str4ng 4 of the 4nput.\") 0.001)\n    (check-within (candidate (list \"3\" \"11111111\")) (list \"the number of odd elements 1n the str1ng 1 of the 1nput.\" \"the number of odd elements 8n the str8ng 8 of the 8nput.\") 0.001)\n    (check-within (candidate (list \"271\" \"137\" \"314\")) (list \"the number of odd elements 2n the str2ng 2 of the 2nput.\" \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \"the number of odd elements 2n the str2ng 2 of the 2nput.\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in a list of strings `VAR_0` and returns a list of strings `VAR_1`. The function loops over each string in the input list and counts the number of odd elements in the string. It then creates a new string that includes the count of odd elements and returns it in a list.\n\nHere's a line-by-line breakdown of the code:\n\n```python\nfrom typing import List\n```\nThis line imports the `List` class from the `typing` module. This is used to specify the type of the input and output of the function.\n\n```python\ndef FUNC_0(VAR_0: List[str]) -> List[str]:\n```\nThis line defines the function `FUNC_0` that takes in a list of strings `VAR_0` and returns a list of strings `VAR_1`. The `-> List[str]` specifies the return type of the function.\n\n```python\nVAR_1 = []\n```\nThis line initializes an empty list `VAR_1` that will be used to store the output.\n\n```python\nfor VAR_2 in VAR_0:\n```\nThis line starts a loop that iterates over each string `VAR_2` in the input list `VAR_0`.\n\n```python\nVAR_3 = sum((((int(VAR_4) % 2) == 1) for VAR_4 in VAR_2))\n```\nThis line counts the number of odd elements in the current string `VAR_2`. It does this by iterating over each character `VAR_4` in the string, converting it to an integer, checking if it's odd, and summing up the results.\n\n```python\nVAR_1.append((((((((('the number of odd elements ' + str(VAR_3)) + 'n the str') + str(VAR_3)) + 'ng ') + str(VAR_3)) + ' of the ') + str(VAR_3)) + 'nput.'))\n```\nThis line creates a new string that includes the count of odd elements and appends it to the output list `VAR_1`. The string is constructed using string concatenation and includes the count of odd elements in various places.\n\n```python\nreturn VAR_1\n```\nThis line returns the output list `VAR_1` containing the strings with the count of odd elements.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (odd_count lst)\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (even_odd_palindrome n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_palindrome))\n    (check-within (candidate 123) (list 8 13) 0.001)\n    (check-within (candidate 12) (list 4 6) 0.001)\n    (check-within (candidate 3) (list 1 2) 0.001)\n    (check-within (candidate 63) (list 6 8) 0.001)\n    (check-within (candidate 25) (list 5 6) 0.001)\n    (check-within (candidate 19) (list 4 6) 0.001)\n    (check-within (candidate 9) (list 4 5) 0.001)\n    (check-within (candidate 1) (list 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer `VAR_0` as input and returns a tuple of two integers. The function first defines another function called `FUNC_1` that takes an input `VAR_1` and returns a boolean indicating whether or not `VAR_1` is a palindrome (i.e., reads the same forwards and backwards). \n\nThe function then initializes two variables `VAR_2` and `VAR_3` to zero. It then loops over the range of integers from 1 to `VAR_0` (inclusive) and checks whether each integer is a palindrome and whether it is even or odd. If the integer is odd and a palindrome, `VAR_3` is incremented by 1. If the integer is even and a palindrome, `VAR_2` is incremented by 1.\n\nFinally, the function returns a tuple of the two counts, `(VAR_2, VAR_3)`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (even_odd_palindrome n)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (prime_length string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n    (check-within (candidate \"Hello\") #t 0.001)\n    (check-within (candidate \"abcdcba\") #t 0.001)\n    (check-within (candidate \"kittens\") #t 0.001)\n    (check-within (candidate \"orange\") #f 0.001)\n    (check-within (candidate \"wow\") #t 0.001)\n    (check-within (candidate \"world\") #t 0.001)\n    (check-within (candidate \"MadaM\") #t 0.001)\n    (check-within (candidate \"Wow\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"HI\") #t 0.001)\n    (check-within (candidate \"go\") #t 0.001)\n    (check-within (candidate \"gogo\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaa\") #f 0.001)\n    (check-within (candidate \"Madam\") #t 0.001)\n    (check-within (candidate \"M\") #f 0.001)\n    (check-within (candidate \"0\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef prime_length(string: str) -> bool:\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a given string is a prime number. Here is a line-by-line breakdown of the code:\n\n```python\ndef FUNC_0(VAR_0: str) -> bool:\n```\n\nThis line defines a function called `FUNC_0` that takes a string as input and returns a boolean value. The function is used to check if the input string is a prime number.\n\n```python\nVAR_1 = len(VAR_0)\n```\n\nThis line calculates the length of the input string and assigns it to a variable called `VAR_1`.\n\n```python\nif ((VAR_1 == 0) or (VAR_1 == 1)):\n    return False\n```\n\nThis line checks if the length of the input string is 0 or 1. If it is, the function returns `False` because a string of length 0 or 1 cannot be a prime number.\n\n```python\nfor VAR_2 in range(2, VAR_1):\n    if ((VAR_1 % VAR_2) == 0):\n        return False\n```\n\nThis line loops through all the numbers from 2 to the length of the input string minus 1. For each number, it checks if the length of the input string is divisible by that number. If it is, the function returns `False` because a prime number can only be divisible by 1 and itself.\n\n```python\nreturn True\n```\n\nIf the function has not returned `False` by this point, it means that the input string is a prime number. The function returns `True`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prime_length string)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (change_base x base)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n    (check-within (candidate 8 3) \"22\" 0.001)\n    (check-within (candidate 9 3) \"100\" 0.001)\n    (check-within (candidate 234 2) \"11101010\" 0.001)\n    (check-within (candidate 16 2) \"10000\" 0.001)\n    (check-within (candidate 8 2) \"1000\" 0.001)\n    (check-within (candidate 7 2) \"111\" 0.001)\n    (check-within (candidate 2 3) \"2\" 0.001)\n    (check-within (candidate 3 4) \"3\" 0.001)\n    (check-within (candidate 4 5) \"4\" 0.001)\n    (check-within (candidate 5 6) \"5\" 0.001)\n    (check-within (candidate 6 7) \"6\" 0.001)\n    (check-within (candidate 7 8) \"7\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef change_base(x: int, base: int) -> str:\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\n### Explanation\n\nThe code is an implementation of a function that converts a number from base 10 to any base between 2 and 36. \n\n```python\ndef FUNC_0(VAR_0: int, VAR_1: int) -> str:\n```\nThe function is defined with two arguments, `VAR_0` and `VAR_1`. `VAR_0` is the number to be converted, while `VAR_1` is the base to convert the number to. The function returns a string.\n\n```python\n    VAR_2 = ''\n```\nA variable `VAR_2` is initialized as an empty string.\n\n```python\n    while (VAR_0 > 0):\n```\nA while loop is started. The loop continues as long as `VAR_0` is greater than 0.\n\n```python\n        VAR_2 = (str((VAR_0 % VAR_1)) + VAR_2)\n```\nIn each iteration of the loop, the remainder of `VAR_0` divided by `VAR_1` is calculated. This remainder is then converted to a string and concatenated with the current value of `VAR_2`. The result is then assigned to `VAR_2`.\n\n```python\n        VAR_0 //= VAR_1\n```\nAfter the remainder is calculated, `VAR_0` is updated to be the quotient of `VAR_0` divided by `VAR_1`. This is equivalent to performing integer division.\n\n```python\n    return VAR_2\n```\nAfter the loop has finished, the final value of `VAR_2` is returned as a string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (change_base x base)\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (remove_vowels text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_vowels))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"abcdef\nghijklm\") \"bcdf\nghjklm\" 0.001)\n    (check-within (candidate \"fedcba\") \"fdcb\" 0.001)\n    (check-within (candidate \"eeeee\") \"\" 0.001)\n    (check-within (candidate \"acBAA\") \"cB\" 0.001)\n    (check-within (candidate \"EcBOO\") \"cB\" 0.001)\n    (check-within (candidate \"ybcd\") \"ybcd\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef remove_vowels(text: str) -> str:\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a string with all vowels removed. \n\n1. `def FUNC_0(VAR_0: str) -> str:` defines a function named `FUNC_0` that takes a string argument `VAR_0` and returns a string. \n2. `return ''.join([VAR_1 for VAR_1 in VAR_0 if (VAR_1.lower() not in ['a', 'e', 'i', 'o', 'u'])])` returns a string that is created by joining all the characters in the input string `VAR_0` that are not vowels. \n    * `VAR_1 for VAR_1 in VAR_0` is a list comprehension that creates a list of all the characters in the input string `VAR_0`.\n    * `if (VAR_1.lower() not in ['a', 'e', 'i', 'o', 'u'])` is a condition that checks if the lowercase version of the current character is not a vowel.\n    * `''.join()` is a method that joins all the characters in the list created by the list comprehension into a single string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (remove_vowels text)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (below_zero operations)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_zero))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)\n    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)\n    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns `True` if the sum of the integers in the list is negative at any point. Otherwise, it returns `False`.\n\n```python\nfrom typing import List\n```\nThis line imports the `List` class from the `typing` module. The `List` class is used to specify that a variable is a list of a certain type.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> bool:\n```\nThis line defines a function named `FUNC_0` that takes a single argument, `VAR_0`, which is a list of integers. The function returns a boolean value.\n\n```python\nVAR_1 = 0\n```\nThis line initializes a variable named `VAR_1` to 0. This variable will be used to keep track of the sum of the integers in the list.\n\n```python\nfor VAR_2 in VAR_0:\n```\nThis line starts a `for` loop that iterates over each element in the `VAR_0` list. The loop variable is named `VAR_2`.\n\n```python\nVAR_1 += VAR_2\n```\nThis line adds the current element (`VAR_2`) to the running sum (`VAR_1`).\n\n```python\nif (VAR_1 < 0):\n    return True\n```\nThis line checks if the running sum (`VAR_1`) is negative. If it is, the function returns `True` immediately, indicating that the sum of the integers in the list is negative.\n\n```python\nreturn False\n```\nIf the loop completes without encountering a negative sum, the function returns `False`, indicating that the sum of the integers in the list is non-negative.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (below_zero operations)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (below_threshold l t)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_threshold))\n    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)\n    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef below_threshold(l: List[int], t: int) -> bool:\n    for e in l:\n        if e >= t:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and an integer, and returns a boolean value. The function checks if any of the integers in the list is greater than or equal to the second integer. If any integer in the list is greater than or equal to the second integer, the function returns False. Otherwise, it returns True.\n\nThe function is defined using the \"def\" keyword, followed by the function name \"FUNC_0\". The function takes two arguments: \"VAR_0\", which is a list of integers, and \"VAR_1\", which is an integer. The \"-> bool\" after the argument list indicates that the function returns a boolean value.\n\nThe function uses a \"for\" loop to iterate over each integer in the list \"VAR_0\". The loop variable is named \"VAR_2\". \n\nWithin the loop, the function checks if the current integer \"VAR_2\" is greater than or equal to the second integer \"VAR_1\". If it is, the function immediately returns False, indicating that at least one integer in the list is greater than or equal to the second integer.\n\nIf the loop completes without finding any integer in the list that is greater than or equal to the second integer, the function returns True, indicating that none of the integers in the list are greater than or equal to the second integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (below_threshold l t)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (int_to_mini_roman number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n    (check-within (candidate 19) \"xix\" 0.001)\n    (check-within (candidate 152) \"clii\" 0.001)\n    (check-within (candidate 251) \"ccli\" 0.001)\n    (check-within (candidate 426) \"cdxxvi\" 0.001)\n    (check-within (candidate 500) \"d\" 0.001)\n    (check-within (candidate 1) \"i\" 0.001)\n    (check-within (candidate 4) \"iv\" 0.001)\n    (check-within (candidate 43) \"xliii\" 0.001)\n    (check-within (candidate 90) \"xc\" 0.001)\n    (check-within (candidate 94) \"xciv\" 0.001)\n    (check-within (candidate 532) \"dxxxii\" 0.001)\n    (check-within (candidate 900) \"cm\" 0.001)\n    (check-within (candidate 994) \"cmxciv\" 0.001)\n    (check-within (candidate 1000) \"m\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef int_to_mini_roman(number: int) -> str:\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n\n### Explanation\n\nThe code is an implementation of a function that converts an integer to a Roman numeral string. \n\n```python\ndef FUNC_0(VAR_0: int) -> str:\n```\nThe function is named `FUNC_0` and takes an integer `VAR_0` as input and returns a string. \n\n```python\nVAR_1 = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\nVAR_2 = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M']\n```\nTwo lists are defined, `VAR_1` and `VAR_2`. `VAR_1` contains the decimal values of the Roman numerals, and `VAR_2` contains the Roman numerals themselves. \n\n```python\nVAR_3 = 12\n```\n`VAR_3` is initialized to 12, which is the index of the largest Roman numeral in the `VAR_1` list. \n\n```python\nVAR_4 = ''\n```\n`VAR_4` is initialized to an empty string. This variable will be used to store the Roman numeral string. \n\n```python\nwhile VAR_0:\n```\nA while loop is started, which will continue until `VAR_0` is zero. \n\n```python\nVAR_5 = (VAR_0 // VAR_1[VAR_3])\nVAR_0 %= VAR_1[VAR_3]\n```\nInside the while loop, `VAR_5` is set to the integer division of `VAR_0` and the value at index `VAR_3` in the `VAR_1` list. The remainder of this division is then assigned to `VAR_0`. \n\n```python\nwhile VAR_5:\n    VAR_4 += VAR_2[VAR_3]\n    VAR_5 -= 1\n```\nAnother while loop is started, which will continue until `VAR_5` is zero. Inside this loop, the Roman numeral at index `VAR_3` in the `VAR_2` list is added to `VAR_4`, and `VAR_5` is decremented by one. This loop will add the appropriate number of Roman numerals to the `VAR_4` string. \n\n```python\nVAR_3 -= 1\n```\nAfter the inner while loop has finished, `VAR_3` is decremented by one, so that the next largest Roman numeral can be used in the next iteration of the outer while loop. \n\n```python\nreturn VAR_4.lower()\n```\nAfter the outer while loop has finished, the resulting Roman numeral string is returned, converted to lowercase.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (int_to_mini_roman number)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (double_the_difference lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate double_the_difference))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 5.0 4.0)) 25 0.001)\n    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)\n    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)\n    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)\n    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)\n    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of floats as input and returns an integer. The function calculates the sum of the squares of all the odd positive integers in the input list that do not contain a decimal point.\n\n```python\nfrom typing import List\n```\nThis line imports the List type from the typing module. The List type is used to indicate that a variable is a list of a specific type.\n\n```python\ndef FUNC_0(VAR_0: List[float]) -> int:\n```\nThis line defines a function called FUNC_0 that takes a list of floats as input and returns an integer. The function is defined using Python's function definition syntax, which starts with the keyword \"def\", followed by the function name, and then the input parameters in parentheses. The \"-> int\" after the parentheses indicates that the function returns an integer.\n\n```python\nreturn sum([(VAR_1 ** 2) for VAR_1 in VAR_0 if ((VAR_1 > 0) and ((VAR_1 % 2) != 0) and ('.' not in str(VAR_1)))])\n```\nThis line is the body of the function. It calculates the sum of the squares of all the odd positive integers in the input list that do not contain a decimal point.\n\nThe calculation is done using a list comprehension, which is a concise way of creating a new list by iterating over an existing list and applying a condition to each element. The list comprehension is enclosed in square brackets, which indicates that it is a list.\n\nThe list comprehension has the following structure:\n\n```python\n[(VAR_1 ** 2) for VAR_1 in VAR_0 if ((VAR_1 > 0) and ((VAR_1 % 2) != 0) and ('.' not in str(VAR_1)))]\n```\n\nThis list comprehension iterates over each element in the input list VAR_0, and applies the condition in the \"if\" statement to each element. If the condition is true, the element is squared and added to the new list.\n\nThe condition in the \"if\" statement has three parts:\n\n1. `VAR_1 > 0`: This checks if the element is positive.\n2. `(VAR_1 % 2) != 0`: This checks if the element is odd by checking if the remainder of the element divided by 2 is not equal to 0.\n3. `('.' not in str(VAR_1))`: This checks if the element does not contain a decimal point by converting the element to a string and checking if the string contains a period.\n\nThe \"sum\" function is then called on the new list to calculate the sum of the squares of all the odd positive integers in the input list that do not contain a decimal point. The result is returned as an integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (double_the_difference lst)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (words_in_sentence sentence)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_in_sentence))\n    (check-within (candidate \"This is a test\") \"is\" 0.001)\n    (check-within (candidate \"lets go for swimming\") \"go for\" 0.001)\n    (check-within (candidate \"there is no place available here\") \"there is no place\" 0.001)\n    (check-within (candidate \"Hi I am Hussein\") \"Hi am Hussein\" 0.001)\n    (check-within (candidate \"go for it\") \"go for it\" 0.001)\n    (check-within (candidate \"here\") \"\" 0.001)\n    (check-within (candidate \"here is\") \"is\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef words_in_sentence(sentence: str) -> str:\n    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` which takes a string as input and returns a string. The function takes a string of words, and returns only the words that are prime numbers.\n\nThe function starts by initializing an empty list called `VAR_1`. This list will be used to store the prime number words.\n\nThe function then enters a `for` loop that iterates over each word in the input string. The loop splits the input string into words using the `split()` method.\n\nFor each word, the function initializes a variable called `VAR_3` to 0. This variable will be used to determine if the word is a prime number.\n\nThe function then enters another `for` loop that iterates over each number from 2 to the length of the word. This loop checks if the length of the word is divisible by the current number. If it is, the function sets `VAR_3` to 1, indicating that the word is not a prime number.\n\nAfter the inner loop completes, the function checks if `VAR_3` is equal to 0 or if the length of the word is 2. If either of these conditions is true, the function appends the word to the `VAR_1` list.\n\nFinally, the function returns a string that is the concatenation of all the words in the `VAR_1` list, separated by a space.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (words_in_sentence sentence)\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (same_chars s0 s1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabc\") #t 0.001)\n    (check-within (candidate \"dddddddabc\" \"abcd\") #t 0.001)\n    (check-within (candidate \"eabcd\" \"dddddddabc\") #f 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabcf\") #f 0.001)\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f 0.001)\n    (check-within (candidate \"aabb\" \"aaccc\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in two string arguments `VAR_0` and `VAR_1`. The function returns a boolean value that is `True` if the two strings have the same set of characters, and `False` otherwise.\n\nThe function works by converting the two input strings into sets using the `set()` function. A set is an unordered collection of unique elements, so converting a string to a set removes any duplicate characters. The `==` operator is then used to compare the two sets, which returns `True` if they are equal (i.e. contain the same elements) and `False` otherwise.\n\nIn Java, the equivalent code would be:\n\n```java\npublic static boolean func0(String var0, String var1) {\n    return new HashSet<>(Arrays.asList(var0.split(\"\"))).equals(new HashSet<>(Arrays.asList(var1.split(\"\"))));\n}\n```\n\nThis code creates two new `HashSet` objects, one for each input string. The `Arrays.asList()` method is used to convert the strings into arrays of individual characters, which are then passed to the `HashSet` constructor. The `equals()` method is then used to compare the two sets, which returns `true` if they are equal and `false` otherwise. Note that the `split()` method is used to split the strings into individual characters, since Java does not have a built-in `set()` function for strings.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (same_chars s0 s1)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (compare_one a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare_one))\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 2.5) 2.5 0.001)\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 5 6) 6 0.001)\n    (check-within (candidate 1 \"2,3\") \"2,3\" 0.001)\n    (check-within (candidate \"5,1\" \"6\") \"6\" 0.001)\n    (check-within (candidate \"1\" \"2\") \"2\" 0.001)\n    (check-within (candidate \"1\" 1) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments and returns the one with the highest value. The function is called `FUNC_0` and takes two arguments, `VAR_0` and `VAR_1`. Both arguments can be of type `int`, `float`, or `str`. The function returns either `VAR_0` or `VAR_1`, depending on which one has the highest value. If the two arguments have the same value, the function returns `None`.\n\nThe first line of the code imports the `Union` type from the `typing` module. This is used to specify that a variable can be of multiple types.\n\nThe second line defines the `FUNC_0` function. The function takes two arguments, `VAR_0` and `VAR_1`, both of which can be of type `int`, `float`, or `str`. The function returns either `int`, `float`, `str`, or `None`.\n\nThe third line creates two variables, `VAR_2` and `VAR_3`, and assigns them the values of `VAR_0` and `VAR_1`, respectively.\n\nThe next two lines check if `VAR_2` and `VAR_3` are of type `str`. If they are, any commas in the strings are replaced with periods. This is done to ensure that the strings can be converted to floats later on.\n\nThe next line checks if `VAR_2` and `VAR_3` are equal as floats. If they are, the function returns `None`.\n\nThe final line returns either `VAR_0` or `VAR_1`, depending on which one has the highest value as a float. This is done by converting `VAR_2` and `VAR_3` to floats and comparing them. If `VAR_2` is greater than `VAR_3`, `VAR_0` is returned. Otherwise, `VAR_1` is returned.<|im_end|>\n\n\n### Racket version\n\n#lang racket\n\n;; \n(define (compare_one a b)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (max_fill grid capacity)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_fill))\n    (check-within (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nimport math\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of lists of integers and an integer as input, and returns an integer. The function calculates the minimum number of hours required to complete all the tasks in the list of lists, given that each task takes a certain number of hours to complete, and that a worker can only work on tasks that are in the same list.\n\nThe function takes two arguments: VAR_0 and VAR_1. VAR_0 is a list of lists of integers, where each inner list represents a set of tasks that can be completed by a single worker. VAR_1 is an integer that represents the number of hours a worker can work in a day.\n\nThe function first imports the math module, which provides mathematical functions. \n\nThe function then defines a function called FUNC_0, which takes two arguments: VAR_0 and VAR_1. The function returns the sum of a list comprehension that iterates over each inner list in VAR_0, calculates the minimum number of workers required to complete the tasks in that list, and adds that number to the sum.\n\nThe list comprehension calculates the minimum number of workers required to complete the tasks in each inner list by dividing the sum of the hours required for each task in the list by VAR_1 (the number of hours a worker can work in a day), and then rounding up to the nearest integer using the math.ceil function. The sum of these minimum worker requirements is then returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (max_fill grid capacity)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (solution lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solution))\n    (check-within (candidate (list 5 8 7 1)) 12 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 9 0.001)\n    (check-within (candidate (list 30 13 24 321)) 0 0.001)\n    (check-within (candidate (list 5 9)) 5 0.001)\n    (check-within (candidate (list 2 4 8)) 0 0.001)\n    (check-within (candidate (list 30 13 23 32)) 23 0.001)\n    (check-within (candidate (list 3 13 2 9)) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef solution(lst: List[int]) -> int:\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the sum of all odd numbers in the list that are in an even position (0-indexed).\n\n```python\nfrom typing import List\n```\nImport the List class from the typing module.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> int:\n```\nDefine a function named `FUNC_0` that takes a list of integers as input and returns an integer. The function signature is annotated with type hints.\n\n```python\nreturn sum([VAR_2 for (VAR_1, VAR_2) in enumerate(VAR_0) if (((VAR_1 % 2) == 0) and ((VAR_2 % 2) == 1))])\n```\nReturn the sum of all odd numbers in the list that are in an even position (0-indexed). The sum is computed using the built-in `sum` function. The list comprehension `[VAR_2 for (VAR_1, VAR_2) in enumerate(VAR_0) if (((VAR_1 % 2) == 0) and ((VAR_2 % 2) == 1))]` generates a list of all odd numbers in the list that are in an even position. The `enumerate` function is used to generate a sequence of tuples `(VAR_1, VAR_2)` where `VAR_1` is the index of the element and `VAR_2` is the element itself. The condition `(((VAR_1 % 2) == 0) and ((VAR_2 % 2) == 1))` filters the tuples to keep only those where the index is even and the element is odd.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solution lst)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (total_match lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate total_match))\n    (check-within (candidate (list ) (list )) (list ) 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\")) (list \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\" \"admin\" \"project\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list \"4\") (list \"1\" \"2\" \"3\" \"4\" \"5\")) (list \"4\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"Hi\")) (list \"hI\" \"Hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hi\")) (list \"hI\" \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hii\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list ) (list \"this\")) (list ) 0.001)\n    (check-within (candidate (list \"this\") (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n\n### Explanation\n\nThe code is an implementation of a function that takes two lists of strings and returns the list with the shortest total length. The function is defined with the name `FUNC_0` and takes two arguments, `VAR_0` and `VAR_1`, both of which are lists of strings. The function returns a list of strings.\n\nThe first line of the code imports the `List` type from the `typing` module. This is used to specify the type of the function arguments and return value.\n\nThe function starts by initializing a variable `VAR_2` to 0. This variable is used to keep track of the total length of all strings in the first list `VAR_0`. The function then loops through each string in `VAR_0` and adds its length to `VAR_2`.\n\nThe function then initializes another variable `VAR_4` to 0. This variable is used to keep track of the total length of all strings in the second list `VAR_1`. The function then loops through each string in `VAR_1` and adds its length to `VAR_4`.\n\nThe function then checks if the total length of the strings in `VAR_0` is less than or equal to the total length of the strings in `VAR_1`. If it is, the function returns `VAR_0`. Otherwise, it returns `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (total_match lst1 lst2)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (vowels_count s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate vowels_count))\n    (check-within (candidate \"abcde\") 2 0.001)\n    (check-within (candidate \"Alone\") 3 0.001)\n    (check-within (candidate \"key\") 2 0.001)\n    (check-within (candidate \"bye\") 1 0.001)\n    (check-within (candidate \"keY\") 2 0.001)\n    (check-within (candidate \"bYe\") 1 0.001)\n    (check-within (candidate \"ACEDY\") 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef vowels_count(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of vowels in a string. The function takes in a string as an argument and returns an integer representing the number of vowels in the string.\n\n```python\ndef FUNC_0(VAR_0: str) -> int:\n```\nThe function is defined with the name `FUNC_0` and takes in a single argument `VAR_0` which is a string. The function returns an integer.\n\n```python\nVAR_1 = 'aeiouAEIOU'\n```\nA string `VAR_1` is defined and assigned the value of all the vowels in both uppercase and lowercase.\n\n```python\nVAR_2 = sum(((VAR_3 in VAR_1) for VAR_3 in VAR_0))\n```\nThe variable `VAR_2` is assigned the value of the sum of a generator expression. The generator expression is used to iterate over each character in the input string `VAR_0` and check if it is a vowel. If the character is a vowel, the expression evaluates to `True`, otherwise it evaluates to `False`. The `sum()` function is used to sum up all the `True` values, which gives us the number of vowels in the string.\n\n```python\nif ((VAR_0[(- 1)] == 'y') or (VAR_0[(- 1)] == 'Y')):\n    VAR_2 += 1\n```\nAn `if` statement is used to check if the last character in the input string is either `y` or `Y`. If it is, then we increment the value of `VAR_2` by 1, since `y` and `Y` are sometimes considered as vowels.\n\n```python\nreturn VAR_2\n```\nFinally, the function returns the value of `VAR_2`, which is the number of vowels in the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (vowels_count s)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (factorize n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate factorize))\n    (check-within (candidate 2) (list 2) 0.001)\n    (check-within (candidate 4) (list 2 2) 0.001)\n    (check-within (candidate 8) (list 2 2 2) 0.001)\n    (check-within (candidate 57) (list 3 19) 0.001)\n    (check-within (candidate 3249) (list 3 3 19 19) 0.001)\n    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)\n    (check-within (candidate 20577) (list 3 19 19 19) 0.001)\n    (check-within (candidate 18) (list 2 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n### Explanation\n\nThe code is an implementation of the prime factorization algorithm. The function takes an integer as input and returns a list of its prime factors. \n\nThe function definition starts with the `def` keyword, followed by the function name `FUNC_0`. The function takes one argument, an integer `VAR_0`, and returns a list of integers. The `->` symbol indicates the return type of the function. The `List` type is imported from the `typing` module.\n\nThe `import` statement brings in the `math` module, which provides access to mathematical functions.\n\nThe next line initializes an empty list `VAR_1` to store the prime factors.\n\nThe variable `VAR_2` is initialized to 2, which is the smallest prime number.\n\nThe `while` loop continues as long as `VAR_2` is less than or equal to the square root of `VAR_0` plus 1. The `int` function is used to convert the square root to an integer.\n\nInside the loop, an `if` statement checks if `VAR_0` is divisible by `VAR_2`. If it is, then `VAR_2` is a prime factor of `VAR_0`, so it is appended to the list `VAR_1`. The `//=` operator is used to perform integer division and update the value of `VAR_0` with the quotient. If `VAR_0` is not divisible by `VAR_2`, then `VAR_2` is incremented by 1.\n\nAfter the loop, an `if` statement checks if `VAR_0` is greater than 1. If it is, then `VAR_0` itself is a prime factor, so it is appended to the list `VAR_1`.\n\nFinally, the function returns the list `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (factorize n)\n"
  },
  {
    "name": "HumanEval_108_count_nums",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_nums arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_108_count_nums.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_nums))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list -1 -2 0)) 0 0.001)\n    (check-within (candidate (list 1 1 2 -2 3 4 5)) 6 0.001)\n    (check-within (candidate (list 1 6 9 -6 0 1 5)) 5 0.001)\n    (check-within (candidate (list 1 100 98 -7 1 -1)) 4 0.001)\n    (check-within (candidate (list 12 23 34 -45 -56 0)) 5 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the number of integers in the list whose digits sum to a positive number. \n\nThe function is defined as FUNC_0 and takes a single argument VAR_0, which is a list of integers. The function returns an integer.\n\nThe function contains a nested function FUNC_1, which takes a single argument VAR_1. FUNC_1 returns the sum of the digits of VAR_1, with the sign of the first digit preserved. \n\nThe first line of FUNC_1 sets VAR_2 to 1. VAR_2 is used to preserve the sign of VAR_1. If VAR_1 is negative, VAR_2 is set to -1 and VAR_1 is made positive. \n\nThe second line of FUNC_1 converts VAR_1 to a list of integers, with each digit of VAR_1 as a separate element in the list. \n\nThe third line of FUNC_1 multiplies the first digit of VAR_1 by VAR_2, preserving the sign of the first digit. \n\nThe fourth line of FUNC_1 returns the sum of the digits of VAR_1.\n\nThe return statement of FUNC_0 applies FUNC_1 to each element of VAR_0 using a list comprehension, and filters the resulting list to only include elements that are greater than 0. The length of the resulting list is returned.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_nums arr)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (max_element l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_element))\n    (check-within (candidate (list 1 2 3)) 3 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef max_element(l: List[int]) -> int:\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns the largest integer in the list. Here is a line-by-line explanation:\n\n```python\nfrom typing import List\n```\n\nThis line imports the List type from the typing module. This is used to specify the type of the input parameter to the function.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> int:\n```\n\nThis line defines a function called FUNC_0 that takes a list of integers as input and returns an integer. The function is defined using the def keyword, followed by the function name, and the input parameter(s) in parentheses. The -> int specifies the return type of the function.\n\n```python\nVAR_1 = VAR_0[0]\n```\n\nThis line initializes a variable VAR_1 to the first element of the input list VAR_0.\n\n```python\nfor VAR_2 in VAR_0:\n```\n\nThis line starts a for loop that iterates over each element in the input list VAR_0. The loop variable VAR_2 takes on the value of each element in turn.\n\n```python\nif (VAR_2 > VAR_1):\n```\n\nThis line checks if the current element VAR_2 is greater than the current maximum VAR_1.\n\n```python\nVAR_1 = VAR_2\n```\n\nThis line updates the maximum to the current element if it is greater.\n\n```python\nreturn VAR_1\n```\n\nThis line returns the maximum value found in the input list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (max_element l)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (bf planet1 planet2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate bf))\n    (check-within (candidate \"Jupiter\" \"Neptune\") (list \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Mercury\") (list \"Venus\") 0.001)\n    (check-within (candidate \"Mercury\" \"Uranus\") (list \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\") 0.001)\n    (check-within (candidate \"Neptune\" \"Venus\") (list \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Mars\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Jupiter\" \"Makemake\") (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n\n### Explanation\n\nThe code is an implementation of a function that takes two planet names as input and returns the names of the planets that are between them in the solar system. The function is defined with the name FUNC_0 and takes two arguments, VAR_0 and VAR_1, both of which are strings. The function returns a tuple of strings.\n\nThe function first defines a list of strings, VAR_2, which contains the names of the planets in the solar system in order from the closest to the sun to the farthest. \n\nThe function then checks if VAR_0 and VAR_1 are both in VAR_2 and are not the same planet. If either of these conditions is not met, the function returns an empty tuple.\n\nIf both VAR_0 and VAR_1 are in VAR_2 and are not the same planet, the function finds the index of VAR_0 and VAR_1 in VAR_2 using the index() method. \n\nIf the index of VAR_0 is less than the index of VAR_1, the function returns a slice of VAR_2 starting from the index after VAR_0 and ending at the index before VAR_1. This slice contains all the planets that are between VAR_0 and VAR_1 in the solar system.\n\nIf the index of VAR_0 is greater than the index of VAR_1, the function returns a slice of VAR_2 starting from the index after VAR_1 and ending at the index before VAR_0. This slice contains all the planets that are between VAR_1 and VAR_0 in the solar system.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (bf planet1 planet2)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (simplify x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate simplify))\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/6\" \"2/1\") #f 0.001)\n    (check-within (candidate \"5/1\" \"3/1\") #t 0.001)\n    (check-within (candidate \"7/10\" \"10/2\") #f 0.001)\n    (check-within (candidate \"2/10\" \"50/10\") #t 0.001)\n    (check-within (candidate \"7/2\" \"4/2\") #t 0.001)\n    (check-within (candidate \"11/6\" \"6/1\") #t 0.001)\n    (check-within (candidate \"2/3\" \"5/2\") #f 0.001)\n    (check-within (candidate \"5/2\" \"3/5\") #f 0.001)\n    (check-within (candidate \"2/4\" \"8/4\") #t 0.001)\n    (check-within (candidate \"2/4\" \"4/2\") #t 0.001)\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/5\" \"1/5\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef simplify(x: str, n: str) -> bool:\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes two string arguments `VAR_0` and `VAR_1` and returns a boolean value. \n\nThe first line of the function definition specifies the types of the input arguments and the return value. `VAR_0` and `VAR_1` are of type `str` and the function returns a `bool`.\n\n```python\ndef FUNC_0(VAR_0: str, VAR_1: str) -> bool:\n```\n\nThe next two lines of the function split the input strings `VAR_0` and `VAR_1` into two parts each, separated by a forward slash (`/`). The resulting substrings are assigned to variables `VAR_2`, `VAR_3`, `VAR_4`, and `VAR_5`.\n\n```python\n    (VAR_2, VAR_3) = VAR_0.split('/')\n    (VAR_4, VAR_5) = VAR_1.split('/')\n```\n\nThe next two lines of the function calculate the product of `VAR_2` and `VAR_4`, and `VAR_3` and `VAR_5`, respectively. The resulting values are assigned to variables `VAR_6` and `VAR_7`.\n\n```python\n    VAR_6 = (int(VAR_2) * int(VAR_4))\n    VAR_7 = (int(VAR_3) * int(VAR_5))\n```\n\nThe next line of the function checks if the result of dividing `VAR_6` by `VAR_7` is an integer. If it is, the function returns `True`. Otherwise, it returns `False`.\n\n```python\n    if ((VAR_6 / VAR_7) == int((VAR_6 / VAR_7))):\n        return True\n    return False\n```\n\nIn summary, the function takes two strings in the format `a/b` and `c/d`, multiplies the numerators and denominators separately, and returns `True` if the result of dividing the products is an integer, and `False` otherwise.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (simplify x n)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (digits n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 54) 5 0.001)\n    (check-within (candidate 120) 1 0.001)\n    (check-within (candidate 5014) 5 0.001)\n    (check-within (candidate 98765) 315 0.001)\n    (check-within (candidate 5576543) 2625 0.001)\n    (check-within (candidate 2468) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef digits(n: int) -> int:\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input, and returns the product of all the odd digits in the integer. If the integer has no odd digits, the function returns 0.\n\n```python\ndef FUNC_0(VAR_0: int) -> int:\n```\nThis line defines a function called `FUNC_0` that takes an integer as input and returns an integer.\n\n```python\nVAR_1 = 1\nVAR_2 = 0\n```\nThese lines initialize two variables, `VAR_1` and `VAR_2`, to 1 and 0 respectively.\n\n```python\nfor VAR_3 in str(VAR_0):\n```\nThis line starts a loop that iterates over each character in the string representation of the input integer.\n\n```python\nVAR_4 = int(VAR_3)\n```\nThis line converts the current character to an integer and assigns it to a variable called `VAR_4`.\n\n```python\nif ((VAR_4 % 2) == 1):\n    VAR_1 = (VAR_1 * VAR_4)\n    VAR_2 += 1\n```\nThese lines check if `VAR_4` is odd. If it is, `VAR_1` is multiplied by `VAR_4`, and `VAR_2` is incremented by 1.\n\n```python\nif (VAR_2 == 0):\n    return 0\nelse:\n    return VAR_1\n```\nThese lines check if there were any odd digits in the input integer. If there were none, the function returns 0. Otherwise, it returns the product of all the odd digits.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (digits n)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (encrypt s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n    (check-within (candidate \"hi\") \"lm\" 0.001)\n    (check-within (candidate \"asdfghjkl\") \"ewhjklnop\" 0.001)\n    (check-within (candidate \"gf\") \"kj\" 0.001)\n    (check-within (candidate \"et\") \"ix\" 0.001)\n    (check-within (candidate \"faewfawefaewg\") \"jeiajeaijeiak\" 0.001)\n    (check-within (candidate \"hellomyfriend\") \"lippsqcjvmirh\" 0.001)\n    (check-within (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" 0.001)\n    (check-within (candidate \"a\") \"e\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef encrypt(s: str) -> str:\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n\n### Explanation\n\nThe code is an implementation of the Caesar Cipher. The Caesar Cipher is a simple encryption technique that shifts each letter in the plaintext message by a fixed number of positions down the alphabet. \n\nThe function `FUNC_0` takes a string `VAR_0` as input and returns a string. The function signature specifies that the input is a string and the output is a string. \n\nThe first line of the function defines the function signature. The function name is `FUNC_0`. The input parameter is `VAR_0` and is of type `str`. The output of the function is of type `str`. \n\nThe second line of the function defines a string `VAR_1` that contains all the letters of the alphabet. \n\nThe third line of the function defines an empty string `VAR_2`. \n\nThe fourth line of the function starts a for loop that iterates over each character in the input string `VAR_0`. \n\nThe fifth line of the function checks if the current character `VAR_3` is in the alphabet string `VAR_1`. \n\nThe sixth line of the function appends the shifted character to the output string `VAR_2`. The shifted character is calculated by finding the index of the current character in the alphabet string `VAR_1`, adding `(2 * 2)` to it, and then taking the modulus of the result with `26`. The modulus operation ensures that the shifted character is always within the range of the alphabet. \n\nThe seventh line of the function appends the current character to the output string `VAR_2` if it is not in the alphabet string `VAR_1`. \n\nThe eighth line of the function returns the output string `VAR_2`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (encrypt s)\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_simple_power x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n    (check-within (candidate 16 2) #t 0.001)\n    (check-within (candidate 143214 16) #f 0.001)\n    (check-within (candidate 4 2) #t 0.001)\n    (check-within (candidate 9 3) #t 0.001)\n    (check-within (candidate 16 4) #t 0.001)\n    (check-within (candidate 24 2) #f 0.001)\n    (check-within (candidate 128 4) #f 0.001)\n    (check-within (candidate 12 6) #f 0.001)\n    (check-within (candidate 1 1) #t 0.001)\n    (check-within (candidate 1 12) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_simple_power(x: int, n: int) -> bool:\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x)\n\n### Explanation\n\nThe code is an implementation of a function that checks if a number is a power of another number. The function takes two integer arguments, `VAR_0` and `VAR_1`, and returns a boolean value. \n\nThe function first checks if `VAR_1` is equal to 1. If it is, then the function returns whether `VAR_0` is also equal to 1. This is because any number raised to the power of 1 is itself, so if `VAR_1` is 1, then `VAR_0` must also be 1 for it to be a power of 1.\n\nIf `VAR_1` is not equal to 1, then the function initializes a variable `VAR_2` to 1. It then enters a while loop that continues as long as `VAR_2` is less than `VAR_0`. In each iteration of the loop, `VAR_2` is multiplied by `VAR_1`. This means that `VAR_2` is raised to the power of `VAR_1` in each iteration. The loop continues until `VAR_2` is greater than or equal to `VAR_0`.\n\nFinally, the function returns whether `VAR_2` is equal to `VAR_0`. If it is, then `VAR_0` is a power of `VAR_1`. If it is not, then `VAR_0` is not a power of `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_simple_power x n)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fib4 n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib4))\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 28 0.001)\n    (check-within (candidate 10) 104 0.001)\n    (check-within (candidate 12) 386 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fib4(n: int) -> int:\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The function takes an integer as input and returns the integer at that position in the Fibonacci sequence. \n\n1. `def FUNC_0(VAR_0: int) -> int:` - This line defines a function named `FUNC_0` that takes an integer `VAR_0` as input and returns an integer. \n2. `VAR_1 = [0, 0, 2, 0]` - This line initializes a list `VAR_1` with four elements: 0, 0, 2, and 0. \n3. `if (VAR_0 < 4):` - This line checks if the input integer is less than 4. If it is, the function returns the element at that position in `VAR_1`. \n4. `return VAR_1[VAR_0]` - This line returns the element at the input integer position in `VAR_1`. \n5. `for VAR_2 in range(4, (VAR_0 + 1)):` - This line starts a loop that iterates from 4 to the input integer plus 1. \n6. `VAR_1.append((((VAR_1[(- 1)] + VAR_1[(- 2)]) + VAR_1[(- 3)]) + VAR_1[(- 4)]))` - This line appends the sum of the last four elements in `VAR_1` to the list. \n7. `VAR_1.pop(0)` - This line removes the first element in `VAR_1`. \n8. `return VAR_1[(- 1)]` - This line returns the last element in `VAR_1`, which is the integer at the input position in the Fibonacci sequence.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fib4 n)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (check_if_last_char_is_a_letter txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n    (check-within (candidate \"apple\") #f 0.001)\n    (check-within (candidate \"apple pi e\") #t 0.001)\n    (check-within (candidate \"eeeee\") #f 0.001)\n    (check-within (candidate \"A\") #t 0.001)\n    (check-within (candidate \"Pumpkin pie \") #f 0.001)\n    (check-within (candidate \"Pumpkin pie 1\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"eeeee e \") #f 0.001)\n    (check-within (candidate \"apple pie\") #f 0.001)\n    (check-within (candidate \"apple pi e \") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in a string `VAR_0` and returns a boolean value. \n\nThe function first splits the input string `VAR_0` into a list of words using the `split()` method. It then gets the last word in the list by indexing it with `[-1]` and assigns it to a variable called `VAR_1`.\n\nThe function then returns `True` if two conditions are met: \n1. The length of `VAR_1` is 1.\n2. The ASCII value of the lowercase version of the character in `VAR_1` is between 97 and 122 (inclusive). \n\nIf either of these conditions is not met, the function returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (check_if_last_char_is_a_letter txt)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (string_sequence n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n    (check-within (candidate 0) \"0\" 0.001)\n    (check-within (candidate 3) \"0 1 2 3\" 0.001)\n    (check-within (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])\n\n### Explanation\n\nThe code is an implementation of a function named FUNC_0 that takes an integer as an argument and returns a string. \n\nThe function takes an integer argument VAR_0 and creates a list of integers from 0 to VAR_0 (inclusive) using a for loop. The list is created using a list comprehension that iterates over a range object created by the range function. The range function creates a sequence of numbers from 0 to VAR_0 (inclusive) that is used to iterate over in the list comprehension. \n\nThe list comprehension creates a new list by iterating over the sequence of numbers created by the range function and converting each number to a string using the str function. The resulting list of strings is then joined together into a single string using the join method of the string class. The join method takes the list of strings as an argument and returns a single string where each element of the list is separated by a space character.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (string_sequence n)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (truncate_number number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n    (check-within (candidate 3.5) 0.5 0.001)\n    (check-within (candidate 1.25) 0.25 0.001)\n    (check-within (candidate 123.0) 0.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef truncate_number(number: float) -> float:\n    return number % 1.0\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a single argument `VAR_0` of type float and returns a float value. The function returns the remainder of `VAR_0` divided by 1.0. This is achieved using the modulo operator `%` which returns the remainder of a division operation.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (truncate_number number)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (unique l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique))\n    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    return sorted(list(set(l)))\n\n### Explanation\n\nThe code is an implementation of a Python function that takes in a list of integers and returns a sorted list of unique integers. \n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is a generic class that is used to represent a list of elements of a specific type. \n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nThis line defines a function named FUNC_0 that takes in a single argument VAR_0, which is a list of integers. The function returns a list of integers, which is also specified in the function signature using the `->` notation.\n\n```python\nreturn sorted(list(set(VAR_0)))\n```\nThis line sorts the input list of integers, removes any duplicates, and returns the resulting list. \n\nThe `set()` function is used to remove duplicates from the input list, and the `list()` function is used to convert the resulting set back into a list. The `sorted()` function is then used to sort the list in ascending order.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (unique l)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (filter_by_prefix strings prefix)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [x for x in strings if x.startswith(prefix)]\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments: a list of strings and a string. The function returns a list of strings that start with the string argument. \n\nThe first line imports the List class from the typing module.\n\nThe second line defines a function called FUNC_0 that takes two arguments: VAR_0 and VAR_1. VAR_0 is a list of strings and VAR_1 is a string. The function returns a list of strings.\n\nThe third line uses a list comprehension to create a new list. The list comprehension iterates over each string in VAR_0 and checks if the string starts with VAR_1. If the string does start with VAR_1, it is added to the new list.\n\nThe fourth line returns the new list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (filter_by_prefix strings prefix)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_palindrome text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n    (check-within (candidate \"\") #t 0.001)\n    (check-within (candidate \"aba\") #t 0.001)\n    (check-within (candidate \"aaaaa\") #t 0.001)\n    (check-within (candidate \"zbcd\") #f 0.001)\n    (check-within (candidate \"xywyx\") #t 0.001)\n    (check-within (candidate \"xywyz\") #f 0.001)\n    (check-within (candidate \"xywzx\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_palindrome(text: str) -> bool:\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a string is a palindrome. Here is a line by line explanation:\n\n```python\ndef FUNC_0(VAR_0: str) -> bool:\n```\nThis line defines a function called `FUNC_0` that takes a string as an argument and returns a boolean value. The function is used to check if the input string is a palindrome.\n\n```python\n    for VAR_1 in range(len(VAR_0)):\n```\nThis line starts a for loop that iterates over the length of the input string. The variable `VAR_1` is used to keep track of the current index in the loop.\n\n```python\n        if (VAR_0[VAR_1] != VAR_0[((len(VAR_0) - 1) - VAR_1)]):\n```\nThis line checks if the character at the current index `VAR_1` is not equal to the character at the corresponding index from the end of the string. If the characters are not equal, the function returns `False` because the string is not a palindrome.\n\n```python\n            return False\n```\nThis line returns `False` if the characters at the current index and the corresponding index from the end of the string are not equal.\n\n```python\n    return True\n```\nThis line returns `True` if the function has not returned `False` during the loop. If the loop completes without returning `False`, the string is a palindrome and the function returns `True`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_palindrome text)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (choose_num x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n    (check-within (candidate 12 15) 14 0.001)\n    (check-within (candidate 13 12) -1 0.001)\n    (check-within (candidate 33 12354) 12354 0.001)\n    (check-within (candidate 5234 5233) -1 0.001)\n    (check-within (candidate 6 29) 28 0.001)\n    (check-within (candidate 27 10) -1 0.001)\n    (check-within (candidate 7 7) -1 0.001)\n    (check-within (candidate 546 546) 546 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns an integer. The function is named FUNC_0 and takes two arguments, VAR_0 and VAR_1. The function returns an integer.\n\nThe function first checks if VAR_0 is greater than VAR_1. If it is, the function returns -1. This is done using an if statement.\n\nThe next if statement checks if VAR_1 is even. If it is, the function returns VAR_1. This is done using the modulo operator (%).\n\nThe third if statement checks if VAR_0 is equal to VAR_1. If it is, the function returns -1.\n\nIf none of the above conditions are met, the function returns VAR_1 - 1. This is done using a return statement.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (choose_num x y)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (add_elements arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)\n    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)\n    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)\n    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)\n    (check-within (candidate (list 1) 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, a list of integers and an integer. The function returns the sum of all integers in the list that have a length of 2 or less, up to the index specified by the second argument.\n\n```python\nfrom typing import List\n```\nThe `typing` module is used to define the type of the function arguments and return value.\n\n```python\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> int:\n```\nThe function is defined with the name `FUNC_0`. It takes two arguments, `VAR_0` which is a list of integers and `VAR_1` which is an integer. The function returns an integer.\n\n```python\nreturn sum((VAR_2 for VAR_2 in VAR_0[:VAR_1] if (len(str(VAR_2)) <= 2)))\n```\nThe function returns the sum of all integers in the list that have a length of 2 or less, up to the index specified by the second argument. The `sum` function is used to add up all the integers that meet the condition. The condition is defined using a generator expression that iterates over the list slice `VAR_0[:VAR_1]` and filters out integers that have a length greater than 2. The length of an integer is calculated by converting it to a string using the `str` function and then getting the length of the resulting string using the `len` function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (add_elements arr k)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (remove_duplicates numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_duplicates))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a list of integers that appear only once in the input list.\n\n```python\nfrom typing import List\n```\nThis line imports the List type from the typing module. The List type is used to specify that a variable is a list of a certain type.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nThis line defines a function called FUNC_0 that takes a list of integers as input and returns a list of integers. The input list is specified as a List of integers using the List type.\n\n```python\nimport collections\n```\nThis line imports the collections module. The collections module provides alternatives to built-in types that are more efficient than the alternatives in some cases.\n\n```python\nVAR_1 = collections.Counter(VAR_0)\n```\nThis line creates a Counter object from the input list VAR_0 using the Counter function from the collections module. The Counter object is stored in the variable VAR_1.\n\n```python\nreturn [VAR_2 for VAR_2 in VAR_0 if (VAR_1[VAR_2] <= 1)]\n```\nThis line returns a list comprehension that iterates over the input list VAR_0 and returns a new list containing only the elements that appear once in the input list. The condition for inclusion in the new list is that the count of the element in the Counter object VAR_1 is less than or equal to 1. The elements that meet this condition are stored in the variable VAR_2. The new list is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (remove_duplicates numbers)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (parse_music music_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_music))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"o o o o\") (list 4 4 4 4) 0.001)\n    (check-within (candidate \".| .| .| .|\") (list 1 1 1 1) 0.001)\n    (check-within (candidate \"o| o| .| .| o o o o\") (list 2 2 1 1 4 4 4 4) 0.001)\n    (check-within (candidate \"o| .| o| .| o o| o o|\") (list 2 1 2 1 4 2 4 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a list of integers. The function is defined using the `def` keyword, followed by the function name `FUNC_0`, and the input parameter `VAR_0` of type `str`. The output of the function is a list of integers, which is specified using the `->` notation followed by the type `List[int]`.\n\nThe function begins by defining a dictionary `VAR_1` that maps certain strings to integer values. The keys of the dictionary are strings, and the values are integers. Specifically, the string `'o'` maps to the integer `4`, the string `'o|'` maps to the integer `2`, and the string `'.|'` maps to the integer `1`.\n\nThe function then returns a list comprehension that iterates over the words in the input string `VAR_0`. The `split` method is called on `VAR_0` with the argument `' '`, which splits the string into a list of words using spaces as the delimiter. The `if VAR_2` condition filters out any empty strings that may be present in the list.\n\nFor each word in the list, the corresponding integer value is obtained from the dictionary `VAR_1` using the square bracket notation. The resulting list of integers is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (parse_music music_string)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (rescale_to_unit numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)\n    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)\n    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of floats and returns a list of floats. The function is called `FUNC_0` and takes one argument, `VAR_0`, which is a list of floats. The function returns a list of floats.\n\nThe first line of the code imports the `List` class from the `typing` module. This is used to specify the type of the input and output of the function.\n\nThe second line of the code defines the function `FUNC_0`. The function takes one argument, `VAR_0`, which is a list of floats. The function returns a list of floats.\n\nThe third line of the code finds the minimum value in the input list `VAR_0` and assigns it to the variable `VAR_1`.\n\nThe fourth line of the code finds the maximum value in the input list `VAR_0` and assigns it to the variable `VAR_2`.\n\nThe fifth line of the code creates a list comprehension that iterates over each value in the input list `VAR_0`. For each value, it calculates the normalized value using the formula `(VAR_3 - VAR_1) / (VAR_2 - VAR_1)` and adds it to the output list.\n\nThe sixth line of the code returns the output list.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (rescale_to_unit numbers)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_product numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n    (check-within (candidate (list )) (list 0 1) 0.001)\n    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)\n    (check-within (candidate (list 100 0)) (list 100 0) 0.001)\n    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)\n    (check-within (candidate (list 10)) (list 10 10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n\n### Explanation\n\nThe code is an implementation of a function `FUNC_0` that takes a list of integers and returns a tuple of two integers. The function calculates the sum and product of all the integers in the list and returns them as a tuple.\n\n```python\nfrom typing import List, Tuple\n```\nThis line imports the `List` and `Tuple` types from the `typing` module. These types are used to specify the types of the function arguments and return value.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> Tuple[(int, int)]:\n```\nThis line defines the function `FUNC_0` that takes a list of integers as an argument and returns a tuple of two integers. The argument is specified as `VAR_0` with type `List[int]` and the return type is specified as `Tuple[(int, int)]`.\n\n```python\nVAR_1 = 0\nVAR_2 = 1\n```\nThese lines initialize two variables `VAR_1` and `VAR_2` to 0 and 1 respectively.\n\n```python\nfor VAR_3 in VAR_0:\n    VAR_1 += VAR_3\n    VAR_2 *= VAR_3\n```\nThis loop iterates over each integer in the input list `VAR_0`. For each integer, it adds it to the variable `VAR_1` and multiplies it by the variable `VAR_2`.\n\n```python\nreturn (VAR_1, VAR_2)\n```\nThis line returns a tuple of two integers, `(VAR_1, VAR_2)`, which contains the sum and product of all the integers in the input list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_product numbers)\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (words_string s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_string))\n    (check-within (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\" \"is\" \"John\") 0.001)\n    (check-within (candidate \"One, two, three, four, five, six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\") 0.001)\n    (check-within (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a list of strings. The function is defined with the name `FUNC_0` and takes a single argument `VAR_0` of type `str`. The function returns a list of strings.\n\n```python\nfrom typing import List\n```\n\nThis line imports the `List` class from the `typing` module. This is used to specify the return type of the function.\n\n```python\ndef FUNC_0(VAR_0: str) -> List[str]:\n```\n\nThis line defines the function `FUNC_0` which takes a single argument `VAR_0` of type `str`. The `-> List[str]` specifies that the function returns a list of strings.\n\n```python\n    if (not VAR_0):\n        return []\n```\n\nThis line checks if the input string is empty. If it is, the function returns an empty list.\n\n```python\n    VAR_1 = []\n```\n\nThis line initializes an empty list `VAR_1`.\n\n```python\n    for VAR_2 in VAR_0:\n```\n\nThis line starts a loop that iterates over each character in the input string.\n\n```python\n        if (VAR_2 == ','):\n            VAR_1.append(' ')\n        else:\n            VAR_1.append(VAR_2)\n```\n\nThis block of code checks if the current character is a comma. If it is, a space is appended to the `VAR_1` list. Otherwise, the current character is appended to the `VAR_1` list.\n\n```python\n    VAR_1 = ''.join(VAR_1)\n```\n\nThis line joins all the characters in the `VAR_1` list into a single string.\n\n```python\n    return VAR_1.split()\n```\n\nThis line splits the string into a list of strings using whitespace as the delimiter. The resulting list is then returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (words_string s)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_prime n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 101) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 13441) #t 0.001)\n    (check-within (candidate 61) #t 0.001)\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 1) #f 0.001)\n    (check-within (candidate 5) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 17) #t 0.001)\n    (check-within (candidate 85) #f 0.001)\n    (check-within (candidate 77) #f 0.001)\n    (check-within (candidate 255379) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_prime(n:int) -> bool:\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n### Explanation\n\nThe code is an implementation of the Sieve of Eratosthenes algorithm to check if a number is prime or not. \n\nThe function is defined as FUNC_0, which takes an integer VAR_0 as input and returns a boolean value. \n\nThe first line of the function checks if the input number is less than 2, which means it is not a prime number. If it is less than 2, the function returns False.\n\nThe next line is a for loop that iterates over a range of numbers from 2 to VAR_0 - 1. This range represents all the possible divisors of VAR_0, except for 1 and VAR_0 itself. \n\nInside the loop, the code checks if VAR_0 is divisible by VAR_1 using the modulo operator (%). If VAR_0 is divisible by VAR_1, it means VAR_0 is not a prime number and the function returns False.\n\nIf the loop completes without finding any divisors of VAR_0, it means VAR_0 is a prime number and the function returns True.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_prime n)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (right_angle_triangle a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n    (check-within (candidate 3 4 5) #t 0.001)\n    (check-within (candidate 1 2 3) #f 0.001)\n    (check-within (candidate 10 6 8) #t 0.001)\n    (check-within (candidate 2 2 2) #f 0.001)\n    (check-within (candidate 7 24 25) #t 0.001)\n    (check-within (candidate 10 5 7) #f 0.001)\n    (check-within (candidate 5 12 13) #t 0.001)\n    (check-within (candidate 15 8 17) #t 0.001)\n    (check-within (candidate 48 55 73) #t 0.001)\n    (check-within (candidate 1 1 1) #f 0.001)\n    (check-within (candidate 2 2 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef right_angle_triangle(a: int, b: int, c: int) -> bool:\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n\n### Explanation\n\nThe code is an implementation of the Pythagorean theorem. It defines a function called `FUNC_0` that takes three integer arguments `VAR_0`, `VAR_1`, and `VAR_2`. The function returns a boolean value that is `True` if the three integers satisfy the Pythagorean theorem, and `False` otherwise.\n\nThe Pythagorean theorem states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of the squares of the lengths of the other two sides. The function checks if any of the three possible combinations of sides satisfy this condition.\n\nThe first condition checks if the square of `VAR_0` is equal to the sum of the squares of `VAR_1` and `VAR_2`. The second condition checks if the square of `VAR_1` is equal to the sum of the squares of `VAR_0` and `VAR_2`. The third condition checks if the square of `VAR_2` is equal to the sum of the squares of `VAR_0` and `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (right_angle_triangle a b c)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (add lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate (list 4 88)) 88 0.001)\n    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)\n    (check-within (candidate (list 4 0 6 7)) 0 0.001)\n    (check-within (candidate (list 4 4 6 8)) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef add(lst: List[int]) -> int:\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the sum of all even-indexed elements that are even numbers.\n\n1. `from typing import List`: Importing the List class from the typing module.\n\n2. `def FUNC_0(VAR_0: List[int]) -> int:`: Defining a function named FUNC_0 that takes a list of integers as input and returns an integer.\n\n3. `return sum([VAR_0[VAR_1] for VAR_1 in range(1, len(VAR_0), 2) if ((VAR_0[VAR_1] % 2) == 0)])`: Returning the sum of a list comprehension that iterates over the list of integers and selects only the even-indexed elements that are even numbers.\n\n    1. `for VAR_1 in range(1, len(VAR_0), 2)`: Iterating over the list of integers starting from the second element and selecting only every other element.\n    \n    2. `if ((VAR_0[VAR_1] % 2) == 0)`: Selecting only the elements that are even numbers.\n    \n    3. `[VAR_0[VAR_1] for VAR_1 in range(1, len(VAR_0), 2) if ((VAR_0[VAR_1] % 2) == 0)]`: Creating a list of the selected elements.\n    \n    4. `sum([VAR_0[VAR_1] for VAR_1 in range(1, len(VAR_0), 2) if ((VAR_0[VAR_1] % 2) == 0)])`: Summing the list of selected elements and returning the result.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (add lst)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fix_spaces text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fix_spaces))\n    (check-within (candidate \"Example\") \"Example\" 0.001)\n    (check-within (candidate \"Mudasir Hanif \") \"Mudasir_Hanif_\" 0.001)\n    (check-within (candidate \"Yellow Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\" 0.001)\n    (check-within (candidate \"Exa   mple\") \"Exa-mple\" 0.001)\n    (check-within (candidate \"   Exa 1 2 2 mple\") \"-Exa_1_2_2_mple\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fix_spaces(text: str) -> str:\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a modified version of the string. The function is defined with the name FUNC_0 and takes a single argument, VAR_0, which is a string. The function returns a string.\n\nThe first line of the function initializes a variable VAR_1 to an empty string.\n\nThe second line initializes a variable VAR_2 to 0.\n\nThe third line initializes two variables VAR_3 and VAR_4 to 0.\n\nThe fourth line starts a while loop that will iterate over the characters in the input string VAR_0. The loop will continue as long as VAR_2 is less than the length of VAR_0.\n\nThe fifth line checks if the current character in VAR_0 is a space. If it is, VAR_4 is incremented by 1. If it is not, the code checks if the difference between VAR_4 and VAR_3 is greater than 2. If it is, a hyphen is added to VAR_1, followed by the current character in VAR_0. If the difference between VAR_4 and VAR_3 is greater than 0 but less than or equal to 2, the code adds a number of underscores equal to the difference between VAR_4 and VAR_3, followed by the current character in VAR_0. If the difference between VAR_4 and VAR_3 is 0, the code simply adds the current character in VAR_0 to VAR_1. After each of these operations, VAR_3 and VAR_4 are set to VAR_2 + 1.\n\nThe last two lines of the while loop increment VAR_2 by 1.\n\nAfter the while loop completes, the code checks if the difference between VAR_4 and VAR_3 is greater than 2. If it is, a hyphen is added to VAR_1. If the difference between VAR_4 and VAR_3 is greater than 0 but less than or equal to 2, the code adds a number of underscores equal to the difference between VAR_4 and VAR_3, followed by a hyphen. If the difference between VAR_4 and VAR_3 is 0, the code simply adds a hyphen to VAR_1.\n\nFinally, the modified string in VAR_1 is returned.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fix_spaces text)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (unique_digits x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_digits))\n    (check-within (candidate (list 15 33 1422 1)) (list 1 15 33) 0.001)\n    (check-within (candidate (list 152 323 1422 10)) (list ) 0.001)\n    (check-within (candidate (list 12345 2033 111 151)) (list 111 151) 0.001)\n    (check-within (candidate (list 135 103 31)) (list 31 135) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a sorted list of integers that have only odd digits. \n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is used to define the type of the input and output of the function.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nThis line defines the function named FUNC_0 that takes a list of integers as input and returns a list of integers as output. The input list is named VAR_0 and the output list is named VAR_1.\n\n```python\nVAR_1 = []\n```\nThis line initializes an empty list named VAR_1.\n\n```python\nfor VAR_2 in VAR_0:\n```\nThis line starts a loop that iterates over each integer in the input list VAR_0. The current integer is assigned to the variable VAR_2.\n\n```python\nif all((((int(VAR_3) % 2) == 1) for VAR_3 in str(VAR_2))):\n```\nThis line checks if all digits in the current integer VAR_2 are odd. The str() function is used to convert the integer to a string, and then each character in the string is converted back to an integer using the int() function. The % operator is used to check if the integer is odd. The all() function is used to check if all digits in the integer are odd.\n\n```python\nVAR_1.append(VAR_2)\n```\nThis line appends the current integer VAR_2 to the list VAR_1 if all digits in the integer are odd.\n\n```python\nreturn sorted(VAR_1)\n```\nThis line returns the sorted list VAR_1 of integers that have only odd digits. The sorted() function is used to sort the list in ascending order.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (unique_digits x)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (valid_date date)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_date))\n    (check-within (candidate \"03-11-2000\") #t 0.001)\n    (check-within (candidate \"15-01-2012\") #f 0.001)\n    (check-within (candidate \"04-0-2040\") #f 0.001)\n    (check-within (candidate \"06-04-2020\") #t 0.001)\n    (check-within (candidate \"01-01-2007\") #t 0.001)\n    (check-within (candidate \"03-32-2011\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"04-31-3000\") #f 0.001)\n    (check-within (candidate \"06-06-2005\") #t 0.001)\n    (check-within (candidate \"21-31-2000\") #f 0.001)\n    (check-within (candidate \"04-12-2003\") #t 0.001)\n    (check-within (candidate \"04122003\") #f 0.001)\n    (check-within (candidate \"20030412\") #f 0.001)\n    (check-within (candidate \"2003-04\") #f 0.001)\n    (check-within (candidate \"2003-04-12\") #f 0.001)\n    (check-within (candidate \"04-2003\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef valid_date(date: str) -> bool:\n    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a boolean value. The function checks if the input string is a valid date in the format \"MM-DD-YYYY\". \n\nThe function definition starts with `def FUNC_0(VAR_0: str) -> bool:`. This defines a function named `FUNC_0` that takes a string argument named `VAR_0` and returns a boolean value. \n\nThe first line of the function body `VAR_0 = VAR_0.strip()` removes any leading or trailing whitespace from the input string. \n\nThe next line `(VAR_1, VAR_2, VAR_3) = VAR_0.split('-')` splits the input string into three parts using the '-' character as a separator. The three parts are assigned to the variables `VAR_1`, `VAR_2`, and `VAR_3`. \n\nThe next line `(VAR_1, VAR_2, VAR_3) = (int(VAR_1), int(VAR_2), int(VAR_3))` converts the three parts of the input string to integers and assigns them back to the same variables. \n\nThe next few lines check if the input date is valid. The first condition `if ((VAR_1 < 1) or (VAR_1 > 12)):` checks if the month is between 1 and 12. If it is not, the function returns False. \n\nThe next condition `if (((VAR_1 in [1, 3, 5, 7, 8, 10, 12]) and (VAR_2 < 1)) or (VAR_2 > 31)):` checks if the day is between 1 and 31 for months with 31 days. If the month is not one of these months or the day is not between 1 and 31, the function returns False. \n\nThe next condition `if (((VAR_1 in [4, 6, 9, 11]) and (VAR_2 < 1)) or (VAR_2 > 30)):` checks if the day is between 1 and 30 for months with 30 days. If the month is not one of these months or the day is not between 1 and 30, the function returns False. \n\nThe final condition `if (((VAR_1 == 2) and (VAR_2 < 1)) or (VAR_2 > 29)):` checks if the day is between 1 and 29 for February. If the month is not February or the day is not between 1 and 29, the function returns False. \n\nIf any of the conditions fail, the function returns False. If all conditions pass, the function returns True. \n\nThe last line `return True` is only reached if none of the conditions fail.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (valid_date date)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (filter_integers values)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9) 0.001)\n    (check-within (candidate (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of any type and returns a list of integers. \n\nThe function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a list of any type. The function returns a list of integers.\n\nThe function uses a list comprehension to iterate over the elements of VAR_0. For each element VAR_1 in VAR_0, the function checks if the element is an instance of the int class using the isinstance() function. If the element is an instance of the int class, it is added to the list that is returned by the function. \n\nThe function is defined using the typing module to specify the types of the arguments and return value. The List and Any classes are imported from the typing module to specify that the function takes a list of any type and returns a list of integers.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (filter_integers values)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (anti_shuffle s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate anti_shuffle))\n    (check-within (candidate \"Hi\") \"Hi\" 0.001)\n    (check-within (candidate \"hello\") \"ehllo\" 0.001)\n    (check-within (candidate \"number\") \"bemnru\" 0.001)\n    (check-within (candidate \"abcd\") \"abcd\" 0.001)\n    (check-within (candidate \"Hello World!!!\") \"Hello !!!Wdlor\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst .Rboot How aer ?ouy\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef anti_shuffle(s: str) -> str:\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes a string as input and returns a string as output. The input string is split into words, and each word is sorted and then joined back together. The words are then joined together with a space in between them.\n\nThe function takes one argument, VAR_0, which is a string. The function returns a string.\n\nThe first line of the function is a return statement. It returns the result of the expression ' '.join([''.join(sorted(list(VAR_1))) for VAR_1 in VAR_0.split(' ')]). This expression is a list comprehension that iterates over each word in VAR_0, splits it into characters, sorts the characters, joins them back together into a string, and then appends the resulting string to a list. Finally, the list is joined together with spaces in between each element to form the output string.\n\nThe expression can be broken down into the following steps:\n\n1. VAR_0.split(' ') - This splits the input string into a list of words, using spaces as the delimiter.\n2. [sorted(list(VAR_1)) for VAR_1 in VAR_0.split(' ')] - This is a list comprehension that iterates over each word in the list of words created in step 1. For each word, it converts the word into a list of characters, sorts the list of characters, and then returns the sorted list.\n3. [''.join(sorted(list(VAR_1))) for VAR_1 in VAR_0.split(' ')] - This is another list comprehension that iterates over each word in the list of words created in step 1. For each word, it converts the word into a list of characters, sorts the list of characters, joins the sorted list of characters back into a string, and then returns the resulting string.\n4. ' '.join([''.join(sorted(list(VAR_1))) for VAR_1 in VAR_0.split(' ')]) - This joins the list of sorted words created in step 3 into a single string, with spaces in between each word.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (anti_shuffle s)\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate separate_paren_groups))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list \"(()())\" \"((()))\" \"()\" \"((())()())\") 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list \"()\" \"(())\" \"((()))\" \"(((())))\") 0.001)\n    (check-within (candidate \"(()(())((())))\") (list \"(()(())((())))\") 0.001)\n    (check-within (candidate \"( ) (( )) (( )( ))\") (list \"()\" \"(())\" \"(()())\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns a list of strings. The function is defined with the `def` keyword and takes a single argument `VAR_0` of type `str`. The function returns a list of strings, which is indicated by the `-> List[str]` annotation.\n\nThe function starts by initializing three variables: `VAR_1`, `VAR_2`, and `VAR_3`. `VAR_1` is an empty list that will be used to store the substrings that are extracted from the input string. `VAR_2` is also an empty list that will be used to store the characters of each substring as they are being extracted. `VAR_3` is an integer that will be used to keep track of the number of open parentheses encountered so far.\n\nThe function then enters a `for` loop that iterates over each character in the input string. For each character, the function checks if it is an open parenthesis (`(`) or a close parenthesis (`)`). If the character is an open parenthesis, the function increments `VAR_3` and appends the character to `VAR_2`. If the character is a close parenthesis, the function decrements `VAR_3`, appends the character to `VAR_2`, and checks if `VAR_3` is equal to 0. If `VAR_3` is equal to 0, it means that a complete substring has been extracted, so the function joins the characters in `VAR_2` into a single string and appends it to `VAR_1`. Finally, the function clears `VAR_2` so that it can be used to store the characters of the next substring.\n\nAfter the `for` loop has finished iterating over all the characters in the input string, the function returns `VAR_1`, which is a list of all the substrings that were extracted from the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (any_int x y z)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate any_int))\n    (check-within (candidate 2 3 1) #t 0.001)\n    (check-within (candidate 2.5 2 3) #f 0.001)\n    (check-within (candidate 1.5 5 3.5) #f 0.001)\n    (check-within (candidate 2 6 2) #f 0.001)\n    (check-within (candidate 4 2 2) #t 0.001)\n    (check-within (candidate 2.2 2.2 2.2) #f 0.001)\n    (check-within (candidate -4 6 2) #t 0.001)\n    (check-within (candidate 2 1 1) #t 0.001)\n    (check-within (candidate 3 4 7) #t 0.001)\n    (check-within (candidate 3.0 4 7) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef any_int(x: float, y: float, z: float) -> bool:\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that takes in three arguments of type float and returns a boolean value. The function is named FUNC_0.\n\nThe function first checks if all three arguments are of type int. If any of the arguments is not of type int, the function returns False. \n\nIf all three arguments are of type int, the function checks if any two of the arguments add up to the third argument. If any two of the arguments add up to the third argument, the function returns True. Otherwise, the function returns False. \n\nNote that the function checks all possible combinations of two arguments adding up to the third argument. \n\nHere is a Java implementation of the same function:\n\n```java\npublic static boolean func0(int var0, int var1, int var2) {\n    if ((var0 instanceof Integer) && (var1 instanceof Integer) && (var2 instanceof Integer)) {\n        if (((var0 + var1) == var2) || ((var0 + var2) == var1) || ((var1 + var2) == var0)) {\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\n```\n\nNote that in Java, we use the `instanceof` operator to check if an object is of a certain type. We also use the `int` type instead of the `float` type, since the function only accepts integer values. Finally, we use the `public static` modifiers to make the function accessible from other classes. \n\nOverall, the Python code checks if any two of the arguments add up to the third argument, while the Java code checks if all three arguments are integers and if any two of the arguments add up to the third argument. Both implementations return a boolean value.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (any_int x y z)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (starts_one_ends n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 2) 18 0.001)\n    (check-within (candidate 3) 180 0.001)\n    (check-within (candidate 4) 1800 0.001)\n    (check-within (candidate 5) 18000 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef starts_one_ends(n: int) -> int:\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer input `VAR_0` and returns an integer output. \n\nThe function is named `FUNC_0` and takes a single argument `VAR_0` of type `int`. \n\nThe function returns an integer value of type `int`.\n\nThe function first checks if the input `VAR_0` is equal to 1. If it is, the function returns 1.\n\nIf the input `VAR_0` is not equal to 1, the function returns the value of `18 * (10 ** (VAR_0 - 2))`.\n\nThe expression `10 ** (VAR_0 - 2)` calculates 10 raised to the power of `VAR_0 - 2`. \n\nThe expression `18 * (10 ** (VAR_0 - 2))` multiplies the result of the previous expression by 18.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (starts_one_ends n)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n    (check-within (candidate 10) 55 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 8) 21 0.001)\n    (check-within (candidate 11) 89 0.001)\n    (check-within (candidate 12) 144 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. In this implementation, the function takes an integer `VAR_0` as input and returns an integer as output.\n\nThe function is defined with the name `FUNC_0` and takes one argument, `VAR_0`, which is an integer. The function returns an integer.\n\nThe first `if` statement checks if `VAR_0` is equal to 0. If it is, the function returns 0.\n\nThe second `if` statement checks if `VAR_0` is equal to 1. If it is, the function returns 1.\n\nIf neither of the above conditions are met, the function returns the sum of the two previous numbers in the sequence. This is done by recursively calling the `FUNC_0` function with the arguments `(VAR_0 - 1)` and `(VAR_0 - 2)`, and adding the results together.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fib n)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (can_arrange arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate can_arrange))\n    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)\n    (check-within (candidate (list 1 2 4 5)) -1 0.001)\n    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)\n    (check-within (candidate (list )) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef can_arrange(arr: List[int]) -> int:\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n\n### Explanation\n\nThe code is an implementation of the [Bubble Sort algorithm](https://en.wikipedia.org/wiki/Bubble_sort) in Python. Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.\n\nThe program takes a list of integers as input and returns the index of the last element in the list that is out of order. If the list is already sorted, it returns -1.\n\nHere is a line-by-line explanation of the code:\n\n```python\nfrom typing import List\n```\n\nThis line imports the List type from the typing module. The List type is a generic type that represents a list of elements of a specific type.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> int:\n```\n\nThis line defines a function named FUNC_0 that takes a list of integers as input and returns an integer. The function signature specifies the types of the input and output parameters.\n\n```python\nVAR_1 = (- 1)\nVAR_2 = 1\n```\n\nThese lines initialize two variables, VAR_1 and VAR_2, to -1 and 1, respectively.\n\n```python\nwhile (VAR_2 < len(VAR_0)):\n```\n\nThis line starts a while loop that will iterate over the list until VAR_2 is greater than or equal to the length of the list.\n\n```python\nif (VAR_0[VAR_2] < VAR_0[(VAR_2 - 1)]):\n    VAR_1 = VAR_2\n```\n\nThis if statement checks if the current element in the list is less than the previous element. If it is, VAR_1 is set to the index of the current element.\n\n```python\nVAR_2 += 1\n```\n\nThis line increments VAR_2 by 1, so that the loop will move on to the next element in the list.\n\n```python\nreturn VAR_1\n```\n\nThis line returns the value of VAR_1, which is the index of the last element in the list that is out of order. If the list is already sorted, VAR_1 will still be -1, which indicates that the list is sorted.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (can_arrange arr)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (skjkasdkd lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)\n    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)\n    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)\n    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)\n    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)\n    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)\n    (check-within (candidate (list 8191)) 19 0.001)\n    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)\n    (check-within (candidate (list 127 97 8192)) 10 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of integers as input and returns a single integer as output. The function finds the largest prime number in the input list and returns the sum of its digits.\n\nThe function begins by defining another function called `FUNC_1` that takes an integer as input and returns a boolean value indicating whether the integer is prime or not. This function uses a for loop to iterate over all integers from 2 to the square root of the input integer plus 1. For each integer in this range, the function checks if the input integer is divisible by it. If it is, the function immediately returns False, indicating that the input integer is not prime. If the loop completes without finding a factor of the input integer, the function returns True, indicating that the input integer is prime.\n\nThe main function `FUNC_0` initializes two variables `VAR_3` and `VAR_4` to 0. It then enters a while loop that iterates over all integers in the input list. For each integer, the function checks if it is greater than `VAR_3` (which is initially 0) and if it is prime by calling the `FUNC_1` function. If both conditions are true, `VAR_3` is set to the current integer. This loop effectively finds the largest prime number in the input list.\n\nAfter the loop completes, the function calculates the sum of the digits of `VAR_3` by converting it to a string, iterating over each character in the string, converting it back to an integer, and summing the resulting integers. This sum is then returned as the output of the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (skjkasdkd lst)\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (reverse_delete s c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate reverse_delete))\n    (check-within (candidate \"abcde\" \"ae\") (list \"bcd\" #f) 0.001)\n    (check-within (candidate \"abcdef\" \"b\") (list \"acdef\" #f) 0.001)\n    (check-within (candidate \"abcdedcba\" \"ab\") (list \"cdedc\" #t) 0.001)\n    (check-within (candidate \"dwik\" \"w\") (list \"dik\" #f) 0.001)\n    (check-within (candidate \"a\" \"a\") (list \"\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"abcdedcba\" \"v\") (list \"abcdedcba\" #t) 0.001)\n    (check-within (candidate \"vabba\" \"v\") (list \"abba\" #t) 0.001)\n    (check-within (candidate \"mamma\" \"mia\") (list \"\" #t) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple\n\ndef reverse_delete(s: str,c: str) -> Tuple[str, bool]:\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n\n### Explanation\n\nThe code is an implementation of a function that takes two string arguments and returns a tuple containing a string and a boolean value. The function is defined with the name `FUNC_0` and takes two arguments `VAR_0` and `VAR_1`. The function returns a tuple containing a string and a boolean value.\n\nThe first line of the function imports the `Tuple` type from the `typing` module. This is used to specify the type of the return value of the function.\n\nThe second line of the function defines the function signature. The function takes two string arguments, `VAR_0` and `VAR_1`, and returns a tuple containing a string and a boolean value.\n\nThe third line of the function creates a new string by joining all the characters in `VAR_0` that are not in `VAR_1`. This is done using a list comprehension that iterates over each character in `VAR_0` and checks if it is not in `VAR_1`. If the character is not in `VAR_1`, it is added to the list. The `join` method is then used to join all the characters in the list into a single string.\n\nThe fourth line of the function checks if the new string is a palindrome. This is done by checking if the string reversed is equal to the original string. If the string is a palindrome, the boolean value `True` is returned. Otherwise, the boolean value `False` is returned.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (reverse_delete s c)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (pairs_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 30)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 31)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 30)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 31)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns a boolean value. The function checks whether there are two integers in the list whose sum is equal to zero. If there are, the function returns True, otherwise it returns False.\n\nThe function is defined using the `def` keyword, followed by the function name `FUNC_0`, and the input parameter `VAR_0`, which is a list of integers. The function returns a boolean value, which is indicated by the `-> bool` syntax.\n\nThe function uses a nested loop to iterate over all possible pairs of integers in the input list. The outer loop uses the `enumerate` function to iterate over the list, and the inner loop uses the `range` function to iterate over the remaining elements in the list.\n\nThe loop variables are defined as follows:\n\n- `VAR_1` is the index of the current element in the list\n- `VAR_2` is the value of the current element in the list\n- `VAR_3` is the index of the element being compared to the current element\n\nThe loop checks whether the sum of the current element and the element being compared to it is equal to zero. If it is, the function returns True, indicating that a pair of integers with a sum of zero has been found.\n\nIf the loop completes without finding a pair of integers with a sum of zero, the function returns False, indicating that no such pair exists.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (pairs_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fruit_distribution s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fruit_distribution))\n    (check-within (candidate \"5 apples and 6 oranges\" 19) 8 0.001)\n    (check-within (candidate \"5 apples and 6 oranges\" 21) 10 0.001)\n    (check-within (candidate \"0 apples and 1 oranges\" 3) 2 0.001)\n    (check-within (candidate \"1 apples and 0 oranges\" 3) 2 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 100) 95 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 5) 0 0.001)\n    (check-within (candidate \"1 apples and 100 oranges\" 120) 19 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fruit_distribution(s: str, n: int) -> int:\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n\n### Explanation\n\nThe code is an implementation of a function that takes two arguments, a string and an integer. The function returns an integer. \n\nThe function is defined with the name `FUNC_0` and takes two arguments `VAR_0` and `VAR_1`. `VAR_0` is of type string and `VAR_1` is of type integer. The function returns an integer.\n\n```python\ndef FUNC_0(VAR_0: str, VAR_1: int) -> int:\n```\n\nThe next line creates an empty list `VAR_2`.\n\n```python\n    VAR_2 = list()\n```\n\nThe next line is a for loop that iterates over each word in the string `VAR_0`. The string is split into words using the `split()` method. \n\n```python\n    for VAR_3 in VAR_0.split(' '):\n```\n\nThe `if` statement checks if the current word is a digit. If it is, it is converted to an integer and appended to the list `VAR_2`.\n\n```python\n        if VAR_3.isdigit():\n            VAR_2.append(int(VAR_3))\n```\n\nThe function returns the difference between `VAR_1` and the sum of the integers in `VAR_2`.\n\n```python\n    return (VAR_1 - sum(VAR_2))\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fruit_distribution s n)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (f n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate 5) (list 1 2 6 24 15) 0.001)\n    (check-within (candidate 7) (list 1 2 6 24 15 720 28) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n    (check-within (candidate 3) (list 1 2 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer `VAR_0` as input and returns a list of integers. The function generates the list by iterating over the range of integers from 1 to `VAR_0`, inclusive. \n\nFor each integer `VAR_2` in the range, the function checks if it is even or odd. If `VAR_2` is even, the function calculates the factorial of `VAR_2` and appends it to the list. If `VAR_2` is odd, the function calculates the sum of the integers from 1 to `VAR_2` and appends it to the list.\n\nThe function then returns the list of integers.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (f n)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (next_smallest lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)\n    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list -35 34 12 -45)) -35 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input and returns the second smallest integer in the list. \n\nThe function is defined with the name `FUNC_0` and takes a single argument `VAR_0` which is a list of integers. The return type of the function is an optional integer. \n\nThe first line of the function sorts the input list in ascending order and removes duplicates. The `set` function is used to remove duplicates, and the `sorted` function is used to sort the list. The sorted list is then assigned back to the input variable `VAR_0`.\n\nThe second line of the function checks if the length of the sorted list is less than 2. If it is, the function returns `None`. Otherwise, the function returns the second element of the sorted list, which is the second smallest integer in the original list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (next_smallest lst)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (multiply a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate multiply))\n    (check-within (candidate 148 412) 16 0.001)\n    (check-within (candidate 19 28) 72 0.001)\n    (check-within (candidate 2020 1851) 0 0.001)\n    (check-within (candidate 14 -15) 20 0.001)\n    (check-within (candidate 76 67) 42 0.001)\n    (check-within (candidate 17 27) 49 0.001)\n    (check-within (candidate 0 1) 0 0.001)\n    (check-within (candidate 0 0) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef multiply(a: int, b: int) -> int:\n    return abs(a % 10) * abs(b % 10)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two integer arguments, `VAR_0` and `VAR_1`, and returns an integer. The function returns the product of the absolute values of the last digits of the two input integers. \n\nThe `abs()` function is used to ensure that the result is always positive. The `%` operator is used to get the remainder of the input integers when divided by 10, which gives the last digit of the integer. \n\nThe function is defined using the `def` keyword, followed by the function name and the input arguments in parentheses. The `->` symbol is used to indicate the return type of the function. \n\nTo rewrite this program in Java, we could use the following code:\n\n```java\npublic static int FUNC_0(int VAR_0, int VAR_1) {\n    return (Math.abs((VAR_0 % 10)) * Math.abs((VAR_1 % 10)));\n}\n```\n\nIn Java, we define the function using the `public static` keywords, followed by the return type, function name, and input arguments in parentheses. We use the `Math.abs()` function to get the absolute value of the input integers, and the `%` operator to get the remainder of the input integers when divided by 10. The function returns the product of the absolute values of the last digits of the two input integers. \n\nNote that the Java code does not include the `-> int` return type declaration, as Java does not require this. \n\nOverall, the Python program is a simple implementation of a function that calculates the product of the last digits of two input integers, and can be easily translated to Java.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (multiply a b)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (modp n p)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n    (check-within (candidate 3 5) 3 0.001)\n    (check-within (candidate 1101 101) 2 0.001)\n    (check-within (candidate 0 101) 1 0.001)\n    (check-within (candidate 3 11) 8 0.001)\n    (check-within (candidate 100 101) 1 0.001)\n    (check-within (candidate 30 5) 4 0.001)\n    (check-within (candidate 31 5) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef modp(n: int, p: int) -> int:\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n\n### Explanation\n\nThe code is an implementation of the modular exponentiation algorithm. It takes two integer inputs, VAR_0 and VAR_1, and returns an integer output. \n\n1. `def FUNC_0(VAR_0: int, VAR_1: int) -> int:` - This line defines a function named FUNC_0 that takes two integer inputs, VAR_0 and VAR_1, and returns an integer output.\n\n2. `VAR_2 = 1` - This line initializes a variable named VAR_2 to 1.\n\n3. `for VAR_3 in range(VAR_0):` - This line starts a for loop that iterates VAR_0 times. The loop variable is named VAR_3.\n\n4. `VAR_2 = ((2 * VAR_2) % VAR_1)` - This line updates VAR_2 by multiplying it by 2 and taking the remainder when divided by VAR_1.\n\n5. `return VAR_2` - This line returns the final value of VAR_2 after the for loop has completed.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (modp n p)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (concatenate strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate concatenate))\n    (check-within (candidate (list )) \"\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"xyz\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\" \"w\" \"k\")) \"xyzwk\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings as input and returns a single string that is the concatenation of all the strings in the list. \n\nThe function is defined using the `def` keyword, which is used to define functions in Python. The function is named `FUNC_0` and takes a single argument, `VAR_0`, which is a list of strings. The `-> str` syntax indicates that the function returns a string.\n\nThe `join` method is called on an empty string (`''`) and passed the list of strings as an argument. This method concatenates all the strings in the list, using the empty string as a separator. The resulting string is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (concatenate strings)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (triples_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -1)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 1 2 5 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 9 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -100)) #f 0.001)\n    (check-within (candidate (list 100 3 5 -100)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a boolean value. The function is called `FUNC_0` and takes a single argument `VAR_0` which is a list of integers. The function returns `True` if there are three integers in the list whose sum is equal to zero, and `False` otherwise.\n\nThe function starts by iterating over the indices of the list `VAR_0` using a `for` loop. The loop variable is `VAR_1`, and it takes on the values `0`, `1`, `2`, ..., `len(VAR_0) - 1`. The `range` function is used to generate these values.\n\nInside the first `for` loop, there is another `for` loop that iterates over the indices of the list `VAR_0` starting from `VAR_1 + 1`. The loop variable is `VAR_2`, and it takes on the values `VAR_1 + 1`, `VAR_1 + 2`, ..., `len(VAR_0) - 1`.\n\nInside the second `for` loop, there is yet another `for` loop that iterates over the indices of the list `VAR_0` starting from `VAR_2 + 1`. The loop variable is `VAR_3`, and it takes on the values `VAR_2 + 1`, `VAR_2 + 2`, ..., `len(VAR_0) - 1`.\n\nInside the third `for` loop, there is an `if` statement that checks whether the sum of the three integers at indices `VAR_1`, `VAR_2`, and `VAR_3` is equal to zero. If it is, the function returns `True`.\n\nIf the `if` statement is not true for any combination of `VAR_1`, `VAR_2`, and `VAR_3`, the function returns `False`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (triples_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (triangle_area a h)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 5 3) 7.5 0.001)\n    (check-within (candidate 2 2) 2.0 0.001)\n    (check-within (candidate 10 8) 40.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef triangle_area(a: int, h: int) -> float:\n    return a * h / 2.0\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns a float. \n\nThe function is defined with the name FUNC_0 and takes two arguments VAR_0 and VAR_1, both of which are integers. \n\nThe function returns the result of the expression (VAR_0 * VAR_1) / 2.0, which is a float. \n\nThe expression multiplies the two integer arguments together and then divides the result by 2.0. \n\nThe result of this division is a float, which is then returned by the function. \n\nThe function does not modify any variables outside of its scope, and does not have any side effects. \n\nIt is a pure function that can be easily tested and reused in other parts of the program.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (triangle_area a h)\n"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (largest_smallest_integers lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_136_largest_smallest_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n    (check-within (candidate (list 2 4 1 3 5 7)) (list #f 1) 0.001)\n    (check-within (candidate (list 2 4 1 3 5 7 0)) (list #f 1) 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 -2)) (list -2 1) 0.001)\n    (check-within (candidate (list 4 5 3 6 2 7 -7)) (list -7 2) 0.001)\n    (check-within (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2) 0.001)\n    (check-within (candidate (list )) (list #f #f) 0.001)\n    (check-within (candidate (list 0)) (list #f #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6)) (list -1 #f) 0.001)\n    (check-within (candidate (list -1 -3 -5 -6 0)) (list -1 #f) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 1)) (list -3 1) 0.001)\n    (check-within (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\ndef largest_smallest_integers(lst: List[int]) -> Tuple[Optional[int], Optional[int]]:\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a tuple of the maximum negative integer and the minimum positive integer in the list. If there are no negative or positive integers in the list, the function returns None for that value.\n\n```python\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\n```\n\nThese lines import the List, Tuple, and Optional types from the typing module. These types are used to specify the types of the function's arguments and return value.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> Tuple[(Optional[int], Optional[int])]:\n```\n\nThis line defines a function named FUNC_0 that takes in a list of integers (VAR_0) and returns a tuple of two optional integers. The function is defined using the def keyword, followed by the function name, and the argument list in parentheses. The -> operator is used to specify the return type of the function.\n\n```python\nVAR_1 = list(filter((lambda VAR_2: (VAR_2 < 0)), VAR_0))\n```\n\nThis line creates a new list (VAR_1) that contains only the negative integers from the input list (VAR_0). This is done using the filter function, which takes in a lambda function that returns True for elements that should be included in the filtered list.\n\n```python\nVAR_3 = list(filter((lambda VAR_2: (VAR_2 > 0)), VAR_0))\n```\n\nThis line creates a new list (VAR_3) that contains only the positive integers from the input list (VAR_0). This is done using the same filter function as before, but with a lambda function that returns True for positive integers.\n\n```python\nreturn ((max(VAR_1) if VAR_1 else None), (min(VAR_3) if VAR_3 else None))\n```\n\nThis line returns a tuple of the maximum negative integer and the minimum positive integer in the input list. If there are no negative or positive integers in the list, the function returns None for that value. This is done using the max and min functions, which return the maximum and minimum values in a list, respectively. The if VAR_1 and if VAR_3 statements are used to handle the case where there are no negative or positive integers in the list, respectively. If the filtered list is empty, the function returns None for that value. The two values are returned as a tuple using parentheses.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_smallest_integers lst)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (cycpattern_check a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n    (check-within (candidate \"xyzw\" \"xyw\") #f 0.001)\n    (check-within (candidate \"yello\" \"ell\") #t 0.001)\n    (check-within (candidate \"whattup\" \"ptut\") #f 0.001)\n    (check-within (candidate \"efef\" \"fee\") #t 0.001)\n    (check-within (candidate \"abab\" \"aabb\") #f 0.001)\n    (check-within (candidate \"winemtt\" \"tinem\") #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef cycpattern_check(a: str , b: str) -> bool:\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n\n### Explanation\n\nThe code is an implementation of the Rabin-Karp algorithm for string pattern matching. The algorithm is used to find a substring within a larger string. \n\nThe function takes two string inputs, VAR_0 and VAR_1, and returns a boolean value. VAR_0 is the string to search within, and VAR_1 is the substring to search for.\n\nThe first line of the function defines the function name and input types. The function name is FUNC_0, and it takes two string inputs, VAR_0 and VAR_1. The \"-> bool\" specifies that the function returns a boolean value.\n\nThe second line of the function calculates the length of VAR_1 and assigns it to VAR_2.\n\nThe third line of the function concatenates VAR_1 with itself and assigns it to VAR_3. This is done to simplify the pattern matching process.\n\nThe fourth line of the function starts a nested for loop. The outer loop iterates over the range of values from 0 to the length of VAR_0 minus VAR_2 plus 1. This is done to ensure that the inner loop does not go out of bounds when checking for matches.\n\nThe inner loop iterates over the range of values from 0 to VAR_2 plus 1. This is done to check for matches of all possible lengths of VAR_1 within VAR_0.\n\nThe fifth line of the function checks if the substring of VAR_0 from VAR_4 to VAR_4 plus VAR_2 is equal to the substring of VAR_3 from VAR_5 to VAR_5 plus VAR_2. If a match is found, the function returns True.\n\nIf no match is found, the function returns False.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (cycpattern_check a b)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (hex_key num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n    (check-within (candidate \"AB\") 1 0.001)\n    (check-within (candidate \"1077E\") 2 0.001)\n    (check-within (candidate \"ABED1A33\") 4 0.001)\n    (check-within (candidate \"2020\") 2 0.001)\n    (check-within (candidate \"123456789ABCDEF0\") 6 0.001)\n    (check-within (candidate \"112233445566778899AABBCCDDEEFF00\") 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef hex_key(num: str) -> int:\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns an integer. The function counts the number of characters in the input string that are either '2', '3', '5', '7', 'B', or 'D'. \n\nHere is a line-by-line explanation of the code:\n\n```python\ndef FUNC_0(VAR_0: str) -> int:\n```\n\nThis line defines a function called `FUNC_0` that takes a string as input and returns an integer. The input string is represented by the variable `VAR_0`.\n\n```python\nVAR_1 = ('2', '3', '5', '7', 'B', 'D')\n```\n\nThis line defines a tuple called `VAR_1` that contains the characters that the function is looking for in the input string.\n\n```python\nVAR_2 = 0\n```\n\nThis line initializes a variable called `VAR_2` to 0. This variable will be used to count the number of characters in the input string that are in the `VAR_1` tuple.\n\n```python\nfor VAR_3 in range(0, len(VAR_0)):\n```\n\nThis line starts a loop that will iterate over each character in the input string. The loop variable is called `VAR_3`, and it takes on the values 0, 1, 2, ..., len(VAR_0)-1.\n\n```python\nif (VAR_0[VAR_3] in VAR_1):\n```\n\nThis line checks if the current character in the input string is in the `VAR_1` tuple. If it is, the following line is executed:\n\n```python\nVAR_2 += 1\n```\n\nThis line increments the `VAR_2` variable by 1.\n\n```python\nreturn VAR_2\n```\n\nThis line returns the final count of characters in the input string that are in the `VAR_1` tuple.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (hex_key num)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (numerical_letter_grade grades)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numerical_letter_grade))\n    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list \"A+\" \"B\" \"C-\" \"C\" \"A-\") 0.001)\n    (check-within (candidate (list 1.2)) (list \"D+\") 0.001)\n    (check-within (candidate (list 0.5)) (list \"D-\") 0.001)\n    (check-within (candidate (list 0.0)) (list \"E\") 0.001)\n    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list \"D\" \"D-\" \"C-\" \"B\" \"B+\") 0.001)\n    (check-within (candidate (list 0.0 0.7)) (list \"E\" \"D-\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n\n### Explanation\n\nThe code is an implementation of a grading system. The function takes in a list of floats and returns a list of strings. The strings are the grades corresponding to the floats in the input list. \n\nThe function definition starts with the `def` keyword, which is used to define a function. The function is named `FUNC_0` and takes in one argument, `VAR_0`, which is a list of floats. The `->` symbol is used to indicate the return type of the function, which is a list of strings.\n\n```python\nfrom typing import List\n```\n\nThis line imports the `List` class from the `typing` module. The `List` class is used to indicate that the argument and return types are lists.\n\n```python\nVAR_1 = []\n```\n\nThis line initializes an empty list `VAR_1` which will be used to store the grades.\n\n```python\nfor VAR_2 in VAR_0:\n```\n\nThis line starts a `for` loop that iterates over each float in the input list `VAR_0`. The current float is assigned to the variable `VAR_2`.\n\n```python\nif (VAR_2 == 4.0):\n    VAR_1.append('A+')\n```\n\nThis line checks if the current float is equal to `4.0`. If it is, the string `'A+'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 3.7):\n    VAR_1.append('A')\n```\n\nThis line checks if the current float is greater than `3.7`. If it is, the string `'A'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 3.3):\n    VAR_1.append('A-')\n```\n\nThis line checks if the current float is greater than `3.3`. If it is, the string `'A-'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 3.0):\n    VAR_1.append('B+')\n```\n\nThis line checks if the current float is greater than `3.0`. If it is, the string `'B+'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 2.7):\n    VAR_1.append('B')\n```\n\nThis line checks if the current float is greater than `2.7`. If it is, the string `'B'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 2.3):\n    VAR_1.append('B-')\n```\n\nThis line checks if the current float is greater than `2.3`. If it is, the string `'B-'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 2.0):\n    VAR_1.append('C+')\n```\n\nThis line checks if the current float is greater than `2.0`. If it is, the string `'C+'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 1.7):\n    VAR_1.append('C')\n```\n\nThis line checks if the current float is greater than `1.7`. If it is, the string `'C'` is appended to the `VAR_1` list.\n\n```python\nelif (VAR_2 > 1.3):\n    VAR_1.append('C-')\n```\n\nThis line checks if the current float is greater than `1.3\n\n### Racket version\n\n#lang racket\n\n;; \n(define (numerical_letter_grade grades)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (minSubArraySum nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSubArraySum))\n    (check-within (candidate (list 2 3 4 1 2 4)) 1 0.001)\n    (check-within (candidate (list -1 -2 -3)) -6 0.001)\n    (check-within (candidate (list -1 -2 -3 2 -10)) -14 0.001)\n    (check-within (candidate (list -9999999999999999)) -9999999999999999 0.001)\n    (check-within (candidate (list 0 10 20 1000000)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 100 -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 10 11 13 8 3 4)) 3 0.001)\n    (check-within (candidate (list 100 -33 32 -1 0 -2)) -33 0.001)\n    (check-within (candidate (list -10)) -10 0.001)\n    (check-within (candidate (list 7)) 7 0.001)\n    (check-within (candidate (list 1 -1)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n\n### Explanation\n\nThe code is an implementation of the Kadane's algorithm. The algorithm is used to find the maximum subarray sum of a given array. \n\nThe function takes a list of integers as input and returns an integer. \n\nThe function definition is as follows:\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> int:\n```\n\nThe function takes a list of integers as input and returns an integer. The input list is named `VAR_0` and the output integer is named `VAR_5`.\n\n```python\nVAR_1 = 0\nVAR_2 = 0\n```\n\nTwo variables `VAR_1` and `VAR_2` are initialized to 0.\n\n```python\nfor VAR_3 in VAR_0:\n```\n\nA for loop is used to iterate over each element in the input list.\n\n```python\nVAR_2 += (- VAR_3)\n```\n\nThe current element is negated and added to `VAR_2`.\n\n```python\nif (VAR_2 < 0):\n    VAR_2 = 0\n```\n\nIf `VAR_2` is less than 0, it is set to 0.\n\n```python\nVAR_1 = max(VAR_2, VAR_1)\n```\n\nThe maximum of `VAR_2` and `VAR_1` is assigned to `VAR_1`.\n\n```python\nif (VAR_1 == 0):\n    VAR_1 = max(((- VAR_4) for VAR_4 in VAR_0))\n```\n\nIf `VAR_1` is 0, it is set to the maximum negative element in the input list.\n\n```python\nVAR_5 = (- VAR_1)\n```\n\n`VAR_1` is negated and assigned to `VAR_5`.\n\n```python\nreturn VAR_5\n```\n\n`VAR_5` is returned as the output of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (minSubArraySum nums)\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (solve N)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate 1000) \"1\" 0.001)\n    (check-within (candidate 150) \"110\" 0.001)\n    (check-within (candidate 147) \"1100\" 0.001)\n    (check-within (candidate 333) \"1001\" 0.001)\n    (check-within (candidate 963) \"10010\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef solve(N: int) -> str:\n    return bin(sum(int(i) for i in str(N)))[2:]\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns a string. The string is the binary representation of the sum of the digits of the input integer.\n\nThe function is defined with the name `FUNC_0` and takes one argument `VAR_0` which is an integer. The function returns a string.\n\nThe function returns the binary representation of the sum of the digits of the input integer. The sum of the digits is calculated by converting the integer to a string and iterating over each character in the string. Each character is then converted to an integer and added to the sum. The sum is then converted to a binary string and returned.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solve N)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (by_length arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate by_length))\n    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\") 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -1 55)) (list \"One\") 0.001)\n    (check-within (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\") 0.001)\n    (check-within (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef by_length(arr: List[int]) -> List[str]:\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a list of strings. The strings are the English names of the integers in the input list, sorted in descending order.\n\n```python\nfrom typing import List\n```\nThis line imports the `List` class from the `typing` module. The `List` class is used to indicate that a variable is a list of a certain type.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[str]:\n```\nThis line defines a function called `FUNC_0` that takes a single argument `VAR_0`, which is a list of integers. The function returns a list of strings.\n\n```python\nVAR_1 = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n```\nThis line defines a dictionary called `VAR_1` that maps integers to their English names.\n\n```python\nVAR_2 = sorted(VAR_0, reverse=True)\n```\nThis line creates a new list called `VAR_2` that is a sorted copy of the input list `VAR_0`. The `reverse=True` argument sorts the list in descending order.\n\n```python\nVAR_3 = []\n```\nThis line creates an empty list called `VAR_3`.\n\n```python\nfor VAR_4 in VAR_2:\n    try:\n        VAR_3.append(VAR_1[VAR_4])\n    except:\n        pass\n```\nThis block of code iterates over each integer in the sorted list `VAR_2`. For each integer, it attempts to look up its English name in the `VAR_1` dictionary. If the integer is not in the dictionary, the `except` block is executed and the loop moves on to the next integer. If the integer is in the dictionary, its English name is appended to the `VAR_3` list.\n\n```python\nreturn VAR_3\n```\nThis line returns the `VAR_3` list, which contains the English names of the integers in the input list, sorted in descending order.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (by_length arr)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (prod_signs arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-within (candidate (list 1 2 2 -4)) -9 0.001)\n    (check-within (candidate (list 0 1)) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 3 -1 1)) -10 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 2 4 1 2 -1 -1 9)) 20 0.001)\n    (check-within (candidate (list -1 1 -1 1)) 4 0.001)\n    (check-within (candidate (list -1 1 1 1)) -4 0.001)\n    (check-within (candidate (list -1 1 1 0)) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef prod_signs(arr: List[int]) -> Optional[int]:\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n\n### Explanation\n\nThe code is an implementation of a function `FUNC_0` that takes a list of integers `VAR_0` as input and returns an integer or None. The function returns None if the input list is empty. Otherwise, it calculates a value based on the input list and returns it.\n\nThe first line imports the `List` and `Optional` types from the `typing` module. These types are used to specify the types of the input and output of the function.\n\n```python\nfrom typing import List\nfrom typing import Optional\n```\n\nThe second line defines the function `FUNC_0` that takes a list of integers `VAR_0` as input and returns an integer or None.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> Optional[int]:\n```\n\nThe third line checks if the input list is empty. If it is, the function returns None.\n\n```python\n    if (not VAR_0):\n        return None\n```\n\nThe fourth line calculates a value based on the input list. It first checks if the number 0 is in the input list. If it is, the value of `VAR_1` is set to 0. Otherwise, it calculates the number of negative integers in the input list and raises -1 to that power. The result is assigned to `VAR_1`.\n\n```python\n    VAR_1 = (0 if (0 in VAR_0) else ((- 1) ** len(list(filter((lambda VAR_2: (VAR_2 < 0)), VAR_0)))))\n```\n\nThe fifth line calculates the final value to be returned by the function. It multiplies `VAR_1` by the sum of the absolute values of the integers in the input list.\n\n```python\n    return (VAR_1 * sum([abs(VAR_3) for VAR_3 in VAR_0]))\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prod_signs arr)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (x_or_y n x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate x_or_y))\n    (check-within (candidate 7 34 12) 34 0.001)\n    (check-within (candidate 15 8 5) 5 0.001)\n    (check-within (candidate 3 33 5212) 33 0.001)\n    (check-within (candidate 1259 3 52) 3 0.001)\n    (check-within (candidate 7919 -1 12) -1 0.001)\n    (check-within (candidate 3609 1245 583) 583 0.001)\n    (check-within (candidate 91 56 129) 129 0.001)\n    (check-within (candidate 6 34 1234) 1234 0.001)\n    (check-within (candidate 1 2 0) 0 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef x_or_y(n: int, x: int, y: int) -> int:\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n\n### Explanation\n\nThe code is an implementation of a function that takes three integer arguments and returns an integer. Here is a line-by-line explanation of the code:\n\n```python\ndef FUNC_0(VAR_0: int, VAR_1: int, VAR_2: int) -> int:\n```\n\nThis line defines a function named `FUNC_0` that takes three integer arguments `VAR_0`, `VAR_1`, and `VAR_2`, and returns an integer. The `-> int` part specifies the return type of the function.\n\n```python\n    if (VAR_0 == 1):\n        return VAR_2\n```\n\nThis line checks if `VAR_0` is equal to 1. If it is, the function returns `VAR_2`.\n\n```python\n    for VAR_3 in range(2, VAR_0):\n        if ((VAR_0 % VAR_3) == 0):\n            return VAR_2\n            break\n```\n\nThis line starts a `for` loop that iterates over the range of integers from 2 to `VAR_0` (exclusive). For each integer `VAR_3` in this range, the code checks if `VAR_0` is divisible by `VAR_3` (i.e., if the remainder of `VAR_0` divided by `VAR_3` is 0). If it is, the function returns `VAR_2` and exits the loop using the `break` statement.\n\n```python\n    else:\n        return VAR_1\n```\n\nIf the loop completes without finding a divisor of `VAR_0`, the function returns `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (x_or_y n x y)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (select_words s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n    (check-within (candidate \"Mary had a little lamb\" 4) (list \"little\") 0.001)\n    (check-within (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\") 0.001)\n    (check-within (candidate \"simple white space\" 2) (list ) 0.001)\n    (check-within (candidate \"Hello world\" 4) (list \"world\") 0.001)\n    (check-within (candidate \"Uncle sam\" 3) (list \"Uncle\") 0.001)\n    (check-within (candidate \"\" 4) (list ) 0.001)\n    (check-within (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"f\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n### Explanation\n\nThe code is an implementation of a function that takes in two parameters, a string and an integer, and returns a list of strings. The function is defined with the name `FUNC_0` and takes in two parameters, `VAR_0` and `VAR_1`, which are a string and an integer respectively. The function returns a list of strings.\n\n```python\nfrom typing import List\n```\n\nThis line imports the `List` type from the `typing` module. This is used to specify the return type of the function.\n\n```python\ndef FUNC_0(VAR_0: str, VAR_1: int) -> List[str]:\n```\n\nThis line defines the function `FUNC_0` with two parameters, `VAR_0` and `VAR_1`, which are a string and an integer respectively. The `-> List[str]` specifies that the function returns a list of strings.\n\n```python\nVAR_2 = []\n```\n\nThis line initializes an empty list `VAR_2` which will be used to store the strings that meet the criteria.\n\n```python\nfor VAR_3 in VAR_0.split():\n```\n\nThis line starts a loop that iterates over each word in the input string `VAR_0`. The `split()` method is used to split the string into a list of words.\n\n```python\nVAR_4 = 0\nfor VAR_5 in range(0, len(VAR_3)):\n    if (VAR_3[VAR_5].lower() not in ['a', 'e', 'i', 'o', 'u']):\n        VAR_4 += 1\n```\n\nThis block of code counts the number of non-vowel characters in each word. The variable `VAR_4` is initialized to 0 and then incremented for each non-vowel character in the word. The `range()` function is used to iterate over each character in the word, and the `lower()` method is used to convert each character to lowercase before checking if it is a vowel.\n\n```python\nif (VAR_4 == VAR_1):\n    VAR_2.append(VAR_3)\n```\n\nThis block of code checks if the number of non-vowel characters in the word is equal to the input integer `VAR_1`. If it is, the word is added to the list `VAR_2` using the `append()` method.\n\n```python\nreturn VAR_2\n```\n\nThis line returns the list of strings that meet the criteria.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (select_words s n)\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_bored S)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n    (check-within (candidate \"Hello world\") 0 0.001)\n    (check-within (candidate \"Is the sky blue?\") 0 0.001)\n    (check-within (candidate \"I love It !\") 1 0.001)\n    (check-within (candidate \"bIt\") 0 0.001)\n    (check-within (candidate \"I feel good today. I will be productive. will kill It\") 2 0.001)\n    (check-within (candidate \"You and I are going for a walk\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_bored(S: str) -> int:\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns an integer. The function splits the input string into sentences and counts the number of sentences that start with the word \"I\".\n\n1. `def FUNC_0(VAR_0: str) -> int:` - This line defines a function named `FUNC_0` that takes a string as input and returns an integer. The input string is represented by the variable `VAR_0`.\n\n2. `import re` - This line imports the Python regular expression module `re`.\n\n3. `VAR_1 = re.split('[.?!]\\\\s*', VAR_0)` - This line splits the input string `VAR_0` into sentences using a regular expression. The regular expression `[.?!]\\\\s*` matches any period, exclamation point, or question mark followed by zero or more whitespace characters. The resulting list of sentences is stored in the variable `VAR_1`.\n\n4. `return sum(((VAR_2[0:2] == 'I ') for VAR_2 in VAR_1))` - This line counts the number of sentences in `VAR_1` that start with the word \"I\". It does this by using a generator expression to create a sequence of boolean values, where each value is `True` if the first two characters of the sentence are \"I \", and `False` otherwise. The `sum()` function is then used to add up the `True` values, which gives the total number of sentences that start with \"I\". This value is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_bored S)\n"
  },
  {
    "name": "HumanEval_160_do_algebra",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (do_algebra operator operand)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_160_do_algebra.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate do_algebra))\n    (check-within (candidate (list \"**\" \"*\" \"+\") (list 2 3 4 5)) 37 0.001)\n    (check-within (candidate (list \"+\" \"*\" \"-\") (list 2 3 4 5)) 9 0.001)\n    (check-within (candidate (list \"//\" \"*\") (list 7 3 4)) 8 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n\n### Explanation\n\nThe code is an implementation of a function that takes two lists as input and returns an integer. The first list is a list of strings and the second list is a list of integers. The function concatenates the first integer in the second list with the first string in the first list, and then concatenates each subsequent integer in the second list with the corresponding string in the first list. The resulting string is then evaluated as a Python expression and the result is returned as an integer.\n\nHere is a line-by-line explanation of the code:\n\n```python\nfrom typing import List\n```\n\nThis line imports the List type from the typing module. The List type is used to specify that a variable is a list of a particular type.\n\n```python\ndef FUNC_0(VAR_0: List[str], VAR_1: List[int]) -> int:\n```\n\nThis line defines a function called FUNC_0 that takes two arguments: VAR_0, a list of strings, and VAR_1, a list of integers. The function returns an integer.\n\n```python\nVAR_2 = str(VAR_1[0])\n```\n\nThis line initializes a variable called VAR_2 to be the string representation of the first integer in VAR_1.\n\n```python\nfor (VAR_3, VAR_4) in zip(VAR_0, VAR_1[1:]):\n```\n\nThis line starts a loop that iterates over pairs of elements from VAR_0 and VAR_1[1:], which is a slice of VAR_1 that excludes the first element. The zip function is used to pair up the elements from the two lists.\n\n```python\nVAR_2 += (VAR_3 + str(VAR_4))\n```\n\nThis line concatenates VAR_3, a string from VAR_0, with the string representation of VAR_4, an integer from VAR_1. The resulting string is then appended to VAR_2.\n\n```python\nreturn eval(VAR_2)\n```\n\nThis line evaluates the string in VAR_2 as a Python expression and returns the result as an integer. The eval function is used to evaluate the string as an expression. This can be dangerous if the string is not trusted, as it can execute arbitrary code. In this case, since the string is constructed from trusted inputs, it is safe to evaluate.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (do_algebra operator operand)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (solve s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate \"AsDf\") \"aSdF\" 0.001)\n    (check-within (candidate \"1234\") \"4321\" 0.001)\n    (check-within (candidate \"ab\") \"AB\" 0.001)\n    (check-within (candidate \"#a@C\") \"#A@c\" 0.001)\n    (check-within (candidate \"#AsdfW^45\") \"#aSDFw^45\" 0.001)\n    (check-within (candidate \"#6@2\") \"2@6#\" 0.001)\n    (check-within (candidate \"#$a^D\") \"#$A^d\" 0.001)\n    (check-within (candidate \"#ccc\") \"#CCC\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef solve(s: str) -> str:\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as an input and returns a modified version of the string. The function is defined with the name FUNC_0, and it takes a single argument, VAR_0, which is a string. The function returns a string.\n\n```\ndef FUNC_0(VAR_0: str) -> str:\n```\n\nThe first line of the function initializes two variables, VAR_1 and VAR_2, to 0. It then creates a list, VAR_3, from the input string, VAR_0.\n\n```\nVAR_1 = 0\nVAR_2 = 0\nVAR_3 = list(VAR_0)\n```\n\nThe function then enters a for loop that iterates over each character in the input string, VAR_0. For each character, the function checks if it is an alphabetic character using the isalpha() method. If the character is alphabetic, the function swaps its case (i.e., changes uppercase letters to lowercase and vice versa) and replaces the corresponding character in the VAR_3 list with the modified character. The function also sets VAR_1 to 1 to indicate that at least one character was modified.\n\n```\nfor VAR_4 in VAR_0:\n    if VAR_4.isalpha():\n        VAR_3[VAR_2] = VAR_4.swapcase()\n        VAR_1 = 1\n    VAR_2 += 1\n```\n\nAfter modifying the characters in VAR_3, the function creates an empty string, VAR_0, and enters another for loop that iterates over each character in the VAR_3 list. For each character, the function appends it to the VAR_0 string.\n\n```\nVAR_0 = ''\nfor VAR_4 in VAR_3:\n    VAR_0 += VAR_4\n```\n\nIf no characters were modified (i.e., VAR_1 is still 0), the function returns the input string in reverse order. Otherwise, the function returns the modified string.\n\n```\nif (VAR_1 == 0):\n    return VAR_0[len(VAR_0)::(- 1)]\nreturn VAR_0\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solve s)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (flip_case string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hello!\") \"hELLO!\" 0.001)\n    (check-within (candidate \"These violent delights have violent ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef flip_case(string: str) -> str:\n    return string.swapcase()\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes in a string as an argument and returns the string with the case of each letter swapped. \n\n```python\ndef FUNC_0(VAR_0: str) -> str:\n```\nThe function is defined with the name `FUNC_0` and takes in a single argument `VAR_0` of type `str`. The function returns a string.\n\n```python\n    return VAR_0.swapcase()\n```\nThe function returns the string `VAR_0` with the case of each letter swapped. The `swapcase()` method is called on the `VAR_0` string object to achieve this.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (flip_case string)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (rolling_max numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)\n    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of integers as input and returns a list of integers as output. The function is defined using Python's type hinting syntax to specify the types of the input and output.\n\n```python\nfrom typing import List, Tuple\n```\n\nThis line imports the `List` and `Tuple` types from the `typing` module, which are used to specify the types of the input and output of the function.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\n\nThis line defines the function `FUNC_0` that takes a single argument `VAR_0`, which is a list of integers, and returns a list of integers. The `-> List[int]` syntax specifies the return type of the function.\n\n```python\nVAR_1 = None\nVAR_2 = []\n```\n\nThese lines initialize two variables `VAR_1` and `VAR_2`. `VAR_1` is initialized to `None` and `VAR_2` is initialized to an empty list.\n\n```python\nfor VAR_3 in VAR_0:\n```\n\nThis line starts a `for` loop that iterates over each element `VAR_3` in the input list `VAR_0`.\n\n```python\nif (VAR_1 is None):\n    VAR_1 = VAR_3\nelse:\n    VAR_1 = max(VAR_1, VAR_3)\n```\n\nThis block of code checks if `VAR_1` is `None`. If it is, then `VAR_1` is set to the current element `VAR_3`. If `VAR_1` is not `None`, then `VAR_1` is set to the maximum value between `VAR_1` and `VAR_3`. This effectively keeps track of the maximum value seen so far in the input list.\n\n```python\nVAR_2.append(VAR_1)\n```\n\nThis line appends the current value of `VAR_1` to the output list `VAR_2`.\n\n```python\nreturn VAR_2\n```\n\nThis line returns the output list `VAR_2` containing the maximum value seen so far for each element in the input list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (rolling_max numbers)\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (decimal_to_binary decimal)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate decimal_to_binary))\n    (check-within (candidate 0) \"db0db\" 0.001)\n    (check-within (candidate 32) \"db100000db\" 0.001)\n    (check-within (candidate 103) \"db1100111db\" 0.001)\n    (check-within (candidate 15) \"db1111db\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef decimal_to_binary(decimal: int) -> str:\n    return \"db\" + bin(decimal)[2:] + \"db\"\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns a string. The function is defined with the name `FUNC_0` and takes a single argument `VAR_0` of type `int`. The function returns a string that is constructed by concatenating three substrings: the string `'db'`, the binary representation of the input integer `VAR_0`, and the string `'db'`.\n\nThe first substring `'db'` is a string literal that is simply appended to the output string. The second substring is the binary representation of the input integer `VAR_0`. This is computed using the built-in `bin()` function, which returns a string that represents the binary value of the input integer. The `bin()` function returns a string that starts with the prefix `'0b'`, which represents that the string is a binary value. The `[2:]` slice notation is used to remove the first two characters of the binary string, which are `'0b'`. The resulting binary string is then appended to the output string.\n\nThe third substring is the string `'db'`, which is simply appended to the output string. The final output string is returned by the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (decimal_to_binary decimal)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (how_many_times string substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n    (check-within (candidate \"\" \"x\") 0 0.001)\n    (check-within (candidate \"xyxyxyx\" \"x\") 4 0.001)\n    (check-within (candidate \"cacacacac\" \"cac\") 4 0.001)\n    (check-within (candidate \"john doe\" \"john\") 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef how_many_times(string: str, substring: str) -> int:\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of times a substring appears in a string. Here's a line-by-line explanation:\n\n```python\ndef FUNC_0(VAR_0: str, VAR_1: str) -> int:\n```\n\nThis line defines a function named `FUNC_0` that takes two arguments, `VAR_0` and `VAR_1`, both of which are strings. The `-> int` part indicates that the function returns an integer.\n\n```python\nVAR_2 = 0\n```\n\nThis line initializes a variable named `VAR_2` to 0.\n\n```python\nfor VAR_3 in range(((len(VAR_0) - len(VAR_1)) + 1)):\n```\n\nThis line starts a loop that iterates over a range of numbers from 0 to the length of `VAR_0` minus the length of `VAR_1` plus 1. This is because we want to check every possible substring of `VAR_0` that is the same length as `VAR_1`.\n\n```python\nif (VAR_0[VAR_3:(VAR_3 + len(VAR_1))] == VAR_1):\n```\n\nThis line checks if the substring of `VAR_0` starting at index `VAR_3` and ending at index `VAR_3 + len(VAR_1)` is equal to `VAR_1`. If it is, we increment `VAR_2` by 1.\n\n```python\nVAR_2 += 1\n```\n\nThis line increments `VAR_2` by 1 if the previous condition is true.\n\n```python\nreturn VAR_2\n```\n\nThis line returns the final value of `VAR_2`, which is the number of times `VAR_1` appears in `VAR_0`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (how_many_times string substring)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (monotonic l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n    (check-within (candidate (list 1 2 4 10)) #t 0.001)\n    (check-within (candidate (list 1 2 4 20)) #t 0.001)\n    (check-within (candidate (list 1 20 4 10)) #f 0.001)\n    (check-within (candidate (list 4 1 0 -10)) #t 0.001)\n    (check-within (candidate (list 4 1 1 0)) #t 0.001)\n    (check-within (candidate (list 1 2 3 2 5 60)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 60)) #t 0.001)\n    (check-within (candidate (list 9 9 9 9)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef monotonic(l: List[int]) -> bool:\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of integers as input and returns a boolean value. The function returns `True` if the input list is sorted in either ascending or descending order, and `False` otherwise.\n\nThe first line of the code imports the `List` type from the `typing` module. This is used to specify the type of the input parameter of the function.\n\nThe second line defines the function `FUNC_0` that takes a single parameter `VAR_0` of type `List[int]` and returns a boolean value.\n\nThe third line checks if the input list is sorted in either ascending or descending order. This is done by comparing the input list to two sorted versions of the same list, one sorted in ascending order and the other sorted in descending order. The `sorted()` function is used to sort the list in either ascending or descending order, depending on the arguments passed to it.\n\nIf the input list is sorted in either ascending or descending order, the function returns `True`. Otherwise, it returns `False`. The `return` statement is used to return a value from the function. If the input list is sorted in either ascending or descending order, the function returns `True`. Otherwise, it returns `False`. The `return` statement is used to return a value from the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (monotonic l)\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (smallest_change arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallest_change))\n    (check-within (candidate (list 1 2 3 5 4 7 9 6)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 3 2 2)) 1 0.001)\n    (check-within (candidate (list 1 4 2)) 1 0.001)\n    (check-within (candidate (list 1 4 4 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 3 1 1 3)) 0 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef smallest_change(arr: List[int]) -> int:\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the number of times that the first half of the list is not equal to the second half of the list. \n\n1. The first line imports the List class from the typing module. This is used to specify the type of the input parameter of the function. \n2. The second line defines a function named FUNC_0 that takes a list of integers as input and returns an integer. \n3. The third line initializes a variable VAR_1 to 0. This variable will be used to keep track of the number of times the first half of the list is not equal to the second half of the list. \n4. The fourth line starts a for loop that iterates over the range of the length of the input list divided by 2. This ensures that we only compare the first half of the list to the second half of the list. \n5. The fifth line checks if the element at the current index of the first half of the list is not equal to the element at the current index of the second half of the list. If they are not equal, then we increment VAR_1 by 1. \n6. The sixth line returns the value of VAR_1, which represents the number of times the first half of the list is not equal to the second half of the list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (smallest_change arr)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (all_prefixes string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate all_prefixes))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"asdfgh\") (list \"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\") 0.001)\n    (check-within (candidate \"WWW\") (list \"W\" \"WW\" \"WWW\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a list of all possible substrings of the input string. Here is a line-by-line explanation:\n\n```python\nfrom typing import List\n```\n\nThis line imports the List type from the typing module. This is used to specify the return type of the function.\n\n```python\ndef FUNC_0(VAR_0: str) -> List[str]:\n```\n\nThis line defines a function named FUNC_0 that takes a string as input and returns a list of strings. The input string is represented by the variable VAR_0.\n\n```python\nVAR_1 = []\n```\n\nThis line initializes an empty list named VAR_1. This list will be used to store the substrings of the input string.\n\n```python\nfor VAR_2 in range(len(VAR_0)):\n```\n\nThis line starts a loop that will iterate over all possible starting positions of the substrings in the input string. The loop variable VAR_2 will take on the values 0, 1, 2, ..., len(VAR_0) - 1.\n\n```python\nVAR_1.append(VAR_0[:(VAR_2 + 1)])\n```\n\nThis line appends a substring of the input string to the list VAR_1. The substring is obtained by slicing the input string from the beginning up to the current value of VAR_2. The +1 is added to include the current character in the substring.\n\n```python\nreturn VAR_1\n```\n\nThis line returns the list VAR_1 containing all possible substrings of the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (all_prefixes string)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (encode message)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n    (check-within (candidate \"TEST\") \"tgst\" 0.001)\n    (check-within (candidate \"Mudasir\") \"mWDCSKR\" 0.001)\n    (check-within (candidate \"YES\") \"ygs\" 0.001)\n    (check-within (candidate \"This is a message\") \"tHKS KS C MGSSCGG\" 0.001)\n    (check-within (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef encode(message: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a string as output. The function is defined with the name FUNC_0 and takes a single argument VAR_0, which is a string. The function returns a string.\n\nThe first line of the function defines a string variable VAR_1 that contains all the vowels in both uppercase and lowercase.\n\nThe second line of the function creates a dictionary VAR_2 that maps each vowel in VAR_1 to the next character in the ASCII table. This is done using a dictionary comprehension that iterates over each character in VAR_1, and creates a key-value pair in VAR_2 where the key is the current character and the value is the character that comes two positions after it in the ASCII table.\n\nThe third line of the function swaps the case of the input string VAR_0 using the swapcase() method.\n\nThe fourth line of the function creates a new string by iterating over each character in the input string VAR_0. For each character, the code checks if it is a vowel by checking if it is in the VAR_1 string. If it is a vowel, the code looks up the corresponding character in VAR_2 and adds it to the new string. If it is not a vowel, the code simply adds the character to the new string.\n\nFinally, the function returns the new string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (encode message)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sum_to_n n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_to_n))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 6) 21 0.001)\n    (check-within (candidate 11) 66 0.001)\n    (check-within (candidate 30) 465 0.001)\n    (check-within (candidate 100) 5050 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef sum_to_n(n: int) -> int:\n    return sum(range(n + 1))\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns the sum of all integers from 0 to the input integer. \n\nThe function is defined with the name `FUNC_0` and takes an integer input `VAR_0`. The function returns an integer. \n\nThe function returns the sum of the range from 0 to `VAR_0 + 1`. The `range()` function returns a sequence of numbers starting from 0 and ending at `VAR_0 + 1`, but excluding `VAR_0 + 1`. The `sum()` function then adds up all the numbers in the sequence and returns the result.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_to_n n)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (specialFilter nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)\n    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)\n    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)\n    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)\n    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the number of integers in the list that are greater than 10 and have odd first and last digits. \n\nThe function is defined on line 2. It takes a list of integers as input and returns an integer. \n\nOn line 3, a variable `VAR_1` is initialized to 0. This variable will be used to count the number of integers in the list that meet the criteria.\n\nOn line 4, a for loop is used to iterate over each integer in the input list. The loop variable is named `VAR_2`.\n\nOn line 5, an if statement is used to check if the current integer is greater than 10. If it is not, the code inside the if statement is skipped and the loop moves on to the next integer.\n\nOn line 6, a tuple `VAR_3` is defined with the odd digits 1, 3, 5, 7, and 9.\n\nOn line 7, the current integer is converted to a string and assigned to the variable `VAR_4`.\n\nOn line 8, another if statement is used to check if the first and last digits of the string representation of the current integer are odd. To do this, the code checks if the first and last characters of the string are in the `VAR_3` tuple. If they are, the code inside the if statement is executed.\n\nOn line 9, the `VAR_1` variable is incremented by 1.\n\nOn line 11, the function returns the value of `VAR_1`, which is the number of integers in the input list that meet the criteria.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (specialFilter nums)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (prime_fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 3) 5 0.001)\n    (check-within (candidate 4) 13 0.001)\n    (check-within (candidate 5) 89 0.001)\n    (check-within (candidate 6) 233 0.001)\n    (check-within (candidate 7) 1597 0.001)\n    (check-within (candidate 8) 28657 0.001)\n    (check-within (candidate 9) 514229 0.001)\n    (check-within (candidate 10) 433494437 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef prime_fib(n: int) -> int:\n    import math\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence, where the nth number in the sequence is the sum of the two preceding ones, except that the function only returns prime numbers in the sequence. \n\n1. Define a function called `FUNC_0` that takes an integer argument `VAR_0` and returns an integer.\n2. Import the `math` module.\n3. Define a nested function called `FUNC_1` that takes an integer argument `VAR_1` and returns a boolean.\n4. If `VAR_1` is less than 2, return `False`.\n5. Loop through the range of integers from 2 to the minimum of the square root of `VAR_1` plus 1 and `VAR_1` minus 1.\n6. If `VAR_1` is divisible by `VAR_2`, return `False`.\n7. Return `True` if the loop completes without returning `False`.\n8. Create a list called `VAR_3` with the initial values of 0 and 1.\n9. Loop indefinitely.\n10. Append the sum of the last two elements of `VAR_3` to `VAR_3`.\n11. If the last element of `VAR_3` is prime, decrement `VAR_0`.\n12. If `VAR_0` is 0, return the last element of `VAR_3`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prime_fib n)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_happy s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n    (check-within (candidate \"a\") #f 0.001)\n    (check-within (candidate \"aa\") #f 0.001)\n    (check-within (candidate \"abcd\") #t 0.001)\n    (check-within (candidate \"aabb\") #f 0.001)\n    (check-within (candidate \"adb\") #t 0.001)\n    (check-within (candidate \"xyy\") #f 0.001)\n    (check-within (candidate \"iopaxpoi\") #t 0.001)\n    (check-within (candidate \"iopaxioi\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef is_happy(s: str) -> bool:\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a boolean value. The function is defined with the name `FUNC_0` and takes a single argument `VAR_0` of type `str`. The return type of the function is `bool`.\n\n```python\nfrom typing import List\n```\n\nThis line imports the `List` type from the `typing` module. However, the `List` type is not used in the function, so this line can be removed.\n\n```python\ndef FUNC_0(VAR_0: str) -> bool:\n```\n\nThis line defines the function `FUNC_0` with a single argument `VAR_0` of type `str`. The return type of the function is `bool`.\n\n```python\nif (len(VAR_0) < 3):\n    return False\n```\n\nThis line checks if the length of the input string `VAR_0` is less than 3. If it is, the function returns `False`.\n\n```python\nfor VAR_1 in range((len(VAR_0) - 2)):\n```\n\nThis line initializes a loop that iterates over the range of values from 0 to the length of the input string `VAR_0` minus 2. The loop variable is named `VAR_1`.\n\n```python\nif ((VAR_0[VAR_1] == VAR_0[(VAR_1 + 1)]) or (VAR_0[(VAR_1 + 1)] == VAR_0[(VAR_1 + 2)]) or (VAR_0[VAR_1] == VAR_0[(VAR_1 + 2)])):\n    return False\n```\n\nThis line checks if any of the following conditions are true:\n\n- The character at index `VAR_1` in the input string `VAR_0` is equal to the character at index `VAR_1 + 1`.\n- The character at index `VAR_1 + 1` in the input string `VAR_0` is equal to the character at index `VAR_1 + 2`.\n- The character at index `VAR_1` in the input string `VAR_0` is equal to the character at index `VAR_1 + 2`.\n\nIf any of these conditions are true, the function returns `False`.\n\n```python\nreturn True\n```\n\nIf none of the conditions in the loop are true, the function returns `True`. This means that the input string `VAR_0` does not contain any consecutive characters that are the same or any characters that are separated by exactly one character that are the same.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_happy s)\n"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (file_name_check file_name)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_141_file_name_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate file_name_check))\n    (check-within (candidate \"example.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"1example.dll\") \"No\" 0.001)\n    (check-within (candidate \"s1sdf3.asd\") \"No\" 0.001)\n    (check-within (candidate \"K.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"MY16FILE3.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"His12FILE94.exe\") \"No\" 0.001)\n    (check-within (candidate \"_Y.txt\") \"No\" 0.001)\n    (check-within (candidate \"?aREYA.exe\") \"No\" 0.001)\n    (check-within (candidate \"/this_is_valid.dll\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.wow\") \"No\" 0.001)\n    (check-within (candidate \"this_is_valid.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"this_is_valid.txtexe\") \"No\" 0.001)\n    (check-within (candidate \"#this2_i4s_5valid.ten\") \"No\" 0.001)\n    (check-within (candidate \"@this1_is6_valid.exe\") \"No\" 0.001)\n    (check-within (candidate \"this_is_12valid.6exe4.txt\") \"No\" 0.001)\n    (check-within (candidate \"all.exe.txt\") \"No\" 0.001)\n    (check-within (candidate \"I563_No.exe\") \"Yes\" 0.001)\n    (check-within (candidate \"Is3youfault.txt\") \"Yes\" 0.001)\n    (check-within (candidate \"no_one#knows.dll\") \"Yes\" 0.001)\n    (check-within (candidate \"1I563_Yes3.exe\") \"No\" 0.001)\n    (check-within (candidate \"I563_Yes3.txtt\") \"No\" 0.001)\n    (check-within (candidate \"final..txt\") \"No\" 0.001)\n    (check-within (candidate \"final132\") \"No\" 0.001)\n    (check-within (candidate \"_f4indsartal132.\") \"No\" 0.001)\n    (check-within (candidate \".txt\") \"No\" 0.001)\n    (check-within (candidate \"s.\") \"No\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef file_name_check(file_name: str) -> str:\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n\n### Explanation\n\nThe code is an implementation of a function called FUNC_0 that takes in a string called VAR_0 and returns a string. The function checks if the string is a valid file name with the extension of either 'txt', 'exe', or 'dll'. \n\n- `def FUNC_0(VAR_0: str) -> str:` defines the function FUNC_0 that takes in a string called VAR_0 and returns a string.\n- `VAR_1 = ['txt', 'exe', 'dll']` creates a list of valid file extensions.\n- `VAR_2 = VAR_0.split(sep='.')` splits the input string VAR_0 by the '.' separator and stores the result in VAR_2.\n- `if (len(VAR_2) != 2):` checks if the length of VAR_2 is not equal to 2. If it is not, then the function returns 'No'.\n- `if (not (VAR_2[1] in VAR_1)):` checks if the second element of VAR_2 is not in the list VAR_1. If it is not, then the function returns 'No'.\n- `if (len(VAR_2[0]) == 0):` checks if the length of the first element of VAR_2 is 0. If it is, then the function returns 'No'.\n- `if (not VAR_2[0][0].isalpha()):` checks if the first character of the first element of VAR_2 is not an alphabet. If it is not, then the function returns 'No'.\n- `VAR_3 = len([VAR_4 for VAR_4 in VAR_2[0] if VAR_4.isdigit()])` creates a list of digits in the first element of VAR_2 and stores the length of the list in VAR_3.\n- `if (VAR_3 > 3):` checks if the length of the list VAR_3 is greater than 3. If it is, then the function returns 'No'.\n- `return 'Yes'` returns 'Yes' if all the conditions are met.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (file_name_check file_name)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (maximum arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)\n    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)\n    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)\n    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)\n    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)\n    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)\n    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)\n    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)\n    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)\n    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)\n    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and an integer `VAR_1` and returns the `VAR_1` largest elements in the list. \n\n```python\nfrom typing import List\n```\nImporting List from the typing module.\n\n```python\ndef FUNC_0(VAR_0: List[int], VAR_1: int) -> List[int]:\n```\nDefining a function called `FUNC_0` that takes two arguments, a list of integers `VAR_0` and an integer `VAR_1`. The function returns a list of integers.\n\n```python\n    if (VAR_1 == 0):\n        return []\n```\nIf `VAR_1` is equal to 0, return an empty list.\n\n```python\n    VAR_0.sort()\n```\nSort the list `VAR_0` in ascending order.\n\n```python\n    VAR_2 = VAR_0[(- VAR_1):]\n```\nAssign to `VAR_2` the last `VAR_1` elements of the sorted list `VAR_0`.\n\n```python\n    return VAR_2\n```\nReturn `VAR_2`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (maximum arr k)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (pluck arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n    (check-within (candidate (list 4 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5 0 3 0 4 2)) (list 0 1) 0.001)\n    (check-within (candidate (list 1 2 3 0 5 3)) (list 0 3) 0.001)\n    (check-within (candidate (list 5 4 8 4 8)) (list 4 1) 0.001)\n    (check-within (candidate (list 7 6 7 1)) (list 6 1) 0.001)\n    (check-within (candidate (list 7 9 7 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of integers and returns a list containing the minimum even integer in the list and its index in the original list. If the input list is empty or contains no even integers, an empty list is returned.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is used to indicate that a variable is a list of a specific type.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nThis line defines a function named FUNC_0 that takes in a list of integers and returns a list of integers. The input list is represented by the variable VAR_0.\n\n```python\nif (len(VAR_0) == 0):\n    return []\n```\nThis line checks if the input list is empty. If it is, an empty list is returned.\n\n```python\nVAR_1 = list(filter((lambda VAR_2: ((VAR_2 % 2) == 0)), VAR_0))\n```\nThis line creates a new list VAR_1 that contains only the even integers from the input list VAR_0. The filter() function is used to create the new list. The lambda function (lambda VAR_2: ((VAR_2 % 2) == 0)) is used to determine if an element in VAR_0 is even. If the element is even, it is added to VAR_1.\n\n```python\nif (VAR_1 == []):\n    return []\n```\nThis line checks if the new list VAR_1 is empty. If it is, an empty list is returned.\n\n```python\nreturn [min(VAR_1), VAR_0.index(min(VAR_1))]\n```\nThis line returns a list containing the minimum even integer in VAR_1 and its index in the original list VAR_0. The min() function is used to find the minimum even integer in VAR_1. The index() function is used to find the index of the minimum even integer in VAR_0. The list is created using square brackets and the two values are separated by a comma.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (pluck arr)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_distinct_characters string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_distinct_characters))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abcde\") 5 0.001)\n    (check-within (candidate \"abcdecadeCADE\") 5 0.001)\n    (check-within (candidate \"aaaaAAAAaaaa\") 1 0.001)\n    (check-within (candidate \"Jerry jERRY JeRRRY\") 5 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n\n### Explanation\n\nThe code is an implementation of a function named `FUNC_0` that takes a string as input and returns an integer. The function returns the number of unique lowercase characters in the input string.\n\nThe function is defined with a single argument `VAR_0` of type `str`. The `-> int` syntax specifies that the function returns an integer.\n\nThe function body consists of a single line that returns the length of a set of lowercase characters in the input string. The `set()` function returns a set of unique characters in the input string. The `lower()` method is called on the input string to convert all characters to lowercase before creating the set. Finally, the `len()` function is called on the set to get the number of unique lowercase characters in the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_distinct_characters string)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (make_palindrome string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"xyz\") \"xyzyx\" 0.001)\n    (check-within (candidate \"xyx\") \"xyx\" 0.001)\n    (check-within (candidate \"jerry\") \"jerryrrej\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while string[beginning_of_suffix:] != string[beginning_of_suffix:][::-1]:\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a string. Here is a line-by-line explanation of the code:\n\n```python\ndef FUNC_0(VAR_0: str) -> str:\n```\n\nThis line defines a function named `FUNC_0` that takes a string argument named `VAR_0` and returns a string. The `-> str` part of the line specifies the return type of the function.\n\n```python\nif (not VAR_0):\n    return ''\n```\n\nThis line checks if the input string is empty. If it is, the function returns an empty string.\n\n```python\nVAR_1 = 0\n```\n\nThis line initializes a variable named `VAR_1` to 0. This variable will be used to keep track of the length of the longest palindrome prefix of the input string.\n\n```python\nwhile (VAR_0[VAR_1:] != VAR_0[VAR_1:][::(- 1)]):\n    VAR_1 += 1\n```\n\nThis line starts a loop that continues until the longest palindrome prefix of the input string is found. The loop works by checking if the substring of the input string starting from index `VAR_1` is equal to the reverse of the same substring. If it is not, `VAR_1` is incremented and the loop continues.\n\n```python\nreturn (VAR_0 + VAR_0[:VAR_1][::(- 1)])\n```\n\nThis line returns the input string concatenated with the reverse of the substring of the input string from index 0 to `VAR_1`. This effectively creates a palindrome by adding the reverse of the prefix to the end of the input string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (make_palindrome string)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (check_dict_case dict)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f 0.001)\n    (check-within (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f 0.001)\n    (check-within (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t 0.001)\n    (check-within (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t 0.001)\n    (check-within (candidate #hash()) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                continue\n        return state == \"upper\" or state == \"lower\"\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a dictionary with string keys and string values as input and returns a boolean value. The function checks if the keys of the input dictionary form a sequence of either all uppercase or all lowercase letters. If the keys are not all uppercase or all lowercase, the function returns False. If the input dictionary is empty, the function also returns False.\n\nHere is a line-by-line explanation of the code:\n\n```python\nfrom typing import Dict\n```\n\nThis line imports the `Dict` class from the `typing` module. The `Dict` class is a generic type that represents a dictionary with string keys and string values.\n\n```python\ndef FUNC_0(VAR_0: Dict[(str, str)]) -> bool:\n```\n\nThis line defines the `FUNC_0` function that takes a dictionary with string keys and string values as input and returns a boolean value. The function is annotated with type hints that specify the types of the input and output.\n\n```python\nif (len(VAR_0.keys()) == 0):\n    return False\n```\n\nThis line checks if the input dictionary is empty. If the dictionary is empty, the function returns False.\n\n```python\nelse:\n    VAR_1 = 'start'\n    for VAR_2 in VAR_0.keys():\n```\n\nIf the input dictionary is not empty, the function initializes a variable `VAR_1` to the string `'start'` and iterates over the keys of the dictionary using a for loop.\n\n```python\nif (isinstance(VAR_2, str) == False):\n    VAR_1 = 'mixed'\n    break\n```\n\nFor each key in the dictionary, the function checks if the key is a string. If the key is not a string, the function sets `VAR_1` to the string `'mixed'` and breaks out of the loop.\n\n```python\nif (VAR_1 == 'start'):\n    if VAR_2.isupper():\n        VAR_1 = 'upper'\n    elif VAR_2.islower():\n        VAR_1 = 'lower'\n    else:\n        break\n```\n\nIf `VAR_1` is still `'start'`, the function checks if the current key is uppercase or lowercase. If the key is uppercase, `VAR_1` is set to `'upper'`. If the key is lowercase, `VAR_1` is set to `'lower'`. If the key is neither uppercase nor lowercase, the function breaks out of the loop.\n\n```python\nelif (((VAR_1 == 'upper') and (not VAR_2.isupper())) or ((VAR_1 == 'lower') and (not VAR_2.islower()))):\n    VAR_1 = 'mixed'\n    break\n```\n\nIf `VAR_1` is not `'start'`, the function checks if the current key is consistent with the case of the previous keys. If `VAR_1` is `'upper'` and the current key is not uppercase, or if `VAR_1` is `'lower'` and the current key is not lowercase, `VAR_1` is set to `'mixed'` and the loop is broken.\n\n```python\nelse:\n    continue\n```\n\nIf the current key is consistent with the case of the previous keys, the function continues to the next key.\n\n```python\nreturn ((VAR_1 == 'upper') or (VAR_1 == 'lower'))\n```\n\nAfter iterating over all the keys in the dictionary, the function checks if `VAR_1` is `'upper'` or `'lower'`. If `VAR_1` is either `'upper'`\n\n### Racket version\n\n#lang racket\n\n;; \n(define (check_dict_case dict)\n"
  },
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"()\") #t 0.001)\n    (check-within (candidate \"(()())\") #t 0.001)\n    (check-within (candidate \"()()(()())()\") #t 0.001)\n    (check-within (candidate \"()()((()()())())(()()(()))\") #t 0.001)\n    (check-within (candidate \"((()())))\") #f 0.001)\n    (check-within (candidate \")(()\") #f 0.001)\n    (check-within (candidate \"(\") #f 0.001)\n    (check-within (candidate \"((((\") #f 0.001)\n    (check-within (candidate \")\") #f 0.001)\n    (check-within (candidate \"(()\") #f 0.001)\n    (check-within (candidate \"()()(()())())(()\") #f 0.001)\n    (check-within (candidate \"()()(()())()))()\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns a boolean value. The function checks if the string contains a balanced set of parentheses. If the parentheses are balanced, the function returns True, otherwise it returns False.\n\nHere is a line-by-line explanation of the code:\n\n```python\ndef FUNC_0(VAR_0: str) -> bool:\n```\n\nThis line defines a function called `FUNC_0` that takes a string as input and returns a boolean value.\n\n```python\nVAR_1 = 0\n```\n\nThis line initializes a variable called `VAR_1` to 0. This variable will be used to keep track of the balance of parentheses in the string.\n\n```python\nfor VAR_2 in VAR_0:\n```\n\nThis line starts a loop that iterates over each character in the input string.\n\n```python\nif (VAR_2 == '('):\n    VAR_1 += 1\nelse:\n    VAR_1 -= 1\n```\n\nThis block of code checks if the current character is an opening parenthesis. If it is, the balance variable `VAR_1` is incremented by 1. If it is not, the balance variable is decremented by 1.\n\n```python\nif (VAR_1 < 0):\n    return False\n```\n\nThis line checks if the balance variable `VAR_1` is negative. If it is, that means there are more closing parentheses than opening parentheses, which means the string is not balanced. In this case, the function returns False.\n\n```python\nreturn (VAR_1 == 0)\n```\n\nThis line checks if the balance variable `VAR_1` is zero. If it is, that means there are an equal number of opening and closing parentheses, which means the string is balanced. In this case, the function returns True. If the balance variable is not zero, the function returns False.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (split_words txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n    (check-within (candidate \"Hello world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello,world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello world,!\") (list \"Hello\" \"world,!\") 0.001)\n    (check-within (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\" \"!\") 0.001)\n    (check-within (candidate \"abcdef\") 3 0.001)\n    (check-within (candidate \"aaabb\") 2 0.001)\n    (check-within (candidate \"aaaBb\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a string as input and returns either a list of strings or an integer. The function is defined using Python's type annotations to indicate that the input is a string and the output is either a list of strings or an integer.\n\n```python\nfrom typing import List\nfrom typing import Union\n\ndef FUNC_0(VAR_0: str) -> Union[(List[str], int)]:\n```\n\nThe function has three branches, each of which returns a different value depending on the input string. The first branch checks if the input string contains a space character. If it does, the function returns a list of strings obtained by splitting the input string at each space character.\n\n```python\n    if (' ' in VAR_0):\n        return VAR_0.split()\n```\n\nThe second branch checks if the input string contains a comma character. If it does, the function replaces all comma characters with space characters and then returns a list of strings obtained by splitting the modified input string at each space character.\n\n```python\n    elif (',' in VAR_0):\n        return VAR_0.replace(',', ' ').split()\n```\n\nThe third branch is the default case, which is executed if the input string does not contain either a space or a comma character. In this case, the function returns an integer that represents the number of lowercase letters in the input string that have an even ASCII code.\n\n```python\n    else:\n        return len([VAR_1 for VAR_1 in VAR_0 if (VAR_1.islower() and ((ord(VAR_1) % 2) == 0))])\n```\n\nThe integer is obtained by first creating a list of all lowercase letters in the input string that have an even ASCII code. This is done using a list comprehension that iterates over each character in the input string and checks if it is a lowercase letter with an even ASCII code. If the character satisfies both conditions, it is added to the list. The length of the resulting list is then returned as the output of the function.<|im_end|>\n\n\n### Racket version\n\n#lang racket\n\n;; \n(define (split_words txt)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (strlen string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strlen))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"x\") 1 0.001)\n    (check-within (candidate \"asdasnakj\") 9 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef strlen(string: str) -> int:\n    return len(string)\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns the length of the string. \n\nThe function is defined with the keyword `def` followed by the name of the function `FUNC_0`. The function takes one argument `VAR_0` which is a string and is annotated with the type `str`. The function returns an integer, which is annotated with the type `int`. \n\nThe function body contains a single statement `return len(VAR_0)`. The `len()` function returns the length of the string passed as argument. The `return` statement returns the length of the string as an integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (strlen string)\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (car_race_collision n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate car_race_collision))\n    (check-within (candidate 2) 4 0.001)\n    (check-within (candidate 3) 9 0.001)\n    (check-within (candidate 4) 16 0.001)\n    (check-within (candidate 8) 64 0.001)\n    (check-within (candidate 10) 100 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef car_race_collision(n: int) -> int:\n    return n**2\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer and returns its square. \n\nThe function is defined with the keyword `def`, followed by the function name `FUNC_0`, and the input parameter `VAR_0` with type annotation `int`. The function returns an integer, also with type annotation `int`. \n\nThe function body consists of a single line that returns the square of the input parameter `VAR_0`. The `**` operator is used to calculate the square of `VAR_0`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (car_race_collision n)\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (fibfib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 1) 0 0.001)\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 24 0.001)\n    (check-within (candidate 10) 81 0.001)\n    (check-within (candidate 12) 274 0.001)\n    (check-within (candidate 14) 927 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. In this implementation, the sequence starts with 0, 0, 1, and then each subsequent number is the sum of the previous three numbers.\n\nThe function is called FUNC_0 and takes an integer argument VAR_0. The function returns an integer.\n\nThe first if statement checks if VAR_0 is equal to 0. If it is, the function returns 0.\n\nThe second if statement checks if VAR_0 is equal to 1. If it is, the function returns 0.\n\nThe third if statement checks if VAR_0 is equal to 2. If it is, the function returns 1.\n\nIf none of the above conditions are met, the function returns the sum of the previous three numbers in the sequence. This is done by recursively calling the FUNC_0 function with VAR_0 - 1, VAR_0 - 2, and VAR_0 - 3 as arguments, and adding the results together. This continues until VAR_0 is equal to 2, at which point the function returns 1, or until VAR_0 is equal to 1 or 0, at which point the function returns 0.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fibfib n)\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (order_by_points nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n    (check-within (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11) 0.001)\n    (check-within (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -11 -32 43 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9) 0.001)\n    (check-within (candidate (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers as input, and returns a sorted list of integers based on the sum of their digits. \n\nThe function is defined as FUNC_0, which takes a single argument VAR_0, which is a list of integers. The function returns a list of integers.\n\nThe function contains an inner function, FUNC_1, which takes a single argument VAR_1. This function converts the input integer into a list of its digits, multiplies the first digit by -1 if the input integer is negative, and returns the sum of the digits.\n\nThe outer function, FUNC_0, sorts the input list VAR_0 based on the output of FUNC_1. The sorted list is returned as the output of FUNC_0.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (order_by_points nums)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (move_one_ball arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate move_one_ball))\n    (check-within (candidate (list 3 4 5 1 2)) #t 0.001)\n    (check-within (candidate (list 3 5 10 1 2)) #t 0.001)\n    (check-within (candidate (list 4 3 1 2)) #f 0.001)\n    (check-within (candidate (list 3 5 4 1 2)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n\n### Explanation\n\nThe code is an implementation of a function that checks if a list of integers is sorted in ascending order after a single rotation. \n\n```python\nfrom typing import List\n```\nThis line imports the List type from the typing module. The List type is used to indicate that a variable is a list of a certain type.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> bool:\n```\nThis line defines a function named FUNC_0 that takes a list of integers as input and returns a boolean value. The function is defined using type annotations, which indicate the types of the input and output variables.\n\n```python\nif (len(VAR_0) == 0):\n    return True\n```\nThis line checks if the input list is empty. If it is, the function returns True, since an empty list is always sorted.\n\n```python\nVAR_1 = sorted(VAR_0)\n```\nThis line creates a sorted copy of the input list and assigns it to the variable VAR_1.\n\n```python\nVAR_2 = []\nVAR_3 = min(VAR_0)\nVAR_4 = VAR_0.index(VAR_3)\nVAR_2 = (VAR_0[VAR_4:] + VAR_0[0:VAR_4])\n```\nThese lines create a rotated copy of the input list and assign it to the variable VAR_2. \n\n- VAR_2 is initialized as an empty list.\n- VAR_3 is assigned the minimum value of the input list.\n- VAR_4 is assigned the index of the minimum value in the input list.\n- VAR_2 is assigned the result of concatenating the sublist of VAR_0 from VAR_4 to the end with the sublist of VAR_0 from the beginning to VAR_4.\n\nThis effectively rotates the input list so that the minimum value is at the beginning.\n\n```python\nfor VAR_5 in range(len(VAR_0)):\n    if (VAR_2[VAR_5] != VAR_1[VAR_5]):\n        return False\n```\nThese lines iterate over the indices of the input list and check if the corresponding elements in VAR_2 and VAR_1 are equal. If any of the elements are not equal, the function returns False, since the rotated list is not sorted. \n\n```python\nreturn True\n```\nIf all the elements are equal, the function returns True, since the rotated list is sorted.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (move_one_ball arr)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (closest_integer value)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-within (candidate \"10\") 10 0.001)\n    (check-within (candidate \"14.5\") 15 0.001)\n    (check-within (candidate \"-15.5\") -16 0.001)\n    (check-within (candidate \"15.3\") 15 0.001)\n    (check-within (candidate \"0\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef closest_integer(value: str) -> int:\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns an integer. The function is named `FUNC_0` and takes one argument `VAR_0` of type `str`. The function returns an integer of type `int`.\n\nThe first line of the function imports the `floor` and `ceil` functions from the `math` module.\n\n```python\nfrom math import floor, ceil\n```\n\nThe second line of the function checks if the input string `VAR_0` contains exactly one decimal point. If it does, it removes any trailing zeros from the decimal part of the string.\n\n```python\nif (VAR_0.count('.') == 1):\n    while (VAR_0[(- 1)] == '0'):\n        VAR_0 = VAR_0[:(- 1)]\n```\n\nThe third line of the function converts the input string `VAR_0` to a floating-point number and assigns it to the variable `VAR_1`.\n\n```python\nVAR_1 = float(VAR_0)\n```\n\nThe fourth line of the function checks if the decimal part of the input string `VAR_0` is exactly `.5`. If it is, the function rounds the floating-point number `VAR_1` up or down depending on whether it is positive or negative, and assigns the result to the variable `VAR_2`.\n\n```python\nif (VAR_0[(- 2):] == '.5'):\n    if (VAR_1 > 0):\n        VAR_2 = ceil(VAR_1)\n    else:\n        VAR_2 = floor(VAR_1)\n```\n\nThe fifth line of the function checks if the length of the input string `VAR_0` is greater than zero. If it is, the function rounds the floating-point number `VAR_1` to the nearest integer and assigns the result to the variable `VAR_2`.\n\n```python\nelif (len(VAR_0) > 0):\n    VAR_2 = int(round(VAR_1))\n```\n\nThe sixth line of the function is an else statement that assigns the value `0` to the variable `VAR_2` if the input string `VAR_0` is empty.\n\n```python\nelse:\n    VAR_2 = 0\n```\n\nFinally, the function returns the value of the variable `VAR_2`.\n\n```python\nreturn VAR_2\n```\n\n### Racket version\n\n#lang racket\n\n;; \n(define (closest_integer value)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (special_factorial n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate special_factorial))\n    (check-within (candidate 4) 288 0.001)\n    (check-within (candidate 5) 34560 0.001)\n    (check-within (candidate 7) 125411328000 0.001)\n    (check-within (candidate 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef special_factorial(n: int) -> int:\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n### Explanation\n\nThe code is an implementation of a function that calculates the factorial of a given integer. \n\nThe function is named `FUNC_0` and takes one argument, `VAR_0`, which is an integer. The function returns an integer. \n\nThe first line of the function definition specifies the function signature, which includes the name of the function, the name of the argument, and the return type. \n\nThe next two lines of the function definition initialize two variables, `VAR_1` and `VAR_2`, to the value 1. \n\nThe next line of the function definition starts a for loop that iterates over a range of integers from 1 to `VAR_0` (inclusive). \n\nWithin the loop, the value of `VAR_1` is updated by multiplying it by the current value of the loop variable `VAR_3`. \n\nThe value of `VAR_2` is then updated by multiplying it by the updated value of `VAR_1`. \n\nAfter the loop completes, the final value of `VAR_2` is returned as the result of the function.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (special_factorial n)\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (is_nested string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n    (check-within (candidate \"[[]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]][[[[[]\") #f 0.001)\n    (check-within (candidate \"[][]\") #f 0.001)\n    (check-within (candidate \"[]\") #f 0.001)\n    (check-within (candidate \"[[[[]]]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]]]]]\") #f 0.001)\n    (check-within (candidate \"[][][[]]\") #t 0.001)\n    (check-within (candidate \"[[]\") #f 0.001)\n    (check-within (candidate \"[]]\") #f 0.001)\n    (check-within (candidate \"[[]][[\") #t 0.001)\n    (check-within (candidate \"[[][]]\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"[[[[[[[[\") #f 0.001)\n    (check-within (candidate \"]]]]]]]]\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef is_nested(string: str) -> bool:\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n### Explanation\n\nThe code is an implementation of a function `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value. The function checks whether the input string contains at least two pairs of square brackets `[]` that are nested inside each other. \n\n1. `def FUNC_0(VAR_0: str) -> bool:`\n\n    This line defines a function `FUNC_0` that takes a string `VAR_0` as input and returns a boolean value. The `-> bool` indicates that the function returns a boolean value.\n\n2. `VAR_1 = []`\n\n    This line initializes an empty list `VAR_1`.\n\n3. `VAR_2 = []`\n\n    This line initializes another empty list `VAR_2`.\n\n4. `for VAR_3 in range(len(VAR_0)):`\n    \n    This line starts a loop that iterates over the indices of the characters in the input string `VAR_0`.\n\n5. `if (VAR_0[VAR_3] == '['):`\n    \n    This line checks if the character at the current index is an opening square bracket `[`. If it is, the index is appended to the list `VAR_1`.\n\n6. `else:`\n    \n    This line is executed if the character at the current index is not an opening square bracket `[`. In this case, the index is appended to the list `VAR_2`.\n\n7. `VAR_2.reverse()`\n    \n    This line reverses the order of the indices in the list `VAR_2`.\n\n8. `VAR_4 = 0`\n    \n    This line initializes a variable `VAR_4` to 0.\n\n9. `VAR_3 = 0`\n    \n    This line initializes another variable `VAR_3` to 0.\n\n10. `VAR_5 = len(VAR_2)`\n    \n    This line initializes a variable `VAR_5` to the length of the list `VAR_2`.\n\n11. `for VAR_6 in VAR_1:`\n    \n    This line starts a loop that iterates over the indices of the opening square brackets `[` in the input string `VAR_0`.\n\n12. `if ((VAR_3 < VAR_5) and (VAR_6 < VAR_2[VAR_3])):`\n    \n    This line checks if the current opening square bracket `[` is nested inside a closing square bracket `]`. It does this by checking if the current opening bracket index is less than the index of the next closing bracket in the reversed list `VAR_2`. If this condition is true, the variable `VAR_4` is incremented by 1 and the variable `VAR_3` is also incremented by 1.\n\n13. `return (VAR_4 >= 2)`\n    \n    This line returns a boolean value indicating whether the input string `VAR_0` contains at least two pairs of nested square brackets `[]`. If the variable `VAR_4` is greater than or equal to 2, the function returns `True`. Otherwise, it returns `False`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_nested string)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (even_odd_count num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n    (check-within (candidate 7) (list 0 1) 0.001)\n    (check-within (candidate -78) (list 1 1) 0.001)\n    (check-within (candidate 3452) (list 2 2) 0.001)\n    (check-within (candidate 346211) (list 3 3) 0.001)\n    (check-within (candidate -345821) (list 3 3) 0.001)\n    (check-within (candidate -2) (list 1 0) 0.001)\n    (check-within (candidate -45347) (list 2 3) 0.001)\n    (check-within (candidate 0) (list 1 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Tuple \n\ndef even_odd_count(num: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes an integer `VAR_0` as input and returns a tuple of two integers. The function calculates the number of even and odd digits in the absolute value of the input integer.\n\n```python\nfrom typing import Tuple\n```\nThe `typing` module is imported to allow the use of type hints in the function definition.\n\n```python\ndef FUNC_0(VAR_0: int) -> Tuple[(int, int)]:\n```\nThe function definition starts with the `def` keyword, followed by the function name `FUNC_0`. The function takes one argument `VAR_0` of type `int` and returns a tuple of two integers. The `->` symbol is used to indicate the return type.\n\n```python\nVAR_1 = 0\nVAR_2 = 0\n```\nTwo variables `VAR_1` and `VAR_2` are initialized to zero.\n\n```python\nfor VAR_3 in str(abs(VAR_0)):\n```\nA `for` loop is used to iterate over each digit in the absolute value of the input integer. The `abs()` function is used to ensure that negative integers are treated as positive.\n\n```python\nif ((int(VAR_3) % 2) == 0):\n    VAR_1 += 1\nelse:\n    VAR_2 += 1\n```\nFor each digit, an `if` statement checks if it is even or odd. If the digit is even, `VAR_1` is incremented by 1. If the digit is odd, `VAR_2` is incremented by 1.\n\n```python\nreturn (VAR_1, VAR_2)\n```\nThe function returns a tuple containing the values of `VAR_1` and `VAR_2`. This tuple represents the number of even and odd digits in the input integer.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (even_odd_count num)\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (string_xor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n    (check-within (candidate \"111000\" \"101010\") \"010010\" 0.001)\n    (check-within (candidate \"1\" \"1\") \"0\" 0.001)\n    (check-within (candidate \"0101\" \"0000\") \"0101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n\n### Explanation\n\nThe code is an implementation of the Hamming distance algorithm. The Hamming distance is the number of positions at which the corresponding symbols are different between two strings of equal length. The function takes two strings as input and returns a string representing the Hamming distance between the two input strings.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. The List class is used to define a list of elements of a specific type.\n\n```python\ndef FUNC_0(VAR_0: str, VAR_1: str) -> str:\n```\nThis line defines a function named FUNC_0 that takes two parameters of type string and returns a string. The function is used to calculate the Hamming distance between two strings.\n\n```python\n    def FUNC_1(VAR_2, VAR_3):\n        if (VAR_2 == VAR_3):\n            return '0'\n        else:\n            return '1'\n```\nThis line defines a nested function named FUNC_1 that takes two parameters and returns a string. The function is used to compare two characters and return '0' if they are equal and '1' if they are different.\n\n```python\n    return ''.join((FUNC_1(VAR_4, VAR_5) for (VAR_4, VAR_5) in zip(VAR_0, VAR_1)))\n```\nThis line returns a string that represents the Hamming distance between the two input strings. The join() method is used to concatenate the output of the FUNC_1 function for each pair of characters in the input strings. The zip() function is used to create an iterator that aggregates the elements from each of the input strings. The output of the zip() function is a list of tuples, where each tuple contains the corresponding characters from the input strings. The for loop iterates over each tuple in the list and calls the FUNC_1 function with the corresponding characters as input. The output of the FUNC_1 function is added to a list comprehension, which is then passed to the join() method to concatenate the output into a single string.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (string_xor a b)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (longest strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"x\" 0.001)\n    (check-within (candidate (list \"x\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\")) \"zzzz\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of strings as input and returns the string with the longest length. If the input list is empty, the function returns None.\n\n```python\nfrom typing import List, Optional\n```\nThis line imports the List and Optional types from the typing module. List is a type hint for a list of a specific type, while Optional is a type hint for an optional value.\n\n```python\ndef FUNC_0(VAR_0: List[str]) -> Optional[str]:\n```\nThis line defines a function named FUNC_0 that takes a list of strings as input and returns an optional string. The function is defined using type hints, where List[str] specifies that the input is a list of strings, and Optional[str] specifies that the output is an optional string.\n\n```python\n    if (not VAR_0):\n        return None\n```\nThis line checks if the input list is empty. If it is, the function returns None.\n\n```python\n    VAR_1 = max((len(VAR_2) for VAR_2 in VAR_0))\n```\nThis line uses a generator expression to find the length of the longest string in the input list. The max() function is used to find the maximum value in the generator expression, which returns the length of each string in the input list.\n\n```python\n    for VAR_3 in VAR_0:\n        if (len(VAR_3) == VAR_1):\n            return VAR_3\n```\nThis line iterates over each string in the input list and checks if its length is equal to the length of the longest string found in the previous line. If it is, the function returns that string. This ensures that the function returns the first string with the longest length if there are multiple strings with the same length.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n;; \n(define (longest strings)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (intersperse numbers delimeter)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersperse))\n    (check-within (candidate (list ) 7) (list ) 0.001)\n    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)\n    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes two arguments: a list of integers called `VAR_0` and an integer called `VAR_1`. The function returns a new list of integers.\n\nThe first line of the code imports the `List` type from the `typing` module. This is used to specify the type of the `VAR_0` argument.\n\nThe second line defines the `FUNC_0` function. It takes two arguments: `VAR_0` and `VAR_1`, both of which are specified with their types. The function returns a list of integers.\n\nThe third line checks if the `VAR_0` list is empty. If it is, the function returns an empty list.\n\nThe fourth line creates an empty list called `VAR_2`.\n\nThe fifth line starts a `for` loop that iterates over all but the last element of the `VAR_0` list. For each element, the loop appends the element to `VAR_2`, followed by `VAR_1`.\n\nThe sixth line appends the last element of `VAR_0` to `VAR_2`.\n\nThe seventh line returns the new list `VAR_2`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (intersperse numbers delimeter)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (histogram test)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate histogram))\n    (check-within (candidate \"a b b a\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c a b\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c d g\") #hash((\"a\" .  1) (\"b\" .  1) (\"c\" .  1) (\"d\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"b b b b a\") #hash((\"b\" .  4)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"\") #hash() 0.001)\n    (check-within (candidate \"a\") #hash((\"a\" .  1)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a dictionary with the count of the most frequently occurring word in the string. Here is a line-by-line explanation of the code:\n\n```python\nfrom typing import Dict\n```\n\nThis line imports the `Dict` type from the `typing` module. This is used to specify the return type of the function.\n\n```python\ndef FUNC_0(VAR_0: str) -> Dict[(str, int)]:\n```\n\nThis line defines a function called `FUNC_0` that takes a string argument `VAR_0` and returns a dictionary with keys of type `str` and values of type `int`. The `->` notation is used to specify the return type of the function.\n\n```python\nVAR_1 = {}\n```\n\nThis line initializes an empty dictionary called `VAR_1`.\n\n```python\nVAR_2 = VAR_0.split(' ')\n```\n\nThis line splits the input string `VAR_0` into a list of words using the `split()` method. The separator used is a space character.\n\n```python\nVAR_3 = 0\nfor VAR_4 in VAR_2:\n    if ((VAR_2.count(VAR_4) > VAR_3) and (VAR_4 != '')):\n        VAR_3 = VAR_2.count(VAR_4)\n```\n\nThese lines iterate over each word in the list `VAR_2` and count the number of times it appears in the list. If the count is greater than the current maximum count `VAR_3`, and the word is not an empty string, then the count is updated to the new maximum.\n\n```python\nif (VAR_3 > 0):\n    for VAR_4 in VAR_2:\n        if (VAR_2.count(VAR_4) == VAR_3):\n            VAR_1[VAR_4] = VAR_3\n```\n\nThese lines iterate over each word in the list `VAR_2` again, and for each word that has a count equal to the maximum count `VAR_3`, it is added to the dictionary `VAR_1` with a value of `VAR_3`.\n\n```python\nreturn VAR_1\n```\n\nThis line returns the dictionary `VAR_1` containing the most frequently occurring word(s) and their count(s).\n\n### Racket version\n\n#lang racket\n\n;; \n(define (histogram test)\n"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_array array)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5)) (list 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3 4 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0) 0.001)\n    (check-within (candidate (list 2 1)) (list 1 2) 0.001)\n    (check-within (candidate (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87) 0.001)\n    (check-within (candidate (list 21 14 23 11)) (list 23 21 14 11) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns a sorted list of integers. If the input list is empty, the function returns an empty list. If the sum of the first and last element of the input list is even, the function returns the sorted list in descending order. Otherwise, it returns the sorted list in ascending order.\n\n```python\nfrom typing import List\n```\nThis line imports the List class from the typing module. This is used to specify the type of the input and output of the function.\n\n```python\ndef FUNC_0(VAR_0: List[int]) -> List[int]:\n```\nThis line defines a function named FUNC_0 that takes a list of integers as input and returns a list of integers as output.\n\n```python\nreturn ([] if (len(VAR_0) == 0) else sorted(VAR_0, reverse=(((VAR_0[0] + VAR_0[(- 1)]) % 2) == 0)))\n```\nThis line returns a sorted list of integers. If the input list is empty, it returns an empty list. If the sum of the first and last element of the input list is even, it returns the sorted list in descending order. Otherwise, it returns the sorted list in ascending order.\n\n```python\n([] if (len(VAR_0) == 0) else sorted(VAR_0, reverse=(((VAR_0[0] + VAR_0[(- 1)]) % 2) == 0)))\n```\nThis is a ternary operator that returns an empty list if the input list is empty, otherwise it sorts the input list in ascending or descending order based on the sum of the first and last element of the input list.\n\n```python\nsorted(VAR_0, reverse=(((VAR_0[0] + VAR_0[(- 1)]) % 2) == 0))\n```\nThis line sorts the input list in ascending or descending order based on the sum of the first and last element of the input list. If the sum is even, it sorts the list in descending order by setting the reverse parameter to True. Otherwise, it sorts the list in ascending order by setting the reverse parameter to False. \n\n```python\n(((VAR_0[0] + VAR_0[(- 1)]) % 2) == 0)\n```\nThis line calculates the sum of the first and last element of the input list and checks if it is even by taking the modulo 2. If the sum is even, it returns True. Otherwise, it returns False.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_array array)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (largest_divisor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_divisor))\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 10) 5 0.001)\n    (check-within (candidate 100) 50 0.001)\n    (check-within (candidate 49) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef largest_divisor(n: int) -> int:\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n\n### Explanation\n\nThe code is an implementation of a function that returns the largest divisor of a given number. Here is a line-by-line explanation of the code:\n\n```python\ndef FUNC_0(VAR_0: int) -> int:\n```\n\nThis line defines a function called `FUNC_0` that takes an integer argument `VAR_0` and returns an integer.\n\n```python\nfor VAR_1 in reversed(range(VAR_0)):\n```\n\nThis line starts a loop that iterates over the range of integers from `VAR_0-1` down to `0`. The `reversed` function is used to iterate in reverse order.\n\n```python\nif ((VAR_0 % VAR_1) == 0):\n```\n\nThis line checks if `VAR_0` is divisible by `VAR_1` with no remainder. If it is, then `VAR_1` is a divisor of `VAR_0`.\n\n```python\nreturn VAR_1\n```\n\nThis line returns the largest divisor of `VAR_0`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_divisor n)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (count_up_to n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_up_to))\n    (check-within (candidate 5) (list 2 3) 0.001)\n    (check-within (candidate 6) (list 2 3 5) 0.001)\n    (check-within (candidate 7) (list 2 3 5) 0.001)\n    (check-within (candidate 10) (list 2 3 5 7) 0.001)\n    (check-within (candidate 0) (list ) 0.001)\n    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)\n    (check-within (candidate 1) (list ) 0.001)\n    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)\n    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)\n    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef count_up_to(n: int) -> List[int]:\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n### Explanation\n\nThe code is an implementation of the Sieve of Eratosthenes algorithm, which is used to find all prime numbers up to a given limit. \n\nThe function `FUNC_0` takes an integer `VAR_0` as input and returns a list of integers. The function signature specifies that the output list will contain integers.\n\nThe first line of the function imports the `List` type from the `typing` module. This is used to specify the type of the output list.\n\nThe second line defines the function `FUNC_0` with a single input parameter `VAR_0` of type `int`. The function returns a list of integers.\n\nThe third line initializes an empty list `VAR_1`.\n\nThe fourth line starts a `for` loop that iterates over the range of integers from 2 to `VAR_0` (exclusive). This loop is used to generate a list of all prime numbers up to `VAR_0`.\n\nThe fifth line initializes a boolean variable `VAR_3` to `True`. This variable is used to keep track of whether the current number being checked is prime or not.\n\nThe sixth line starts another `for` loop that iterates over the range of integers from 2 to `VAR_2` (exclusive). This loop is used to check whether `VAR_2` is divisible by any number other than 1 and itself.\n\nThe seventh line checks whether `VAR_2` is divisible by `VAR_4`. If it is, then `VAR_3` is set to `False` and the loop is broken using the `break` statement.\n\nThe eighth line checks whether `VAR_3` is still `True`. If it is, then `VAR_2` is a prime number and is appended to the list `VAR_1`.\n\nThe ninth line returns the list `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_up_to n)\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (sort_even l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_even))\n    (check-within (candidate (list 1 2 3)) (list 1 2 3) 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123) 0.001)\n    (check-within (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\nfrom typing import List\n\ndef sort_even(l: List[int]) -> List[int]:\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n\n### Explanation\n\nThe code is an implementation of a function called `FUNC_0` that takes a list of integers as input and returns a list of integers as output. The function performs the following steps:\n\n1. Import the `List` type from the `typing` module.\n2. Define the `FUNC_0` function that takes a list of integers as input and returns a list of integers as output.\n3. Create a new list `VAR_1` that contains every other element of the input list `VAR_0`.\n4. Create a new list `VAR_2` that contains every other element of the input list `VAR_0` starting from the second element.\n5. Sort the `VAR_1` list in ascending order.\n6. Create an empty list `VAR_3`.\n7. Iterate over the `VAR_1` and `VAR_2` lists in parallel using the `zip` function.\n8. For each pair of elements `(VAR_4, VAR_5)` in the `VAR_1` and `VAR_2` lists, append `VAR_4` and `VAR_5` to the `VAR_3` list.\n9. If the length of `VAR_1` is greater than the length of `VAR_2`, append the last element of `VAR_1` to the `VAR_3` list.\n10. Return the `VAR_3` list.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_even l)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (add x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate 0 1) 1 0.001)\n    (check-within (candidate 1 0) 1 0.001)\n    (check-within (candidate 2 3) 5 0.001)\n    (check-within (candidate 5 7) 12 0.001)\n    (check-within (candidate 7 5) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef add(x: int, y: int) -> int:\n    return x + y\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns their sum. \n\n```python\ndef FUNC_0(VAR_0: int, VAR_1: int) -> int:\n```\nThe function is defined with the name `FUNC_0` and takes two integer arguments `VAR_0` and `VAR_1`. The `-> int` specifies that the function returns an integer.\n\n```python\n    return (VAR_0 + VAR_1)\n```\nThe function returns the sum of the two integer arguments `VAR_0` and `VAR_1`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (add x y)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rkt",
    "prompt": "#lang racket\n\n;; \n(define (circular_shift x shift)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n    (check-within (candidate 100 2) \"001\" 0.001)\n    (check-within (candidate 12 2) \"12\" 0.001)\n    (check-within (candidate 97 8) \"79\" 0.001)\n    (check-within (candidate 12 1) \"21\" 0.001)\n    (check-within (candidate 11 101) \"11\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Python version\n\ndef circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n\n### Explanation\n\nThe code is an implementation of a function that takes two integer arguments and returns a string. Here is a line by line explanation of the code:\n\n```python\ndef FUNC_0(VAR_0: int, VAR_1: int) -> str:\n```\n\nThis line defines a function called `FUNC_0` that takes two integer arguments `VAR_0` and `VAR_1` and returns a string. The `-> str` syntax indicates that the function returns a string.\n\n```python\nVAR_2 = str(VAR_0)\n```\n\nThis line converts the first argument `VAR_0` to a string and assigns it to a new variable `VAR_2`.\n\n```python\nif (VAR_1 > len(VAR_2)):\n    return VAR_2[::(- 1)]\n```\n\nThis line checks if the second argument `VAR_1` is greater than the length of the string `VAR_2`. If it is, it returns the string `VAR_2` reversed. The `[::-1]` syntax is used to reverse the string.\n\n```python\nelse:\n    return (VAR_2[(len(VAR_2) - VAR_1):] + VAR_2[:(len(VAR_2) - VAR_1)])\n```\n\nIf the second argument `VAR_1` is less than or equal to the length of the string `VAR_2`, this line returns a new string that is created by concatenating the last `VAR_1` characters of `VAR_2` with the first `len(VAR_2) - VAR_1` characters of `VAR_2`. The `[(len(VAR_2) - VAR_1):]` syntax is used to slice the last `VAR_1` characters of `VAR_2`, and the `[:len(VAR_2) - VAR_1]` syntax is used to slice the first `len(VAR_2) - VAR_1` characters of `VAR_2`.\n\n### Racket version\n\n#lang racket\n\n;; \n(define (circular_shift x shift)\n"
  }
]