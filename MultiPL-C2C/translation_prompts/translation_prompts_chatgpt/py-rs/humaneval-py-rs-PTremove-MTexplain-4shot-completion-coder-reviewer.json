[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rs",
    "prompt": "fn correct_bracketing(brackets: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Explanation\n\nThis function takes a string of brackets as input and returns True if the brackets are correctly balanced, False otherwise. The function works by iterating over each bracket in the input string and keeping track of the current depth of the bracket. If the bracket is an opening bracket, the depth is incremented by 1. If the bracket is a closing bracket, the depth is decremented by 1. If the depth ever becomes negative, it means that there is a closing bracket without a corresponding opening bracket, so the function returns False. Finally, if the depth is zero at the end of the iteration, it means that all opening brackets have been closed, so the function returns True.\n\n### Rust version\n\nfn correct_bracketing(brackets: String) -> bool {\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rs",
    "prompt": "fn triangle_area(a: isize, h: isize) -> f64 {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5, 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10, 8), 40.0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef triangle_area(a: int, h: int) -> float:\n    return a * h / 2.0\n\n### Explanation\n\nThis Python program defines a function called `triangle_area` that takes two integer arguments `a` and `h` and returns a float. The function calculates the area of a triangle with base `a` and height `h` using the formula `a * h / 2.0`.\n\n### Rust version\n\nfn triangle_area(a: isize, h: isize) -> f64 {\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rs",
    "prompt": "fn special_factorial(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef special_factorial(n: int) -> int:\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n### Explanation\n\nThis program defines a function called `special_factorial` that takes an integer `n` as input and returns an integer as output. The function calculates the special factorial of `n` using a for loop. The special factorial of `n` is the product of factorials of all numbers from 1 to `n`. The function initializes two variables `fact_i` and `special_fact` to 1. It then iterates over all numbers from 1 to `n` and calculates the factorial of each number using the `fact_i` variable. It then multiplies the `fact_i` variable with the `special_fact` variable to calculate the special factorial of `n`. Finally, the function returns the special factorial of `n`.\n\n### Rust version\n\nfn special_factorial(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "language": "rs",
    "prompt": "fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_136_largest_smallest_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\ndef largest_smallest_integers(lst: List[int]) -> Tuple[Optional[int], Optional[int]]:\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n\n### Explanation\n\nThis function takes a list of integers as input and returns a tuple with the largest negative integer and the smallest positive integer in the list. If there are no negative integers in the list, the first element of the tuple is None. If there are no positive integers in the list, the second element of the tuple is None. \n\nThe function first filters the list to get all the negative integers and stores them in a variable called `smallest`. It then filters the list again to get all the positive integers and stores them in a variable called `largest`. Finally, it returns a tuple with the largest negative integer and the smallest positive integer. If there are no negative integers in the list, it returns None as the first element of the tuple. If there are no positive integers in the list, it returns None as the second element of the tuple.\n\n### Rust version\n\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rs",
    "prompt": "fn move_one_ball(arr: Vec<isize>) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n\n### Explanation\n\nThis Python program checks if a list of integers can be sorted by moving only one element to another position in the list. The function `move_one_ball` takes a list of integers as input and returns a boolean value. The function first checks if the list is empty, if it is, the function returns True. The function then sorts the list and stores it in a variable called `sorted_array`. The function then creates an empty list called `my_arr`. The function then finds the minimum value in the input list and stores it in a variable called `min_value`. The function then finds the index of the minimum value in the input list and stores it in a variable called `min_index`. The function then creates a new list called `my_arr` by concatenating the sublist of the input list from the minimum index to the end of the list with the sublist of the input list from the beginning of the list to the minimum index. The function then iterates through the input list and checks if each element in the new list `my_arr` is equal to the corresponding element in the sorted list `sorted_array`. If any element is not equal, the function returns False. If all elements are equal, the function returns True.\n\n### Rust version\n\nfn move_one_ball(arr: Vec<isize>) -> bool {\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rs",
    "prompt": "fn digits(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5), 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n    assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n    assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef digits(n: int) -> int:\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n\n### Explanation\n\nThis program takes an integer as input and returns the product of all the odd digits in the integer. If there are no odd digits, it returns 0. \n\nThe function `digits` takes an integer `n` as input and initializes two variables, `product` and `odd_count`, to 1 and 0 respectively. It then loops through each digit in the string representation of `n`, converts it to an integer, and checks if it is odd. If it is odd, it multiplies it with the current value of `product` and increments `odd_count`. \n\nFinally, if `odd_count` is 0, it returns 0, otherwise it returns `product`.\n\n### Rust version\n\nfn digits(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rs",
    "prompt": "fn fib4(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = fib4;\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 28);\n    assert_eq!(candidate(10), 104);\n    assert_eq!(candidate(12), 386);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef fib4(n: int) -> int:\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n\n### Explanation\n\nThis function returns the nth number in the Fibonacci series, where each number is the sum of the previous four numbers. The function initializes a list with the first four numbers of the series, and then iteratively computes the next number in the series by summing the previous four numbers. The function returns the last number in the list, which is the nth number in the series. \n\n```java\npublic static int fib4(int n) {\n    List<Integer> results = new ArrayList<>(Arrays.asList(0, 0, 2, 0));\n    if (n < 4) {\n        return results.get(n);\n    }\n\n    for (int i = 4; i <= n; i++) {\n        results.add(results.get(results.size() - 1) + results.get(results.size() - 2) + results.get(results.size() - 3) + results.get(results.size() - 4));\n        results.remove(0);\n    }\n\n    return results.get(results.size() - 1);\n}\n```\n\n### Rust version\n\nfn fib4(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "rs",
    "prompt": "fn sort_even(l: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_even(l: List[int]) -> List[int]:\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n\n### Explanation\n\nThis program takes a list of integers as input and returns a new list with the even numbers sorted in ascending order and the odd numbers in their original order. If there are more even numbers than odd numbers, the last even number is appended to the end of the list. \n\nThe function `sort_even` first creates two new lists, `evens` and `odds`, by slicing the input list `l`. The `evens` list contains all even-indexed elements of `l`, while the `odds` list contains all odd-indexed elements of `l`. The `evens` list is then sorted in ascending order using the `sort()` method. \n\nThe function then creates a new empty list `ans` and uses the `zip()` function to iterate over the `evens` and `odds` lists in parallel. For each pair of elements `(e, o)`, the function appends `e` and `o` to `ans` in that order. \n\nFinally, if the length of `evens` is greater than the length of `odds`, the function appends the last element of `evens` to `ans`. The function then returns `ans`.\n\n### Rust version\n\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "rs",
    "prompt": "fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n\n### Explanation\n\nThis Python program defines a function `order_by_points` that takes in a list of integers and returns a new list of integers sorted by the sum of their digits. The function uses a helper function `digits_sum` to calculate the sum of digits of a given integer. The `digits_sum` function first checks if the integer is negative and stores the sign. It then converts the integer to a list of digits and multiplies the first digit by the sign. Finally, it returns the sum of the digits. The `order_by_points` function uses the `sorted` function to sort the input list by the sum of digits of each element. The sorted list is then returned.\n\n### Rust version\n\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rs",
    "prompt": "fn is_happy(s: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_happy(s: str) -> bool:\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n\n### Explanation\n\nThis Python program checks if a string is happy. A string is happy if there are no adjacent characters that are the same. The program returns `True` if the string is happy and `False` otherwise. \n\nThe function `is_happy` takes a string `s` as input and returns a boolean value. The function first checks if the length of the string is less than 3. If the length of the string is less than 3, the function returns `False`. Otherwise, the function checks if there are any adjacent characters that are the same. If there are any adjacent characters that are the same, the function returns `False`. If there are no adjacent characters that are the same, the function returns `True`.\n\n### Rust version\n\nfn is_happy(s: String) -> bool {\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rs",
    "prompt": "fn circular_shift(x: isize, shift: isize) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100, 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12, 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"11\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n\n### Explanation\n\nThis function takes two integer arguments, `x` and `shift`. It then converts `x` to a string and checks if `shift` is greater than the length of the string. If `shift` is greater than the length of the string, it returns the reversed string. Otherwise, it returns the substring of `s` from `len(s) - shift` to the end of the string concatenated with the substring of `s` from the beginning of the string to `len(s) - shift`. \n\nIn Java, the function would look like this:\n\n```java\npublic static String circularShift(int x, int shift) {\n    String s = Integer.toString(x);\n    if (shift > s.length()) {\n        return new StringBuilder(s).reverse().toString();\n    } else {\n        return s.substring(s.length() - shift) + s.substring(0, s.length() - shift);\n    }\n}\n```\n\nNote that in Java, we need to use `Integer.toString(x)` instead of `str(x)` to convert `x` to a string. We also need to use `new StringBuilder(s).reverse().toString()` instead of `s[::-1]` to reverse the string. Finally, we use `s.substring()` instead of slicing to get substrings of `s`.\n\n### Rust version\n\nfn circular_shift(x: isize, shift: isize) -> String {\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rs",
    "prompt": "fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nimport math\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n\n### Explanation\n\nThis Python program takes in a 2D list of integers called `grid` and an integer called `capacity`. It then returns the maximum number of containers needed to fill the grid. The `math.ceil` function is used to round up the result of the division of the sum of each inner list of `grid` by `capacity`. The `sum` function is used to sum the elements of each inner list of `grid`. The `sum` function is called on a list comprehension that iterates through each inner list of `grid`. The `sum` function is called on the result of the `math.ceil` function. The `math.ceil` function is called on the result of the division of the sum of each inner list of `grid` by `capacity`. The `math.ceil` function is used to round up the result of the division of the sum of each inner list of `grid` by `capacity`. The `sum` function is used to sum the elements of each inner list of `grid`. The `sum` function is called on a list comprehension that iterates through each inner list of `grid`. The `sum` function is called on the result of the `math.ceil` function. The `math.ceil` function is called on the result of the division of the sum of each inner list of `grid` by `capacity`. The `math.ceil` function is used to round up the result of the division of the sum of each inner list of `grid` by `capacity`. The `sum` function is used to sum the elements of each inner list of `grid`. The `sum` function is called on a list comprehension that iterates through each inner list of `grid`. The `sum` function is called on the result of the `math.ceil` function. The `math.ceil` function is called on the result of the division of the sum of each inner list of `grid` by `capacity`. The `math.ceil` function is used to round up the result of the division of the sum of each inner list of `grid` by `capacity`. The `sum` function is used to sum the elements of each inner list of `grid`. The `sum` function is called on a list comprehension that iterates through each inner list of `grid`. The `sum` function is called on the result of the `math.ceil` function. The `math.ceil` function is called on the result of the division of the sum of each inner list of `grid` by `capacity`. The `math.ceil` function is used to round up the result of the division of the sum of each inner list of `grid` by `capacity`. The `sum` function is used to sum the elements of each inner list of `grid`. The `sum` function is called on a list comprehension that iterates through each inner list of `grid`. The `sum` function is called on the result of the `math.ceil` function. The `math.ceil` function is called on the result of the division of the sum of each inner list of `grid` by `capacity`. The `math.ceil` function is used to round up the result of the division of the sum of each inner list of `grid` by `capacity`. The `sum` function is used to sum the elements of each inner list of `grid`. The `sum` function is called on a list comprehension that iterates through each inner list of `grid`. The `sum` function is called on the result of the `math.ceil` function. The `math.ceil` function is called on the result of the division of the sum of each inner list of `grid` by `capacity`.\n\n### Rust version\n\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rs",
    "prompt": "fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n### Explanation\n\nThis program takes in a list of float numbers and a threshold, and returns True if any two elements in the list are closer than the threshold. Otherwise, it returns False. \n\nThe program iterates through the list twice, comparing each element with every other element in the list. If the distance between any two elements is less than the threshold, the function returns True. If no two elements are closer than the threshold, the function returns False.\n\n### Rust version\n\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rs",
    "prompt": "fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = numerical_letter_grade;\n    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]);\n    assert_eq!(candidate(vec![1.2]), vec![String::from(\"D+\")]);\n    assert_eq!(candidate(vec![0.5]), vec![String::from(\"D-\")]);\n    assert_eq!(candidate(vec![0.0]), vec![String::from(\"E\")]);\n    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(\"D\"), String::from(\"D-\"), String::from(\"C-\"), String::from(\"B\"), String::from(\"B+\")]);\n    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(\"E\"), String::from(\"D-\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n\n### Explanation\n\nThis Python program takes in a list of numerical grades and returns a list of letter grades. The function `numerical_letter_grade` takes in a list of floats called `grades` and returns a list of strings called `letter_grade`. The function loops through the list of grades and assigns a letter grade based on the numerical grade. If the numerical grade is 4.0, the letter grade is \"A+\". If the numerical grade is greater than 3.7, the letter grade is \"A\". If the numerical grade is greater than 3.3, the letter grade is \"A-\". If the numerical grade is greater than 3.0, the letter grade is \"B+\". If the numerical grade is greater than 2.7, the letter grade is \"B\". If the numerical grade is greater than 2.3, the letter grade is \"B-\". If the numerical grade is greater than 2.0, the letter grade is \"C+\". If the numerical grade is greater than 1.7, the letter grade is \"C\". If the numerical grade is greater than 1.3, the letter grade is \"C-\". If the numerical grade is greater than 1.0, the letter grade is \"D+\". If the numerical grade is greater than 0.7, the letter grade is \"D\". If the numerical grade is greater than 0.0, the letter grade is \"D-\". If the numerical grade is 0.0 or less, the letter grade is \"E\". \n\nHere is the equivalent Java code:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<String> numerical_letter_grade(List<Float> grades) {\n        List<String> letter_grade = new ArrayList<>();\n        for (float gpa : grades) {\n            if (gpa == 4.0) {\n                letter_grade.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letter_grade.add(\"A\");\n            } else if (gpa > 3.3) {\n                letter_grade.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letter_grade.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letter_grade.add(\"B\");\n            } else if (gpa > 2.3) {\n                letter_grade.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letter_grade.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letter_grade.add(\"C\");\n            } else if (gpa > 1.3) {\n                letter_grade.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letter_grade.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letter_grade.add(\"D\");\n            } else if (gpa > 0.0) {\n                letter_grade.add(\"D-\");\n            } else {\n                letter_grade.add(\"E\");\n            }\n        }\n        return letter_grade;\n    }\n\n    public static void main(String[] args) {\n        List<Float> grades = new ArrayList<>();\n        grades.add(3.5f);\n        grades.add(2.0f);\n        grades.add(4.0f);\n        grades.add(1.7f);\n        grades.add(3.3f);\n        List<String> letter_grades = numerical_letter_grade(grades);\n        System.out.println(letter_grades);\n    }\n}\n```\n\nThe Java code is almost identical to the Python\n\n### Rust version\n\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rs",
    "prompt": "fn x_or_y(n: isize, x: isize, y: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = x_or_y;\n    assert_eq!(candidate(7, 34, 12), 34);\n    assert_eq!(candidate(15, 8, 5), 5);\n    assert_eq!(candidate(3, 33, 5212), 33);\n    assert_eq!(candidate(1259, 3, 52), 3);\n    assert_eq!(candidate(7919, -1, 12), -1);\n    assert_eq!(candidate(3609, 1245, 583), 583);\n    assert_eq!(candidate(91, 56, 129), 129);\n    assert_eq!(candidate(6, 34, 1234), 1234);\n    assert_eq!(candidate(1, 2, 0), 0);\n    assert_eq!(candidate(2, 2, 0), 2);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef x_or_y(n: int, x: int, y: int) -> int:\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n\n### Explanation\n\nThis Python program defines a function `x_or_y` that takes in three integer arguments `n`, `x`, and `y`. The function returns `y` if `n` is equal to 1, otherwise it returns `y` if `n` is divisible by any number other than 1 and itself, and `x` otherwise. In Java, the equivalent code would look like this:\n\n```\npublic static int x_or_y(int n, int x, int y) {\n    if (n == 1) {\n        return y;\n    }\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```\n\n### Rust version\n\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rs",
    "prompt": "fn specialFilter(nums: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = specialFilter;\n    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);\n    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);\n    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);\n    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);\n    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count\n\n### Explanation\n\nThis Python program takes a list of integers as input and returns the count of integers that are greater than 10 and have odd digits in the first and last positions. \n\nThe function `specialFilter` takes a list of integers as input and returns an integer. \n\nThe function initializes a variable `count` to 0. \n\nThe function then iterates through each integer in the input list. \n\nFor each integer, the function checks if it is greater than 10. If it is, the function checks if the first and last digits of the integer are odd. \n\nIf both the first and last digits are odd, the function increments the `count` variable by 1. \n\nFinally, the function returns the `count` variable. \n\nTo rewrite this program in Java, you would need to replace the `List[int]` type hint with the appropriate Java syntax for a list of integers, and replace the `def` keyword with the appropriate Java syntax for defining a function. You would also need to replace the `if` statement syntax with the appropriate Java syntax. \n\nHere is an example of how the program might look in Java:\n\n```java\nimport java.util.List;\n\npublic class SpecialFilter {\n    public static int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int num : nums) {\n            if (num > 10) {\n                int[] oddDigits = {1, 3, 5, 7, 9};\n                String numberAsString = Integer.toString(num);\n                if (oddDigits.contains(Character.getNumericValue(numberAsString.charAt(0))) && \n                    oddDigits.contains(Character.getNumericValue(numberAsString.charAt(numberAsString.length() - 1)))) {\n                    count += 1;\n                }\n            }\n        }\n        return count;\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn specialFilter(nums: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rs",
    "prompt": "fn parse_music(music_string: String) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n\n### Explanation\n\nThis 3-line Python program defines a function called `parse_music` that takes a string as input and returns a list of integers. The input string is expected to contain a sequence of musical notes, where each note is represented by a string of characters. The function maps each note string to an integer value using a dictionary called `note_map`, and then returns a list of all the mapped values. The `note_map` dictionary maps the string `'o'` to the integer `4`, the string `'o|'` to the integer `2`, and the string `'.|'` to the integer `1`. The function splits the input string into a list of note strings using the space character as a delimiter, and then filters out any empty strings. Finally, the function maps each non-empty note string to its corresponding integer value using the `note_map` dictionary, and returns a list of all the mapped values.\n\n### Rust version\n\nfn parse_music(music_string: String) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rs",
    "prompt": "fn count_distinct_characters(string: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = count_distinct_characters;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abcde\")), 5);\n    assert_eq!(candidate(String::from(\"abcdecadeCADE\")), 5);\n    assert_eq!(candidate(String::from(\"aaaaAAAAaaaa\")), 1);\n    assert_eq!(candidate(String::from(\"Jerry jERRY JeRRRY\")), 5);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n\n### Explanation\n\nThis 1-line Python program defines a function called `count_distinct_characters` that takes a string as an argument and returns the number of distinct characters in the string. The function first converts the string to lowercase, then creates a set of the characters in the string, and finally returns the length of the set. In other words, it counts the number of unique characters in the string, ignoring case.\n\n### Rust version\n\nfn count_distinct_characters(string: String) -> isize {\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rs",
    "prompt": "fn digitSum(s: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = digitSum;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abAB\")), 131);\n    assert_eq!(candidate(String::from(\"abcCd\")), 67);\n    assert_eq!(candidate(String::from(\"helloE\")), 69);\n    assert_eq!(candidate(String::from(\"woArBld\")), 131);\n    assert_eq!(candidate(String::from(\"aAaaaXa\")), 153);\n    assert_eq!(candidate(String::from(\" How are yOu?\")), 151);\n    assert_eq!(candidate(String::from(\"You arE Very Smart\")), 327);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef digitSum(s: str) -> int:\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n\n### Explanation\n\nThis 1-line Python program defines a function called `digitSum` that takes a string as input and returns an integer. The function first checks if the input string is empty, and if it is, it returns 0. Otherwise, it computes the sum of the ASCII values of all uppercase characters in the string, and returns that sum.\n\n### Rust version\n\nfn digitSum(s: String) -> isize {\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rs",
    "prompt": "fn sum_squares(lst: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1, 2, 3]), 6);\n    assert_eq!(candidate(vec![1, 4, 9]), 14);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n    assert_eq!(candidate(vec![0]), 0);\n    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);\n    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);\n    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);\n    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[int]) -> int:\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n\n### Explanation\n\nThis function takes in a list of integers and returns the sum of the squares of the integers in the list. If the index of the integer is divisible by 3, the square of the integer is added to the result list. If the index of the integer is divisible by 4 and not divisible by 3, the cube of the integer is added to the result list. Otherwise, the integer itself is added to the result list. Finally, the sum of the result list is returned.\n\n### Rust version\n\nfn sum_squares(lst: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rs",
    "prompt": "fn count_up_to(n: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = count_up_to;\n    assert_eq!(candidate(5), vec![2, 3]);\n    assert_eq!(candidate(6), vec![2, 3, 5]);\n    assert_eq!(candidate(7), vec![2, 3, 5]);\n    assert_eq!(candidate(10), vec![2, 3, 5, 7]);\n    assert_eq!(candidate(0), Vec::<isize>::new());\n    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    assert_eq!(candidate(1), Vec::<isize>::new());\n    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef count_up_to(n: int) -> List[int]:\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n### Explanation\n\nThis Python program generates a list of prime numbers up to a given integer `n`. The function `count_up_to` takes an integer `n` as input and returns a list of all prime numbers up to `n`. The program first initializes an empty list called `primes`. It then loops through all integers between 2 and `n` using the `range` function. For each integer `i`, it checks if it is prime by looping through all integers between 2 and `i-1`. If `i` is divisible by any integer between 2 and `i-1`, it is not prime and the program sets the `is_prime` flag to `False`. If `i` is not divisible by any integer between 2 and `i-1`, it is prime and the program appends it to the `primes` list. Finally, the program returns the `primes` list.\n\n### Rust version\n\nfn count_up_to(n: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rs",
    "prompt": "fn sum_squares(lst: Vec<f64>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);\n    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);\n    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);\n    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);\n    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);\n    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);\n    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n    assert_eq!(candidate(vec![0.0]), 0);\n    assert_eq!(candidate(vec![-1.0]), 1);\n    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n\n### Explanation\n\nThis program takes in a list of floats, and returns the sum of the squares of each element in the list. The program first imports the math module, which is used to perform mathematical operations. It then initializes a variable called squared to 0. The program then iterates through each element in the list, and adds the square of the ceiling of that element to the squared variable. Finally, the program returns the squared variable. To rewrite this program in Java, you would need to import the Math class, and use a for loop to iterate through the list and perform the necessary calculations. You would also need to declare the list as an array of floats. \n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.lang.Math;\n\npublic class SumSquares {\n    public static int sumSquares(List<Float> lst) {\n        int squared = 0;\n        for (float i : lst) {\n            squared += Math.ceil(i) * Math.ceil(i);\n        }\n        return squared;\n    }\n\n    public static void main(String[] args) {\n        List<Float> lst = new ArrayList<Float>();\n        lst.add(1.5f);\n        lst.add(2.3f);\n        lst.add(3.7f);\n        lst.add(4.1f);\n        lst.add(5.9f);\n        System.out.println(sumSquares(lst));\n    }\n}\n```\n\n### Rust version\n\nfn sum_squares(lst: Vec<f64>) -> isize {\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rs",
    "prompt": "fn unique(l: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = unique;\n    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    return sorted(list(set(l)))\n\n### Explanation\n\nThis 3-line Python program defines a function called `unique` that takes a list of integers as input and returns a new list with the same integers, but with duplicates removed and sorted in ascending order. The function first converts the input list to a set to remove duplicates, then converts the set back to a list and sorts it. To rewrite this program in Java, you would need to use the `List` interface from the `java.util` package, and write a function that takes a `List<Integer>` as input and returns a new `List<Integer>` with duplicates removed and sorted in ascending order. You would also need to use a `HashSet` to remove duplicates, and a `TreeSet` to sort the elements. Here's an example implementation in Java:\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static List<Integer> unique(List<Integer> l) {\n        Set<Integer> set = new HashSet<>(l);\n        List<Integer> result = new ArrayList<>(set);\n        Collections.sort(result);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> l = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5);\n        List<Integer> result = unique(l);\n        System.out.println(result);\n    }\n}\n```\n\nThis Java program defines a `Main` class with a `unique` method that takes a `List<Integer>` as input and returns a new `List<Integer>` with duplicates removed and sorted in ascending order. The method first creates a `HashSet` from the input list to remove duplicates, then creates a new `ArrayList` from the set and sorts it using the `Collections.sort` method. The `main` method creates a sample input list, calls the `unique` method to get the result, and prints it to the console. The output should be `[1, 2, 3, 4, 5, 6, 9]`.<|im_end|>\n\n### Rust version\n\nfn unique(l: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rs",
    "prompt": "fn fib(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10), 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n    assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef fib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n### Explanation\n\nThis Python program defines a function `fib` that takes an integer `n` as input and returns the `n`-th number in the Fibonacci sequence. The Fibonacci sequence is a sequence of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. The function uses recursion to calculate the `n`-th number in the sequence. If `n` is 0, the function returns 0. If `n` is 1, the function returns 1. Otherwise, the function returns the sum of the `n-1`-th and `n-2`-th numbers in the sequence.\n\n### Rust version\n\nfn fib(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rs",
    "prompt": "fn fizz_buzz(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = fizz_buzz;\n    assert_eq!(candidate(50), 0);\n    assert_eq!(candidate(78), 2);\n    assert_eq!(candidate(79), 3);\n    assert_eq!(candidate(100), 3);\n    assert_eq!(candidate(200), 6);\n    assert_eq!(candidate(4000), 192);\n    assert_eq!(candidate(10000), 639);\n    assert_eq!(candidate(100000), 8026);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef fizz_buzz(n: int) -> int:\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n\n### Explanation\n\nThis Python program defines a function `fizz_buzz` that takes an integer `n` as input and returns the number of times the digit `7` appears in the concatenation of all numbers between 0 and `n` that are divisible by either 11 or 13. \n\nThe function first creates an empty list `ns` and then iterates over all numbers between 0 and `n` using a for loop. For each number `i`, it checks if `i` is divisible by either 11 or 13 using the modulo operator `%`. If `i` is divisible by either 11 or 13, it appends `i` to the list `ns`. \n\nNext, the function creates a string `s` by joining all elements of `ns` as strings. It then initializes a variable `ans` to 0 and iterates over all characters in the string `s`. For each character `c`, it checks if `c` is equal to the character `'7'`. If `c` is equal to `'7'`, it increments the variable `ans` by 1. Finally, the function returns the value of `ans`.\n\n### Rust version\n\nfn fizz_buzz(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rs",
    "prompt": "fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n### Explanation\n\nThis Python program takes in a class name and a list of string extensions. It then loops through the list of extensions and calculates the difference between the number of uppercase and lowercase letters in each extension. The extension with the highest difference is then returned with the class name as a prefix. \n\nThe equivalent Java code would be:\n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static String Strongest_Extension(String class_name, List<String> extensions) {\n        String strong = extensions.get(0);\n        int my_val = countUppercase(strong) - countLowercase(strong);\n        for (String s : extensions) {\n            int val = countUppercase(s) - countLowercase(s);\n            if (val > my_val) {\n                strong = s;\n                my_val = val;\n            }\n        }\n\n        return class_name + \".\" + strong;\n    }\n\n    private static int countUppercase(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static int countLowercase(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        List<String> extensions = List.of(\"ext1\", \"ext2\", \"ext3\");\n        System.out.println(Strongest_Extension(\"ClassName\", extensions));\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rs",
    "prompt": "fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n\n### Explanation\n\nThis Python program finds the closest pair of elements in a list of floating point numbers. It does this by iterating through the list twice, comparing each element with every other element, and keeping track of the closest pair found so far. The result is returned as a tuple of the two closest elements. To rewrite this program in Java, you would need to replace the Python-specific syntax with equivalent Java syntax, such as using an ArrayList instead of a List, and using a for loop instead of a for-each loop. You would also need to change the function signature to use Java syntax for specifying the return type. \n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Arrays;\n\npublic class ClosestElements {\n    public static void main(String[] args) {\n        List<Double> numbers = new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0));\n        System.out.println(findClosestElements(numbers));\n    }\n\n    public static Tuple<Double, Double> findClosestElements(List<Double> numbers) {\n        Tuple<Double, Double> closestPair = null;\n        Double distance = null;\n\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = 0; j < numbers.size(); j++) {\n                if (i != j) {\n                    Double elem = numbers.get(i);\n                    Double elem2 = numbers.get(j);\n                    if (distance == null) {\n                        distance = Math.abs(elem - elem2);\n                        closestPair = new Tuple<>(Math.min(elem, elem2), Math.max(elem, elem2));\n                    } else {\n                        Double newDistance = Math.abs(elem - elem2);\n                        if (newDistance < distance) {\n                            distance = newDistance;\n                            closestPair = new Tuple<>(Math.min(elem, elem2), Math.max(elem, elem2));\n                        }\n                    }\n                }\n            }\n        }\n\n        return closestPair;\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rs",
    "prompt": "fn valid_date(date: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef valid_date(date: str) -> bool:\n    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n\n### Explanation\n\nThis Python program checks if a date is valid. It takes a string as input and returns a boolean value. If the date is valid, it returns True, otherwise it returns False. The date is considered valid if it is in the format \"MM-DD-YYYY\" and the month, day and year are valid. The month must be between 1 and 12, the day must be between 1 and 31 (depending on the month) and the year can be any positive integer. The program first strips the input string of any whitespace characters. It then splits the string into three parts using the '-' character as a separator. It then converts each part into an integer and checks if the month, day and year are valid. If any of the checks fail, the program returns False. If all checks pass, it returns True. \n\n```java\npublic static boolean validDate(String date) {\n    try {\n        date = date.trim();\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n        if (month < 1 || month > 12) {\n            return false;\n        }\n        if (month == 2 && (day < 1 || day > 29)) {\n            return false;\n        }\n        if (month == 4 || month == 6 || month == 9 || month == 11) {\n            if (day < 1 || day > 30) {\n                return false;\n            }\n        } else {\n            if (day < 1 || day > 31) {\n                return false;\n            }\n        }\n    } catch (Exception e) {\n        return false;\n    }\n    return true;\n}\n```\n\n### Rust version\n\nfn valid_date(date: String) -> bool {\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rs",
    "prompt": "fn add(x: isize, y: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(0, 1), 1);\n    assert_eq!(candidate(1, 0), 1);\n    assert_eq!(candidate(2, 3), 5);\n    assert_eq!(candidate(5, 7), 12);\n    assert_eq!(candidate(7, 5), 12);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef add(x: int, y: int) -> int:\n    return x + y\n\n### Explanation\n\nThis 3-line Python program defines a function called `add` which takes two integer arguments `x` and `y` and returns their sum. The function is defined using Python's type annotations to specify the types of the arguments and the return value. To rewrite this program in Java, you would need to define a method with the same name, arguments, and return type, and implement it to return the sum of the two arguments. Java does not have type annotations, so you would need to rely on comments or other documentation to specify the types of the arguments and return value. Here is an example Java implementation:\n\n```java\npublic static int add(int x, int y) {\n    return x + y;\n}\n```\n\nNote that Java does not require the `static` keyword, but it is commonly used for utility methods like this one. Also note that Java uses camelCase for method names, whereas Python uses snake_case. Finally, Java does not use the `->` syntax for type annotations, but you could use Javadoc comments to specify the types:\n\n```java\n/**\n * Adds two integers and returns their sum.\n *\n * @param x the first integer\n * @param y the second integer\n * @return the sum of x and y\n */\npublic static int add(int x, int y) {\n    return x + y;\n}\n```\n\nThis is not strictly necessary, but it can be helpful for documentation and code readability.<|im_end|>\n\n### Rust version\n\nfn add(x: isize, y: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rs",
    "prompt": "fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n### Explanation\n\nThis program takes in a list of integers and returns True if there are three integers in the list that sum up to zero. The function `triples_sum_to_zero` takes in a list of integers `l` and returns a boolean value. The function uses three nested loops to iterate over all possible combinations of three integers in the list. If the sum of the three integers is zero, the function returns True. If no such combination is found, the function returns False.\n\n### Rust version\n\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rs",
    "prompt": "fn largest_divisor(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3), 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n    assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef largest_divisor(n: int) -> int:\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n\n### Explanation\n\nThis 3-line program defines a function called `largest_divisor` that takes an integer `n` as input and returns the largest divisor of `n`. The function iterates over all integers from `n-1` down to `1` (inclusive) and returns the first integer that divides `n` without a remainder. If `n` is `0`, the function returns `0`. If `n` is `1`, the function returns `1`. If `n` is negative, the function returns `-1`.\n\n### Rust version\n\nfn largest_divisor(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rs",
    "prompt": "fn sort_numbers(numbers: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sort_numbers;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"three\")), String::from(\"three\"));\n    assert_eq!(candidate(String::from(\"three five nine\")), String::from(\"three five nine\"));\n    assert_eq!(candidate(String::from(\"five zero four seven nine eight\")), String::from(\"zero four five seven eight nine\"));\n    assert_eq!(candidate(String::from(\"six five four three two one zero\")), String::from(\"zero one two three four five six\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n\n### Explanation\n\nThis Python program takes in a string of numbers in English and returns a sorted string of numbers in English. It does this by first creating a dictionary that maps the English words for numbers to their integer values. It then splits the input string into a list of individual words, filters out any empty strings, and sorts the remaining words based on their integer values. Finally, it joins the sorted list of words back into a string and returns it. To rewrite this program in Java, you would need to create a similar dictionary mapping English words to integer values, split the input string into an array of individual words, filter out any empty strings, sort the remaining words based on their integer values, and then join the sorted array of words back into a string. You would also need to specify the return type of the function as a string. \n\n```java\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SortNumbers {\n    public static String sortNumbers(String numbers) {\n        Map<String, Integer> valueMap = new HashMap<>();\n        valueMap.put(\"zero\", 0);\n        valueMap.put(\"one\", 1);\n        valueMap.put(\"two\", 2);\n        valueMap.put(\"three\", 3);\n        valueMap.put(\"four\", 4);\n        valueMap.put(\"five\", 5);\n        valueMap.put(\"six\", 6);\n        valueMap.put(\"seven\", 7);\n        valueMap.put(\"eight\", 8);\n        valueMap.put(\"nine\", 9);\n\n        String[] words = numbers.split(\" \");\n        Arrays.sort(words, (a, b) -> Integer.compare(valueMap.get(a), valueMap.get(b)));\n\n        return String.join(\" \", words);\n    }\n}\n```\n\n### Rust version\n\nfn sort_numbers(numbers: String) -> String {\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rs",
    "prompt": "fn smallest_change(arr: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef smallest_change(arr: List[int]) -> int:\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n\n### Explanation\n\nThis Python program takes in a list of integers and returns the number of times an element in the list needs to be changed to make the list a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. \n\nThe function `smallest_change` takes in a list of integers and returns an integer. It first initializes a variable `ans` to 0. It then loops through the list of integers from the beginning to the middle of the list. For each element in the list, it checks if the element is the same as the element at the corresponding position from the end of the list. If the elements are not the same, it increments the `ans` variable by 1. Finally, it returns the `ans` variable, which is the number of changes needed to make the list a palindrome.\n\nTo rewrite this program in Java, you would need to replace the `List[int]` type hint with `List<Integer>` and change the `range` function to a `for` loop that iterates over the indices of the list. Here is the equivalent Java code:\n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static int smallestChange(List<Integer> arr) {\n        int ans = 0;\n        for (int i = 0; i < arr.size() / 2; i++) {\n            if (!arr.get(i).equals(arr.get(arr.size() - i - 1))) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn smallest_change(arr: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rs",
    "prompt": "fn below_threshold(l: Vec<isize>, t: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = below_threshold;\n    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef below_threshold(l: List[int], t: int) -> bool:\n    for e in l:\n        if e >= t:\n            return False\n    return True\n\n### Explanation\n\nThis Python program defines a function called `below_threshold` that takes in a list of integers `l` and an integer `t`. The function returns `True` if all the elements in the list are less than `t`, and `False` otherwise. \n\nThe function iterates through each element in the list and checks if it is greater than or equal to `t`. If it is, the function immediately returns `False`. If the function has iterated through the entire list without returning `False`, then it returns `True`.\n\n### Rust version\n\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rs",
    "prompt": "fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef prod_signs(arr: List[int]) -> Optional[int]:\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n\n### Explanation\n\nThis Python program takes in a list of integers and returns the product of the signs of the integers in the list multiplied by the sum of the absolute values of the integers in the list. If the list is empty, the function returns None. \n\nThe function first checks if the list is empty. If it is, it returns None. If it is not, it calculates the product of the signs of the integers in the list. If the list contains a 0, the product is 0. If the list does not contain a 0, the product is -1 raised to the power of the number of negative integers in the list. \n\nThe function then multiplies the product of the signs of the integers in the list by the sum of the absolute values of the integers in the list and returns the result. \n\nTo rewrite this program in Java, you would need to declare the function and its parameters, import the necessary libraries, and translate the logic of the program into Java syntax. \n\n```java\nimport java.util.List;\nimport java.util.Optional;\n\npublic class Main {\n    public static Optional<Integer> prodSigns(List<Integer> arr) {\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n        int prod = 0;\n        if (!arr.contains(0)) {\n            int negatives = 0;\n            for (int i : arr) {\n                if (i < 0) {\n                    negatives++;\n                }\n            }\n            prod = (int) Math.pow(-1, negatives);\n        }\n        int sum = 0;\n        for (int i : arr) {\n            sum += Math.abs(i);\n        }\n        return Optional.of(prod * sum);\n    }\n}\n```\n\n### Rust version\n\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rs",
    "prompt": "fn modp(n: isize, p: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef modp(n: int, p: int) -> int:\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n\n### Explanation\n\nThis Python program defines a function `modp(n: int, p: int) -> int` that takes two integer arguments, `n` and `p`, and returns an integer. The function initializes a variable `ret` to 1, and then loops `n` times, each time multiplying `ret` by 2 and taking the result modulo `p`. The final value of `ret` is returned.\n\n### Rust version\n\nfn modp(n: isize, p: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rs",
    "prompt": "fn count_upper(s: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef count_upper(s: str) -> int:\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n\n### Explanation\n\nThis program takes a string as input and returns the number of uppercase vowels in the string. The function `count_upper` first initializes a counter variable `count` to 0. It then loops through the string `s` in steps of 2, checking if the character at the current index is an uppercase vowel. If it is, it increments the counter. Finally, it returns the count of uppercase vowels in the string.\n\n### Rust version\n\nfn count_upper(s: String) -> isize {\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rs",
    "prompt": "fn multiply(a: isize, b: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef multiply(a: int, b: int) -> int:\n    return abs(a % 10) * abs(b % 10)\n\n### Explanation\n\nThis Python program defines a function called `multiply` that takes two integer arguments `a` and `b`. The function returns the product of the absolute values of the last digits of `a` and `b`. \n\nFor example, if `a` is 123 and `b` is 456, the function will return 18, which is the product of 3 and 6. \n\nTo rewrite the program in Java, you would define a function with the same name and arguments, and use the `Math.abs()` method to get the absolute value of the last digit of each argument. You would then return the product of these values. \n\nHere's an example implementation in Java:\n\n```\npublic static int multiply(int a, int b) {\n    int lastDigitA = Math.abs(a % 10);\n    int lastDigitB = Math.abs(b % 10);\n    return lastDigitA * lastDigitB;\n}\n```\n\n### Rust version\n\nfn multiply(a: isize, b: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rs",
    "prompt": "fn unique_digits(x: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = unique_digits;\n    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);\n    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());\n    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);\n    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n\n### Explanation\n\nThis Python program takes in a list of integers and returns a sorted list of integers that have only odd digits. The function `unique_digits` takes in a list of integers `x` and returns a list of integers `odd_digit_elements` that have only odd digits. The function iterates over each integer in the input list `x` and checks if each digit in the integer is odd. If all the digits in the integer are odd, then the integer is added to the `odd_digit_elements` list. Finally, the `odd_digit_elements` list is sorted and returned.\n\n### Rust version\n\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "rs",
    "prompt": "fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef will_it_fly(q: List[int], w: int) -> bool:\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n\n### Explanation\n\nThis program takes in a list of integers `q` and an integer `w`. It returns `True` if the sum of the integers in `q` is less than or equal to `w` and the list is a palindrome (meaning it reads the same forwards and backwards), otherwise it returns `False`. \n\nThe function `will_it_fly` first checks if the sum of the integers in `q` is greater than `w`. If it is, it returns `False`. If not, it sets two pointers `i` and `j` to the beginning and end of the list, respectively. It then iterates through the list, comparing the elements at `i` and `j`. If they are not equal, it returns `False`. If they are equal, it increments `i` and decrements `j` and continues until `i` is greater than or equal to `j`. If it makes it through the loop without returning `False`, it returns `True`.\n\n### Rust version\n\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rs",
    "prompt": "fn is_multiply_prime(a: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_multiply_prime;\n    assert_eq!(candidate(5), false);\n    assert_eq!(candidate(30), true);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(125), true);\n    assert_eq!(candidate(105), true);\n    assert_eq!(candidate(126), false);\n    assert_eq!(candidate(729), false);\n    assert_eq!(candidate(891), false);\n    assert_eq!(candidate(1001), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef is_multiply_prime(a: int) -> bool:\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n\n### Explanation\n\nThis program checks if a number `a` is a multiple of three prime numbers in the range of 2 to 100. The function `is_multiply_prime` takes an integer `a` as input and returns a boolean value. The function `is_prime` is a helper function that checks if a number is prime. The program first checks if `i`, `j`, and `k` are prime numbers, then checks if their product is equal to `a`. If the product is equal to `a`, the function returns `True`. If the program has checked all possible combinations of prime numbers and none of them multiply to `a`, the function returns `False`.\n\n### Rust version\n\nfn is_multiply_prime(a: isize) -> bool {\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rs",
    "prompt": "fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n\n### Explanation\n\nThis Python program defines a function called `maximum` that takes in a list of integers `arr` and an integer `k`. The function returns the `k` largest elements of the list `arr`. If `k` is zero, the function returns an empty list. The function first sorts the list `arr` in ascending order and then returns the last `k` elements of the sorted list.\n\n### Rust version\n\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rs",
    "prompt": "fn skjkasdkd(lst: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n### Explanation\n\nThis Python program takes a list of integers as input and returns the sum of the digits of the largest prime number in the list. It starts by defining a helper function `isPrime` that checks whether a given number is prime or not. It then initializes two variables `maxx` and `i` to 0 and iterates over the input list. For each element in the list, it checks if it is greater than `maxx` and if it is prime. If both conditions are satisfied, it updates `maxx` to the current element. Finally, it calculates the sum of the digits of `maxx` and returns the result. \n\nTo rewrite this program in Java, you would need to replace the `List[int]` type hint with `List<Integer>` and use the appropriate syntax for defining functions and iterating over lists in Java. You would also need to import the `java.util.List` class. Here's an example Java implementation:\n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static int skjkasdkd(List<Integer> lst) {\n        int maxx = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) > maxx && isPrime(lst.get(i))) {\n                maxx = lst.get(i);\n            }\n        }\n        int result = 0;\n        while (maxx > 0) {\n            result += maxx % 10;\n            maxx /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> lst = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        int result = skjkasdkd(lst);\n        System.out.println(result); // prints 7\n    }\n}\n```\n\nNote that the Java implementation uses a slightly different approach for calculating the sum of the digits of `maxx`. Instead of converting `maxx` to a string and iterating over its digits, it uses a while loop to extract the digits one by one and add them to `result`. This is because Java does not have a built-in method for iterating over the digits of an integer. The Java implementation also includes a `main` method for testing the `skjkasdkd` function. \n\nHope this helps! Let me know if you have any questions.<|im_end|>\n\n### Rust version\n\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rs",
    "prompt": "fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n\n### Explanation\n\nThis Python program takes two lists of strings as input and returns the list with the smallest total length. The function `total_match` takes two lists of strings `lst1` and `lst2` as input and returns the list with the smallest total length. The function first calculates the total length of all strings in `lst1` and `lst2` and then returns the list with the smallest total length. If the total length of `lst1` is less than or equal to the total length of `lst2`, then `lst1` is returned, otherwise `lst2` is returned.\n\n### Rust version\n\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "language": "rs",
    "prompt": "fn string_to_md5(text: String) -> Option<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_162_string_to_md5.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = string_to_md5;\n    assert_eq!(candidate(String::from(\"Hello world\")), Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert_eq!(candidate(String::from(\"\")), None);\n    assert_eq!(candidate(String::from(\"A B C\")), Some(String::from(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert_eq!(candidate(String::from(\"password\")), Some(String::from(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import Optional\n\ndef string_to_md5(text: str) -> Optional[str]:\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n\n### Explanation\n\nThis 5-line Python program defines a function `string_to_md5` that takes a string as input and returns an optional string. If the input string is not `None`, the function returns the MD5 hash of the input string as a hexadecimal string. If the input string is `None`, the function returns `None`.\n\nThe function makes use of the `hashlib` module in Python's standard library to compute the MD5 hash of the input string. The `encode` method is used to convert the input string to a bytes object that can be passed to the `hashlib.md5` function. The `hexdigest` method is used to convert the resulting hash value to a hexadecimal string.\n\nTo rewrite this program in Java, you would need to use a library that provides an implementation of the MD5 hash algorithm, such as the `java.security.MessageDigest` class in the Java standard library. You would also need to handle the case where the input string is `null` instead of `None`. Here is an example of how the program could be rewritten in Java:\n\n```java\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"hello world\";\n        String md5 = stringToMd5(text);\n        System.out.println(md5);\n    }\n\n    public static String stringToMd5(String text) {\n        if (text == null) {\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] digest = md.digest(text.getBytes(\"UTF-8\"));\n            StringBuilder sb = new StringBuilder();\n            for (byte b : digest) {\n                sb.append(String.format(\"%02x\", b & 0xff));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\nThis Java program defines a `stringToMd5` method that takes a string as input and returns a string. If the input string is `null`, the method returns `null`. Otherwise, the method computes the MD5 hash of the input string using the `java.security.MessageDigest` class, and returns the hash value as a hexadecimal string. The `getBytes` method is used to convert the input string to a byte array that can be passed to the `MessageDigest.digest` method. The `StringBuilder` class is used to construct the hexadecimal string representation of the hash value. The `String.format` method is used to format each byte of the hash value as a two-digit hexadecimal number. The `&` operator is used to ensure that the byte value is treated as an unsigned integer. The `RuntimeException` is thrown if the MD5 algorithm or the UTF-8 encoding is not supported by the system. The `main` method is used to test the `stringToMd5` method with a sample input string. The output of the program should be the same as the output of the original Python program when run with the same input string.<|im_end|>\n\n### Rust version\n\nfn string_to_md5(text: String) -> Option<String> {\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rs",
    "prompt": "fn car_race_collision(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef car_race_collision(n: int) -> int:\n    return n**2\n\n### Explanation\n\nThis 1-line Python program defines a function called `car_race_collision` that takes an integer `n` as input and returns the square of `n`.\n\n### Rust version\n\nfn car_race_collision(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rs",
    "prompt": "fn is_simple_power(x: isize, n: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef is_simple_power(x: int, n: int) -> bool:\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x)\n\n### Explanation\n\nThis Python program checks if an integer `x` is a power of another integer `n`. It does this by checking if `x` is equal to `n` raised to some power. The function `is_simple_power` takes two arguments, `x` and `n`, and returns a boolean value indicating whether `x` is a power of `n`. The function first checks if `n` is equal to 1, and if so, returns True if `x` is also equal to 1. If `n` is not equal to 1, the function initializes a variable `power` to 1 and enters a while loop that multiplies `power` by `n` until `power` is greater than or equal to `x`. If `power` is equal to `x`, the function returns True, indicating that `x` is a power of `n`. If `power` is greater than `x`, the function returns False, indicating that `x` is not a power of `n`.\n\n### Rust version\n\nfn is_simple_power(x: isize, n: isize) -> bool {\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rs",
    "prompt": "fn encode(message: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef encode(message: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n\n### Explanation\n\nThis function takes in a string `message` and returns a string. It first creates a string `vowels` containing all vowels in both uppercase and lowercase. It then creates a dictionary `vowels_replace` that maps each vowel to the vowel that is two characters after it in the ASCII table. It then swaps the case of all characters in `message` using the `swapcase()` method. Finally, it replaces each vowel in the swapped message with the corresponding vowel from the `vowels_replace` dictionary, and returns the resulting string.\n\n### Rust version\n\nfn encode(message: String) -> String {\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rs",
    "prompt": "fn incr_list(l: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = incr_list;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);\n    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef incr_list(l: List[int]) -> List[int]:\n    return [(e + 1) for e in l]\n\n### Explanation\n\nThis 3-line Python program defines a function called `incr_list` that takes a list of integers as input and returns a new list where each element is incremented by 1. The function uses a list comprehension to create the new list. The `typing` module is used to specify the types of the input and output parameters. To rewrite this program in Java, you would need to define a method that takes an array of integers as input and returns a new array where each element is incremented by 1. You would also need to specify the types of the input and output parameters using the appropriate syntax in Java.\n\n```java\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int[] newArr = incrArray(arr);\n        System.out.println(Arrays.toString(newArr));\n    }\n\n    public static int[] incrArray(int[] arr) {\n        int[] newArr = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            newArr[i] = arr[i] + 1;\n        }\n        return newArr;\n    }\n}\n```\n\nThe Java version of the program defines a `Main` class with a `main` method that creates an array of integers, calls the `incrArray` method to increment each element of the array, and prints the resulting array. The `incrArray` method takes an array of integers as input, creates a new array of the same length, and uses a `for` loop to iterate over the elements of the input array, incrementing each element by 1 and storing the result in the corresponding position of the new array. The method then returns the new array. The `Arrays.toString` method is used to convert the array to a string representation that can be printed to the console. The `public static` keywords are used to specify that the method can be called from outside the class without creating an instance of the class. The `int[]` syntax is used to specify that the method returns an array of integers, and the `(int[] arr)` syntax is used to specify that the method takes an array of integers as input.\n\n### Rust version\n\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rs",
    "prompt": "fn flip_case(string: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")), String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef flip_case(string: str) -> str:\n    return string.swapcase()\n\n### Explanation\n\nThis 1-line Python program defines a function called \"flip_case\" that takes a string as input and returns the same string with all uppercase characters converted to lowercase and vice versa. The \"swapcase()\" method is used to achieve this. To rewrite this program in Java, you would need to define a function with the same name and input/output types, and use the \"toUpperCase()\" and \"toLowerCase()\" methods to swap the case of each character in the string. \n\n```java\npublic static String flip_case(String string) {\n    StringBuilder sb = new StringBuilder();\n    for (char c : string.toCharArray()) {\n        if (Character.isUpperCase(c)) {\n            sb.append(Character.toLowerCase(c));\n        } else {\n            sb.append(Character.toUpperCase(c));\n        }\n    }\n    return sb.toString();\n}\n```<|im_end|>\n\n### Rust version\n\nfn flip_case(string: String) -> String {\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rs",
    "prompt": "fn vowels_count(s: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef vowels_count(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n\n### Explanation\n\nThis function takes a string as input and returns the number of vowels in the string. It first initializes a string containing all vowels in both uppercase and lowercase. It then uses the `sum()` function to count the number of characters in the input string that are in the `vowels` string. Finally, it checks if the last character in the input string is 'y' or 'Y', and if so, it increments the vowel count by 1. The function then returns the total vowel count. To rewrite this program in Java, you would need to declare a function that takes a string as input and returns an integer, and then use a loop to iterate over each character in the string and check if it is a vowel. You would also need to add a conditional statement to check if the last character is 'y' or 'Y'. \n\n```java\npublic static int vowelsCount(String s) {\n    String vowels = \"aeiouAEIOU\";\n    int n_vowels = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (vowels.indexOf(s.charAt(i)) != -1) {\n            n_vowels++;\n        }\n    }\n    if (s.charAt(s.length() - 1) == 'y' || s.charAt(s.length() - 1) == 'Y') {\n        n_vowels++;\n    }\n    return n_vowels;\n}\n```\n\n### Rust version\n\nfn vowels_count(s: String) -> isize {\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "rs",
    "prompt": "fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef sorted_list_sum(lst: List[str]) -> List[str]:\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n\n### Explanation\n\nThis Python program takes in a list of strings and returns a new list of strings that are sorted by length and only include strings with an even number of characters. \n\nTo rewrite this program in Java, you would need to import the List class from the java.util package and use the Collections.sort() method to sort the list. You would also need to use a for loop to iterate over the list and an if statement to check if the length of each string is even. Finally, you would use the Collections.sort() method again to sort the new list by length. \n\nHere is an example of what the Java code might look like:\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class SortedListSum {\n    public static List<String> sortedListSum(List<String> lst) {\n        Collections.sort(lst);\n        List<String> newLst = new ArrayList<String>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                newLst.add(str);\n            }\n        }\n        Collections.sort(newLst, (a, b) -> a.length() - b.length());\n        return newLst;\n    }\n}<|im_end|>\n\n### Rust version\n\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "rs",
    "prompt": "fn words_string(s: String) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = words_string;\n    assert_eq!(candidate(String::from(\"Hi, my name is John\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]);\n    assert_eq!(candidate(String::from(\"One, two, three, four, five, six\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"Hi, my name\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\")]);\n    assert_eq!(candidate(String::from(\"One,, two, three, four, five, six,\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"ahmed     , gamal\")), vec![String::from(\"ahmed\"), String::from(\"gamal\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n\n### Explanation\n\nThis Python program takes a string as input and returns a list of words in the string. The function `words_string` first checks if the input string is empty, and if it is, returns an empty list. If the input string is not empty, the function creates an empty list `s_list`, and iterates over each character in the input string. If the character is a comma, the function appends a space to `s_list`, otherwise it appends the character. The function then joins `s_list` into a single string, and splits the string into a list of words using the `split()` method.\n\n### Rust version\n\nfn words_string(s: String) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rs",
    "prompt": "fn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3, 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4, 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1, 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2, 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2, 2, 10), -1.0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef triangle_area(a: int, b: int, c: int) -> float:\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n\n### Explanation\n\nThis function takes three integer arguments, a, b, and c, representing the lengths of the sides of a triangle. If the sum of any two sides is less than or equal to the length of the third side, the function returns -1. Otherwise, it calculates the area of the triangle using Heron's formula and returns the result rounded to two decimal places.\n\n### Rust version\n\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rs",
    "prompt": "use std::collections::HashMap;\n\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                continue\n        return state == \"upper\" or state == \"lower\"\n\n### Explanation\n\nThis Python program checks if all keys in a dictionary are in the same case. If all keys are in uppercase or all keys are in lowercase, the function returns True. Otherwise, it returns False. \n\nThe function takes a dictionary as an argument and iterates through all keys. If the key is not a string, the function returns False. If the key is a string, the function checks if the first key is uppercase or lowercase. If the first key is uppercase, the function sets the state to \"upper\". If the first key is lowercase, the function sets the state to \"lower\". If the next key is not in the same case as the first key, the function sets the state to \"mixed\" and returns False. If all keys are in the same case, the function returns True. \n\nTo rewrite this program in Java, you would need to replace the type hints with the appropriate Java types. You would also need to replace the \"isinstance\" function with an equivalent Java function. Finally, you would need to replace the \"isupper\" and \"islower\" functions with equivalent Java functions. \n\nHere is an example of how you could rewrite this program in Java:\n\n```java\nimport java.util.Map;\n\npublic class CheckDictCase {\n    public static boolean checkDictCase(Map<String, String> dict) {\n        if (dict.keySet().size() == 0) {\n            return false;\n        } else {\n            String state = \"start\";\n            for (String key : dict.keySet()) {\n                if (!(key instanceof String)) {\n                    state = \"mixed\";\n                    break;\n                }\n                if (state.equals(\"start\")) {\n                    if (key.toUpperCase().equals(key)) {\n                        state = \"upper\";\n                    } else if (key.toLowerCase().equals(key)) {\n                        state = \"lower\";\n                    } else {\n                        break;\n                    }\n                } else if ((state.equals(\"upper\") && !key.toUpperCase().equals(key)) || (state.equals(\"lower\") && !key.toLowerCase().equals(key))) {\n                    state = \"mixed\";\n                    break;\n                } else {\n                    continue;\n                }\n            }\n            return state.equals(\"upper\") || state.equals(\"lower\");\n        }\n    }\n}\n```\n\n### Rust version\n\nuse std::collections::HashMap;\n\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n"
  },
  {
    "name": "HumanEval_130_tri",
    "language": "rs",
    "prompt": "fn tri(n: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_130_tri.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = tri;\n    assert_eq!(candidate(3), vec![1, 3, 2, 8]);\n    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);\n    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);\n    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);\n    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);\n    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);\n    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n    assert_eq!(candidate(0), vec![1]);\n    assert_eq!(candidate(1), vec![1, 3]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef tri(n: int) -> List[int]:\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n\n### Explanation\n\nThis program generates a list of numbers that represents the triangle of numbers. The function takes an integer `n` as input and returns a list of `n` numbers. The first number in the list is always 1. The second number in the list is always 3. The rest of the numbers are generated by the following formula:\n\n- If the index of the number is even, then the number is `(index / 2) + 1`.\n- If the index of the number is odd, then the number is the sum of the two previous numbers in the list, plus `(index + 3) / 2`.\n\nTo rewrite this program in Java, you would need to replace the `List[int]` type hint with `List<Integer>`, and replace the `range` function with a `for` loop that iterates over the range of values. You would also need to change the division operator `/` to the integer division operator `//` when calculating the even-indexed numbers. Here is the Java version of the program:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TriangleNumbers {\n    public static List<Integer> tri(int n) {\n        if (n == 0) {\n            List<Integer> my_tri = new ArrayList<>();\n            my_tri.add(1);\n            return my_tri;\n        }\n        List<Integer> my_tri = new ArrayList<>();\n        my_tri.add(1);\n        my_tri.add(3);\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                my_tri.add(i / 2 + 1);\n            } else {\n                my_tri.add(my_tri.get(i - 1) + my_tri.get(i - 2) + (i + 3) / 2);\n            }\n        }\n        return my_tri;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> my_tri = tri(10);\n        System.out.println(my_tri);\n    }\n}\n```\n\nThis Java program generates the same list of numbers as the original Python program, and prints it to the console. Note that the `main` method is included to demonstrate how to use the `tri` function. You can change the argument to `tri` to generate a different number of triangle numbers.<|im_end|>\n\n### Rust version\n\nfn tri(n: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rs",
    "prompt": "fn median(l: Vec<isize>) -> f64 {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6, 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef median(l: List[int]) -> float:\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n\n### Explanation\n\nThis Python program takes in a list of integers, sorts the list, and then returns the median value of the list. If the length of the list is odd, the median is the middle value. If the length of the list is even, the median is the average of the two middle values. To rewrite this program in Java, you would need to import the List class from the java.util package and use the Collections.sort() method to sort the list. You would also need to use an if-else statement to check if the length of the list is odd or even and calculate the median accordingly. \n\n```java\nimport java.util.List;\nimport java.util.Collections;\n\npublic class Median {\n    public static double median(List<Integer> l) {\n        Collections.sort(l);\n        if (l.size() % 2 == 1) {\n            return l.get(l.size() / 2);\n        } else {\n            return (l.get(l.size() / 2 - 1) + l.get(l.size() / 2)) / 2.0;\n        }\n    }\n}\n```\n\n### Rust version\n\nfn median(l: Vec<isize>) -> f64 {\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rs",
    "prompt": "fn change_base(x: isize, base: isize) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef change_base(x: int, base: int) -> str:\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\n### Explanation\n\nThis Python program defines a function called `change_base` that takes in two arguments, an integer `x` and an integer `base`. The function returns a string that represents the integer `x` in the given `base`. The function does this by first initializing an empty string called `ret`. It then enters a while loop that continues until `x` is no longer greater than 0. Within the while loop, the function takes the remainder of `x` divided by `base`, converts it to a string, and concatenates it to the beginning of the `ret` string. The function then updates `x` to be the integer division of `x` by `base`. Once the while loop has completed, the function returns the `ret` string.\n\n### Rust version\n\nfn change_base(x: isize, base: isize) -> String {\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rs",
    "prompt": "fn longest(strings: Vec<String>) -> Option<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n### Explanation\n\nThis Python program takes a list of strings as input and returns the longest string in the list. If the input list is empty, the function returns None. The function first checks if the input list is empty, and if it is, returns None. If the list is not empty, it finds the length of the longest string in the list using the max() function and a generator expression. It then iterates over the list of strings and returns the first string that has the same length as the longest string. If there are multiple strings with the same length, it returns the first one it encounters.\n\n### Rust version\n\nfn longest(strings: Vec<String>) -> Option<String> {\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "rs",
    "prompt": "fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n\n### Explanation\n\nThis 3-line program sorts an array of integers by the number of 1's in their binary representation. It does so by first sorting the array in ascending order, and then sorting it again by the number of 1's in their binary representation. The `bin(x)[2:]` function returns the binary representation of `x` as a string, and the `count('1')` method counts the number of times the character '1' appears in the string. The `typing` module is used to specify the types of the input and output of the `sort_array` function. To rewrite this program in Java, you would need to use the `Integer.toBinaryString` method to convert integers to binary strings, and then use the `Collections.sort` method with a custom comparator to sort the array by the number of 1's in their binary representation. \n\n```java\nimport java.util.*;\n\npublic class SortArray {\n    public static List<Integer> sortArray(List<Integer> arr) {\n        Collections.sort(arr);\n        Collections.sort(arr, new Comparator<Integer>() {\n            public int compare(Integer a, Integer b) {\n                return Integer.bitCount(a) - Integer.bitCount(b);\n            }\n        });\n        return arr;\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rs",
    "prompt": "fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n\n### Explanation\n\nThis program takes two lists of integers as input and returns a list of integers that are common to both lists. The function `common` takes two lists `l1` and `l2` as input and returns a list of integers that are common to both lists. The function first initializes an empty set `ret`. It then iterates over each element `e1` in `l1` and for each element `e1`, it iterates over each element `e2` in `l2`. If `e1` is equal to `e2`, then `e1` is added to the set `ret`. Finally, the function returns a sorted list of the elements in `ret`.\n\n### Rust version\n\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rs",
    "prompt": "fn cycpattern_check(a: String, b: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = cycpattern_check;\n    assert_eq!(candidate(String::from(\"xyzw\"), String::from(\"xyw\")), false);\n    assert_eq!(candidate(String::from(\"yello\"), String::from(\"ell\")), true);\n    assert_eq!(candidate(String::from(\"whattup\"), String::from(\"ptut\")), false);\n    assert_eq!(candidate(String::from(\"efef\"), String::from(\"fee\")), true);\n    assert_eq!(candidate(String::from(\"abab\"), String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"winemtt\"), String::from(\"tinem\")), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef cycpattern_check(a: str , b: str) -> bool:\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n\n### Explanation\n\nThis function `cycpattern_check` takes two string inputs `a` and `b`. The function returns a boolean value. The function checks if the string `b` is a cyclic pattern of the string `a`. A cyclic pattern is a pattern that can be obtained by rotating the string `b` by any number of positions. \n\nThe function first calculates the length of the string `b`. It then creates a new string `pat` by concatenating the string `b` with itself. \n\nThe function then loops through the string `a` and checks if any substring of length `l` in the string `a` is equal to any substring of length `l` in the string `pat`. If there is a match, the function returns `True`. If there is no match, the function returns `False`.\n\n### Rust version\n\nfn cycpattern_check(a: String, b: String) -> bool {\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rs",
    "prompt": "fn minSubArraySum(nums: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = minSubArraySum;\n    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);\n    assert_eq!(candidate(vec![-1, -2, -3]), -6);\n    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);\n    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);\n    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);\n    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);\n    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);\n    assert_eq!(candidate(vec![-10]), -10);\n    assert_eq!(candidate(vec![7]), 7);\n    assert_eq!(candidate(vec![1, -1]), -1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n\n### Explanation\n\nThis function takes a list of integers as input and returns the minimum sum of any contiguous subarray of that list. It does this by iterating over the list and keeping track of the maximum sum seen so far. If the current sum is negative, it resets the sum to zero. If the maximum sum is zero, it returns the maximum negative value in the list. Finally, it returns the negative of the maximum sum as the minimum sum. To rewrite this program in Java, you would need to replace the type annotations with the appropriate Java types and remove the import statement for List. You would also need to change the syntax for the for loop and the if statement. \n\n```java\npublic static int minSubArraySum(int[] nums) {\n    int max_sum = 0;\n    int s = 0;\n    for (int num : nums) {\n        s += -num;\n        if (s < 0) {\n            s = 0;\n        }\n        max_sum = Math.max(s, max_sum);\n    }\n    if (max_sum == 0) {\n        int max_neg = Integer.MIN_VALUE;\n        for (int i : nums) {\n            max_neg = Math.max(max_neg, -i);\n        }\n        max_sum = max_neg;\n    }\n    int min_sum = -max_sum;\n    return min_sum;\n}\n```\n\n### Rust version\n\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rs",
    "prompt": "use std::collections::HashMap;\n\nfn histogram(test: String) -> HashMap<String, isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")), HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"a\"), 1)]));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n\n### Explanation\n\nThis program takes a string as input and returns a dictionary with the frequency of each word in the string. The function `histogram` takes a string `test` as input and returns a dictionary `dict1` with the frequency of each word in the string. The string is split into a list of words using the `split` method. The variable `t` is initialized to 0. The program then loops through the list of words and checks if the count of the word is greater than `t` and the word is not an empty string. If the count of the word is greater than `t`, `t` is updated to the count of the word. The program then loops through the list of words again and checks if the count of the word is equal to `t`. If the count of the word is equal to `t`, the word and its count are added to the dictionary `dict1`. The dictionary `dict1` is then returned.\n\n### Rust version\n\nuse std::collections::HashMap;\n\nfn histogram(test: String) -> HashMap<String, isize> {\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rs",
    "prompt": "fn get_odd_collatz(n: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef get_odd_collatz(n: int) -> List[int]:\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n\n### Explanation\n\nThis Python program takes an integer as input and returns a sorted list of all odd numbers in the Collatz sequence of the input integer. The Collatz sequence is generated by repeatedly applying the following rules to the input integer: if the integer is even, divide it by 2, otherwise multiply it by 3 and add 1. The sequence ends when the integer reaches 1. \n\nThe function first checks if the input integer is even, if it is, it initializes an empty list. If the input integer is odd, it initializes a list with the input integer. The function then generates the Collatz sequence of the input integer and appends all odd numbers in the sequence to the list. Finally, the function returns the sorted list of odd numbers. \n\nTo rewrite this program in Java, you would need to change the function signature to:\n\n```java\npublic static List<Integer> getOddCollatz(int n) {\n```\n\nYou would also need to change the syntax for checking if a number is even or odd, and for appending an element to a list. The rest of the logic can be kept the same. \n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CollatzSequence {\n    public static List<Integer> getOddCollatz(int n) {\n        List<Integer> oddCollatz = new ArrayList<>();\n        if (n % 2 == 1) {\n            oddCollatz.add(n);\n        }\n        while (n > 1) {\n            if (n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = n * 3 + 1;\n            }\n            if (n % 2 == 1) {\n                oddCollatz.add(n);\n            }\n        }\n        Collections.sort(oddCollatz);\n        return oddCollatz;\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rs",
    "prompt": "fn derivative(xs: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef derivative(xs: List[int]) -> List[int]:\n    return [(i * x) for i, x in enumerate(xs)][1:]\n\n### Explanation\n\nThis Python program takes a list of integers as input and returns a list of integers as output. The output list is the derivative of the input list. The derivative of a list is a list of the differences between consecutive elements of the input list, except for the first element. The first element of the output list is the difference between the second and first elements of the input list, the second element of the output list is the difference between the third and second elements of the input list, and so on. The input list is represented by the variable xs, and the output list is constructed using a list comprehension. The list comprehension iterates over the input list, and for each element x and its index i, it multiplies i by x and appends the result to the output list. Finally, the first element of the output list is removed, since it corresponds to the difference between the first and zeroth elements of the input list, which is not defined.\n\n### Rust version\n\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rs",
    "prompt": "fn fibfib(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = fibfib;\n    assert_eq!(candidate(2), 1);\n    assert_eq!(candidate(1), 0);\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 24);\n    assert_eq!(candidate(10), 81);\n    assert_eq!(candidate(12), 274);\n    assert_eq!(candidate(14), 927);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n\n### Explanation\n\nThis Python program is a recursive function that returns the nth number in the Fibonacci sequence. The function takes an integer n as input and returns an integer. If n is 0, the function returns 0. If n is 1, the function returns 0. If n is 2, the function returns 1. Otherwise, the function returns the sum of the three previous numbers in the sequence. To rewrite this program in Java, you would need to create a new function with the same name and input parameters, and use the Java syntax for conditional statements and function calls. \n\n```java\npublic static int fibfib(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n```\n\n### Rust version\n\nfn fibfib(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rs",
    "prompt": "fn truncate_number(number: f64) -> f64 {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef truncate_number(number: float) -> float:\n    return number % 1.0\n\n### Explanation\n\nThis 1-line Python function takes a float as input and returns the remainder of the float divided by 1.0. In other words, it returns the decimal part of the float. For example, `truncate_number(3.14159)` would return `0.14159`. To rewrite this program in Java, you would need to define a function that takes a float as input and returns a float. You would then use the modulo operator (`%`) to return the remainder of the float divided by 1.0. Here's an example implementation in Java:\n\n```java\npublic static float truncateNumber(float number) {\n    return number % 1.0f;\n}\n```\n\nNote that in Java, you need to use the `f` suffix to indicate that 1.0 is a float, not a double. Also note that the function signature in Java is slightly different, as Java does not support type annotations like Python does. Finally, note that the `float` type in Java is equivalent to the `float` type in Python. If you need more precision, you can use the `double` type in Java, which is equivalent to the `float` type in Python.<|im_end|>\n\n### Rust version\n\nfn truncate_number(number: f64) -> f64 {\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rs",
    "prompt": "fn max_element(l: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = max_element;\n    assert_eq!(candidate(vec![1, 2, 3]), 3);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef max_element(l: List[int]) -> int:\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n\n### Explanation\n\nThis Python program defines a function `max_element` that takes a list of integers as input and returns the maximum value in the list. The function iterates over the list and keeps track of the maximum value seen so far. If the current element is greater than the maximum value seen so far, the maximum value is updated. The function then returns the maximum value. \n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static int maxElement(List<Integer> l) {\n        int m = l.get(0);\n        for (int e : l) {\n            if (e > m) {\n                m = e;\n            }\n        }\n        return m;\n    }\n}\n```\n\n### Rust version\n\nfn max_element(l: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rs",
    "prompt": "fn closest_integer(value: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"0\")), 0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef closest_integer(value: str) -> int:\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n### Explanation\n\nThis function takes in a string representation of a number and returns the closest integer to that number. The function first checks if the input string has a decimal point. If it does, it removes any trailing zeros. It then converts the string to a float and checks if the last two characters are \".5\". If they are, it rounds up if the number is positive and rounds down if the number is negative. If the last two characters are not \".5\", the function rounds the number to the nearest integer. If the input string is empty, the function returns 0.\n\n### Rust version\n\nfn closest_integer(value: String) -> isize {\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rs",
    "prompt": "fn prime_fib(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = prime_fib;\n    assert_eq!(candidate(1), 2);\n    assert_eq!(candidate(2), 3);\n    assert_eq!(candidate(3), 5);\n    assert_eq!(candidate(4), 13);\n    assert_eq!(candidate(5), 89);\n    assert_eq!(candidate(6), 233);\n    assert_eq!(candidate(7), 1597);\n    assert_eq!(candidate(8), 28657);\n    assert_eq!(candidate(9), 514229);\n    assert_eq!(candidate(10), 433494437);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef prime_fib(n: int) -> int:\n    import math\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n\n### Explanation\n\nThis Python program generates the nth prime Fibonacci number. It does this by first defining a helper function `is_prime` that checks if a number is prime. Then it initializes a list `f` with the first two Fibonacci numbers. It then generates the next Fibonacci number and checks if it is prime. If it is, it decrements the counter `n`. It continues generating Fibonacci numbers and checking if they are prime until `n` is decremented to 0, at which point it returns the last prime Fibonacci number generated. \n\nHere is the equivalent Java code:\n\n```java\npublic static int primeFib(int n) {\n    List<Integer> f = new ArrayList<>(Arrays.asList(0, 1));\n    while (true) {\n        int nextFib = f.get(f.size() - 1) + f.get(f.size() - 2);\n        if (isPrime(nextFib)) {\n            n--;\n        }\n        if (n == 0) {\n            return nextFib;\n        }\n        f.add(nextFib);\n    }\n}\n\npublic static boolean isPrime(int p) {\n    if (p < 2) {\n        return false;\n    }\n    for (int k = 2; k <= Math.min((int) Math.sqrt(p) + 1, p - 1); k++) {\n        if (p % k == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```<|im_end|>\n\n### Rust version\n\nfn prime_fib(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rs",
    "prompt": "fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n\n### Explanation\n\nThis program takes in a list of integers and returns a tuple of two integers. The first integer is the sum of all the integers in the list and the second integer is the product of all the integers in the list. \n\nTo rewrite this program in Java, you would need to import the `java.util.List` and `java.util.ArrayList` classes. You would also need to import the `java.util.Tuple` class, which is not available in Java. Here is the equivalent Java code:\n\n```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = new ArrayList<>();\n        numbers.add(1);\n        numbers.add(2);\n        numbers.add(3);\n        numbers.add(4);\n        numbers.add(5);\n\n        Tuple<Integer, Integer> result = sumProduct(numbers);\n        System.out.println(\"Sum: \" + result.getFirst());\n        System.out.println(\"Product: \" + result.getSecond());\n    }\n\n    public static Tuple<Integer, Integer> sumProduct(List<Integer> numbers) {\n        int sumValue = 0;\n        int prodValue = 1;\n\n        for (int n : numbers) {\n            sumValue += n;\n            prodValue *= n;\n        }\n\n        return new Tuple<>(sumValue, prodValue);\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rs",
    "prompt": "fn select_words(s: String, n: isize) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n### Explanation\n\nThis Python program defines a function called `select_words` that takes two arguments: a string `s` and an integer `n`. The function returns a list of all words in the string that have exactly `n` consonants. A consonant is any letter that is not a vowel (a, e, i, o, u). The function first initializes an empty list called `result`. It then loops through each word in the string `s` by splitting the string on whitespace. For each word, it counts the number of consonants by looping through each character in the word and checking if it is a consonant. If the word has exactly `n` consonants, it is added to the `result` list. Finally, the function returns the `result` list.\n\n### Rust version\n\nfn select_words(s: String, n: isize) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rs",
    "prompt": "fn add_elements(arr: Vec<isize>, k: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = add_elements;\n    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);\n    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n    assert_eq!(candidate(vec![1], 1), 1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n\n### Explanation\n\nThis Python program defines a function called `add_elements` that takes in two arguments: a list of integers called `arr` and an integer called `k`. The function returns the sum of the first `k` elements in the list `arr` that have a length of 2 or less. \n\nThe function uses a list comprehension to iterate over the first `k` elements of the list `arr` and checks if the length of the string representation of the current element is less than or equal to 2. If it is, the element is added to a running total using the `sum` function. The final total is returned as the output of the function.\n\n### Rust version\n\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rs",
    "prompt": "fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef eat(number: int, need: int, remaining: int) -> List[int]:\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n\n### Explanation\n\nThis Python program defines a function called `eat` that takes three integer arguments `number`, `need` and `remaining`. The function returns a list of two integers. If `need` is less than or equal to `remaining`, the function returns a list containing `number + need` and `remaining - need`. Otherwise, the function returns a list containing `number + remaining` and `0`.\n\n### Rust version\n\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rs",
    "prompt": "fn odd_count(lst: Vec<String>) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = odd_count;\n    assert_eq!(candidate(vec![String::from(\"1234567\")]), vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"3\"), String::from(\"11111111\")]), vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"271\"), String::from(\"137\"), String::from(\"314\")]), vec![String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\"), String::from(\"the number of odd elements 3n the str3ng 3 of the 3nput.\"), String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n\n### Explanation\n\nThis program takes a list of strings as input and returns a list of strings. Each string in the output list is a sentence that describes the number of odd digits in the corresponding string in the input list. The sentence is of the form \"the number of odd elements X in the string Y of the Z input.\" where X is the number of odd digits in the string, Y is the index of the string in the input list, and Z is the total number of strings in the input list. \n\nFor example, if the input list is [\"123\", \"4567\", \"89\"], the output list would be [\"the number of odd elements 1 in the string 1 of the 3 input.\", \"the number of odd elements 2 in the string 2 of the 3 input.\", \"the number of odd elements 1 in the string 3 of the 3 input.\"]. \n\nTo rewrite this program in Java, you would need to replace the type annotations with the appropriate Java types, and use a for loop to iterate over the input list. You would also need to use the modulus operator to check if a digit is odd, and concatenate strings using the \"+\" operator. Here is an example Java implementation:\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<String> oddCount(List<String> lst) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            String arr = lst.get(i);\n            int n = 0;\n            for (int j = 0; j < arr.length(); j++) {\n                if (arr.charAt(j) % 2 == 1) {\n                    n++;\n                }\n            }\n            res.add(\"the number of odd elements \" + n + \" in the string \" + (i+1) + \" of the \" + lst.size() + \" input.\");\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        List<String> lst = new ArrayList<>();\n        lst.add(\"123\");\n        lst.add(\"4567\");\n        lst.add(\"89\");\n        List<String> res = oddCount(lst);\n        for (String s : res) {\n            System.out.println(s);\n        }\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rs",
    "prompt": "fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n\n### Explanation\n\nThis 3-line Python program defines a function called `next_smallest` that takes a list of integers as input and returns the second smallest integer in the list. If the list has less than two unique integers, the function returns `None`. The function first removes duplicates from the input list, then sorts it in ascending order, and finally returns the second element of the sorted list, if it exists. The function uses Python's built-in `sorted` function to sort the list, and the `set` function to remove duplicates. The function uses Python's optional type hinting syntax to indicate that it returns an integer or `None`.\n\n### Rust version\n\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "rs",
    "prompt": "fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n\n### Explanation\n\nThis program takes a list of lists of integers and an integer x as input. It then returns a list of tuples, where each tuple contains the coordinates of the integer x in the list of lists. The coordinates are sorted first by row and then by column, with the leftmost column being the first. \n\nTo rewrite this program in Java, you would need to replace the type annotations with the appropriate Java types. You would also need to replace the lambda functions with equivalent Java code. Finally, you would need to use the appropriate Java methods to sort the list of tuples. \n\nHere is an example of what the Java code might look like:\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<List<Integer>> lst = new ArrayList<>();\n        lst.add(new ArrayList<>(List.of(1, 2, 3)));\n        lst.add(new ArrayList<>(List.of(4, 5, 6)));\n        lst.add(new ArrayList<>(List.of(7, 8, 9)));\n        int x = 5;\n        List<Tuple<Integer, Integer>> result = getRow(lst, x);\n        System.out.println(result);\n    }\n\n    public static List<Tuple<Integer, Integer>> getRow(List<List<Integer>> lst, int x) {\n        List<Tuple<Integer, Integer>> coords = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                if (lst.get(i).get(j) == x) {\n                    coords.add(new Tuple<>(i, j));\n                }\n            }\n        }\n        Collections.sort(coords, new Comparator<Tuple<Integer, Integer>>() {\n            @Override\n            public int compare(Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2) {\n                if (o1.getFirst() < o2.getFirst()) {\n                    return -1;\n                } else if (o1.getFirst() > o2.getFirst()) {\n                    return 1;\n                } else {\n                    return Integer.compare(o2.getSecond(), o1.getSecond());\n                }\n            }\n        });\n        return coords;\n    }\n}\n\nclass Tuple<A, B> {\n    private final A first;\n    private final B second;\n\n    public Tuple(A first, B second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public A getFirst() {\n        return first;\n    }\n\n    public B getSecond() {\n        return second;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + first + \", \" + second + \")\";\n    }\n}\n```\n\nNote that the `Tuple` class needs to be defined separately, since Java does not have a built-in tuple type. Also note that the `get_row` function has been renamed to `getRow` to follow Java naming conventions. Finally, the `sorted` function has been replaced with the `Collections.sort` method, which takes a `Comparator` object as an argument. The `Comparator` object is defined using an anonymous inner class that implements the `compare` method. The `key` argument of the `sorted` function has been replaced with the `compare` method of the `Comparator` object. The `reverse` argument of the `sorted` function has been replaced with a call to `Integer.compare` with the arguments reversed. \n\nOverall, the Java code is more verbose than the Python code, but the logic is the same. The Java code iterates over the list of lists using nested loops, and adds the coordinates of the\n\n### Rust version\n\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rs",
    "prompt": "fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = filter_by_prefix;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [x for x in strings if x.startswith(prefix)]\n\n### Explanation\n\nThis Python program defines a function called `filter_by_prefix` that takes in two arguments: a list of strings called `strings` and a string called `prefix`. The function returns a new list of strings that only contains the strings from the original list that start with the given prefix. \n\nThe function uses a list comprehension to create the new list of strings. The list comprehension iterates over each string in the original list and checks if it starts with the given prefix. If it does, the string is added to the new list. If it doesn't, the string is skipped.\n\nTo rewrite this program in Java, you would need to define a method with the same name and arguments, and use a for loop to iterate over the original list and check each string for the prefix. You would also need to create a new list to store the filtered strings and return that list at the end of the method. Here is an example implementation in Java:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FilterByPrefix {\n    public static List<String> filterByPrefix(List<String> strings, String prefix) {\n        List<String> filteredStrings = new ArrayList<>();\n        for (String s : strings) {\n            if (s.startsWith(prefix)) {\n                filteredStrings.add(s);\n            }\n        }\n        return filteredStrings;\n    }\n}\n```\n\n### Rust version\n\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rs",
    "prompt": "fn choose_num(x: isize, y: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = choose_num;\n    assert_eq!(candidate(12, 15), 14);\n    assert_eq!(candidate(13, 12), -1);\n    assert_eq!(candidate(33, 12354), 12354);\n    assert_eq!(candidate(5234, 5233), -1);\n    assert_eq!(candidate(6, 29), 28);\n    assert_eq!(candidate(27, 10), -1);\n    assert_eq!(candidate(7, 7), -1);\n    assert_eq!(candidate(546, 546), 546);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n\n### Explanation\n\nThis function takes two integer parameters, `x` and `y`, and returns an integer. If `x` is greater than `y`, the function returns `-1`. If `y` is even, the function returns `y`. If `x` is equal to `y`, the function returns `-1`. Otherwise, the function returns `y - 1`.\n\n### Rust version\n\nfn choose_num(x: isize, y: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rs",
    "prompt": "fn prime_length(string: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef prime_length(string: str) -> bool:\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n\n### Explanation\n\nThis function takes a string as input and returns True if the length of the string is a prime number, False otherwise. The function first calculates the length of the string and then checks if the length is 0 or 1. If the length is 0 or 1, the function returns False. If the length is greater than 1, the function checks if the length is divisible by any number between 2 and the length of the string. If the length is divisible by any number between 2 and the length of the string, the function returns False. If the length is not divisible by any number between 2 and the length of the string, the function returns True.\n\n### Rust version\n\nfn prime_length(string: String) -> bool {\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rs",
    "prompt": "fn sum_to_n(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sum_to_n;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(6), 21);\n    assert_eq!(candidate(11), 66);\n    assert_eq!(candidate(30), 465);\n    assert_eq!(candidate(100), 5050);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef sum_to_n(n: int) -> int:\n    return sum(range(n + 1))\n\n### Explanation\n\nThis 1-line Python program defines a function `sum_to_n` that takes an integer `n` as input and returns the sum of all integers from 0 to `n`. It does this by generating a range of integers from 0 to `n` (inclusive) and then summing them using the built-in `sum` function. To rewrite this program in Java, you would need to define a function that takes an integer `n` as input, generates a range of integers from 0 to `n`, and then sums them using a loop or a stream. Here's an example implementation in Java:\n\n```java\npublic static int sumToN(int n) {\n    int sum = 0;\n    for (int i = 0; i <= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n```\n\nThis Java function initializes a variable `sum` to 0, then iterates over a range of integers from 0 to `n` (inclusive) using a for loop. Inside the loop, it adds each integer to the `sum` variable. Finally, it returns the `sum` variable. Alternatively, you could use a stream to generate the range of integers and sum them in a single line:\n\n```java\npublic static int sumToN(int n) {\n    return IntStream.rangeClosed(0, n).sum();\n}\n```\n\nThis Java function uses the `IntStream` class to generate a range of integers from 0 to `n` (inclusive), then calls the `sum` method to sum them and return the result. Note that you would need to import the `java.util.stream.IntStream` class to use this implementation.<|im_end|>\n\n### Rust version\n\nfn sum_to_n(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rs",
    "prompt": "fn fix_spaces(text: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = fix_spaces;\n    assert_eq!(candidate(String::from(\"Example\")), String::from(\"Example\"));\n    assert_eq!(candidate(String::from(\"Mudasir Hanif \")), String::from(\"Mudasir_Hanif_\"));\n    assert_eq!(candidate(String::from(\"Yellow Yellow  Dirty  Fellow\")), String::from(\"Yellow_Yellow__Dirty__Fellow\"));\n    assert_eq!(candidate(String::from(\"Exa   mple\")), String::from(\"Exa-mple\"));\n    assert_eq!(candidate(String::from(\"   Exa 1 2 2 mple\")), String::from(\"-Exa_1_2_2_mple\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef fix_spaces(text: str) -> str:\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n\n### Explanation\n\nThis function takes a string as input and returns a string. The input string is iterated over character by character. If the character is a space, the end index is incremented. If the character is not a space, the function checks if there are more than 2 spaces between the last non-space character and the current character. If there are more than 2 spaces, the function adds a hyphen and the current character to the new string. If there are between 1 and 2 spaces, the function adds underscores to the new string followed by the current character. If there are no spaces, the function simply adds the current character to the new string. The start and end indices are then updated to reflect the current character. Finally, if there are more than 2 spaces at the end of the string, the function adds a hyphen to the new string. If there are between 1 and 2 spaces at the end of the string, the function adds underscores to the new string. If there are no spaces at the end of the string, the function simply returns the new string.\n\n### Rust version\n\nfn fix_spaces(text: String) -> String {\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rs",
    "prompt": "fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n\n### Explanation\n\nThis function takes a list of integers as input and returns a list of integers. The output list contains the maximum value of the input list up to that point. For example, if the input list is [1, 2, 3, 2, 1], the output list will be [1, 2, 3, 3, 3]. \n\nThe function works by initializing a variable called `running_max` to `None` and an empty list called `result`. It then iterates over the input list and for each element, it checks if the `running_max` is `None`. If it is, it sets `running_max` to the current element. If it is not `None`, it compares the current element to `running_max` and sets `running_max` to the maximum of the two. It then appends `running_max` to the `result` list. Finally, it returns the `result` list. \n\nTo rewrite this program in Java, you would need to replace the `List` and `Tuple` types with their Java equivalents. You would also need to change the syntax for the `max` function and the `None` value. Here is an example of what the Java code might look like:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RollingMax {\n\n    public static List<Integer> rollingMax(List<Integer> numbers) {\n        Integer runningMax = null;\n        List<Integer> result = new ArrayList<>();\n\n        for (Integer n : numbers) {\n            if (runningMax == null) {\n                runningMax = n;\n            } else {\n                runningMax = Math.max(runningMax, n);\n            }\n\n            result.add(runningMax);\n        }\n\n        return result;\n    }\n\n}\n```<|im_end|>\n\n### Rust version\n\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rs",
    "prompt": "fn words_in_sentence(sentence: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef words_in_sentence(sentence: str) -> str:\n    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n\n### Explanation\n\nThis program takes a string as input and returns a new string with only the words that have a length of 1 or a length that is a prime number. \n\nThe program first creates an empty list called `new_lst`. It then loops through each word in the input string by splitting the string on whitespace. For each word, it sets a flag variable called `flg` to 0. If the length of the word is 1, it sets `flg` to 1. It then loops through the range of 2 to the length of the word. For each number in the range, it checks if the length of the word is divisible by that number. If it is, it sets `flg` to 1. If `flg` is still 0 after the loop or if the length of the word is 2, it appends the word to the `new_lst` list. Finally, it returns a string that is the result of joining the words in `new_lst` with a single space between them.\n\n### Rust version\n\nfn words_in_sentence(sentence: String) -> String {\n"
  },
  {
    "name": "HumanEval_160_do_algebra",
    "language": "rs",
    "prompt": "fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_160_do_algebra.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"**\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"+\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"//\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n\n### Explanation\n\nThis function takes in two lists, `operator` and `operand`. The `operator` list contains the operators that are to be used in the algebraic expression and the `operand` list contains the operands. The function then constructs the algebraic expression by concatenating the first operand with the first operator, the second operand with the second operator and so on. Finally, it evaluates the expression and returns the result.\n\n### Rust version\n\nfn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rs",
    "prompt": "fn get_closest_vowel(word: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef get_closest_vowel(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n\n### Explanation\n\nThis Python program takes in a string as input and returns the closest vowel to the second last letter of the string. If the length of the string is less than 3, it returns an empty string. The program first checks if the length of the string is less than 3. If it is, it returns an empty string. If not, it creates a set of vowels and loops through the string starting from the second last letter. It checks if the current letter is a vowel. If it is, it checks if the letters before and after it are not vowels. If they are not, it returns the current letter. If it does not find any such letter, it returns an empty string.\n\n### Rust version\n\nfn get_closest_vowel(word: String) -> String {\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rs",
    "prompt": "fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = compare;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);\n    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);\n    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);\n    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef compare(game: List[int],guess: List[int]) -> List[int]:\n    return [abs(x-y) for x,y in zip(game,guess)]\n\n### Explanation\n\nThis 3-line Python program defines a function called `compare` that takes two lists of integers as input, and returns a list of integers. The function uses a list comprehension to create a new list, where each element is the absolute difference between the corresponding elements in the two input lists. The `zip` function is used to iterate over the two lists in parallel, and the `abs` function is used to compute the absolute difference. The function is annotated with type hints to indicate that it takes two lists of integers as input, and returns a list of integers. To rewrite this program in Java, you would need to define a method with the same signature, and use a for loop to iterate over the two input arrays and compute the absolute difference between the corresponding elements. You would also need to import the `List` class from the `java.util` package to specify the type of the input arrays. \n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            result.add(diff);\n        }\n        return result;\n    }\n}\n```\n\n### Rust version\n\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rs",
    "prompt": "fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = remove_duplicates;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n\n### Explanation\n\nThis Python program takes in a list of integers and returns a list of integers with duplicates removed. It does this by first creating a Counter object from the collections module, which counts the number of occurrences of each integer in the input list. It then returns a new list that only contains integers that have a count of 1 or less in the Counter object. This effectively removes all duplicates from the input list. To rewrite this program in Java, you would need to use a HashMap to count the occurrences of each integer in the input list, and then iterate over the map to create a new list that only contains integers with a count of 1 or less. \n\n```Java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RemoveDuplicates {\n    public static List<Integer> removeDuplicates(List<Integer> numbers) {\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (int n : numbers) {\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (int n : numbers) {\n            if (countMap.get(n) <= 1) {\n                result.add(n);\n            }\n        }\n        return result;\n    }\n}\n```\n\n### Rust version\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "rs",
    "prompt": "fn same_chars(s0: String, s1: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"aabb\"), String::from(\"aaccc\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n\n### Explanation\n\nThis 3-line Python program defines a function called `same_chars` that takes two string arguments `s0` and `s1`. The function returns `True` if the two strings contain the same characters, regardless of order, and `False` otherwise. The function uses the `set()` function to convert each string into a set of unique characters, and then compares the two sets using the `==` operator.\n\n### Rust version\n\nfn same_chars(s0: String, s1: String) -> bool {\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rs",
    "prompt": "fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n\n### Explanation\n\nThis Python program takes in a string of nested parentheses and returns a list of integers representing the maximum depth of each group of parentheses. The `parse_paren_group` function takes in a string and iterates through it, keeping track of the depth of the parentheses. It returns the maximum depth of the parentheses in the string. The `parse_nested_parens` function splits the input string by spaces and applies the `parse_paren_group` function to each group of parentheses. The resulting list of maximum depths is returned. To rewrite this program in Java, you would need to define the `parse_paren_group` function and call it in the `parse_nested_parens` function. You would also need to change the syntax for list comprehension and the `split` method. \n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NestedParens {\n    public static List<Integer> parseNestedParens(String parenString) {\n        List<Integer> depths = new ArrayList<>();\n        String[] groups = parenString.split(\" \");\n        for (String group : groups) {\n            if (!group.isEmpty()) {\n                depths.add(parseParenGroup(group));\n            }\n        }\n        return depths;\n    }\n\n    private static int parseParenGroup(String s) {\n        int depth = 0;\n        int maxDepth = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                depth++;\n                maxDepth = Math.max(depth, maxDepth);\n            } else {\n                depth--;\n            }\n        }\n        return maxDepth;\n    }\n}\n```\n\n### Rust version\n\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rs",
    "prompt": "fn even_odd_count(num: isize) -> (isize, isize) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = even_odd_count;\n    assert_eq!(candidate(7), (0, 1));\n    assert_eq!(candidate(-78), (1, 1));\n    assert_eq!(candidate(3452), (2, 2));\n    assert_eq!(candidate(346211), (3, 3));\n    assert_eq!(candidate(-345821), (3, 3));\n    assert_eq!(candidate(-2), (1, 0));\n    assert_eq!(candidate(-45347), (2, 3));\n    assert_eq!(candidate(0), (1, 0));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import Tuple \n\ndef even_odd_count(num: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n\n### Explanation\n\nThis Python program takes an integer as input and returns a tuple containing the count of even and odd digits in the integer. The function first initializes two counters, even_count and odd_count, to 0. It then iterates through the string representation of the absolute value of the input integer, checking if each digit is even or odd. If the digit is even, the even_count is incremented by 1. If the digit is odd, the odd_count is incremented by 1. Finally, the function returns a tuple containing the even_count and odd_count.\n\n### Rust version\n\nfn even_odd_count(num: isize) -> (isize, isize) {\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rs",
    "prompt": "fn fruit_distribution(s: String, n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = fruit_distribution;\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 21), 10);\n    assert_eq!(candidate(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"1 apples and 0 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 5), 0);\n    assert_eq!(candidate(String::from(\"1 apples and 100 oranges\"), 120), 19);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef fruit_distribution(s: str, n: int) -> int:\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n\n### Explanation\n\nThis Python program takes a string `s` and an integer `n` as input. The string `s` contains a list of integers separated by spaces. The program extracts all integers from `s` and stores them in a list `lis`. The program then returns the difference between `n` and the sum of all integers in `lis`. \n\nThe equivalent Java program is:\n\n```java\npublic static int fruitDistribution(String s, int n) {\n    List<Integer> lis = new ArrayList<>();\n    for (String i : s.split(\" \")) {\n        if (i.matches(\"\\\\d+\")) {\n            lis.add(Integer.parseInt(i));\n        }\n    }\n    int sum = 0;\n    for (int i : lis) {\n        sum += i;\n    }\n    return n - sum;\n}\n```\n\nThe Java program uses a regular expression to check if a string is an integer. The regular expression `\\\\d+` matches one or more digits. The program then converts the string to an integer using `Integer.parseInt()`. The program then calculates the sum of all integers in `lis` using a for-each loop. Finally, the program returns the difference between `n` and the sum of all integers in `lis`. \n\nNote: The Java program uses `List<Integer>` instead of `list()` because Java is a strongly-typed language and requires the type of the list to be specified. The Java program also uses `ArrayList` instead of `list()` because `ArrayList` is a commonly used implementation of the `List` interface in Java.\n\n### Rust version\n\nfn fruit_distribution(s: String, n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rs",
    "prompt": "fn string_xor(a: String, b: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n\n### Explanation\n\nThis Python program defines a function called `string_xor` that takes two string arguments `a` and `b` and returns a string. The function uses a nested function called `xor` that takes two arguments `i` and `j` and returns a string. The `xor` function returns '0' if `i` is equal to `j` and '1' otherwise. The `string_xor` function uses the `zip` function to iterate over the characters of `a` and `b` in parallel, and applies the `xor` function to each pair of characters. Finally, the `join` method is used to concatenate the resulting strings into a single string, which is then returned. The program uses the `typing` module to specify the types of the function arguments and return value.\n\n### Rust version\n\nfn string_xor(a: String, b: String) -> String {\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rs",
    "prompt": "fn strlen(string: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = strlen;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"x\")), 1);\n    assert_eq!(candidate(String::from(\"asdasnakj\")), 9);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef strlen(string: str) -> int:\n    return len(string)\n\n### Explanation\n\nThis 1-line Python program defines a function called `strlen` that takes in a string argument called `string` and returns the length of that string. The `len` function is a built-in Python function that returns the length of a string. The `-> int` syntax is Python's way of specifying the return type of the function. In this case, it specifies that the function returns an integer. To rewrite this program in Java, you would define a function called `strlen` that takes in a `String` argument called `string` and returns the length of that string using the `length()` method of the `String` class. Here's what the Java code would look like:\n\n```java\npublic static int strlen(String string) {\n    return string.length();\n}\n```<|im_end|>\n\n### Rust version\n\nfn strlen(string: String) -> isize {\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rs",
    "prompt": "fn string_sequence(n: isize) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = string_sequence;\n    assert_eq!(candidate(0), String::from(\"0\"));\n    assert_eq!(candidate(3), String::from(\"0 1 2 3\"));\n    assert_eq!(candidate(10), String::from(\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])\n\n### Explanation\n\nThis 1-line Python program defines a function called `string_sequence` that takes an integer `n` as input and returns a string. The string is a space-separated sequence of integers from 0 to `n`, inclusive. \n\nThe function first creates a list of integers from 0 to `n` using a list comprehension. It then converts each integer to a string using the `str()` function and joins all the strings with a space character using the `join()` method of the string class.\n\n### Rust version\n\nfn string_sequence(n: isize) -> String {\n"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "language": "rs",
    "prompt": "fn file_name_check(file_name: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_141_file_name_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef file_name_check(file_name: str) -> str:\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n\n### Explanation\n\nThis Python program checks if a file name is valid. A valid file name has the following properties:\n- it has a suffix that is either 'txt', 'exe' or 'dll'\n- it has a name that starts with a letter\n- it has a name that has at most 3 digits\n- it has a name that is not empty\n\nThe function `file_name_check` takes a string argument `file_name` and returns 'Yes' if the file name is valid and 'No' otherwise.\n\n### Rust version\n\nfn file_name_check(file_name: String) -> String {\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rs",
    "prompt": "fn can_arrange(arr: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef can_arrange(arr: List[int]) -> int:\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n\n### Explanation\n\nThis Python program takes in a list of integers and returns the index of the first element in the list that is not in ascending order. If all elements are in ascending order, it returns -1. \n\nThe function `can_arrange` takes in a list of integers `arr` and returns an integer. It first initializes a variable `ind` to -1. It then initializes a variable `i` to 1. It then enters a while loop that runs as long as `i` is less than the length of `arr`. Within the while loop, it checks if the current element is less than the previous element. If it is, it updates the value of `ind` to `i`. It then increments `i` by 1. Once the while loop is done, it returns the value of `ind`. If the while loop never updated the value of `ind`, it returns -1.\n\n### Rust version\n\nfn can_arrange(arr: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rs",
    "prompt": "fn add(lst: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(vec![4, 88]), 88);\n    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);\n    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);\n    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef add(lst: List[int]) -> int:\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n\n### Explanation\n\nThis Python program takes a list of integers as input and returns the sum of all even integers at odd indices. \n\nTo rewrite this program in Java, we can use the following code:\n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n}\n```\n\nNote that we use `List<Integer>` instead of `List<int>` in Java, and we use `lst.get(i)` instead of `lst[i]` to access the elements of the list. We also use a for loop instead of a list comprehension to iterate over the list. Finally, we initialize the sum to 0 and add to it only if the element at the current index is even.\n\n### Rust version\n\nfn add(lst: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rs",
    "prompt": "fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n\n### Explanation\n\nThis Python program takes a list of integers and a delimiter integer as input. It then returns a new list with the delimiter integer interspersed between each integer in the original list. If the original list is empty, it returns an empty list. The function `intersperse` takes two arguments: a list of integers `numbers` and an integer `delimiter`. It returns a new list with the delimiter integer interspersed between each integer in the original list. The function first checks if the list is empty. If it is, it returns an empty list. Otherwise, it initializes an empty list `result`. It then iterates over all but the last element of the input list, appending each element and the delimiter to the result list. Finally, it appends the last element of the input list to the result list and returns it.\n\n### Rust version\n\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rs",
    "prompt": "fn match_parens(lst: Vec<String>) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n\n### Explanation\n\nThis Python program takes a list of two strings as input, and checks if the two strings can be concatenated in any order to form a string with balanced parentheses. If the parentheses are balanced, the function returns 'Yes', otherwise it returns 'No'. \n\nThe function `check` takes a string as input and checks if the parentheses in the string are balanced. It does this by iterating through the string and keeping track of the number of open and closed parentheses encountered so far. If the number of closed parentheses encountered is greater than the number of open parentheses encountered, the function returns False. If the number of open and closed parentheses is equal at the end of the string, the function returns True, otherwise it returns False.\n\nThe function then concatenates the two input strings in both possible orders and checks if either of the resulting strings have balanced parentheses. If at least one of the strings has balanced parentheses, the function returns 'Yes', otherwise it returns 'No'. \n\nTo rewrite this program in Java, you would need to replace the `List` type with an array of strings, and use a for loop to iterate through the characters in the input strings. You would also need to use the `StringBuilder` class to concatenate the strings. Here is an example Java implementation:\n\n```java\npublic static String matchParens(String[] lst) {\n    StringBuilder s1 = new StringBuilder(lst[0]).append(lst[1]);\n    StringBuilder s2 = new StringBuilder(lst[1]).append(lst[0]);\n    if (check(s1.toString()) || check(s2.toString())) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\npublic static boolean check(String s) {\n    int val = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == '(') {\n            val++;\n        } else {\n            val--;\n        }\n        if (val < 0) {\n            return false;\n        }\n    }\n    return val == 0;\n}\n```<|im_end|>\n\n### Rust version\n\nfn match_parens(lst: Vec<String>) -> String {\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "rs",
    "prompt": "fn any_int(x: f64, y: f64, z: f64) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef any_int(x: float, y: float, z: float) -> bool:\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n\n### Explanation\n\nThis Python function takes three float arguments x, y, and z. It returns True if any two of the arguments sum to the third argument, and False otherwise. The function first checks if all three arguments are integers. If they are, it checks if any two of the arguments sum to the third argument. If they do, it returns True. If not, it returns False. If any of the arguments are not integers, the function returns False.\n\n### Rust version\n\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rs",
    "prompt": "fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\")), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]\n\n### Explanation\n\nThis Python program receives a list of strings and a substring. It returns a new list with only the strings that contain the substring. The list comprehension `[x for x in strings if substring in x]` is used to filter the strings that contain the substring. The returned list is of the same type as the input list, and the function signature indicates that the input and output lists are of type `List[str]`. To rewrite this program in Java, you would need to declare a method that receives a `List<String>` and a `String` as input, and returns a `List<String>`. Inside the method, you would need to create a new list, iterate over the input list, and add the strings that contain the substring to the new list. Finally, you would return the new list. The Java code would look something like this:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FilterBySubstring {\n    public static List<String> filterBySubstring(List<String> strings, String substring) {\n        List<String> filteredStrings = new ArrayList<>();\n        for (String s : strings) {\n            if (s.contains(substring)) {\n                filteredStrings.add(s);\n            }\n        }\n        return filteredStrings;\n    }\n}\n```\n\nNote that the `contains` method is used in Java to check if a string contains another string. Also note that the `ArrayList` class is used to create the new list, and that the `for` loop is used to iterate over the input list. Finally, the `add` method is used to add the strings that contain the substring to the new list. The returned list is of type `List<String>`, as indicated by the method signature.<|im_end|>\n\n### Rust version\n\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rs",
    "prompt": "fn find_max(words: Vec<String>) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef find_max(words: List[str]) -> str:\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n\n### Explanation\n\nThis 3-line Python program defines a function called `find_max` that takes a list of strings called `words` as input and returns a string. The function returns the string in the input list that has the highest number of unique characters. If there are multiple strings with the same number of unique characters, the function returns the string that comes first in alphabetical order. \n\nTo achieve this, the function first sorts the input list of strings using a lambda function that sorts the strings by two criteria: first, by the number of unique characters in the string (in descending order), and second, by the alphabetical order of the string (in ascending order). The `sorted` function returns a new list of strings that is sorted according to these criteria. Finally, the function returns the first string in the sorted list, which is the string with the highest number of unique characters and comes first in alphabetical order. \n\nTo rewrite this program in Java, you would need to define a function that takes an array of strings as input and returns a string. You would then need to implement the same sorting logic using Java's built-in `Arrays.sort` method and a custom `Comparator` object that sorts the strings by the same two criteria as the Python lambda function. Finally, you would return the first string in the sorted array, just like in the Python program. \n\nHere's an example Java implementation of the same program:\n\n```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] words = {\"hello\", \"world\", \"python\", \"java\", \"programming\"};\n        System.out.println(findMax(words)); // prints \"programming\"\n    }\n\n    public static String findMax(String[] words) {\n        Arrays.sort(words, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                int uniqueChars1 = (int) s1.chars().distinct().count();\n                int uniqueChars2 = (int) s2.chars().distinct().count();\n                if (uniqueChars1 != uniqueChars2) {\n                    return Integer.compare(uniqueChars2, uniqueChars1);\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n        return words[0];\n    }\n}\n```\n\nThis Java program defines a `findMax` function that takes an array of strings called `words` as input and returns a string. The function first sorts the input array of strings using the `Arrays.sort` method and a custom `Comparator` object that sorts the strings by two criteria: first, by the number of unique characters in the string (in descending order), and second, by the alphabetical order of the string (in ascending order). The `Comparator` object uses the `distinct` method of the `String` class to count the number of unique characters in each string. Finally, the function returns the first string in the sorted array, which is the string with the highest number of unique characters and comes first in alphabetical order. \n\nThe `main` method of the program demonstrates how to use the `findMax` function with an example input array of strings. The program prints the expected output, which is the string \"programming\".<|im_end|>\n\n### Rust version\n\nfn find_max(words: Vec<String>) -> String {\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rs",
    "prompt": "fn generate_integers(a: isize, b: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = generate_integers;\n    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(17, 89), Vec::<isize>::new());\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n\n### Explanation\n\nThis program generates a list of even integers between two given integers. The function `generate_integers` takes two integer arguments `a` and `b`, and returns a list of integers. The function first sets the lower bound to be the maximum of 2 and the minimum of `a` and `b`, and the upper bound to be the minimum of 8 and the maximum of `a` and `b`. It then generates a list of integers between the lower and upper bounds, inclusive, that are even, and returns that list.\n\n### Rust version\n\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rs",
    "prompt": "fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(\"YES\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n\n### Explanation\n\nThis Python program takes in two lists of integers, lst1 and lst2, and returns \"YES\" if there are more even numbers in lst2 than odd numbers in lst1, otherwise it returns \"NO\". \n\nThe function `exchange` takes in two lists of integers, lst1 and lst2. It initializes two variables, `odd` and `even`, to 0. It then loops through lst1 and increments `odd` by 1 if the current element is odd. It then loops through lst2 and increments `even` by 1 if the current element is even. If `even` is greater than or equal to `odd`, the function returns \"YES\". Otherwise, it returns \"NO\". \n\nTo rewrite this program in Java, you would need to replace the `List` type with an array of integers. You would also need to change the syntax for the for loops. Here is an example of what the Java code might look like:\n\n```java\npublic static String exchange(int[] lst1, int[] lst2) {\n    int odd = 0;\n    int even = 0;\n    for (int i : lst1) {\n        if (i % 2 == 1) {\n            odd++;\n        }\n    }\n    for (int i : lst2) {\n        if (i % 2 == 0) {\n            even++;\n        }\n    }\n    if (even >= odd) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```<|im_end|>\n\n### Rust version\n\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rs",
    "prompt": "fn int_to_mini_roman(number: isize) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef int_to_mini_roman(number: int) -> str:\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n\n### Explanation\n\nThis function takes an integer and returns a string that represents the integer in mini roman numerals. The function first creates two lists, one with the values of the roman numerals and another with the symbols of the roman numerals. The function then initializes a variable `i` to 12 and an empty string `res`. The function then enters a while loop that continues as long as the input number is not zero. In the loop, the function first calculates the integer division of the input number and the value of the roman numeral at the current index `i` of the `num` list. It then calculates the remainder of the input number divided by the value of the roman numeral at the current index `i` of the `num` list. The function then enters another while loop that continues as long as the integer division is not zero. In the loop, the function adds the symbol of the roman numeral at the current index `i` of the `sym` list to the `res` string and decrements the integer division by one. The function then decrements the index `i` by one. Finally, the function returns the `res` string in lowercase.\n\n### Rust version\n\nfn int_to_mini_roman(number: isize) -> String {\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rs",
    "prompt": "fn is_equal_to_sum_even(n: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_equal_to_sum_even;\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), true);\n    assert_eq!(candidate(11), false);\n    assert_eq!(candidate(12), true);\n    assert_eq!(candidate(13), false);\n    assert_eq!(candidate(16), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef is_equal_to_sum_even(n: int) -> bool:\n    return n%2 == 0 and n >= 8\n\n### Explanation\n\nThis 1-line Python function takes an integer `n` as input and returns a boolean value. The function returns `True` if `n` is an even number greater than or equal to 8, and `False` otherwise.\n\n### Rust version\n\nfn is_equal_to_sum_even(n: isize) -> bool {\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "rs",
    "prompt": "fn decimal_to_binary(decimal: isize) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef decimal_to_binary(decimal: int) -> str:\n    return \"db\" + bin(decimal)[2:] + \"db\"\n\n### Explanation\n\nThis 1-line Python program defines a function called `decimal_to_binary` that takes an integer argument called `decimal` and returns a string. The string is the concatenation of the string \"db\", the binary representation of the decimal number (without the \"0b\" prefix), and the string \"db\". For example, `decimal_to_binary(10)` returns the string \"db1010db\".\n\n### Rust version\n\nfn decimal_to_binary(decimal: isize) -> String {\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rs",
    "prompt": "fn sort_third(l: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n\n### Explanation\n\nThis 3-line Python program sorts a list of integers by their third element. It does this by first converting the input list to a mutable list, then sorting every third element of the list, and finally returning the sorted list. To rewrite this program in Java, you would need to use an ArrayList to create a mutable list, and then use a for loop to sort every third element of the list. \n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class SortThird {\n    public static ArrayList<Integer> sortThird(ArrayList<Integer> l) {\n        ArrayList<Integer> result = new ArrayList<>(l);\n        for (int i = 2; i < result.size(); i += 3) {\n            Collections.sort(result.subList(i - 2, i + 1));\n        }\n        return result;\n    }\n}\n```\n\n### Rust version\n\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rs",
    "prompt": "fn simplify(x: String, n: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = simplify;\n    assert_eq!(candidate(String::from(\"1/5\"), String::from(\"5/1\")), true);\n    assert_eq!(candidate(String::from(\"1/6\"), String::from(\"2/1\")), false);\n    assert_eq!(candidate(String::from(\"5/1\"), String::from(\"3/1\")), true);\n    assert_eq!(candidate(String::from(\"7/10\"), String::from(\"10/2\")), false);\n    assert_eq!(candidate(String::from(\"2/10\"), String::from(\"50/10\")), true);\n    assert_eq!(candidate(String::from(\"7/2\"), String::from(\"4/2\")), true);\n    assert_eq!(candidate(String::from(\"11/6\"), String::from(\"6/1\")), true);\n    assert_eq!(candidate(String::from(\"2/3\"), String::from(\"5/2\")), false);\n    assert_eq!(candidate(String::from(\"5/2\"), String::from(\"3/5\")), false);\n    assert_eq!(candidate(String::from(\"2/4\"), String::from(\"8/4\")), true);\n    assert_eq!(candidate(String::from(\"2/4\"), String::from(\"4/2\")), true);\n    assert_eq!(candidate(String::from(\"1/5\"), String::from(\"5/1\")), true);\n    assert_eq!(candidate(String::from(\"1/5\"), String::from(\"1/5\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef simplify(x: str, n: str) -> bool:\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n\n### Explanation\n\nThis Python program defines a function called `simplify` that takes two string arguments `x` and `n` and returns a boolean value. The function first splits the two arguments by the `/` character and assigns the resulting values to the variables `a`, `b`, `c`, and `d`. It then multiplies the integers `a` and `c` to get the numerator of a fraction and multiplies the integers `b` and `d` to get the denominator of the fraction. The function then checks if the numerator divided by the denominator is equal to the integer value of the numerator divided by the denominator. If it is, the function returns `True`, otherwise it returns `False`. \n\nThis program checks if the fraction `x` is a simplified version of the fraction `n`. To rewrite this program in Java, you would need to define a function with the same name and arguments, and use the `split` method to split the strings into arrays of strings. You would then need to convert the strings to integers and perform the same calculations as in the Python program. Finally, you would need to check if the numerator divided by the denominator is equal to the integer value of the numerator divided by the denominator and return a boolean value accordingly. \n\nHere is an example of how you could rewrite this program in Java:\n\n```java\npublic static boolean simplify(String x, String n) {\n    String[] xArray = x.split(\"/\");\n    String[] nArray = n.split(\"/\");\n    int a = Integer.parseInt(xArray[0]);\n    int b = Integer.parseInt(xArray[1]);\n    int c = Integer.parseInt(nArray[0]);\n    int d = Integer.parseInt(nArray[1]);\n    int numerator = a * c;\n    int denom = b * d;\n    if (numerator / denom == numerator / denom) {\n        return true;\n    }\n    return false;\n}\n```\n\n### Rust version\n\nfn simplify(x: String, n: String) -> bool {\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rs",
    "prompt": "fn solve(s: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef solve(s: str) -> str:\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n\n### Explanation\n\nThis Python program takes a string as input and returns a string as output. The function `solve` first initializes two variables `flg` and `idx` to 0. It then creates a new list `new_str` which is a copy of the input string `s`. The function then iterates over each character in the input string `s`. If the character is an alphabet, it swaps the case of the character and updates the corresponding character in the `new_str` list. It also sets the `flg` variable to 1. The `idx` variable is used to keep track of the index of the character being processed. After processing all characters in the input string, the function creates an empty string `s` and iterates over each character in the `new_str` list and appends it to the `s` string. If no alphabets were found in the input string, it returns the reverse of the input string. Otherwise, it returns the modified string.\n\n### Rust version\n\nfn solve(s: String) -> String {\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rs",
    "prompt": "fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3, 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10, 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7, 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5, 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48, 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2, 2, 10), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef right_angle_triangle(a: int, b: int, c: int) -> bool:\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n\n### Explanation\n\nThis 3-line Python program defines a function called `right_angle_triangle` that takes three integer arguments `a`, `b`, and `c`. The function returns `True` if the three integers form a right-angled triangle, and `False` otherwise. A right-angled triangle is a triangle in which one of the angles is a right angle (90 degrees). The function checks whether the Pythagorean theorem is satisfied for any of the three sides of the triangle. The Pythagorean theorem states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of the squares of the lengths of the other two sides. Therefore, the function checks whether `a*a == b*b + c*c` or `b*b == a*a + c*c` or `c*c == a*a + b*b`.\n\n### Rust version\n\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rs",
    "prompt": "fn double_the_difference(lst: Vec<f64>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()), 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n\n### Explanation\n\nThis Python program takes a list of floats as input and returns the sum of the squares of all the positive odd numbers in the list. \n\nThe equivalent Java program would be:\n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static int doubleTheDifference(List<Float> lst) {\n        int sum = 0;\n        for (float i : lst) {\n            if (i > 0 && i % 2 != 0 && !Float.toString(i).contains(\".\")) {\n                sum += i * i;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n### Rust version\n\nfn double_the_difference(lst: Vec<f64>) -> isize {\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rs",
    "prompt": "fn below_zero(operations: Vec<isize>) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n\n### Explanation\n\nThis Python program takes in a list of integers called `operations` and returns a boolean value. It iterates through the list of integers and adds each integer to a variable called `balance`. If at any point the `balance` variable becomes negative, the function returns `True`. If the `balance` variable never becomes negative, the function returns `False`. \n\nThe program checks if the sum of the integers in the list is less than zero. If it is, it returns `True`, otherwise it returns `False`. \n\nTo rewrite this program in Java, you would need to create a method that takes in a list of integers as an argument and returns a boolean value. You would then iterate through the list of integers and add each integer to a variable called `balance`. If at any point the `balance` variable becomes negative, the function should return `true`. If the `balance` variable never becomes negative, the function should return `false`. \n\n```java\npublic boolean belowZero(List<Integer> operations) {\n    int balance = 0;\n\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```<|im_end|>\n\n### Rust version\n\nfn below_zero(operations: Vec<isize>) -> bool {\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rs",
    "prompt": "fn greatest_common_divisor(a: isize, b: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = greatest_common_divisor;\n    assert_eq!(candidate(3, 7), 1);\n    assert_eq!(candidate(10, 15), 5);\n    assert_eq!(candidate(49, 14), 7);\n    assert_eq!(candidate(144, 60), 12);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n\n### Explanation\n\nThis function takes two integers as input and returns their greatest common divisor. It does this by using the Euclidean algorithm, which is an efficient way to find the greatest common divisor of two numbers. The algorithm works by repeatedly subtracting the smaller number from the larger number until the two numbers are equal. At this point, the common divisor is the difference between the two numbers. If the two numbers are not equal, the algorithm continues by subtracting the smaller number from the larger number and repeating the process until the two numbers are equal. This process is repeated until the smaller number is zero, at which point the larger number is the greatest common divisor.\n\n### Rust version\n\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rs",
    "prompt": "fn f(n: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);\n    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);\n    assert_eq!(candidate(1), vec![1]);\n    assert_eq!(candidate(3), vec![1, 2, 6]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n\n### Explanation\n\nThis Python program defines a function `f(n)` that takes an integer `n` as input and returns a list of integers. The list contains `n` elements, where each element is either the product of all integers from 1 to the current index (inclusive) if the index is even, or the sum of all integers from 1 to the current index (inclusive) if the index is odd. The function first initializes an empty list `ret`, then iterates over the range of integers from 1 to `n` (inclusive). For each integer `i` in the range, the function checks if `i` is even or odd. If `i` is even, the function initializes a variable `x` to 1, then iterates over the range of integers from 1 to `i` (inclusive) and multiplies `x` by each integer in the range. If `i` is odd, the function initializes a variable `x` to 0, then iterates over the range of integers from 1 to `i` (inclusive) and adds each integer in the range to `x`. Finally, the function appends the value of `x` to the list `ret`. After iterating over all integers in the range, the function returns the list `ret`. \n\nHere is the equivalent Java code:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<Integer> f(int n) {\n        List<Integer> ret = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                int x = 1;\n                for (int j = 1; j <= i; j++) {\n                    x *= j;\n                }\n                ret.add(x);\n            } else {\n                int x = 0;\n                for (int j = 1; j <= i; j++) {\n                    x += j;\n                }\n                ret.add(x);\n            }\n        }\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(f(5)); // [1, 3, 24, 10, 720]\n    }\n}\n```\n\nThe `f` method takes an integer `n` as input and returns a list of integers. The list contains `n` elements, where each element is either the product of all integers from 1 to the current index (inclusive) if the index is even, or the sum of all integers from 1 to the current index (inclusive) if the index is odd. The method first initializes an empty list `ret`, then iterates over the range of integers from 1 to `n` (inclusive). For each integer `i` in the range, the method checks if `i` is even or odd. If `i` is even, the method initializes a variable `x` to 1, then iterates over the range of integers from 1 to `i` (inclusive) and multiplies `x` by each integer in the range. If `i` is odd, the method initializes a variable `x` to 0, then iterates over the range of integers from 1 to `i` (inclusive) and adds each integer in the range to `x`. Finally, the method adds the value of `x` to the list `ret`. After iterating over all integers in the range, the method returns the list `ret`. \n\nThe `main` method simply calls the `f` method with an input of 5 and prints the result. The output should be `[1,\n\n### Rust version\n\nfn f(n: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rs",
    "prompt": "fn monotonic(l: Vec<isize>) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1, 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n    assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef monotonic(l: List[int]) -> bool:\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n\n### Explanation\n\nThis Python program checks if a list of integers is monotonic. A list is monotonic if it is either non-increasing or non-decreasing. The function `monotonic` takes a list of integers `l` as input and returns a boolean value. The function returns `True` if the input list is monotonic, otherwise it returns `False`. The function first checks if the input list is sorted in increasing order or decreasing order. If the list is sorted in either of these ways, then it is monotonic and the function returns `True`. If the list is not sorted in either of these ways, then it is not monotonic and the function returns `False`.\n\n### Rust version\n\nfn monotonic(l: Vec<isize>) -> bool {\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rs",
    "prompt": "fn by_length(arr: Vec<isize>) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef by_length(arr: List[int]) -> List[str]:\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n\n### Explanation\n\nThis Python program takes in a list of integers and returns a list of strings. The strings are the English names of the integers in the input list, sorted in descending order of the length of the names. For example, if the input list is [3, 4, 5, 1], the output list will be [\"Three\", \"Four\", \"Five\", \"One\"] because \"Three\" is the longest name, followed by \"Four\" and \"Five\", and \"One\" is the shortest name. If two or more integers have the same length of name, they will be sorted in descending order of their values. If an integer in the input list is not in the dictionary, it will be ignored. \n\nHere is the equivalent Java code:\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> arr = new ArrayList<>(Arrays.asList(3, 4, 5, 1));\n        List<String> result = byLength(arr);\n        System.out.println(result); // [\"Three\", \"Four\", \"Five\", \"One\"]\n    }\n\n    public static List<String> byLength(List<Integer> arr) {\n        Map<Integer, String> dic = new HashMap<>();\n        dic.put(1, \"One\");\n        dic.put(2, \"Two\");\n        dic.put(3, \"Three\");\n        dic.put(4, \"Four\");\n        dic.put(5, \"Five\");\n        dic.put(6, \"Six\");\n        dic.put(7, \"Seven\");\n        dic.put(8, \"Eight\");\n        dic.put(9, \"Nine\");\n\n        List<Integer> sortedArr = new ArrayList<>(arr);\n        Collections.sort(sortedArr, Collections.reverseOrder());\n\n        List<String> newArr = new ArrayList<>();\n        for (Integer var : sortedArr) {\n            if (dic.containsKey(var)) {\n                newArr.add(dic.get(var));\n            }\n        }\n\n        Collections.sort(newArr, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                if (s1.length() == s2.length()) {\n                    return s2.compareTo(s1);\n                } else {\n                    return s2.length() - s1.length();\n                }\n            }\n        });\n\n        return newArr;\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "rs",
    "prompt": "fn remove_vowels(text: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = remove_vowels;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"abcdef\nghijklm\")), String::from(\"bcdf\nghjklm\"));\n    assert_eq!(candidate(String::from(\"fedcba\")), String::from(\"fdcb\"));\n    assert_eq!(candidate(String::from(\"eeeee\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"acBAA\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"EcBOO\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"ybcd\")), String::from(\"ybcd\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef remove_vowels(text: str) -> str:\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n\n### Explanation\n\nThis Python program takes a string as input and returns a new string with all vowels removed. The function `remove_vowels` receives a string `text` as input and returns a new string that is the result of joining all characters in `text` that are not vowels. The list comprehension `[s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]]` iterates over all characters in `text` and returns a new list with all characters that are not vowels. Finally, the `join` method is used to concatenate all characters in the list into a new string.\n\n### Rust version\n\nfn remove_vowels(text: String) -> String {\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rs",
    "prompt": "fn check_if_last_char_is_a_letter(txt: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n\n### Explanation\n\nThis 1-line Python function takes a string as input and returns a boolean value. The function checks if the last character of the input string is a letter. If the last character is a letter, the function returns True. If the last character is not a letter, the function returns False. The function uses the `split()` method to split the input string into a list of words. It then uses the `[-1]` index to get the last word in the list. Finally, it checks if the length of the last word is 1 and if the ASCII code of the lowercase version of the last character is between 97 and 122 (inclusive). If both conditions are true, the function returns True. Otherwise, it returns False.\n\n### Rust version\n\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rs",
    "prompt": "fn iscube(a: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef iscube(a: int) -> bool:\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n\n### Explanation\n\nThis 3-line Python program defines a function `iscube` that takes an integer `a` and returns a boolean. The function returns `True` if `a` is a perfect cube, and `False` otherwise. The function first takes the absolute value of `a` to ensure that negative numbers are handled correctly. It then computes the cube root of `a` using the `**` operator and the `1/3` exponent. The result is rounded to the nearest integer using the `round` function, and then cubed using the `**` operator again. If the result is equal to `a`, then `a` is a perfect cube and the function returns `True`. Otherwise, it returns `False`.\n\n### Rust version\n\nfn iscube(a: isize) -> bool {\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "rs",
    "prompt": "fn reverse_delete(s: String, c: String) -> (String, bool) {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import Tuple\n\ndef reverse_delete(s: str,c: str) -> Tuple[str, bool]:\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n\n### Explanation\n\nThis 3-line Python program defines a function `reverse_delete` that takes two parameters: a string `s` and a string `c`. The function returns a tuple containing two values: the modified string `s` and a boolean indicating whether the modified string is a palindrome.\n\nThe function first removes all characters in `s` that are also in `c`. It then checks whether the modified string is a palindrome by comparing it to its reverse. If the modified string is a palindrome, the second value in the tuple is `True`, otherwise it is `False`.\n\n### Rust version\n\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rs",
    "prompt": "fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = mean_absolute_deviation;\n    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n### Explanation\n\nThis Python program calculates the mean absolute deviation of a list of numbers. The mean is first calculated by dividing the sum of the numbers by the length of the list. Then, the absolute difference between each number and the mean is calculated and summed up. Finally, the sum is divided by the length of the list to get the mean absolute deviation. To rewrite this program in Java, you would need to declare a List of floats as the input parameter, calculate the mean using the sum() and size() methods, and then calculate the sum of the absolute differences using a for loop. Finally, divide the sum by the size of the list to get the mean absolute deviation. \n\n```java\nimport java.util.List;\n\npublic class MeanAbsoluteDeviation {\n    public static float meanAbsoluteDeviation(List<Float> numbers) {\n        float mean = 0;\n        for (float number : numbers) {\n            mean += number;\n        }\n        mean /= numbers.size();\n        float sum = 0;\n        for (float number : numbers) {\n            sum += Math.abs(number - mean);\n        }\n        return sum / numbers.size();\n    }\n}\n```\n\n### Rust version\n\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rs",
    "prompt": "fn correct_bracketing(brackets: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Explanation\n\nThis function takes a string of brackets and returns True if the brackets are balanced, False otherwise. The brackets are balanced if each opening bracket has a corresponding closing bracket. In this case, the brackets are \"<\" and \">\". The function works by iterating through each bracket in the string. If the bracket is an opening bracket, the depth is incremented. If the bracket is a closing bracket, the depth is decremented. If the depth ever becomes negative, it means that there is a closing bracket without a corresponding opening bracket, so the function returns False. If the depth is zero at the end of the iteration, it means that all opening brackets have a corresponding closing bracket, so the function returns True.\n\n### Rust version\n\nfn correct_bracketing(brackets: String) -> bool {\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rs",
    "prompt": "fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n\n### Explanation\n\nThis Python program takes a list of floating point numbers as input and returns a new list of the same numbers, but rescaled to the interval [0, 1]. The rescaling is done by subtracting the minimum value of the input list from each element and then dividing the result by the difference between the maximum and minimum values. The function `rescale_to_unit` takes a list of floating point numbers as input and returns a new list of the same numbers, but rescaled to the interval [0, 1]. The rescaling is done by subtracting the minimum value of the input list from each element and then dividing the result by the difference between the maximum and minimum values. The function uses the `min` and `max` functions to find the minimum and maximum values of the input list, and then applies the rescaling formula to each element using a list comprehension.\n\n### Rust version\n\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rs",
    "prompt": "fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n\n### Explanation\n\nThis Python program defines a function `intersection` that takes two tuples of integers as input and returns a string. The function first defines a helper function `is_prime` that checks if a given number is prime. The function then finds the intersection of the two input intervals and calculates its length. If the length is a prime number, the function returns \"YES\", otherwise it returns \"NO\". The function can be rewritten in Java using the `java.util` package for tuples and a separate function for checking prime numbers. Here is an example implementation:\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Pair<Integer, Integer> interval1 = new Pair<>(1, 5);\n        Pair<Integer, Integer> interval2 = new Pair<>(3, 7);\n        System.out.println(intersection(interval1, interval2));\n    }\n\n    public static String intersection(Pair<Integer, Integer> interval1, Pair<Integer, Integer> interval2) {\n        int l = Math.max(interval1.getKey(), interval2.getKey());\n        int r = Math.min(interval1.getValue(), interval2.getValue());\n        int length = r - l;\n        if (length > 0 && isPrime(length)) {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n    public static boolean isPrime(int num) {\n        if (num == 1 || num == 0) {\n            return false;\n        }\n        if (num == 2) {\n            return true;\n        }\n        for (int i = 2; i < num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}<|im_end|>\n\n### Rust version\n\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rs",
    "prompt": "fn hex_key(num: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef hex_key(num: str) -> int:\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n\n### Explanation\n\nThis Python program takes a string of hexadecimal digits as input and returns the number of digits that are prime numbers (2, 3, 5, 7, B, and D). The function `hex_key` takes one argument, `num`, which is the hexadecimal string. The function iterates over each character in the string and checks if it is a prime number. If it is, it increments a counter. Finally, the function returns the total count of prime numbers found in the input string. \n\nTo rewrite this program in Java, you would need to change the function signature to:\n\n```java\npublic static int hex_key(String num) {\n```\n\nYou would also need to replace the `for` loop with a `while` loop or a `foreach` loop, since Java does not have a `range` function. Additionally, you would need to change the `if` statement to use `char` literals instead of string literals, since Java treats single characters as `char` types, not `String` types. Here is an example of what the Java code might look like:\n\n```java\npublic static int hex_key(String num) {\n    char[] primes = {'2', '3', '5', '7', 'B', 'D'};\n    int total = 0;\n    for (int i = 0; i < num.length(); i++) {\n        if (contains(primes, num.charAt(i))) {\n            total++;\n        }\n    }\n    return total;\n}\n\npublic static boolean contains(char[] arr, char c) {\n    for (char ch : arr) {\n        if (ch == c) {\n            return true;\n        }\n    }\n    return false;\n}\n```<|im_end|>\n\n### Rust version\n\nfn hex_key(num: String) -> isize {\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rs",
    "prompt": "fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n\n### Explanation\n\nThis function sorts a list of integers in a strange way. It starts by creating an empty list called `res` and a boolean variable called `switch` which is set to `True`. Then, it enters a while loop that runs as long as the input list `lst` is not empty. Inside the loop, it appends either the minimum or maximum value of `lst` to `res` depending on the value of `switch`. It then removes the last element of `lst` from the list and toggles the value of `switch`. Finally, it returns the sorted list `res`.\n\n### Rust version\n\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "rs",
    "prompt": "fn is_bored(S: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef is_bored(S: str) -> int:\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n\n### Explanation\n\nThis 3-line program defines a function `is_bored` that takes a string `S` as input and returns an integer. The function first imports the `re` module, which provides support for regular expressions. It then splits the input string `S` into a list of sentences using a regular expression that matches any of the characters `.`, `?`, or `!` followed by zero or more whitespace characters. Finally, it counts the number of sentences that start with the substring `'I '` (i.e., the first two characters of the sentence are `'I '`), and returns this count.\n\n### Rust version\n\nfn is_bored(S: String) -> isize {\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rs",
    "prompt": "fn all_prefixes(string: String) -> Vec<String> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\")]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n\n### Explanation\n\nThis Python program takes a string as input and returns a list of all the prefixes of the string. A prefix of a string is a substring that starts from the beginning of the string. The function `all_prefixes` takes a string as input and initializes an empty list called `result`. It then iterates over the length of the string using a `for` loop and appends the substring of the string from the beginning to the current index to the `result` list. Finally, it returns the `result` list containing all the prefixes of the input string.\n\n### Rust version\n\nfn all_prefixes(string: String) -> Vec<String> {\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rs",
    "prompt": "fn how_many_times(string: String, substring: String) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef how_many_times(string: str, substring: str) -> int:\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n### Explanation\n\nThis Python program defines a function called `how_many_times` that takes two string arguments, `string` and `substring`, and returns an integer. The function counts the number of times the `substring` appears in the `string`. The function does this by initializing a variable called `times` to 0, and then iterating over the `string` using a for loop. The loop iterates over the indices of the `string` from 0 to the length of the `string` minus the length of the `substring` plus 1. At each iteration, the function checks if the substring appears in the `string` at the current index. If it does, it increments the `times` variable. Finally, the function returns the `times` variable.\n\n### Rust version\n\nfn how_many_times(string: String, substring: String) -> isize {\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rs",
    "prompt": "fn solution(lst: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = solution;\n    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);\n    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);\n    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);\n    assert_eq!(candidate(vec![5, 9]), 5);\n    assert_eq!(candidate(vec![2, 4, 8]), 0);\n    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);\n    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef solution(lst: List[int]) -> int:\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n\n### Explanation\n\nThis Python program takes in a list of integers and returns the sum of all the odd numbers in the list that are at even indices (0-indexed). \n\nThe function `solution` takes in a list of integers `lst` and returns an integer. The function uses a list comprehension to iterate through the list and sum up all the odd numbers that are at even indices. The `enumerate` function is used to get the index and value of each element in the list. The `if` statement checks if the index is even and the value is odd. If both conditions are true, the value is added to the sum. The `sum` function is used to add up all the values in the list comprehension and return the final sum.\n\n### Rust version\n\nfn solution(lst: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rs",
    "prompt": "fn search(lst: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n    assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]), 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]), -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef search(lst: List[int]) -> int:\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n\n### Explanation\n\nThis Python program takes a list of integers as input and returns the largest integer `i` such that there are at least `i` occurrences of `i` in the input list. If there is no such integer, it returns `-1`. \n\nThe function `search` first creates a list `frq` of length `max(lst) + 1` and initializes all its elements to `0`. It then iterates over the input list `lst` and increments the element of `frq` corresponding to the current element of `lst`. \n\nFinally, it iterates over the elements of `frq` from index `1` to `len(frq) - 1` (inclusive) and checks if the element at index `i` is greater than or equal to `i`. If it is, it updates the answer variable `ans` to `i`. The function then returns `ans`. \n\nTo rewrite this program in Java, you would need to replace the `List` import with `java.util.List` and use the appropriate syntax for declaring and initializing arrays and iterating over them. Here is a possible Java implementation:\n\n```java\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Search {\n    public static int search(List<Integer> lst) {\n        int[] frq = new int[Collections.max(lst) + 1];\n        for (int i : lst) {\n            frq[i]++;\n        }\n\n        int ans = -1;\n        for (int i = 1; i < frq.length; i++) {\n            if (frq[i] >= i) {\n                ans = i;\n            }\n        }\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> lst = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4, 4);\n        int ans = search(lst);\n        System.out.println(ans); // prints 3\n    }\n}\n```<|im_end|>\n\n### Rust version\n\nfn search(lst: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rs",
    "prompt": "fn pluck(arr: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n\n### Explanation\n\nThis function takes in a list of integers and returns a list with two elements. The first element is the smallest even number in the input list and the second element is the index of the smallest even number in the input list. If there are no even numbers in the input list, the function returns an empty list. If the input list is empty, the function returns an empty list.\n\n### Rust version\n\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rs",
    "prompt": "fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n\n### Explanation\n\nThis Python program takes in a list of integers and returns a boolean value indicating whether there are any two numbers in the list that sum to zero. The function `pairs_sum_to_zero` iterates over each element in the list, and for each element, it checks all the remaining elements in the list to see if their sum is zero. If a pair of elements is found that sum to zero, the function returns `True`. If no such pair is found, the function returns `False`.\n\n### Rust version\n\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rs",
    "prompt": "fn make_palindrome(string: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while string[beginning_of_suffix:] != string[beginning_of_suffix:][::-1]:\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n\n### Explanation\n\nThis program takes a string as input and returns a palindrome by concatenating the input string with its reverse. If the input string is already a palindrome, the function returns the input string. If the input string is empty, the function returns an empty string.\n\nThe function starts by checking if the input string is empty. If it is, the function returns an empty string. If the input string is not empty, the function initializes a variable `beginning_of_suffix` to 0. The variable `beginning_of_suffix` is used to keep track of the beginning of the suffix that needs to be added to the input string to make it a palindrome.\n\nThe function then enters a while loop that continues until the suffix added to the input string makes it a palindrome. The suffix is obtained by slicing the input string from the index `beginning_of_suffix` to the end of the string and reversing it. The function checks if the input string concatenated with the suffix is a palindrome. If it is not, the function increments the `beginning_of_suffix` variable and tries again.\n\nOnce the suffix is found, the function returns the input string concatenated with the reversed suffix.\n\n### Rust version\n\nfn make_palindrome(string: String) -> String {\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rs",
    "prompt": "fn starts_one_ends(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef starts_one_ends(n: int) -> int:\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n\n### Explanation\n\nThis Python function `starts_one_ends` takes an integer `n` and returns another integer. If `n` is equal to 1, the function returns 1. Otherwise, it returns 18 times 10 to the power of `n` minus 2.\n\n### Rust version\n\nfn starts_one_ends(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "rs",
    "prompt": "fn get_positive(l: Vec<isize>) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = get_positive;\n    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);\n    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n    return [e for e in l if e > 0]\n\n### Explanation\n\nThis 3-line Python program defines a function called `get_positive` that takes a list of integers as input and returns a new list containing only the positive integers. The function uses a list comprehension to create the new list, iterating over the input list and including only those elements that are greater than zero. The `typing` module is used to provide type hints for the function signature, indicating that the input is a list of integers and the output is also a list of integers. To translate this program to Java, you would need to define a method that takes an array of integers as input and returns a new array containing only the positive integers. You would need to use a loop to iterate over the input array and check each element to see if it is greater than zero before adding it to the output array. You would also need to specify the types of the input and output parameters in the method signature, using the appropriate syntax for Java. \n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = {1, -2, 3, -4, 5};\n        int[] posArr = getPositive(arr);\n        for (int i : posArr) {\n            System.out.println(i);\n        }\n    }\n\n    public static int[] getPositive(int[] arr) {\n        List<Integer> posList = new ArrayList<>();\n        for (int i : arr) {\n            if (i > 0) {\n                posList.add(i);\n            }\n        }\n        int[] posArr = new int[posList.size()];\n        for (int i = 0; i < posList.size(); i++) {\n            posArr[i] = posList.get(i);\n        }\n        return posArr;\n    }\n}\n```\n\nThis Java program defines a `Main` class with a `main` method that creates an array of integers, calls the `getPositive` method to get a new array containing only the positive integers, and prints the elements of the new array. The `getPositive` method takes an array of integers as input and returns a new array containing only the positive integers. The method uses a loop to iterate over the input array and add each positive integer to a `List` of integers. Then, it creates a new array with the same size as the `List` and copies the elements of the `List` to the new array. Finally, it returns the new array. The `List` class is used to store the positive integers because it allows for dynamic resizing, unlike arrays which have a fixed size. The `ArrayList` implementation of the `List` interface is used because it provides efficient add and get operations. The `static` keyword is used to define the `getPositive` method as a class method that can be called without creating an instance of the `Main` class. The `public` keyword is used to make the method accessible from outside the class. The `int[]` type is used to specify the type of the input and output parameters. The `for-each` loop is used to iterate over the elements of the input array and the `size` method is used to get the size of the `List`. The `get` method is used to access the elements of the `List` by index. The `new` keyword is used to create a new array with a specified size. The `return` keyword is used to return the new array.\n\n### Rust version\n\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rs",
    "prompt": "fn concatenate(strings: Vec<String>) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n\n### Explanation\n\nThis 3-line Python program defines a function called `concatenate` that takes a list of strings as input and returns a single string that is the concatenation of all the strings in the input list. The function uses the built-in `join` method of Python strings to concatenate the strings in the input list. The function is defined with type annotations for the input and output types, indicating that the input is a list of strings and the output is a single string. To rewrite this program in Java, you would need to define a function that takes an array of strings as input and returns a single string that is the concatenation of all the strings in the input array. You would also need to use the `StringBuilder` class in Java to concatenate the strings, rather than the `join` method used in Python. Here is an example Java implementation:\n\n```java\nimport java.util.Arrays;\n\npublic class ConcatenateStrings {\n    public static String concatenate(String[] strings) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : strings) {\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        String[] strings = {\"hello\", \"world\"};\n        String result = concatenate(strings);\n        System.out.println(result);\n    }\n}\n```\n\n### Rust version\n\nfn concatenate(strings: Vec<String>) -> String {\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rs",
    "prompt": "fn is_nested(string: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef is_nested(string: str) -> bool:\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n### Explanation\n\nThis program checks if a string is nested. A string is considered nested if it contains two or more pairs of square brackets that are properly nested. \n\nThe function `is_nested` takes a string as input and returns a boolean value. It first initializes two empty lists, `opening_bracket_index` and `closing_bracket_index`. It then iterates through the string and appends the index of each opening bracket to `opening_bracket_index` and the index of each closing bracket to `closing_bracket_index`. \n\nThe function then reverses the order of the elements in `closing_bracket_index`. It then initializes a counter `cnt` to 0, an index `i` to 0, and a variable `l` to the length of `closing_bracket_index`. \n\nThe function then iterates through each index in `opening_bracket_index`. If `i` is less than `l` and the current index in `opening_bracket_index` is less than the current index in `closing_bracket_index`, then `cnt` is incremented and `i` is incremented. \n\nFinally, the function returns `True` if `cnt` is greater than or equal to 2, indicating that there are at least two pairs of properly nested square brackets in the string, and `False` otherwise. \n\nTo rewrite this program in Java, you would need to declare the function signature and replace the `for` loops with equivalent Java syntax. Here is an example:\n\n```java\npublic static boolean isNested(String string) {\n    List<Integer> openingBracketIndex = new ArrayList<>();\n    List<Integer> closingBracketIndex = new ArrayList<>();\n    for (int i = 0; i < string.length(); i++) {\n        if (string.charAt(i) == '[') {\n            openingBracketIndex.add(i);\n        } else if (string.charAt(i) == ']') {\n            closingBracketIndex.add(i);\n        }\n    }\n    Collections.reverse(closingBracketIndex);\n    int cnt = 0;\n    int i = 0;\n    int l = closingBracketIndex.size();\n    for (int idx : openingBracketIndex) {\n        if (i < l && idx < closingBracketIndex.get(i)) {\n            cnt++;\n            i++;\n        }\n    }\n    return cnt >= 2;\n}\n```<|im_end|>\n\n### Rust version\n\nfn is_nested(string: String) -> bool {\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rs",
    "prompt": "fn is_palindrome(text: String) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef is_palindrome(text: str) -> bool:\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n\n### Explanation\n\nThis Python program checks if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward. The function `is_palindrome` takes in a string `text` and returns a boolean value indicating whether the string is a palindrome or not. The function iterates through the string, comparing the first and last characters, then the second and second-to-last characters, and so on. If any of the characters don't match, the function returns `False`. If all the characters match, the function returns `True`.\n\n### Rust version\n\nfn is_palindrome(text: String) -> bool {\n"
  },
  {
    "name": "HumanEval_108_count_nums",
    "language": "rs",
    "prompt": "fn count_nums(arr: Vec<isize>) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_108_count_nums.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n\n### Explanation\n\nThis Python program takes in an array of integers and returns the count of integers whose digits sum to a positive number. The `count_nums` function takes in an array of integers `arr` and returns the length of the list of integers whose digits sum to a positive number. The `digits_sum` function takes in an integer `n` and returns the sum of the digits of `n`. The `digits_sum` function first checks if `n` is negative and sets a flag `neg` to -1 if it is. It then converts `n` to a string and splits it into a list of integers. It then multiplies the first element of the list by `neg` and returns the sum of the list. The `count_nums` function uses a lambda function to filter the list of integers returned by `digits_sum` to only include positive integers. It then returns the length of this filtered list.\n\n### Rust version\n\nfn count_nums(arr: Vec<isize>) -> isize {\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rs",
    "prompt": "fn factorize(n: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n### Explanation\n\nThis Python program takes an integer `n` as input and returns a list of integers that are the prime factors of `n`. The function `factorize` first imports the `math` module and initializes an empty list `fact`. It then initializes a variable `i` to 2 and enters a while loop that runs as long as `i` is less than or equal to the square root of `n` plus 1. If `n` is divisible by `i`, `i` is appended to the list `fact` and `n` is divided by `i`. Otherwise, `i` is incremented by 1. If `n` is greater than 1, it is appended to the list `fact`. The function then returns the list `fact`.\n\n### Rust version\n\nfn factorize(n: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rs",
    "prompt": "fn largest_prime_factor(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef largest_prime_factor(n: int) -> int:\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n\n### Explanation\n\nThis function takes an integer `n` as input and returns the largest prime factor of `n`. It does this by first defining a helper function `is_prime(k)` that checks whether a number `k` is prime or not. The `is_prime()` function returns `True` if `k` is prime and `False` otherwise. The main function then initializes a variable `largest` to 1 and loops over all numbers `j` from 2 to `n`. For each `j`, it checks whether `n` is divisible by `j` and whether `j` is prime. If both conditions are true, it updates the value of `largest` to be the maximum of its current value and `j`. Finally, it returns the value of `largest`, which is the largest prime factor of `n`. \n\nTo rewrite this program in Java, you would need to define a `largestPrimeFactor(int n)` function that takes an integer `n` as input and returns the largest prime factor of `n`. You would also need to define a helper function `isPrime(int k)` that checks whether a number `k` is prime or not. The rest of the code would be similar to the Python version, with a loop over all numbers from 2 to `n` and an `if` statement that checks whether `n` is divisible by the current number and whether the current number is prime. You would also need to use the `Math.max()` function to update the value of `largest`. Finally, you would return the value of `largest`, which is the largest prime factor of `n`. \n\nHere is an example Java implementation:\n\n```\npublic static int largestPrimeFactor(int n) {\n    int largest = 1;\n    for (int j = 2; j <= n; j++) {\n        if (n % j == 0 && isPrime(j)) {\n            largest = Math.max(largest, j);\n        }\n    }\n    return largest;\n}\n\npublic static boolean isPrime(int k) {\n    if (k < 2) {\n        return false;\n    }\n    for (int i = 2; i <= Math.sqrt(k); i++) {\n        if (k % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```<|im_end|>\n\n### Rust version\n\nfn largest_prime_factor(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rs",
    "prompt": "fn get_max_triples(n: isize) -> isize {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5), 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n    assert_eq!(candidate(100), 53361);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef get_max_triples(n: int) -> int:\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n\n### Explanation\n\nThis Python program returns the number of triples (i,j,k) such that i < j < k and (A[i]+A[j]+A[k])%3 == 0, where A[i] = i*i - i + 1 for i in range(1,n+1). \n\nThe function `get_max_triples` takes an integer `n` as input and returns an integer. It first constructs a list `A` of length `n` where the i-th element of `A` is equal to i*i - i + 1. It then initializes an empty list `ans` and loops over all possible triples (i,j,k) with i < j < k and adds the triple to `ans` if (A[i]+A[j]+A[k])%3 == 0. Finally, the function returns the length of `ans`.\n\n### Rust version\n\nfn get_max_triples(n: isize) -> isize {\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rs",
    "prompt": "fn anti_shuffle(s: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef anti_shuffle(s: str) -> str:\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n\n### Explanation\n\nThis 1-liner Python function takes a string `s` and returns a new string where each word in `s` has its letters sorted alphabetically. The words are separated by spaces. The function works by first splitting the input string into a list of words, then sorting the letters of each word, and finally joining the words back into a string with spaces between them. The function is called `anti_shuffle` because it undoes the effect of shuffling the letters of each word in the input string. To rewrite this program in Java, you would need to use a loop to iterate over the words in the input string, and another loop to sort the letters of each word. You would also need to use a StringBuilder to construct the output string.\n\n### Rust version\n\nfn anti_shuffle(s: String) -> String {\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "rs",
    "prompt": "fn solve(N: isize) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(1000), String::from(\"1\"));\n    assert_eq!(candidate(150), String::from(\"110\"));\n    assert_eq!(candidate(147), String::from(\"1100\"));\n    assert_eq!(candidate(333), String::from(\"1001\"));\n    assert_eq!(candidate(963), String::from(\"10010\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef solve(N: int) -> str:\n    return bin(sum(int(i) for i in str(N)))[2:]\n\n### Explanation\n\nThis 1-line function takes an integer `N` and returns a string that represents the binary representation of the sum of the digits of `N`. \n\nFirst, the digits of `N` are converted to a list of integers using `str(N)` and `int(i) for i in str(N)`. Then, the sum of the digits is computed using `sum()`. Finally, the binary representation of the sum is computed using `bin()`, and the first two characters of the result are removed using `[2:]` to remove the `0b` prefix.\n\n### Rust version\n\nfn solve(N: isize) -> String {\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rs",
    "prompt": "fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n\n### Explanation\n\nThis Python program takes a 2D grid of integers and an integer `k` as input. The program then finds the minimum path from the top-left corner to the bottom-right corner of the grid, where the path can only move right or down. The program then returns a list of length `k`, where the even-indexed elements are 1 and the odd-indexed elements are the minimum path value. \n\nTo rewrite this program in Java, you would need to replace the `List` type with an array, and use a for-loop to iterate over the array instead of using the `range` function. You would also need to change the syntax for appending elements to a list, and use a different syntax for finding the minimum value in a list. Here is an example Java implementation:\n\n```java\npublic static int[] minPath(int[][] grid, int k) {\n    int n = grid.length;\n    int val = n * n + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                List<Integer> temp = new ArrayList<>();\n                if (i != 0) {\n                    temp.add(grid[i - 1][j]);\n                }\n\n                if (j != 0) {\n                    temp.add(grid[i][j - 1]);\n                }\n\n                if (i != n - 1) {\n                    temp.add(grid[i + 1][j]);\n                }\n\n                if (j != n - 1) {\n                    temp.add(grid[i][j + 1]);\n                }\n\n                val = Collections.min(temp);\n            }\n        }\n    }\n\n    int[] ans = new int[k];\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            ans[i] = 1;\n        } else {\n            ans[i] = val;\n        }\n    }\n    return ans;\n}\n```<|im_end|>\n\n### Rust version\n\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rs",
    "prompt": "fn encrypt(s: String) -> String {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef encrypt(s: str) -> str:\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n\n### Explanation\n\nThis function takes a string as input and returns a string. It first initializes a string `d` with all the lowercase letters of the alphabet. It then initializes an empty string `out`. It then iterates over each character `c` in the input string `s`. If the character `c` is in the string `d`, it finds the index of `c` in `d`, adds `2*2` to it, takes the result modulo `26`, and uses the resulting index to get the corresponding character in `d`. This character is then appended to the string `out`. If the character `c` is not in the string `d`, it is simply appended to `out`. Finally, the function returns the string `out`.\n\n### Rust version\n\nfn encrypt(s: String) -> String {\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rs",
    "prompt": "fn make_a_pile(n: isize) -> Vec<isize> {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\nfrom typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2*i for i in range(n)]\n\n### Explanation\n\nThis 3-line Python program defines a function called `make_a_pile` that takes an integer `n` as input and returns a list of integers. The list contains `n` elements, where each element is equal to `n` plus twice the index of the element in the list. The first element of the list is `n`, the second element is `n+2`, the third element is `n+4`, and so on.\n\n### Rust version\n\nfn make_a_pile(n: isize) -> Vec<isize> {\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rs",
    "prompt": "fn is_prime(n: isize) -> bool {\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n}\n",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Python program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Rust?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Explanation\n\nThis function takes an integer `n` as input and returns a tuple of two integers. The first integer is the number of even palindromes between 1 and `n`, and the second integer is the number of odd palindromes between 1 and `n`. A palindrome is a number that reads the same forwards and backwards.\n\nThe function first defines a helper function `is_palindrome` that takes a number and returns `True` if it is a palindrome and `False` otherwise. This is done by converting the number to a string and checking if the string is equal to its reverse.\n\nThe function then initializes two counters, `even_palindrome_count` and `odd_palindrome_count`, to 0. It then loops through all numbers between 1 and `n` (inclusive) and checks if each number is a palindrome and even or odd. If the number is a palindrome and odd, it increments `odd_palindrome_count`. If the number is a palindrome and even, it increments `even_palindrome_count`.\n\nFinally, the function returns a tuple of the two counters.\n\n### Rust version\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    fn is_palindrome(n: isize) -> bool {\n        n.to_string() == n.to_string().chars().rev().collect::<String>()\n    }\n\n    let mut even_palindrome_count = 0;\n    let mut odd_palindrome_count = 0;\n\n    for i in 1..=n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1;\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1;\n        }\n    }\n    (even_palindrome_count, odd_palindrome_count)\n}\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Explanation\n\nThis function takes in a list of integers and returns a boolean indicating whether the list is sorted in non-descending order and has no more than two occurrences of any integer. The function first creates a dictionary where the keys are the integers in the list and the values are the number of times that integer appears in the list. It then checks if any integer appears more than twice in the list, and returns False if so. Finally, it checks if the list is sorted in non-descending order, and returns True if so, and False otherwise.\n\n### Rust version\n\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut count_digit = std::collections::HashMap::new();\n    for i in &lst {\n        *count_digit.entry(i).or_insert(0) += 1;\n    }\n\n    if lst.iter().any(|i| count_digit[i] > 2) {\n        return false;\n    }\n\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Explanation\n\nThis function takes a string of parentheses and returns a list of strings, where each string is a group of parentheses. A group is defined as a set of parentheses that are balanced, meaning that each opening parenthesis has a corresponding closing parenthesis. The function works by iterating over each character in the input string, and keeping track of the current depth of nested parentheses. When an opening parenthesis is encountered, the depth is incremented and the character is added to the current string. When a closing parenthesis is encountered, the depth is decremented and the character is added to the current string. If the depth reaches 0, it means that a complete group has been found, so the current string is added to the result list and cleared for the next group. The function returns the list of groups.\n\n### Rust version\n\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current_string = vec![];\n    let mut current_depth = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.iter().collect());\n                current_string.clear();\n            }\n        }\n    }\n\n    result\n}\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Explanation\n\nThis function takes a list of integers `array` as input and returns a sorted list of integers. The function first checks if the input list is empty. If it is, it returns an empty list. Otherwise, it sorts the list using the `sorted` function. The `reverse` parameter is set to `True` if the sum of the first and last elements of the array is even (and the array will be sorted in descending order), otherwise, it is set to `False` (and the array will be sorted in ascending order).\n\n### Rust version\n\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n        return vec![];\n    }\n    let reverse = (array[0] + array[array.len() - 1]) % 2 == 0;\n    let mut array = array;\n    array.sort_unstable();\n    if reverse {\n        array.reverse();\n    }\n    array\n}\n\n### Python version\n\ndef is_prime(n:int) -> bool:\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n### Explanation\n\nThis Python program checks if a given number `n` is a prime number. A prime number is a number that is divisible only by 1 and itself. The function `is_prime` takes an integer `n` as input and returns `True` if `n` is a prime number and `False` otherwise. The function first checks if `n` is less than 2, in which case it returns `False`. Then it loops through all integers `k` from 2 to `n-1` and checks if `n` is divisible by `k`. If `n` is divisible by `k`, then it is not a prime number and the function returns `False`. If the loop completes without finding a divisor of `n`, then `n` is a prime number and the function returns `True`.\n\n### Rust version\n\nfn is_prime(n: isize) -> bool {\n"
  }
]