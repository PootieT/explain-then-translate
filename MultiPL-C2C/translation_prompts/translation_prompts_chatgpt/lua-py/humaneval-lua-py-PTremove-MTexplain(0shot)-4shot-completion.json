[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "py",
    "prompt": "def correct_bracketing(brackets: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('()') == True\n    assert candidate('(()())') == True\n    assert candidate('()()(()())()') == True\n    assert candidate('()()((()()())())(()()(()))') == True\n    assert candidate('((()())))') == False\n    assert candidate(')(()') == False\n    assert candidate('(') == False\n    assert candidate('((((') == False\n    assert candidate(')') == False\n    assert candidate('(()') == False\n    assert candidate('()()(()())())(()') == False\n    assert candidate('()()(()())()))()') == False\n\ndef test_check():\n    check(correct_bracketing)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for i=1, #brackets do\n        if brackets:sub(i,i) == \"(\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThis Lua program defines a function called `correct_bracketing` that takes a string of brackets as input and returns `true` if the brackets are balanced and `false` otherwise. The function works by iterating over each character in the input string and keeping track of the depth of the bracketing. If the depth ever goes negative, it means that there is a closing bracket without a corresponding opening bracket, so the function returns `false`. If the depth is zero at the end of the iteration, it means that all brackets are balanced, so the function returns `true`.\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "py",
    "prompt": "def triangle_area(a: int, h: int) -> float:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, h)\n    return a * h / 2\nend\n\n### Explanation\n\nThis Lua program defines a function `triangle_area` that takes two arguments `a` and `h` and returns the area of a triangle with base `a` and height `h`. The area is calculated by multiplying `a` and `h` and dividing the result by 2. The `math` module is used to perform the multiplication and division operations.\n\n### Python version\n\ndef triangle_area(a: int, h: int) -> float:\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "py",
    "prompt": "def special_factorial(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(4) == 288\n    assert candidate(5) == 34560\n    assert candidate(7) == 125411328000\n    assert candidate(1) == 1\n\ndef test_check():\n    check(special_factorial)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function special_factorial(n)\n  local fact_i = 1\n  local special_fact = 1\n  for i=1, n do\n    fact_i = fact_i * i\n    special_fact = special_fact * fact_i\n  end\n  return special_fact\nend\n\n### Explanation\n\nThis program defines a function called `special_factorial` which takes an integer `n` as input. The function then calculates a special factorial of `n` and returns it. The special factorial is calculated by multiplying each factorial of the integers from 1 to `n`. The factorial of an integer `i` is calculated by multiplying all integers from 1 to `i`. The program uses a loop to calculate the factorial of each integer from 1 to `n` and then multiplies them together to get the special factorial.\n\n### Python version\n\ndef special_factorial(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "py",
    "prompt": "from typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([3, 4, 5, 1, 2]) == True\n    assert candidate([3, 5, 10, 1, 2]) == True\n    assert candidate([4, 3, 1, 2]) == False\n    assert candidate([3, 5, 4, 1, 2]) == False\n    assert candidate([]) == True\n\ndef test_check():\n    check(move_one_ball)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function move_one_ball(arr)\n  if #arr==0 then\n    return true\n  end\n  local sorted_array = {}\n  for i=1,#arr do\n    sorted_array[i]=arr[i]\n  end\n  table.sort(sorted_array)\n  local my_arr = {}\n  local min_value = math.min(table.unpack(arr))\n  local min_index = 1\n  for i=1,#arr do\n    if arr[i]==min_value then\n      min_index = i\n      break\n    end\n  end\n  for i=min_index,#arr do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,min_index-1 do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,#arr do\n    if my_arr[i]~=sorted_array[i] then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis program defines a function `move_one_ball` that takes an array of integers as input. The function returns `true` if the input array can be sorted by moving one element from the beginning of the array to the end of the array, and `false` otherwise.\n\nThe function first creates a sorted copy of the input array using `table.sort`. It then finds the minimum value and index of the input array using `math.min` and a loop. It then constructs a new array `my_arr` by taking the elements of the input array starting from the minimum index and appending them to the end of the array, followed by the elements before the minimum index. Finally, it checks if `my_arr` is equal to the sorted copy of the input array, and returns `true` or `false` accordingly.\n\n### Python version\n\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "py",
    "prompt": "def digits(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) == 1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n    assert candidate(2468) == 0\n\ndef test_check():\n    check(digits)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function digits(n)\n    local product = 1\n    local odd_count = 0\n    for digit in tostring(n):gmatch(\"%d\") do\n        local int_digit = tonumber(digit)\n        if int_digit%2 == 1 then\n            product= product*int_digit\n            odd_count=odd_count+1\n        end\n    end\n    if odd_count ==0 then\n        return 0\n    else\n        return product\n    end\nend\n\n### Explanation\n\nThis program defines a function `digits` which takes an integer `n` as input and returns the product of all odd digits of `n`. If `n` has no odd digits, the function returns 0. \n\nThe function first initializes two variables, `product` and `odd_count`, to 1 and 0 respectively. It then iterates over each digit of `n` using the `gmatch` method of the string returned by `tostring(n)`. For each digit, it checks if it is odd by computing the remainder of the division by 2. If the digit is odd, it multiplies `product` by the digit and increments `odd_count`. Finally, if `odd_count` is 0, the function returns 0, otherwise it returns `product`.\n\n### Python version\n\ndef digits(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "py",
    "prompt": "def fib4(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\ndef test_check():\n    check(fib4)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function fib4(n)\n  local results = {0, 0, 2, 0}\n  if n < 4 then\n    return results[n]\n  end\n\n  for i = 4, n do\n    table.insert(results, results[#results] + results[#results - 1] + results[#results - 2] + results[#results - 3])\n    table.remove(results, 1)\n  end\n\n  return results[#results]\nend\n\n### Explanation\n\nThis program calculates the fourth element of the Fibonacci sequence using a table to store the last four elements of the sequence. The function takes an integer n as input and returns the nth element of the sequence. If n is less than 4, the function returns a pre-defined value from the results table. Otherwise, the function iteratively calculates the next element of the sequence by summing the last four elements in the table and appending the result to the end of the table. The first element of the table is then removed to keep the table size at four. Finally, the last element of the table is returned as the result.\n\n### Python version\n\ndef fib4(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "py",
    "prompt": "from typing import List\n\ndef sort_even(l: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3]) == [1, 2, 3]\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]\n    assert candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]\n\ndef test_check():\n    check(sort_even)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function sort_even(l)\n    local evens = {}\n    local odds = {}\n    for i = 1, #l, 2 do\n        table.insert(evens, l[i])\n    end\n    for i = 2, #l, 2 do\n        table.insert(odds, l[i])\n    end\n    table.sort(evens)\n    local ans = {}\n    for i = 1, math.min(#evens, #odds) do\n        table.insert(ans, evens[i])\n        table.insert(ans, odds[i])\n    end\n    if #evens > #odds then\n        table.insert(ans, evens[#evens])\n    end\n    return ans\nend\n\n### Explanation\n\nThis program takes a list of integers as input and returns a new list with all even numbers sorted in ascending order, followed by all odd numbers in their original order. If there are more even numbers than odd numbers, the last even number is appended to the result. \n\nThe program first splits the input list into two lists, one with even numbers and one with odd numbers. It then sorts the even numbers and combines the two lists by alternating between the two lists until one of them is exhausted. Finally, if there are more even numbers than odd numbers, the last even number is appended to the result. \n\nTo rewrite this program in Python, one could use the following code:\n\n### Python version\n\nfrom typing import List\n\ndef sort_even(l: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "py",
    "prompt": "def is_happy(s: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('a') == False\n    assert candidate('aa') == False\n    assert candidate('abcd') == True\n    assert candidate('aabb') == False\n    assert candidate('adb') == True\n    assert candidate('xyy') == False\n    assert candidate('iopaxpoi') == True\n    assert candidate('iopaxioi') == False\n\ndef test_check():\n    check(is_happy)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function is_happy(s)\n  if #s < 3 then\n    return false\n  end\n\n  for i = 1, #s - 2 do\n    if s:sub(i,i) == s:sub(i+1,i+1) or s:sub(i+1,i+1) == s:sub(i+2,i+2) or s:sub(i,i) == s:sub(i+2,i+2) then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis Lua program defines a function called `is_happy` that takes a string `s` as input. The function returns `true` if the string `s` is happy, and `false` otherwise. A string is happy if it has at least three characters and no three consecutive characters are the same. The function first checks if the length of the string is less than three, and returns `false` if it is. Otherwise, it iterates over the string and checks if any three consecutive characters are the same. If it finds any, it returns `false`. If it makes it through the loop without finding any consecutive characters, it returns `true`.\n\n### Python version\n\ndef is_happy(s: str) -> bool:\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "py",
    "prompt": "def circular_shift(x: int, shift: int) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(100, 2) == '001'\n    assert candidate(12, 2) == '12'\n    assert candidate(97, 8) == '79'\n    assert candidate(12, 1) == '21'\n    assert candidate(11, 101) == '11'\n\ndef test_check():\n    check(circular_shift)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function circular_shift(x, shift)\n    local s = tostring(x)\n    if shift > #s then\n        return s:reverse()\n    else\n        return s:sub(#s-shift+1) .. s:sub(1, #s-shift)\n    end\nend\n\n### Explanation\n\nThis program defines a function `circular_shift` that takes two arguments, `x` and `shift`. The function converts `x` to a string, and then shifts the string by `shift` characters. If `shift` is greater than the length of the string, the function returns the reverse of the string. Otherwise, it returns the substring of the string starting from the `#s-shift+1`th character, concatenated with the substring of the string starting from the first character up to the `#s-shift`th character. `#s` is the length of the string `s`.\n\n### Python version\n\ndef circular_shift(x: int, shift: int) -> str:\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "py",
    "prompt": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6\n    assert candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) == 5\n    assert candidate([[0, 0, 0], [0, 0, 0]], 5) == 0\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2) == 4\n    assert candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9) == 2\n\ndef test_check():\n    check(max_fill)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function max_fill(grid, capacity)\n  local sum = 0\n  for i=1, #grid do\n    local row_sum = 0\n    for j=1, #grid[i] do\n      row_sum = row_sum + grid[i][j]\n    end\n    sum = sum + math.ceil(row_sum/capacity)\n  end\n  return sum\nend\n\n### Explanation\n\nThis program defines a function `max_fill` that takes two arguments: a 2D array of integers `grid` and an integer `capacity`. The function returns the maximum number of containers needed to hold the contents of the grid, given that each container can hold at most `capacity` units of content. The function iterates over the rows of the grid, calculates the sum of each row, divides the sum by the capacity, rounds up to the nearest integer, and adds the result to a running total. The final total is returned as the result of the function.\n\n### Python version\n\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "py",
    "prompt": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\ndef test_check():\n    check(has_close_elements)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function has_close_elements(numbers, threshold)\n  for idx, elem in ipairs(numbers) do\n    for idx2, elem2 in ipairs(numbers) do\n      if idx ~= idx2 then\n        local distance = math.abs(elem - elem2)\n        if distance < threshold then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis program defines a function `has_close_elements` that takes two arguments: `numbers` and `threshold`. The function returns `true` if there are two elements in the `numbers` list that are closer than `threshold` to each other, and `false` otherwise. The function iterates over the `numbers` list twice, comparing each element to every other element in the list except itself. If the absolute difference between two elements is less than `threshold`, the function returns `true`. Otherwise, it returns `false`.\n\n### Python version\n\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "py",
    "prompt": "from typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1.0, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0.0, 0.7]) == ['E', 'D-']\n\ndef test_check():\n    check(numerical_letter_grade)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function numerical_letter_grade(grades)\n    letter_grade = {}\n    for i, gpa in ipairs(grades) do\n        if gpa == 4.0 then\n            table.insert(letter_grade, \"A+\")\n        elseif gpa > 3.7 then\n            table.insert(letter_grade, \"A\")\n        elseif gpa > 3.3 then\n            table.insert(letter_grade, \"A-\")\n        elseif gpa > 3.0 then\n            table.insert(letter_grade, \"B+\")\n        elseif gpa > 2.7 then\n            table.insert(letter_grade, \"B\")\n        elseif gpa > 2.3 then\n            table.insert(letter_grade, \"B-\")\n        elseif gpa > 2.0 then\n            table.insert(letter_grade, \"C+\")\n        elseif gpa > 1.7 then\n            table.insert(letter_grade, \"C\")\n        elseif gpa > 1.3 then\n            table.insert(letter_grade, \"C-\")\n        elseif gpa > 1.0 then\n            table.insert(letter_grade, \"D+\")\n        elseif gpa > 0.7 then\n            table.insert(letter_grade, \"D\")\n        elseif gpa > 0.0 then\n            table.insert(letter_grade, \"D-\")\n        else\n            table.insert(letter_grade, \"E\")\n        end\n    end\n    return letter_grade\nend\n\n### Explanation\n\nThis program takes a list of numerical grades and returns a list of letter grades. The letter grades are determined by a set of if-else statements that check the numerical grade against a set of thresholds. If the numerical grade is above a threshold, the corresponding letter grade is added to the output list. The output list is returned at the end of the function. To rewrite this program in Python, you would need to replace the Lua-specific syntax with Python syntax, but the logic of the program would remain the same.\n\n### Python version\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "py",
    "prompt": "def x_or_y(n: int, x: int, y: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\ndef test_check():\n    check(x_or_y)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function x_or_y(n, x, y)\n    if n == 1 then\n        return y\n    end\n    for i=2, n-1 do\n        if n % i == 0 then\n            return y\n        end\n    end\n    return x\nend\n\n### Explanation\n\nThis program defines a function `x_or_y` that takes three arguments: `n`, `x`, and `y`. The function returns `y` if `n` is equal to 1 or if `n` is divisible by any number other than 1 and itself. Otherwise, the function returns `x`. The `math` library is used to perform arithmetic operations.\n\n### Python version\n\ndef x_or_y(n: int, x: int, y: int) -> int:\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "py",
    "prompt": "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([5, -2, 1, -5]) == 0\n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n    assert candidate([1]) == 0\n    assert candidate([]) == 0\n\ndef test_check():\n    check(specialFilter)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function specialFilter(nums)\n    local count = 0\n    for _, num in ipairs(nums) do\n        if num > 10 then\n            local odd_digits = {1, 3, 5, 7, 9}\n            local number_as_string = tostring(num)\n            if math.floor(num / 10^(#number_as_string - 1)) % 2 == 1 and num % 10 % 2 == 1 then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThis program defines a function called `specialFilter` that takes a list of numbers as an argument. The function returns the number of elements in the list that are greater than 10 and have an odd first digit and an odd last digit. The function first initializes a counter variable called `count` to 0. It then iterates over each element in the input list using the `ipairs` function. For each element, it checks if it is greater than 10. If it is, it converts the number to a string and checks if the first digit is odd and the last digit is odd. If both conditions are true, it increments the `count` variable. Finally, it returns the `count` variable.\n\n### Python version\n\nfrom typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "py",
    "prompt": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n\ndef test_check():\n    check(parse_music)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function parse_music(music_string)\n    local note_map = {o=4, ['o|']=2, ['.|']=1}\n    local notes = {}\n    for x in music_string:gmatch(\"%S+\") do\n        table.insert(notes, note_map[x])\n    end\n    return notes\nend\n\n### Explanation\n\nThis program defines a function `parse_music` that takes a string of music notes as input and returns a list of integers representing the duration of each note. The input string is split into individual notes using the `gmatch` function, and each note is looked up in a table to determine its duration. The resulting list of note durations is returned.\n\n### Python version\n\nfrom typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "py",
    "prompt": "from typing import Union, List\n\ndef split_words(txt: str) -> Union[List[str], int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Hello world!') == ['Hello', 'world!']\n    assert candidate('Hello,world!') == ['Hello', 'world!']\n    assert candidate('Hello world,!') == ['Hello', 'world,!']\n    assert candidate('Hello,Hello,world !') == ['Hello,Hello,world', '!']\n    assert candidate('abcdef') == 3\n    assert candidate('aaabb') == 2\n    assert candidate('aaaBb') == 1\n    assert candidate('') == 0\n\ndef test_check():\n    check(split_words)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function split_words(txt)\n    if string.find(txt, \" \") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt, \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    elseif string.find(txt, \",\") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt:gsub(\",\", \" \"), \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    else\n        local count = 0\n        for i = 1, #txt do\n            if string.match(txt:sub(i, i), \"%l\") and string.byte(txt:sub(i, i)) % 2 == 0 then\n                count = count + 1\n            end\n        end\n        return count\n    end\nend\n\n### Explanation\n\nThis Lua program defines a function `split_words` that takes a string as input and returns either a list of words or a count of lowercase letters with even ASCII values. If the input string contains spaces, the function splits the string into words and returns a list of those words. If the input string contains commas, the function replaces the commas with spaces, splits the string into words, and returns a list of those words. If the input string contains no spaces or commas, the function counts the number of lowercase letters with even ASCII values and returns that count.\n\n### Python version\n\nfrom typing import Union, List\n\ndef split_words(txt: str) -> Union[List[str], int]:\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "py",
    "prompt": "def count_distinct_characters(string: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcdecadeCADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n\ndef test_check():\n    check(count_distinct_characters)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function count_distinct_characters(string)\n    local set = {}\n    for i=1, #string do\n        set[string:sub(i, i):lower()] = true\n    end\n    local count = 0\n    for k, v in pairs(set) do\n        count = count + 1\n    end\n    return count\nend\n\n### Explanation\n\nThis program defines a function `count_distinct_characters` that takes a string as input and returns the number of distinct characters in the string. The function first creates an empty set, then iterates over each character in the string and adds it to the set. Finally, the function returns the size of the set.\n\n### Python version\n\ndef count_distinct_characters(string: str) -> int:\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "py",
    "prompt": "from typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Jupiter', 'Neptune') == ('Saturn', 'Uranus')\n    assert candidate('Earth', 'Mercury') == ('Venus',)\n    assert candidate('Mercury', 'Uranus') == ('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\n    assert candidate('Neptune', 'Venus') == ('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')\n    assert candidate('Earth', 'Earth') == ()\n    assert candidate('Mars', 'Earth') == ()\n    assert candidate('Jupiter', 'Makemake') == ()\n\ndef test_check():\n    check(bf)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function bf(planet1, planet2)\n    local planet_names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    if not (table.concat(planet_names, ','):find(planet1) and table.concat(planet_names, ','):find(planet2)) or planet1 == planet2 then\n        return {}\n    end\n    local planet1_index = 0\n    local planet2_index = 0\n    for i, planet in ipairs(planet_names) do\n        if planet == planet1 then\n            planet1_index = i\n        elseif planet == planet2 then\n            planet2_index = i\n        end\n    end\n    if planet1_index < planet2_index then\n        return {table.unpack(planet_names, planet1_index + 1, planet2_index - 1)}\n    else\n        return {table.unpack(planet_names, planet2_index + 1, planet1_index - 1)}\n    end\nend\n\n### Explanation\n\nThis Lua program defines a function `bf` that takes two arguments, `planet1` and `planet2`. The function returns a list of planet names that are between `planet1` and `planet2` in the solar system. If `planet1` or `planet2` is not a valid planet name or if they are the same planet, an empty list is returned. The function first creates a list of planet names, then finds the indices of `planet1` and `planet2` in the list. Finally, it returns a slice of the list between the two indices, depending on which index is smaller.\n\n### Python version\n\nfrom typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "py",
    "prompt": "def digitSum(s: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abAB') == 131\n    assert candidate('abcCd') == 67\n    assert candidate('helloE') == 69\n    assert candidate('woArBld') == 131\n    assert candidate('aAaaaXa') == 153\n    assert candidate(' How are yOu?') == 151\n    assert candidate('You arE Very Smart') == 327\n\ndef test_check():\n    check(digitSum)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function digitSum(s)\n    if s == \"\" then return 0 end\n    local sum = 0\n    for char in s:gmatch(\".\") do\n        sum = sum + (char:match(\"%u\") and string.byte(char) or 0)\n    end\n    return sum\nend\n\n### Explanation\n\nThis program defines a function `digitSum` that takes a string `s` as input and returns the sum of the ASCII values of all uppercase letters in `s`. If `s` is empty, the function returns 0. The function first checks if `s` is empty and returns 0 if it is. Otherwise, it initializes a variable `sum` to 0 and iterates over each character in `s`. For each character, it checks if it is uppercase using the pattern `%u`. If it is, it adds the ASCII value of the character to `sum`. Finally, it returns `sum`.\n\n### Python version\n\ndef digitSum(s: str) -> int:\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "py",
    "prompt": "from typing import List\n\ndef sum_squares(lst: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3]) == 6\n    assert candidate([1, 4, 9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]) == 9\n    assert candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1, -5, 2, -1, -5]) == -126\n    assert candidate([-56, -99, 1, 0, -2]) == 3030\n    assert candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n\ndef test_check():\n    check(sum_squares)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n    local result = {}\n    for i=1, #lst do\n        if i % 3 == 1 then\n            result[#result+1] = lst[i]^2\n        elseif i % 4 == 1 and i % 3 ~= 1 then\n            result[#result+1] = lst[i]^3\n        else\n            result[#result+1] = lst[i]\n        end\n    end\n    local sum = 0\n    for i=1, #result do\n        sum = sum + result[i]\n    end\n    return sum\nend\n\n### Explanation\n\nThis program defines a function `sum_squares` that takes a list of numbers as input. The function iterates over the list and for each element, it checks if the index is divisible by 3 with a remainder of 1. If it is, it squares the element and adds it to a new list called `result`. If the index is not divisible by 3 with a remainder of 1, but is divisible by 4 with a remainder of 1, it cubes the element and adds it to `result`. If neither of these conditions are met, it adds the element to `result` as is. Finally, the function iterates over `result` and returns the sum of all elements in the list.\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "py",
    "prompt": "from typing import List\n\ndef count_up_to(n: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5) == [2, 3]\n    assert candidate(6) == [2, 3, 5]\n    assert candidate(7) == [2, 3, 5]\n    assert candidate(10) == [2, 3, 5, 7]\n    assert candidate(0) == []\n    assert candidate(22) == [2, 3, 5, 7, 11, 13, 17, 19]\n    assert candidate(1) == []\n    assert candidate(18) == [2, 3, 5, 7, 11, 13, 17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\ndef test_check():\n    check(count_up_to)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function count_up_to(n)\n  local primes = {}\n  for i = 2, n - 1 do\n    local is_prime = true\n    for j = 2, i - 1 do\n      if i % j == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(primes, i)\n    end\n  end\n  return primes\nend\n\n### Explanation\n\nThis program generates all prime numbers up to a given number `n`. It does this by iterating over all numbers from `2` to `n-1` and checking if each number is prime. If a number is prime, it is added to a list of primes. The list of primes is returned at the end of the function.\n\n### Python version\n\nfrom typing import List\n\ndef count_up_to(n: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "py",
    "prompt": "from typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.0]) == 14\n    assert candidate([1.0, 2.0, 3.0]) == 14\n    assert candidate([1.0, 3.0, 5.0, 7.0]) == 84\n    assert candidate([1.4, 4.2, 0.0]) == 29\n    assert candidate([-2.4, 1.0, 1.0]) == 6\n    assert candidate([100.0, 1.0, 15.0, 2.0]) == 10230\n    assert candidate([10000.0, 10000.0]) == 200000000\n    assert candidate([-1.4, 4.6, 6.3]) == 75\n    assert candidate([-1.4, 17.9, 18.9, 19.9]) == 1086\n    assert candidate([0.0]) == 0\n    assert candidate([-1.0]) == 1\n    assert candidate([-1.0, 1.0, 0.0]) == 2\n\ndef test_check():\n    check(sum_squares)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n  local squared = 0\n  for _, i in ipairs(lst) do\n    squared = squared + math.ceil(i)^2\n  end\n  return squared\nend\n\n### Explanation\n\nThis program defines a function `sum_squares` that takes a list of numbers as input. It then iterates over each number in the list, rounds it up to the nearest integer, squares it, and adds it to a running total. The final result is the sum of the squares of all the numbers in the list, rounded up to the nearest integer.\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "py",
    "prompt": "from typing import List\n\ndef unique(l: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\ndef test_check():\n    check(unique)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function unique(l)\n  local s = {}\n  for _, v in ipairs(l) do\n    s[v] = true\n  end\n  local r = {}\n  for k, _ in pairs(s) do\n    table.insert(r, k)\n  end\n  table.sort(r)\n  return r\nend\n\n### Explanation\n\nThis program defines a function `unique` that takes a list of values as an argument. The function returns a new list that contains only the unique values from the input list, sorted in ascending order. \n\nThe function works by creating a set `s` that contains the unique values from the input list. It then creates a new list `r` by iterating over the keys of the set `s` and appending them to the list. Finally, it sorts the list `r` and returns it. \n\nTo rewrite this program in Python, you would need to replace the Lua-specific syntax with Python syntax. For example, you would need to replace `require('math')` with `import math`. You would also need to replace the Lua-specific functions `ipairs`, `pairs`, and `table.insert` with their Python equivalents. Here's an example Python implementation:\n\n### Python version\n\nfrom typing import List\n\ndef unique(l: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "py",
    "prompt": "def fib(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\ndef test_check():\n    check(fib)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function fib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nend\n\n### Explanation\n\nThis program defines a function `fib` that returns the nth number in the Fibonacci sequence. The function is defined recursively, with the base cases of `n == 0` and `n == 1` returning `0` and `1` respectively. For all other values of `n`, the function returns the sum of the previous two numbers in the sequence, calculated recursively using `fib(n - 1)` and `fib(n - 2)`. The program uses the `math` library to perform arithmetic operations.\n\n### Python version\n\ndef fib(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "py",
    "prompt": "def fizz_buzz(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\ndef test_check():\n    check(fizz_buzz)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function fizz_buzz(n)\n  local ns = {}\n  for i = 0, n - 1 do\n    if i % 11 == 0 or i % 13 == 0 then\n      table.insert(ns, i)\n    end\n  end\n  local s = table.concat(ns)\n  local ans = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '7' then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThis program defines a function `fizz_buzz` that takes an integer `n` as input. It then creates an empty table `ns`, and for each integer `i` from 0 to `n - 1`, it checks if `i` is divisible by 11 or 13. If it is, it adds `i` to the `ns` table. It then concatenates all the elements in `ns` into a string `s`, and counts the number of times the character '7' appears in `s`. This count is returned as the output of the function.\n\n### Python version\n\ndef fizz_buzz(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "py",
    "prompt": "from typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n\ndef test_check():\n    check(Strongest_Extension)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function Strongest_Extension(class_name, extensions)\n    local strong = extensions[1]\n    local my_val = #extensions[1]:gsub('[^%a]', ''):gsub('[^%u]', '') - #extensions[1]:gsub('[^%a]', ''):gsub('[^%l]', '')\n    for i = 2, #extensions do\n        local s = extensions[i]\n        local val = #s:gsub('[^%a]', ''):gsub('[^%u]', '') - #s:gsub('[^%a]', ''):gsub('[^%l]', '')\n        if val > my_val then\n            strong = s\n            my_val = val\n        end\n    end\n    return class_name .. '.' .. strong\nend\n\n### Explanation\n\nThis Lua program defines a function called `Strongest_Extension` which takes two arguments: `class_name` and `extensions`. The function returns a string that is the concatenation of `class_name`, a period, and the strongest extension in `extensions`. The strength of an extension is determined by the number of uppercase letters minus the number of lowercase letters in the extension, ignoring non-letter characters. The function first calculates the strength of the first extension in `extensions`, then iterates over the remaining extensions, updating the strongest extension and its strength if a stronger extension is found.\n\n### Python version\n\nfrom typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "py",
    "prompt": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\ndef test_check():\n    check(find_closest_elements)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function find_closest_elements(numbers)\n    local closest_pair = nil\n    local distance = nil\n\n    for idx, elem in ipairs(numbers) do\n        for idx2, elem2 in ipairs(numbers) do\n            if idx ~= idx2 then\n                if distance == nil then\n                    distance = math.abs(elem - elem2)\n                    closest_pair = {elem, elem2}\n                else\n                    new_distance = math.abs(elem - elem2)\n                    if new_distance < distance then\n                        distance = new_distance\n                        closest_pair = {elem, elem2}\n                    end\n                end\n            end\n        end\n    end\n\n    table.sort(closest_pair)\n    return closest_pair\nend\n\n### Explanation\n\nThis Lua program defines a function called `find_closest_elements` that takes an array of numbers as input. The function loops through the array twice, comparing each element to every other element in the array (except itself). It calculates the absolute difference between each pair of elements and keeps track of the pair with the smallest difference. Finally, it sorts the pair in ascending order and returns it.\n\n### Python version\n\nfrom typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "py",
    "prompt": "def valid_date(date: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('03-11-2000') == True\n    assert candidate('15-01-2012') == False\n    assert candidate('04-0-2040') == False\n    assert candidate('06-04-2020') == True\n    assert candidate('01-01-2007') == True\n    assert candidate('03-32-2011') == False\n    assert candidate('') == False\n    assert candidate('04-31-3000') == False\n    assert candidate('06-06-2005') == True\n    assert candidate('21-31-2000') == False\n    assert candidate('04-12-2003') == True\n    assert candidate('04122003') == False\n    assert candidate('20030412') == False\n    assert candidate('2003-04') == False\n    assert candidate('2003-04-12') == False\n    assert candidate('04-2003') == False\n\ndef test_check():\n    check(valid_date)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function valid_date(date)\n    local month, day, year = date:match(\"(%d+)-(%d+)-(%d+)\")\n    if not month or not day or not year then\n        return false\n    end\n    month, day, year = tonumber(month), tonumber(day), tonumber(year)\n    if month < 1 or month > 12 then\n        return false\n    end\n    if month == 2 and (day < 1 or day > 29) then\n        return false\n    end\n    if month == 4 or month == 6 or month == 9 or month == 11 then\n        if day < 1 or day > 30 then\n            return false\n        end\n    else\n        if day < 1 or day > 31 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `valid_date` that takes a string argument `date` in the format `YYYY-MM-DD` and returns a boolean indicating whether the date is valid or not. A date is considered valid if it is a real date in the Gregorian calendar. The function first extracts the month, day, and year from the input string using a regular expression. It then checks whether the month is between 1 and 12, and whether the day is within the valid range for that month (taking into account leap years for February). If the date is valid, the function returns `true`, otherwise it returns `false`.\n\n### Python version\n\ndef valid_date(date: str) -> bool:\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "py",
    "prompt": "def add(x: int, y: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\ndef test_check():\n    check(add)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function add(x, y)\n  return x + y\nend\n\n### Explanation\n\nThis program imports the math library and defines a function called add that takes two arguments and returns their sum.\n\n### Python version\n\ndef add(x: int, y: int) -> int:\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "py",
    "prompt": "from typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\ndef test_check():\n    check(triples_sum_to_zero)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function triples_sum_to_zero(l)\n  for i = 1, #l do\n    for j = i + 1, #l do\n      for k = j + 1, #l do\n        if l[i] + l[j] + l[k] == 0 then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis program defines a function `triples_sum_to_zero` that takes a list `l` as input. The function then iterates over all possible triples of elements in `l` and checks if their sum is equal to zero. If such a triple is found, the function returns `true`. If no such triple is found, the function returns `false`. The `math` module is imported but not used in this program.\n\n### Python version\n\nfrom typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "py",
    "prompt": "def largest_divisor(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n\ndef test_check():\n    check(largest_divisor)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function largest_divisor(n)\n    for i=n-1, 1, -1 do\n        if n % i == 0 then\n            return i\n        end\n    end\nend\n\n### Explanation\n\nThis Lua program defines a function called `largest_divisor` that takes an integer `n` as input. The function then loops through all integers from `n-1` down to `1`, and returns the first integer `i` that divides `n` without a remainder. If no such integer is found, the function returns `nil`. The program also imports the `math` library, but does not use it in this function.\n\n### Python version\n\ndef largest_divisor(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "py",
    "prompt": "def sort_numbers(numbers: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n\ndef test_check():\n    check(sort_numbers)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function sort_numbers(numbers)\n    local value_map = {\n        zero = 0,\n        one = 1,\n        two = 2,\n        three = 3,\n        four = 4,\n        five = 5,\n        six = 6,\n        seven = 7,\n        eight = 8,\n        nine = 9\n    }\n    local words = {}\n    for word in numbers:gmatch(\"%w+\") do\n        table.insert(words, word)\n    end\n    table.sort(words, function(a, b) return value_map[a] < value_map[b] end)\n    return table.concat(words, ' ')\nend\n\n### Explanation\n\nThis program defines a function called `sort_numbers` which takes a string of words as input. The function then extracts all the words from the input string and sorts them based on their numerical value. The numerical value of each word is defined in the `value_map` table. Finally, the sorted words are concatenated into a single string and returned.\n\n### Python version\n\ndef sort_numbers(numbers: str) -> str:\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "py",
    "prompt": "from typing import List\n\ndef smallest_change(arr: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\ndef test_check():\n    check(smallest_change)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function smallest_change(arr)\n  local ans = 0\n  for i = 1, math.floor(#arr / 2) do\n    if arr[i] ~= arr[#arr - i + 1] then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThis program defines a function `smallest_change` that takes an array of numbers as input and returns the number of elements that need to be changed to make the array a palindrome. The function iterates over the first half of the array and compares each element with its corresponding element in the second half of the array. If the elements are not equal, the counter `ans` is incremented. The function then returns the value of `ans`.\n\n### Python version\n\nfrom typing import List\n\ndef smallest_change(arr: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "py",
    "prompt": "from typing import List\n\ndef below_threshold(l: List[int], t: int) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100) == True\n    assert candidate([1, 20, 4, 10], 5) == False\n    assert candidate([1, 20, 4, 10], 21) == True\n    assert candidate([1, 20, 4, 10], 22) == True\n    assert candidate([1, 8, 4, 10], 11) == True\n    assert candidate([1, 8, 4, 10], 10) == False\n\ndef test_check():\n    check(below_threshold)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function below_threshold(l, t)\n  for _, e in ipairs(l) do\n    if e >= t then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis program defines a function `below_threshold` that takes a list `l` and a threshold `t`. The function returns `true` if all elements in `l` are less than `t`, and `false` otherwise. The function uses a for loop to iterate over the elements of `l`, and returns `false` as soon as it finds an element that is greater than or equal to `t`. If the loop completes without finding such an element, the function returns `true`. The program also imports the `math` module, but does not use it.\n\n### Python version\n\nfrom typing import List\n\ndef below_threshold(l: List[int], t: int) -> bool:\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "py",
    "prompt": "from typing import List, Optional\n\ndef prod_signs(arr: List[int]) -> Optional[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4, 1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\ndef test_check():\n    check(prod_signs)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n    local prod = 0\n    local neg_count = 0\n    for i = 1, #arr do\n        if arr[i] == 0 then\n            return 0\n        end\n        if arr[i] < 0 then\n            neg_count = neg_count + 1\n        end\n    end\n    prod = math.pow(-1, neg_count)\n    local sum = 0\n    for i = 1, #arr do\n        sum = sum + math.abs(arr[i])\n    end\n    return prod * sum\nend\n\n### Explanation\n\nThis program defines a function called `prod_signs` which takes an array of integers as input. The function returns the product of the signs of the integers in the array multiplied by the sum of the absolute values of the integers in the array. The product of the signs is calculated by counting the number of negative integers in the array and raising -1 to that power. If the array contains a 0, the function returns 0. If the array is empty, the function returns nil.\n\n### Python version\n\nfrom typing import List, Optional\n\ndef prod_signs(arr: List[int]) -> Optional[int]:\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "py",
    "prompt": "def modp(n: int, p: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\ndef test_check():\n    check(modp)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function modp(n, p)\n    local ret = 1\n    for i=1, n do\n        ret = (2 * ret) % p\n    end\n    return ret\nend\n\n### Explanation\n\nThis program defines a function `modp` which takes two arguments, `n` and `p`. The function returns `2^n % p`. The `math` module is imported to use the `math.pow` function.\n\n### Python version\n\ndef modp(n: int, p: int) -> int:\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "py",
    "prompt": "def count_upper(s: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('aBCdEf') == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B') == 0\n    assert candidate('U') == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\ndef test_check():\n    check(count_upper)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function count_upper(s)\n    local count = 0\n    for i = 1, #s, 2 do\n        if s:sub(i, i):match(\"[AEIOU]\") then\n            count = count + 1\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThis program defines a function `count_upper` that takes a string `s` as input. The function counts the number of uppercase vowels (A, E, I, O, U) in every other character of the string `s`. The function returns the count of uppercase vowels.\n\n### Python version\n\ndef count_upper(s: str) -> int:\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "py",
    "prompt": "def multiply(a: int, b: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(148, 412) == 16\n    assert candidate(19, 28) == 72\n    assert candidate(2020, 1851) == 0\n    assert candidate(14, -15) == 20\n    assert candidate(76, 67) == 42\n    assert candidate(17, 27) == 49\n    assert candidate(0, 1) == 0\n    assert candidate(0, 0) == 0\n\ndef test_check():\n    check(multiply)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function multiply(a, b)\n  return math.abs(a % 10) * math.abs(b % 10)\nend\n\n### Explanation\n\nThis program defines a function called `multiply` that takes two arguments `a` and `b`. The function returns the absolute value of the product of the last digit of `a` and the last digit of `b`. The `math.abs` function is used to ensure that the result is positive. The `%` operator is used to get the remainder of `a` and `b` when divided by 10, which gives the last digit of each number.\n\n### Python version\n\ndef multiply(a: int, b: int) -> int:\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "py",
    "prompt": "from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\ndef test_check():\n    check(unique_digits)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function unique_digits(x)\n    local odd_digit_elements = {}\n    for i=1, #x do\n        local is_odd = true\n        for c in tostring(x[i]):gmatch\".\" do\n            if tonumber(c) % 2 == 0 then\n                is_odd = false\n                break\n            end\n        end\n        if is_odd then\n            table.insert(odd_digit_elements, x[i])\n        end\n    end\n    table.sort(odd_digit_elements)\n    return odd_digit_elements\nend\n\n### Explanation\n\nThis program defines a function `unique_digits` that takes a list of integers `x` as input and returns a sorted list of integers that contain only odd digits. The function iterates over each element of the input list, and for each element, it checks if all its digits are odd. If all digits are odd, the element is added to a new list called `odd_digit_elements`. Finally, the function sorts the `odd_digit_elements` list and returns it.\n\n### Python version\n\nfrom typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "py",
    "prompt": "def is_multiply_prime(a: int) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(105) == True\n    assert candidate(126) == False\n    assert candidate(729) == False\n    assert candidate(891) == False\n    assert candidate(1001) == True\n\ndef test_check():\n    check(is_multiply_prime)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function is_multiply_prime(a)\n  local function is_prime(n)\n    for j = 2, n-1 do\n      if n%j == 0 then\n        return false\n      end\n    end\n    return true\n  end\n\n  for i = 2, 100 do\n    if not is_prime(i) then goto continue1 end\n    for j = 2, 100 do\n      if not is_prime(j) then goto continue2 end\n      for k = 2, 100 do\n        if not is_prime(k) then goto continue3 end\n        if i*j*k == a then return true end\n        ::continue3::\n      end\n      ::continue2::\n    end\n    ::continue1::\n  end\n  return false\nend\n\n### Explanation\n\nThis program defines a function `is_multiply_prime(a)` that takes an integer `a` as input and returns `true` if `a` can be expressed as the product of three prime numbers. Otherwise, it returns `false`. The function uses nested loops to iterate over all possible combinations of three prime numbers between 2 and 100. If the product of these three numbers equals `a`, the function returns `true`. Otherwise, it returns `false`.\n\n### Python version\n\ndef is_multiply_prime(a: int) -> bool:\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "py",
    "prompt": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0, 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\ndef test_check():\n    check(maximum)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function maximum(arr, k)\n    if k == 0 then\n        return {}\n    end\n    table.sort(arr)\n    local ans = {}\n    for i=#arr-k+1, #arr do\n        table.insert(ans, arr[i])\n    end\n    return ans\nend\n\n### Explanation\n\nThis program defines a function `maximum` that takes two arguments, an array `arr` and an integer `k`. The function returns the `k` largest elements in the array. If `k` is zero, the function returns an empty array. The function first sorts the array, then returns the last `k` elements of the sorted array.\n\n### Python version\n\nfrom typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "py",
    "prompt": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {  }, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n\ndef test_check():\n    check(filter_integers)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function filter_integers(values)\n  local result = {}\n  for _, x in ipairs(values) do\n    if type(x) == 'number' and math.floor(x) == x then\n      table.insert(result, x)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThis program defines a function called `filter_integers` that takes a list of values as input. The function returns a new list that contains only the integers from the input list. The function uses the `math` library to check if each value is an integer and then adds it to the result list if it is.\n\n### Python version\n\nfrom typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "py",
    "prompt": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10\n    assert candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25\n    assert candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13\n    assert candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11\n    assert candidate([0, 81, 12, 3, 1, 21]) == 3\n    assert candidate([0, 8, 1, 2, 1, 7]) == 7\n    assert candidate([8191]) == 19\n    assert candidate([8191, 123456, 127, 7]) == 19\n    assert candidate([127, 97, 8192]) == 10\n\ndef test_check():\n    check(skjkasdkd)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function skjkasdkd(lst)\n  local function isPrime(n)\n    for i = 2, math.floor(n^0.5) do\n      if n % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local maxx = 0\n  local i = 1\n  while i <= #lst do\n    if lst[i] > maxx and isPrime(lst[i]) then\n      maxx = lst[i]\n    end\n    i = i + 1\n  end\n  local result = 0\n  for digit in tostring(maxx):gmatch('%d') do\n    result = result + tonumber(digit)\n  end\n  return result\nend\n\n### Explanation\n\nThis program defines a function called `skjkasdkd` that takes a list of integers as input. The function iterates over the list and finds the largest prime number in the list. It then calculates the sum of the digits in that number and returns the result. \n\nTo rewrite this program in Python, you would need to replace the `math` module with the equivalent Python module, and replace the `^` operator with `**`. Here is the Python version:\n\n### Python version\n\nfrom typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "py",
    "prompt": "from typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\ndef test_check():\n    check(total_match)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function total_match(lst1, lst2)\n    local l1 = 0\n    for i = 1, #lst1 do\n        l1 = l1 + #lst1[i]\n    end\n\n    local l2 = 0\n    for i = 1, #lst2 do\n        l2 = l2 + #lst2[i]\n    end\n\n    if l1 <= l2 then\n        return lst1\n    else\n        return lst2\n    end\nend\n\n### Explanation\n\nThis program defines a function `total_match` which takes two lists of strings as input. The function calculates the total length of all strings in each list and returns the list with the smaller total length. If the total lengths are equal, the first list is returned. The function is defined using two loops to calculate the total length of each list. The `math` module is imported to allow for mathematical operations.\n\n### Python version\n\nfrom typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "py",
    "prompt": "def car_race_collision(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\ndef test_check():\n    check(car_race_collision)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function car_race_collision(n)\n    return n^2\nend\n\n### Explanation\n\nThis program defines a function `car_race_collision` which takes a single argument `n`. The function returns the square of `n`. The program also imports the `math` module, but does not use it.\n\n### Python version\n\ndef car_race_collision(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "py",
    "prompt": "def is_simple_power(x: int, n: int) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(16, 2) == True\n    assert candidate(143214, 16) == False\n    assert candidate(4, 2) == True\n    assert candidate(9, 3) == True\n    assert candidate(16, 4) == True\n    assert candidate(24, 2) == False\n    assert candidate(128, 4) == False\n    assert candidate(12, 6) == False\n    assert candidate(1, 1) == True\n    assert candidate(1, 12) == True\n\ndef test_check():\n    check(is_simple_power)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function is_simple_power(x, n)\n    if n == 1 then\n        return x == 1\n    end\n    local power = 1\n    while power < x do\n        power = power * n\n    end\n    return power == x\nend\n\n### Explanation\n\nThis program defines a function `is_simple_power` that takes two arguments `x` and `n`. The function returns `true` if `x` is a power of `n` and `false` otherwise. The function works by repeatedly multiplying `n` by itself until the result is greater than or equal to `x`. If the result is equal to `x`, then `x` is a power of `n`.\n\n### Python version\n\ndef is_simple_power(x: int, n: int) -> bool:\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "py",
    "prompt": "def encode(message: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('TEST') == 'tgst'\n    assert candidate('Mudasir') == 'mWDCSKR'\n    assert candidate('YES') == 'ygs'\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG'\n    assert candidate('I DoNt KnOw WhAt tO WrItE') == 'k dQnT kNqW wHcT Tq wRkTg'\n\ndef test_check():\n    check(encode)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function encode(message)\n  local vowels = \"aeiouAEIOU\"\n  local vowels_replace = {}\n  for i = 1, #vowels do\n    vowels_replace[vowels:sub(i, i)] = string.char(string.byte(vowels:sub(i, i)) + 2)\n  end\n  message = message:gsub(\"%a\", function(c)\n    return c == c:upper() and c:lower() or c:upper()\n  end)\n  return message:gsub(\".\", function(c)\n    return vowels_replace[c] or c\n  end)\nend\n\n### Explanation\n\nThis program defines a function `encode` that takes a string as input and returns a modified version of the string. The function first creates a table `vowels_replace` that maps each vowel to a new character obtained by adding 2 to its ASCII code. It then converts all letters in the input string to uppercase if they are lowercase, and vice versa. Finally, it replaces each character in the input string with the corresponding value in `vowels_replace`, or leaves it unchanged if it is not a vowel. The modified string is returned as the output of the function.\n\n### Python version\n\ndef encode(message: str) -> str:\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "py",
    "prompt": "from typing import List\n\ndef incr_list(l: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\ndef test_check():\n    check(incr_list)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function incr_list(l)\n  local res = {}\n  for i = 1, #l do\n    res[i] = l[i] + 1\n  end\n  return res\nend\n\n### Explanation\n\nThis program defines a function `incr_list` that takes a list as an argument and returns a new list with each element incremented by 1. The function first creates an empty list `res`, then iterates over each element of the input list `l`, increments it by 1, and appends the result to `res`. Finally, the function returns `res`. The program also imports the `math` module, but does not use it.\n\n### Python version\n\nfrom typing import List\n\ndef incr_list(l: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "py",
    "prompt": "def flip_case(string: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n\ndef test_check():\n    check(flip_case)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function flip_case(string)\n    return string:gsub(\"%a\", function(c) return c:match(\"%l\") and c:upper() or c:lower() end)\nend\n\n### Explanation\n\nThis program defines a function `flip_case` that takes a string as an argument and returns a new string with the case of each letter flipped. It does this by using the `gsub` function to replace each letter in the input string with a new letter based on whether it is upper or lower case. If the letter is lower case, it is converted to upper case, and if it is upper case, it is converted to lower case. The `math` module is also loaded, but it is not used in this program.\n\n### Python version\n\ndef flip_case(string: str) -> str:\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "py",
    "prompt": "def vowels_count(s: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('abcde') == 2\n    assert candidate('Alone') == 3\n    assert candidate('key') == 2\n    assert candidate('bye') == 1\n    assert candidate('keY') == 2\n    assert candidate('bYe') == 1\n    assert candidate('ACEDY') == 3\n\ndef test_check():\n    check(vowels_count)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function vowels_count(s)\n  local vowels = \"aeiouAEIOU\"\n  local n_vowels = 0\n  for i = 1, #s do\n    if string.find(vowels, s:sub(i, i), 1, true) then\n      n_vowels = n_vowels + 1\n    end\n  end\n  if s:sub(-1) == 'y' or s:sub(-1) == 'Y' then\n    n_vowels = n_vowels + 1\n  end\n  return n_vowels\nend\n\n### Explanation\n\nThis program defines a function `vowels_count` which takes a string `s` as input and returns the number of vowels in the string. The function iterates over each character in the string and checks if it is a vowel (either lowercase or uppercase). If the last character in the string is 'y' or 'Y', it is also counted as a vowel. The function returns the total number of vowels found in the string.\n\n### Python version\n\ndef vowels_count(s: str) -> int:\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "py",
    "prompt": "from typing import List\n\ndef words_string(s: str) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Hi, my name is John') == ['Hi', 'my', 'name', 'is', 'John']\n    assert candidate('One, two, three, four, five, six') == ['One', 'two', 'three', 'four', 'five', 'six']\n    assert candidate('Hi, my name') == ['Hi', 'my', 'name']\n    assert candidate('One,, two, three, four, five, six,') == ['One', 'two', 'three', 'four', 'five', 'six']\n    assert candidate('') == []\n    assert candidate('ahmed     , gamal') == ['ahmed', 'gamal']\n\ndef test_check():\n    check(words_string)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function words_string(s)\n    if not s then\n        return {}\n    end\n\n    local s_list = {}\n\n    for i=1, #s do\n        local letter = s:sub(i, i)\n        if letter == ',' then\n            table.insert(s_list, ' ')\n        else\n            table.insert(s_list, letter)\n        end\n    end\n\n    s_list = table.concat(s_list)\n    local words = {}\n    for word in s_list:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n    return words\nend\n\n### Explanation\n\nThis program defines a function `words_string` that takes a string `s` as input and returns a list of words. The function first splits the input string into a list of characters, replacing commas with spaces. It then concatenates the list of characters back into a string and splits it into a list of words using a regular expression. The resulting list of words is returned.\n\n### Python version\n\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "py",
    "prompt": "def triangle_area(a: int, b: int, c: int) -> float:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(3, 4, 5) == 6.0\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n    assert candidate(1, 1, 1) == 0.43\n    assert candidate(2, 2, 10) == -1\n\ndef test_check():\n    check(triangle_area)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, b, c)\n    if a + b <= c or a + c <= b or b + c <= a then\n        return -1 \n    end\n    s = (a + b + c)/2    \n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = math.floor(area * 100 + 0.5) / 100\n    return area\nend\n\n### Explanation\n\nThis program defines a function called `triangle_area` which takes three arguments `a`, `b`, and `c`. The function first checks if the three sides can form a triangle, and returns -1 if they cannot. If they can form a triangle, the function calculates the area of the triangle using Heron's formula and returns the result rounded to two decimal places. The `math` library is used to perform the square root calculation and rounding.\n\n### Python version\n\ndef triangle_area(a: int, b: int, c: int) -> float:\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "py",
    "prompt": "from typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate({ 'p': 'pineapple', 'b': 'banana' }) == True\n    assert candidate({ 'p': 'pineapple', 'A': 'banana', 'B': 'banana' }) == False\n    assert candidate({ 'p': 'pineapple', '5': 'banana', 'a': 'apple' }) == False\n    assert candidate({ 'Name': 'John', 'Age': '36', 'City': 'Houston' }) == False\n    assert candidate({ 'STATE': 'NC', 'ZIP': '12345' }) == True\n    assert candidate({ 'fruit': 'Orange', 'taste': 'Sweet' }) == True\n    assert candidate({  }) == False\n\ndef test_check():\n    check(check_dict_case)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function check_dict_case(dict)\n    if next(dict) == nil then\n        return false\n    else\n        local state = \"start\"\n        for key, value in pairs(dict) do\n            if type(key) ~= \"string\" then\n                state = \"mixed\"\n                break\n            end\n            if state == \"start\" then\n                if key:upper() == key then\n                    state = \"upper\"\n                elseif key:lower() == key then\n                    state = \"lower\"\n                else\n                    break\n                end\n            elseif (state == \"upper\" and key:upper() ~= key) or (state == \"lower\" and key:lower() ~= key) then\n                state = \"mixed\"\n                break\n            end\n        end\n        return state == \"upper\" or state == \"lower\"\n    end\nend\n\n### Explanation\n\nThis Lua program checks whether a dictionary has all keys in either uppercase or lowercase. If the dictionary is empty, it returns false. If the dictionary has mixed case keys, it returns false. Otherwise, it returns true if all keys are in either uppercase or lowercase.\n\n### Python version\n\nfrom typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "py",
    "prompt": "from typing import List\n\ndef median(l: List[int]) -> float:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7\n\ndef test_check():\n    check(median)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function median(l)\n  table.sort(l)\n  if #l % 2 == 1 then\n    return l[math.floor(#l / 2) + 1]\n  else\n    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n  end\nend\n\n### Explanation\n\nThis program defines a function called `median` that takes a list of numbers as input. The function first sorts the list, and then calculates the median value of the list. If the length of the list is odd, the median is the middle value. If the length of the list is even, the median is the average of the two middle values. The function returns the median value.\n\n### Python version\n\nfrom typing import List\n\ndef median(l: List[int]) -> float:\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "py",
    "prompt": "def change_base(x: int, base: int) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(8, 3) == '22'\n    assert candidate(9, 3) == '100'\n    assert candidate(234, 2) == '11101010'\n    assert candidate(16, 2) == '10000'\n    assert candidate(8, 2) == '1000'\n    assert candidate(7, 2) == '111'\n    assert candidate(2, 3) == '2'\n    assert candidate(3, 4) == '3'\n    assert candidate(4, 5) == '4'\n    assert candidate(5, 6) == '5'\n    assert candidate(6, 7) == '6'\n    assert candidate(7, 8) == '7'\n\ndef test_check():\n    check(change_base)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function change_base(x, base)\n  local ret = \"\"\n  while x > 0 do\n    ret = tostring(x % base) .. ret\n    x = math.floor(x / base)\n  end\n  return ret\nend\n\n### Explanation\n\nThis program defines a function `change_base` that takes two arguments, `x` and `base`. The function returns a string that represents the number `x` in the given `base`. The function works by repeatedly dividing `x` by `base` and appending the remainder to the result string. The result string is returned after all digits have been appended.\n\n### Python version\n\ndef change_base(x: int, base: int) -> str:\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "py",
    "prompt": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n\ndef test_check():\n    check(longest)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function longest(strings)\n    if not strings then\n        return nil\n    end\n\n    local maxlen = 0\n    for _, s in ipairs(strings) do\n        maxlen = math.max(maxlen, #s)\n    end\n\n    for _, s in ipairs(strings) do\n        if #s == maxlen then\n            return s\n        end\n    end\nend\n\n### Explanation\n\nThis program defines a function called `longest` that takes a table of strings as input and returns the longest string in the table. If the input is nil, the function returns nil. The function first iterates over the table to find the length of the longest string, and then iterates over the table again to find the first string with that length. The `math` module is used to find the maximum length of the strings.\n\n### Python version\n\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "py",
    "prompt": "from typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\ndef test_check():\n    check(common)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function common(l1, l2)\n    local ret = {}\n    local set_l2 = {}\n    for i=1, #l2 do\n        set_l2[l2[i]] = true\n    end\n    for i=1, #l1 do\n        if set_l2[l1[i]] then\n            table.insert(ret, l1[i])\n        end\n    end\n    table.sort(ret)\n    return ret\nend\n\n### Explanation\n\nThis program defines a function called `common` that takes two lists as arguments. The function returns a new list that contains all the elements that are common to both input lists. The returned list is sorted in ascending order. \n\nThe function first creates an empty table called `ret`. It then creates another table called `set_l2` that contains all the elements of the second input list as keys. This is done so that we can quickly check if an element in the first list is also in the second list. \n\nThe function then loops through all the elements of the first input list. For each element, it checks if it is in the `set_l2` table. If it is, then it adds it to the `ret` table. \n\nFinally, the function sorts the `ret` table and returns it.\n\n### Python version\n\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "py",
    "prompt": "def cycpattern_check(a: str, b: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('xyzw', 'xyw') == False\n    assert candidate('yello', 'ell') == True\n    assert candidate('whattup', 'ptut') == False\n    assert candidate('efef', 'fee') == True\n    assert candidate('abab', 'aabb') == False\n    assert candidate('winemtt', 'tinem') == True\n\ndef test_check():\n    check(cycpattern_check)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function cycpattern_check(a, b)\n  local l = #b\n  local pat = b .. b\n  for i = 1, #a - l + 1 do\n    for j = 1, l + 1 do\n      if a:sub(i, i + l - 1) == pat:sub(j, j + l - 1) then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis program defines a function `cycpattern_check` that takes two string arguments `a` and `b`. The function returns `true` if `b` is a cyclic pattern of `a`, and `false` otherwise. A cyclic pattern is a string that can be obtained by concatenating `a` with itself any number of times, and then taking a substring of the resulting string. The function works by concatenating `b` with itself, and then checking if any substring of length `#b` in `a` matches a substring of the same length in the concatenated string. If a match is found, the function returns `true`. Otherwise, it returns `false`.\n\n### Python version\n\ndef cycpattern_check(a: str, b: str) -> bool:\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "py",
    "prompt": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n    assert candidate([-10]) == -10\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n\ndef test_check():\n    check(minSubArraySum)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function minSubArraySum(nums)\n    local max_sum = 0\n    local s = 0\n    for i=1, #nums do\n        s = s - nums[i]\n        if s < 0 then\n            s = 0\n        end\n        max_sum = math.max(s, max_sum)\n    end\n    if max_sum == 0 then\n        max_sum = -math.huge\n        for i=1, #nums do\n            max_sum = math.max(max_sum, -nums[i])\n        end\n    end\n    local min_sum = -max_sum\n    return min_sum\nend\n\n### Explanation\n\nThis program defines a function `minSubArraySum` that takes an array of numbers as input. The function returns the minimum sum of any contiguous subarray of the input array. If all subarrays have a positive sum, the function returns 0. If there are negative subarrays, the function returns the sum of the most negative subarray. The function uses a sliding window approach to compute the maximum sum of any subarray, and then negates that value to get the minimum sum. If the maximum sum is 0, the function iterates over the array to find the most negative value and returns its negation.\n\n### Python version\n\nfrom typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "py",
    "prompt": "from typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('a b b a') == { 'a': 2, 'b': 2 }\n    assert candidate('a b c a b') == { 'a': 2, 'b': 2 }\n    assert candidate('a b c d g') == { 'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1 }\n    assert candidate('r t g') == { 'r': 1, 't': 1, 'g': 1 }\n    assert candidate('b b b b a') == { 'b': 4 }\n    assert candidate('r t g') == { 'r': 1, 't': 1, 'g': 1 }\n    assert candidate('') == {  }\n    assert candidate('a') == { 'a': 1 }\n\ndef test_check():\n    check(histogram)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function histogram(test)\n    local dict1 = {}\n    local list1 = {}\n    for word in test:gmatch(\"%w+\") do\n        table.insert(list1, word)\n    end\n\n    local t = 0\n    for i=1, #list1 do\n        if list1[i] ~= '' and list1[i] ~= nil then\n            if list1.count == nil then\n                list1.count = function(list, value)\n                    local count = 0\n                    for i=1, #list do\n                        if list[i] == value then\n                            count = count + 1\n                        end\n                    end\n                    return count\n                end\n            end\n            if list1:count(list1[i]) > t then\n                t = list1:count(list1[i])\n            end\n        end\n    end\n\n    if t > 0 then\n        for i=1, #list1 do\n            if list1[i] ~= '' and list1[i] ~= nil then\n                if list1:count(list1[i]) == t then\n                    dict1[list1[i]] = t\n                end\n            end\n        end\n    end\n\n    return dict1\nend\n\n### Explanation\n\nThis Lua program takes a string as input and returns a dictionary with the most common word(s) in the string and their frequency. The program first splits the string into a list of words, then counts the frequency of each word in the list. The most common word(s) and their frequency are then added to a dictionary and returned.\n\n### Python version\n\nfrom typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "py",
    "prompt": "from typing import List\n\ndef get_odd_collatz(n: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5]\n    assert candidate(1) == [1]\n\ndef test_check():\n    check(get_odd_collatz)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function get_odd_collatz(n)\n    local odd_collatz = (n%2==0) and {} or {n}\n    while n > 1 do\n        if n % 2 == 0 then\n            n = n/2\n        else\n            n = n*3 + 1\n        end\n        if n%2 == 1 then\n            table.insert(odd_collatz, math.floor(n))\n        end\n    end\n    table.sort(odd_collatz)\n    return odd_collatz\nend\n\n### Explanation\n\nThis program defines a function `get_odd_collatz` that takes an integer `n` as input and returns a sorted list of odd numbers in the Collatz sequence starting from `n`. The Collatz sequence is generated by repeatedly applying the following rule: if the current number is even, divide it by 2, otherwise multiply it by 3 and add 1. The function first checks if `n` is odd or even, and initializes an empty list or a list with `n` depending on the parity of `n`. It then generates the Collatz sequence by repeatedly applying the rule until the sequence reaches 1. If the current number is odd, it adds it to the list. Finally, it sorts the list and returns it.\n\n### Python version\n\nfrom typing import List\n\ndef get_odd_collatz(n: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "py",
    "prompt": "from typing import List\n\ndef derivative(xs: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\ndef test_check():\n    check(derivative)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function derivative(xs)\n    local result = {}\n    for i=1, #xs-1 do\n        result[i] = i * xs[i+1]\n    end\n    return result\nend\n\n### Explanation\n\nThis program defines a function called `derivative` that takes a list of numbers as input. The function returns a new list of numbers where each element is the derivative of the corresponding element in the input list. The derivative is calculated as the difference between each element and the previous element, multiplied by the index of the element. The `math` library is used to access the `math` module, which provides mathematical functions.\n\n### Python version\n\nfrom typing import List\n\ndef derivative(xs: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "py",
    "prompt": "def fibfib(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\ndef test_check():\n    check(fibfib)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function fibfib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    end\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\nend\n\n### Explanation\n\nThis is a recursive function that calculates the nth number in the Fibonacci sequence. The function takes an integer n as input and returns the nth number in the sequence. If n is 0, the function returns 0. If n is 1, the function returns 0. If n is 2, the function returns 1. Otherwise, the function returns the sum of the three previous numbers in the sequence (n-1, n-2, and n-3).\n\n### Python version\n\ndef fibfib(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "py",
    "prompt": "def truncate_number(number: float) -> float:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function truncate_number(number)\n    return number % 1\nend\n\n### Explanation\n\nThis program imports the math library and defines a function called `truncate_number` that takes a number as an argument. The function returns the remainder of the number divided by 1. This is equivalent to the decimal part of the number.\n\n### Python version\n\ndef truncate_number(number: float) -> float:\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "py",
    "prompt": "from typing import List\n\ndef max_element(l: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n\ndef test_check():\n    check(max_element)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function max_element(l)\n    local m = l[1]\n    for i=2, #l do\n        if l[i] > m then\n            m = l[i]\n        end\n    end\n    return m\nend\n\n### Explanation\n\nThis program defines a function `max_element` that takes a list of numbers as input and returns the maximum element in the list. The function iterates over the list and keeps track of the maximum element seen so far. The `math` library is used to get the value of infinity, which is used to initialize the maximum element to a very small value.\n\n### Python version\n\nfrom typing import List\n\ndef max_element(l: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "py",
    "prompt": "def closest_integer(value: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('10') == 10\n    assert candidate('14.5') == 15\n    assert candidate('-15.5') == -16\n    assert candidate('15.3') == 15\n    assert candidate('0') == 0\n\ndef test_check():\n    check(closest_integer)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if value:find('%.5$') then\n        if num > 0 then\n            return math.ceil(num)\n        else\n            return math.floor(num)\n        end\n    elseif #value > 0 then\n        return math.floor(num + 0.5)\n    else\n        return 0\n    end\nend\n\n### Explanation\n\nThis program defines a function `closest_integer` which takes a string `value` and returns the closest integer to the float value represented by `value`. If `value` ends with `.5`, the function rounds up if the number is positive and down if the number is negative. Otherwise, the function rounds to the nearest integer. If `value` is empty, the function returns 0.\n\n### Python version\n\ndef closest_integer(value: str) -> int:\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "py",
    "prompt": "def prime_fib(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\ndef test_check():\n    check(prime_fib)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function prime_fib(n)\n  local function is_prime(p)\n    if p < 2 then\n      return false\n    end\n    for k = 2, math.min(math.sqrt(p) + 1, p - 1) do\n      if p % k == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local f = {0, 1}\n  while true do\n    table.insert(f, f[#f] + f[#f - 1])\n    if is_prime(f[#f]) then\n      n = n - 1\n    end\n    if n == 0 then\n      return f[#f]\n    end\n  end\nend\n\n### Explanation\n\nThis Lua program defines a function called `prime_fib` that takes an integer `n` as input. The function generates the first `n` Fibonacci numbers and returns the last one that is also a prime number. The Fibonacci sequence is defined as follows: `f(0) = 0`, `f(1) = 1`, and `f(n) = f(n-1) + f(n-2)` for `n >= 2`. The function `is_prime` is a helper function that checks whether a given number is prime. It does this by checking whether the number is less than 2 (in which case it is not prime), and then checking whether it is divisible by any number between 2 and the square root of the number (inclusive). If the number is divisible by any of these numbers, it is not prime. If the function finds `n` prime Fibonacci numbers, it returns the last one.\n\n### Python version\n\ndef prime_fib(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "py",
    "prompt": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (15, 105)\n    assert candidate([10]) == (10, 10)\n\ndef test_check():\n    check(sum_product)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function sum_product(numbers)\n    local sum_value = 0\n    local prod_value = 1\n\n    for _, n in ipairs(numbers) do\n        sum_value = sum_value + n\n        prod_value = prod_value * n\n    end\n    return {sum_value, prod_value}\nend\n\n### Explanation\n\nThis program defines a function called `sum_product` which takes a list of numbers as input. The function then iterates over the list, calculating the sum and product of all the numbers. Finally, it returns a table containing the sum and product as separate values.\n\n### Python version\n\nfrom typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "py",
    "prompt": "from typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Mary had a little lamb', 4) == ['little']\n    assert candidate('Mary had a little lamb', 3) == ['Mary', 'lamb']\n    assert candidate('simple white space', 2) == []\n    assert candidate('Hello world', 4) == ['world']\n    assert candidate('Uncle sam', 3) == ['Uncle']\n    assert candidate('', 4) == []\n    assert candidate('a b c d e f', 1) == ['b', 'c', 'd', 'f']\n\ndef test_check():\n    check(select_words)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function select_words(s, n)\n  local result = {}\n  for word in s:gmatch(\"%S+\") do\n    local n_consonants = 0\n    for i = 1, #word do\n      if not word:sub(i,i):lower():find(\"[aeiou]\") then\n        n_consonants = n_consonants + 1\n      end\n    end\n    if n_consonants == n then\n      table.insert(result, word)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThis program defines a function called `select_words` that takes two arguments: a string `s` and an integer `n`. The function returns a table of words in the string `s` that have exactly `n` consonants. A word is defined as a sequence of non-space characters. The function uses the `gmatch` method of the string object to iterate over the words in the string. For each word, it counts the number of consonants by iterating over the characters in the word and checking if each character is a consonant (i.e., not a vowel). If the word has exactly `n` consonants, it is added to the result table. The function returns the result table.\n\n### Python version\n\nfrom typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "py",
    "prompt": "from typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) == -4\n    assert candidate([111, 121, 3, 4000, 5, 6], 2) == 0\n    assert candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) == 125\n    assert candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) == 24\n    assert candidate([1], 1) == 1\n\ndef test_check():\n    check(add_elements)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function add_elements(arr, k)\n  local sum = 0\n  for i = 1, k do\n    if #tostring(arr[i]) <= 2 then\n      sum = sum + arr[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThis program defines a function `add_elements` that takes two arguments: an array `arr` and an integer `k`. The function returns the sum of the first `k` elements of `arr` that have at most two digits. If `arr` has fewer than `k` elements, the function returns the sum of all elements of `arr` that have at most two digits. The program uses the `math` library to perform arithmetic operations and the `tostring` function to convert numbers to strings for length comparison.\n\n### Python version\n\nfrom typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "py",
    "prompt": "from typing import List\n\ndef eat(number: int, need: int, remaining: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5, 6, 10) == [11, 4]\n    assert candidate(4, 8, 9) == [12, 1]\n    assert candidate(1, 10, 10) == [11, 0]\n    assert candidate(2, 11, 5) == [7, 0]\n    assert candidate(4, 5, 7) == [9, 2]\n    assert candidate(4, 5, 1) == [5, 0]\n\ndef test_check():\n    check(eat)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function eat(number, need, remaining)\n    if need <= remaining then\n        return {number + need, remaining - need}\n    else\n        return {number + remaining, 0}\n    end\nend\n\n### Explanation\n\nThis program defines a function `eat` which takes three arguments: `number`, `need`, and `remaining`. The function returns a table with two elements: the first element is the sum of `number` and `need` if `need` is less than or equal to `remaining`, otherwise it is the sum of `number` and `remaining`; the second element is `remaining` minus `need` if `need` is less than or equal to `remaining`, otherwise it is 0. The program also imports the `math` library.\n\n### Python version\n\nfrom typing import List\n\ndef eat(number: int, need: int, remaining: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "py",
    "prompt": "from typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(['1234567']) == ['the number of odd elements 4n the str4ng 4 of the 4nput.']\n    assert candidate(['3', '11111111']) == ['the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.']\n    assert candidate(['271', '137', '314']) == ['the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.']\n\ndef test_check():\n    check(odd_count)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function odd_count(lst)\n  local res = {}\n  for _, arr in ipairs(lst) do\n    local n = 0\n    for d in arr:gmatch('%d') do\n      if math.fmod(tonumber(d), 2) == 1 then\n        n = n + 1\n      end\n    end\n    table.insert(res, \"the number of odd elements \" .. n .. \"n the str\" .. n .. \"ng \" .. n .. \" of the \" .. n .. \"nput.\")\n  end\n  return res\nend\n\n### Explanation\n\nThis program takes a list of strings as input. For each string, it counts the number of odd digits and returns a string that says how many odd digits there are in the input string. The returned string is added to a list of strings that is returned at the end of the function.\n\n### Python version\n\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "py",
    "prompt": "from typing import List, Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1, 1, 1, 1, 0]) == 1\n    assert candidate([1, 1]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\ndef test_check():\n    check(next_smallest)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function next_smallest(lst)\n    table.sort(lst)\n    for i = 2, #lst do\n        if lst[i] > lst[1] then\n            return lst[i]\n        end\n    end\nend\n\n### Explanation\n\nThis program defines a function `next_smallest` which takes a list of numbers as an argument. The function sorts the list, and then iterates through the list from the second element to the last. If an element is greater than the first element of the list, the function returns that element. If no such element is found, the function returns `nil`.\n\n### Python version\n\nfrom typing import List, Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "py",
    "prompt": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n\ndef test_check():\n    check(filter_by_prefix)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_prefix(strings, prefix)\n    local res = {}\n    for _, x in ipairs(strings) do\n        if string.sub(x, 1, #prefix) == prefix then\n            table.insert(res, x)\n        end\n    end\n    return res\nend\n\n### Explanation\n\nThis program defines a function `filter_by_prefix` that takes a list of strings `strings` and a string `prefix` as arguments. The function returns a new list of strings that have the `prefix` string as a prefix. The function first creates an empty list `res`. It then iterates over each string in `strings`. If the string has the `prefix` string as a prefix, it is added to the `res` list. Finally, the `res` list is returned.\n\n### Python version\n\nfrom typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "py",
    "prompt": "def choose_num(x: int, y: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\ndef test_check():\n    check(choose_num)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function choose_num(x, y)\n    if x > y then\n        return -1\n    end\n    if y % 2 == 0 then\n        return y\n    end\n    if x == y then\n        return -1\n    end\n    return y - 1\nend\n\n### Explanation\n\nThis program defines a function called `choose_num` that takes two arguments, `x` and `y`. If `x` is greater than `y`, the function returns `-1`. If `y` is even, the function returns `y`. If `x` and `y` are equal, the function returns `-1`. Otherwise, the function returns `y - 1`.\n\n### Python version\n\ndef choose_num(x: int, y: int) -> int:\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "py",
    "prompt": "def prime_length(string: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\ndef test_check():\n    check(prime_length)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function prime_length(string)\n  local l = #string\n  if l == 0 or l == 1 then\n    return false\n  end\n  for i = 2, l - 1 do\n    if l % i == 0 then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis program defines a function `prime_length` that takes a string as input and returns true if the length of the string is a prime number, and false otherwise. The function first checks if the length of the string is 0 or 1, in which case it returns false. Otherwise, it checks whether the length of the string is divisible by any number between 2 and the length of the string minus 1 (inclusive). If it is, the function returns false. If it is not, the function returns true.\n\n### Python version\n\ndef prime_length(string: str) -> bool:\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "py",
    "prompt": "def sum_to_n(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\ndef test_check():\n    check(sum_to_n)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function sum_to_n(n)\n  return (n * (n + 1)) / 2\nend\n\n### Explanation\n\nThis program defines a function `sum_to_n` which takes an integer `n` as input. The function returns the sum of all integers from 1 to `n`. The program uses the `math` module to perform the multiplication and division operations.\n\n### Python version\n\ndef sum_to_n(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "py",
    "prompt": "def fix_spaces(text: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Example') == 'Example'\n    assert candidate('Mudasir Hanif ') == 'Mudasir_Hanif_'\n    assert candidate('Yellow Yellow  Dirty  Fellow') == 'Yellow_Yellow__Dirty__Fellow'\n    assert candidate('Exa   mple') == 'Exa-mple'\n    assert candidate('   Exa 1 2 2 mple') == '-Exa_1_2_2_mple'\n\ndef test_check():\n    check(fix_spaces)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function fix_spaces(text)\n    local new_text = \"\"\n    local i = 1\n    local start, _end = 1, 1\n    while i <= #text do\n        local c = text:sub(i, i)\n        if c == \" \" then\n            _end = _end + 1\n        else\n            if _end - start > 2 then\n                new_text = new_text .. \"-\" .. c\n            elseif _end - start > 0 then\n                new_text = new_text .. (\"_\"):rep(_end - start) .. c\n            else\n                new_text = new_text .. c\n            end\n            start, _end = i+1, i+1\n        end\n        i = i + 1\n    end\n    if _end - start > 2 then\n        new_text = new_text .. \"-\"\n    elseif _end - start > 0 then\n        new_text = new_text .. \"_\"\n    end\n    return new_text\nend\n\n### Explanation\n\nThis program defines a function `fix_spaces` that takes a string as input and returns a new string with spaces replaced by underscores and hyphens. If there are two or more spaces in a row, they are replaced by a hyphen followed by the next character. If there is only one space, it is replaced by an underscore. If the input string ends with one or more spaces, they are replaced by a hyphen or underscore, depending on whether there are two or more spaces in a row. The function uses a loop to iterate over the characters in the input string, keeping track of the start and end positions of each sequence of spaces. It then constructs the output string by concatenating substrings of the input string with the appropriate replacements.\n\n### Python version\n\ndef fix_spaces(text: str) -> str:\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "py",
    "prompt": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n\ndef test_check():\n    check(rolling_max)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function rolling_max(numbers)\n    local running_max = nil\n    local result = {}\n\n    for _, n in ipairs(numbers) do\n        if running_max == nil then\n            running_max = n\n        else\n            running_max = math.max(running_max, n)\n        end\n\n        table.insert(result, running_max)\n    end\n\n    return result\nend\n\n### Explanation\n\nThis program defines a function called `rolling_max` which takes a list of numbers as input. It then iterates over the list of numbers, keeping track of the maximum number seen so far. It then appends the current maximum to a list of results. Finally, it returns the list of results.\n\n### Python version\n\nfrom typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "py",
    "prompt": "def words_in_sentence(sentence: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('This is a test') == 'is'\n    assert candidate('lets go for swimming') == 'go for'\n    assert candidate('there is no place available here') == 'there is no place'\n    assert candidate('Hi I am Hussein') == 'Hi am Hussein'\n    assert candidate('go for it') == 'go for it'\n    assert candidate('here') == ''\n    assert candidate('here is') == 'is'\n\ndef test_check():\n    check(words_in_sentence)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function words_in_sentence(sentence)\n    local new_lst = {}\n    for word in sentence:gmatch(\"%S+\") do\n        local flg = 0\n        if #word == 1 then\n            flg = 1\n        end\n        for i=2, #word-1 do\n            if #word%i == 0 then\n                flg = 1\n            end\n        end\n        if flg == 0 or #word == 2 then\n            table.insert(new_lst, word)\n        end\n    end\n    return table.concat(new_lst, \" \")\nend\n\n### Explanation\n\nThis program defines a function `words_in_sentence` that takes a string `sentence` as input. It then creates an empty list `new_lst` and loops through each word in the sentence. For each word, it checks if the length of the word is 1 or if the word has any factors other than 1 and itself. If either of these conditions are true, the word is not added to `new_lst`. Otherwise, the word is added to `new_lst`. Finally, the function returns a string that is the concatenation of all the words in `new_lst`, separated by spaces.\n\n### Python version\n\ndef words_in_sentence(sentence: str) -> str:\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "py",
    "prompt": "def get_closest_vowel(word: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('yogurt') == 'u'\n    assert candidate('full') == 'u'\n    assert candidate('easy') == ''\n    assert candidate('eAsy') == ''\n    assert candidate('ali') == ''\n    assert candidate('bad') == 'a'\n    assert candidate('most') == 'o'\n    assert candidate('ab') == ''\n    assert candidate('ba') == ''\n    assert candidate('quick') == ''\n    assert candidate('anime') == 'i'\n    assert candidate('Asia') == ''\n    assert candidate('Above') == 'o'\n\ndef test_check():\n    check(get_closest_vowel)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function get_closest_vowel(word)\n    if #word < 3 then\n        return \"\"\n    end\n\n    local vowels = {a=true, e=true, i=true, o=true, u=true, A=true, E=true, I=true, O=true, U=true}\n    for i=#word-1, 2, -1 do\n        if vowels[word:sub(i, i)] then\n            if not (vowels[word:sub(i-1, i-1)] or vowels[word:sub(i+1, i+1)]) then\n                return word:sub(i, i)\n            end\n        end\n    end\n    return \"\"\nend\n\n### Explanation\n\nThis Lua program defines a function called `get_closest_vowel` that takes a string `word` as input and returns the closest vowel to the end of the word that is not surrounded by other vowels. If the word is less than three characters long, an empty string is returned. The function first creates a table of vowels, then iterates over the characters of the word from the second-to-last character to the second character, checking if each character is a vowel and if the characters immediately before and after it are not vowels. If such a character is found, it is returned. If no such character is found, an empty string is returned.\n\n### Python version\n\ndef get_closest_vowel(word: str) -> str:\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "py",
    "prompt": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3]\n    assert candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0]\n    assert candidate([1, 2, 3], [-1, -2, -3]) == [2, 4, 6]\n    assert candidate([1, 2, 3, 5], [-1, 2, 3, 4]) == [2, 0, 0, 1]\n\ndef test_check():\n    check(compare)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function compare(game, guess)\n  local result = {}\n  for i = 1, #game do\n    result[i] = math.abs(game[i] - guess[i])\n  end\n  return result\nend\n\n### Explanation\n\nThis program defines a function `compare` that takes two arrays `game` and `guess` of the same length as input. It returns an array `result` of the same length as the input arrays, where each element is the absolute difference between the corresponding elements of `game` and `guess`. The `math` module is used to compute the absolute value of the differences.\n\n### Python version\n\nfrom typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "py",
    "prompt": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n\ndef test_check():\n    check(remove_duplicates)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function remove_duplicates(numbers)\n  local c = {}\n  for _, n in ipairs(numbers) do\n    c[n] = (c[n] or 0) + 1\n  end\n  local result = {}\n  for _, n in ipairs(numbers) do\n    if c[n] <= 1 then\n      table.insert(result, n)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThis program takes an array of numbers and returns a new array with all the duplicates removed. The function `remove_duplicates` first creates a table `c` to count the frequency of each number in the input array. Then, it creates a new array `result` and inserts only the numbers that appear once in the input array. Finally, it returns the `result` array with all duplicates removed.\n\n### Python version\n\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "py",
    "prompt": "def same_chars(s0: str, s1: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\ndef test_check():\n    check(same_chars)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function same_chars(s0, s1)\n    local set0, set1 = {}, {}\n    for i=1, #s0 do set0[s0:sub(i,i)] = true end\n    for i=1, #s1 do set1[s1:sub(i,i)] = true end\n    for k in pairs(set0) do if not set1[k] then return false end end\n    for k in pairs(set1) do if not set0[k] then return false end end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `same_chars` that takes two strings as arguments and returns a boolean indicating whether the two strings have the same characters. The function works by creating two sets of characters, one for each string, and then checking that each set contains all of the characters in the other set. The `math` module is imported but not used in this program.\n\n### Python version\n\ndef same_chars(s0: str, s1: str) -> bool:\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "py",
    "prompt": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function parse_nested_parens(paren_string)\n    local function parse_paren_group(s)\n        local depth = 0\n        local max_depth = 0\n        for c in s:gmatch('.') do\n            if c == '(' then\n                depth = depth + 1\n                max_depth = math.max(depth, max_depth)\n            else\n                depth = depth - 1\n            end\n        end\n        return max_depth\n    end\n    local res = {}\n    for x in paren_string:gmatch('%S+') do\n        table.insert(res, parse_paren_group(x))\n    end\n    return res\nend\n\n### Explanation\n\nThis Lua program defines a function called `parse_nested_parens` which takes a string of parentheses as input. The function returns a list of integers, where each integer represents the maximum depth of nested parentheses in each group of parentheses in the input string. For example, if the input string is `\"(()) () ((()))\"`, the function would return `{2, 1, 3}`. The function works by iterating through each group of parentheses in the input string, and counting the maximum depth of nested parentheses in each group. The function uses Lua's built-in `math` library to find the maximum depth. To rewrite this program in Python, you would need to replace the `local` keyword with `def`, and replace the `table.insert` function with Python's `append` method. You would also need to replace the `gmatch` function with Python's `split` method. Here is the Python version of the program:\n\n### Python version\n\nfrom typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "py",
    "prompt": "from typing import Tuple\n\ndef even_odd_count(num: int) -> Tuple[int, int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\ndef test_check():\n    check(even_odd_count)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_count(num)\n    local even_count = 0\n    local odd_count = 0\n    for i in tostring(math.abs(num)):gmatch(\".\") do\n        if tonumber(i)%2==0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n    end\n    return {even_count, odd_count}\nend\n\n### Explanation\n\nThis Lua program defines a function called `even_odd_count` which takes an integer as an argument. The function returns an array of two integers, the first integer is the count of even digits in the input integer and the second integer is the count of odd digits in the input integer. The function first converts the input integer to a string and then iterates over each character in the string. If the character is an even digit, the `even_count` variable is incremented, otherwise the `odd_count` variable is incremented. Finally, the function returns an array containing the `even_count` and `odd_count` variables.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_count(num: int) -> Tuple[int, int]:\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "py",
    "prompt": "def fruit_distribution(s: str, n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('5 apples and 6 oranges', 19) == 8\n    assert candidate('5 apples and 6 oranges', 21) == 10\n    assert candidate('0 apples and 1 oranges', 3) == 2\n    assert candidate('1 apples and 0 oranges', 3) == 2\n    assert candidate('2 apples and 3 oranges', 100) == 95\n    assert candidate('2 apples and 3 oranges', 5) == 0\n    assert candidate('1 apples and 100 oranges', 120) == 19\n\ndef test_check():\n    check(fruit_distribution)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function fruit_distribution(s, n)\n    local sum = 0\n    for i in string.gmatch(s, \"%d+\") do\n        sum = sum + tonumber(i)\n    end\n    return n - sum\nend\n\n### Explanation\n\nThis program defines a function `fruit_distribution` that takes two arguments, `s` and `n`. `s` is a string containing a sequence of numbers separated by non-numeric characters. The function returns the difference between `n` and the sum of the numbers in `s`. The function uses the `string.gmatch` function to iterate over the numbers in `s`, and `tonumber` to convert each number from a string to a number. The `math` module is imported but not used in this program.\n\n### Python version\n\ndef fruit_distribution(s: str, n: int) -> int:\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "py",
    "prompt": "def string_xor(a: str, b: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n\ndef test_check():\n    check(string_xor)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function string_xor(a, b)\n    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result = result .. '0'\n        else\n            result = result .. '1'\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThis program defines a function `string_xor` which takes two strings `a` and `b` and returns a string that is the result of a bitwise XOR operation between the two input strings. The function iterates over each character in the input strings and compares them. If the characters are the same, the function appends a '0' to the result string, otherwise it appends a '1'. The program also imports the `math` library.\n\n### Python version\n\ndef string_xor(a: str, b: str) -> str:\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "py",
    "prompt": "def strlen(string: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n\ndef test_check():\n    check(strlen)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function strlen(string)\n    return #string\nend\n\n### Explanation\n\nThis program defines a function called strlen that takes a string as input and returns the length of the string. The function is defined using the local keyword, which means that it is only accessible within the scope of the current block. The math library is imported using the require function, which allows the program to use math functions.\n\n### Python version\n\ndef strlen(string: str) -> int:\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "py",
    "prompt": "def string_sequence(n: int) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n\ndef test_check():\n    check(string_sequence)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function string_sequence(n)\n    local t = {}\n    for i = 0, n do\n        t[#t + 1] = tostring(i)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThis program defines a function `string_sequence` that takes an integer `n` and returns a string of space-separated integers from 0 to `n`. The function first creates an empty table `t`, then loops from 0 to `n` and adds each integer to the table as a string. Finally, the function returns the concatenation of all the strings in the table, separated by spaces.\n\n### Python version\n\ndef string_sequence(n: int) -> str:\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "py",
    "prompt": "from typing import List\n\ndef can_arrange(arr: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 4, 3, 5]) == 3\n    assert candidate([1, 2, 4, 5]) == -1\n    assert candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2\n    assert candidate([4, 8, 5, 7, 3]) == 4\n    assert candidate([]) == -1\n\ndef test_check():\n    check(can_arrange)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function can_arrange(arr)\n    local ind=-1\n    local i=1\n    while i<#arr do\n      if arr[i]>arr[i+1] then\n        ind=i\n      end\n      i=i+1\n    end\n    return ind\nend\n\n### Explanation\n\nThis program defines a function `can_arrange` that takes an array of numbers as input, and returns the index of the first element that is greater than the element that comes after it. If no such element exists, the function returns -1.\n\n### Python version\n\nfrom typing import List\n\ndef can_arrange(arr: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "py",
    "prompt": "from typing import List\n\ndef add(lst: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\ndef test_check():\n    check(add)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function add(lst)\n  local sum = 0\n  for i = 2, #lst, 2 do\n    if lst[i]%2 == 0 then\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThis program defines a function `add` that takes a list as input and returns the sum of all even numbers in the list. The function iterates over every second element in the list, checks if it is even, and adds it to the sum if it is. The `math` library is imported but not used.\n\n### Python version\n\nfrom typing import List\n\ndef add(lst: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "py",
    "prompt": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n\ndef test_check():\n    check(intersperse)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function intersperse(numbers, delimeter)\n    if not numbers then\n        return {}\n    end\n\n    local result = {}\n\n    for i=1, #numbers-1 do\n        table.insert(result, numbers[i])\n        table.insert(result, delimeter)\n    end\n\n    table.insert(result, numbers[#numbers])\n\n    return result\nend\n\n### Explanation\n\nThis program defines a function `intersperse` that takes two arguments: `numbers` and `delimiter`. It returns a new table that contains the elements of `numbers` separated by `delimiter`. If `numbers` is empty, the function returns an empty table. The function uses the `table.insert` function to add elements to the result table.\n\n### Python version\n\nfrom typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "py",
    "prompt": "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function match_parens(lst)\n    local function check(s)\n        local val = 0\n        for i=1, #s do\n            if s:sub(i,i) == '(' then\n                val = val + 1\n            else\n                val = val - 1\n            end\n            if val < 0 then\n                return false\n            end\n        end\n        return val == 0\n    end\n\n    local S1 = lst[1] .. lst[2]\n    local S2 = lst[2] .. lst[1]\n    if check(S1) or check(S2) then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\n\n### Explanation\n\nThis program defines a function `match_parens` that takes a list of two strings as input. The function checks if the two strings can be concatenated in any order to form a string containing balanced parentheses. If the parentheses are balanced, the function returns the string 'Yes', otherwise it returns 'No'. The function uses a nested function `check` to determine if a given string contains balanced parentheses. The function iterates over the characters of the string, incrementing a counter for each opening parenthesis and decrementing it for each closing parenthesis. If the counter ever becomes negative, the string is unbalanced and the function returns false. If the counter is zero at the end of the iteration, the string is balanced and the function returns true. The function concatenates the two input strings in both orders and checks if either of them contains balanced parentheses using the `check` function. If either string is balanced, the function returns 'Yes', otherwise it returns 'No'.\n\n### Python version\n\nfrom typing import List\n\ndef match_parens(lst: List[str]) -> str:\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "py",
    "prompt": "def any_int(x: float, y: float, z: float) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(2, 3, 1) == True\n    assert candidate(2.5, 2, 3) == False\n    assert candidate(1.5, 5, 3.5) == False\n    assert candidate(2, 6, 2) == False\n    assert candidate(4, 2, 2) == True\n    assert candidate(2.2, 2.2, 2.2) == False\n    assert candidate(-4, 6, 2) == True\n    assert candidate(2, 1, 1) == True\n    assert candidate(3, 4, 7) == True\n    assert candidate(3.0, 4, 7) == False\n\ndef test_check():\n    check(any_int)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function any_int(x, y, z)\n    if math.type(x) == \"integer\" and math.type(y) == \"integer\" and math.type(z) == \"integer\" then\n        if (x+y==z) or (x+z==y) or (y+z==x) then\n            return true\n        end\n        return false\n    end\n    return false\nend\n\n### Explanation\n\nThis program defines a function `any_int` that takes three arguments `x`, `y`, and `z`. The function checks if all three arguments are integers, and if so, checks if any two of the arguments add up to the third argument. If so, the function returns `true`, otherwise it returns `false`. If any of the arguments are not integers, the function returns `false`.\n\n### Python version\n\ndef any_int(x: float, y: float, z: float) -> bool:\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "py",
    "prompt": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n\ndef test_check():\n    check(filter_by_substring)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_substring(strings, substring)\n    local result = {}\n    for _, v in pairs(strings) do\n        if string.find(v, substring) then\n            table.insert(result, v)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThis program defines a function `filter_by_substring` that takes two arguments: a list of strings and a substring. It returns a new list containing only the strings that contain the substring. The function uses the `string.find` function to check if each string contains the substring, and if it does, it adds it to the result list using `table.insert`. The `math` module is imported but not used in this program.\n\n### Python version\n\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "py",
    "prompt": "from typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(2, 10) == [2, 4, 6, 8]\n    assert candidate(10, 2) == [2, 4, 6, 8]\n    assert candidate(132, 2) == [2, 4, 6, 8]\n    assert candidate(17, 89) == []\n\ndef test_check():\n    check(generate_integers)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function generate_integers(a, b)\n    local lower = math.max(2, math.min(a, b))\n    local upper = math.min(8, math.max(a, b))\n\n    local result = {}\n    for i=lower, upper do\n        if i%2 == 0 then\n            table.insert(result, i)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThis program defines a function `generate_integers` which takes two integers `a` and `b` as arguments. The function returns a list of even integers between `a` and `b`, inclusive. If `a` or `b` is less than 2, the function uses 2 as the lower bound. If `a` or `b` is greater than 8, the function uses 8 as the upper bound.\n\n### Python version\n\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "py",
    "prompt": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == 'YES'\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == 'NO'\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == 'YES'\n    assert candidate([5, 7, 3], [2, 6, 4]) == 'YES'\n    assert candidate([5, 7, 3], [2, 6, 3]) == 'NO'\n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == 'NO'\n    assert candidate([100, 200], [200, 200]) == 'YES'\n\ndef test_check():\n    check(exchange)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function exchange(lst1, lst2)\n    local odd = 0\n    local even = 0\n    for i=1, #lst1 do\n        if lst1[i]%2 == 1 then\n            odd = odd + 1\n        end\n    end\n    for i=1, #lst2 do\n        if lst2[i]%2 == 0 then\n            even = even + 1\n        end\n    end\n    if even >= odd then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThis program defines a function called `exchange` that takes two lists as input. It then counts the number of odd numbers in the first list and the number of even numbers in the second list. If the number of even numbers is greater than or equal to the number of odd numbers, it returns the string \"YES\". Otherwise, it returns the string \"NO\".\n\n### Python version\n\nfrom typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "py",
    "prompt": "def int_to_mini_roman(number: int) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\ndef test_check():\n    check(int_to_mini_roman)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function int_to_mini_roman(number)\n    local num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}\n    local sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\n    local i = 13\n    local res = \"\"\n    while number > 0 do\n        local div = math.floor(number / num[i])\n        number = number % num[i]\n        while div > 0 do\n            res = res .. sym[i]\n            div = div - 1\n        end\n        i = i - 1\n    end\n    return string.lower(res)\nend\n\n### Explanation\n\nThis program defines a function `int_to_mini_roman` that takes an integer as input and returns a string that represents the integer in Roman numerals. The Roman numerals are represented using the \"subtractive\" notation, where the symbols for 4, 9, 40, 90, 400, and 900 are represented using a combination of the symbols for 1, 5, 10, 50, 100, and 1000. The function first defines two arrays, `num` and `sym`, that represent the values and symbols of the Roman numerals. It then iterates over the values in `num` from largest to smallest, dividing the input number by each value and adding the corresponding symbol to the result string as many times as the quotient of the division. The function returns the result string in lowercase.\n\n### Python version\n\ndef int_to_mini_roman(number: int) -> str:\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "py",
    "prompt": "def is_equal_to_sum_even(n: int) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n\ndef test_check():\n    check(is_equal_to_sum_even)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function is_equal_to_sum_even(n)\n  return n%2 == 0 and n >= 8\nend\n\n### Explanation\n\nThis program defines a function called `is_equal_to_sum_even` which takes a single argument `n`. The function returns `true` if `n` is an even number greater than or equal to 8, and `false` otherwise.\n\n### Python version\n\ndef is_equal_to_sum_even(n: int) -> bool:\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "py",
    "prompt": "from typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5]\n    assert candidate([5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5]\n    assert candidate([5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5]\n    assert candidate([5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1]\n\ndef test_check():\n    check(sort_third)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function sort_third(l)\n    l = {table.unpack(l)}\n    for i = 3, #l, 3 do\n        local j = i\n        while j > 1 and l[j - 3 + 1] > l[j + 1] do\n            l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]\n            j = j - 3\n        end\n    end\n    return l\nend\n\n### Explanation\n\nThis Lua program defines a function `sort_third` that sorts a list of numbers by their third element. The function takes a list `l` as input, and returns a new list with the same elements as `l`, but sorted by the third element of each element in `l`. The sorting is done using an insertion sort algorithm, which is implemented using a while loop and a series of swaps. The function uses the `math` module to access the `table.unpack` function, which is used to create a copy of the input list `l`.\n\n### Python version\n\nfrom typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "py",
    "prompt": "def simplify(x: str, n: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('1/5', '5/1') == True\n    assert candidate('1/6', '2/1') == False\n    assert candidate('5/1', '3/1') == True\n    assert candidate('7/10', '10/2') == False\n    assert candidate('2/10', '50/10') == True\n    assert candidate('7/2', '4/2') == True\n    assert candidate('11/6', '6/1') == True\n    assert candidate('2/3', '5/2') == False\n    assert candidate('5/2', '3/5') == False\n    assert candidate('2/4', '8/4') == True\n    assert candidate('2/4', '4/2') == True\n    assert candidate('1/5', '5/1') == True\n    assert candidate('1/5', '1/5') == False\n\ndef test_check():\n    check(simplify)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function simplify(x, n)\n  local a, b = x:match(\"([^/]+)/([^/]+)\")\n  local c, d = n:match(\"([^/]+)/([^/]+)\")\n  local numerator = tonumber(a) * tonumber(c)\n  local denom = tonumber(b) * tonumber(d)\n  if (numerator/denom == math.floor(numerator/denom)) then\n    return true\n  end\n  return false\nend\n\n### Explanation\n\nThis Lua program defines a function called `simplify` that takes two arguments, `x` and `n`. The function then extracts the numerator and denominator from both `x` and `n`, multiplies the numerators together and the denominators together, and then checks if the numerator divided by the denominator is a whole number. If it is, the function returns `true`, otherwise it returns `false`.\n\n### Python version\n\ndef simplify(x: str, n: str) -> bool:\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "py",
    "prompt": "def solve(s: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('AsDf') == 'aSdF'\n    assert candidate('1234') == '4321'\n    assert candidate('ab') == 'AB'\n    assert candidate('#a@C') == '#A@c'\n    assert candidate('#AsdfW^45') == '#aSDFw^45'\n    assert candidate('#6@2') == '2@6#'\n    assert candidate('#$a^D') == '#$A^d'\n    assert candidate('#ccc') == '#CCC'\n\ndef test_check():\n    check(solve)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function solve(s)\n    local flg = 0\n    local idx = 1\n    local new_str = {}\n    for i=1, #s do\n        if string.match(s:sub(i,i), '%a') then\n            new_str[idx] = string.match(s:sub(i,i), '%a'):upper() == s:sub(i,i) and string.match(s:sub(i,i), '%a'):lower() or string.match(s:sub(i,i), '%a'):upper()\n            flg = 1\n        else\n            new_str[idx] = s:sub(i,i)\n        end\n        idx = idx + 1\n    end\n    s = table.concat(new_str)\n    if flg == 0 then\n        return s:reverse()\n    end\n    return s\nend\n\n### Explanation\n\nThis Lua program defines a function `solve` that takes a string `s` as input. The function then iterates through each character of the string, and if the character is a letter, it swaps its case (upper to lower or lower to upper) and adds it to a new string. If the character is not a letter, it just adds it to the new string. If the original string contains no letters, the function returns the reversed string. Otherwise, it returns the modified string.\n\n### Python version\n\ndef solve(s: str) -> str:\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "py",
    "prompt": "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(3, 4, 5) == True\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n    assert candidate(1, 1, 1) == False\n    assert candidate(2, 2, 10) == False\n\ndef test_check():\n    check(right_angle_triangle)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function right_angle_triangle(a, b, c)\n  return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\nend\n\n### Explanation\n\nThis program defines a function `right_angle_triangle` that takes three arguments, `a`, `b`, and `c`. The function returns `true` if the arguments form a right-angled triangle, and `false` otherwise. A right-angled triangle is one where the square of one of the sides is equal to the sum of the squares of the other two sides. The program uses the `math` library to perform the necessary calculations.\n\n### Python version\n\ndef right_angle_triangle(a: int, b: int, c: int) -> bool:\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "py",
    "prompt": "from typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == 0\n    assert candidate([5.0, 4.0]) == 25\n    assert candidate([0.1, 0.2, 0.3]) == 0\n    assert candidate([-10.0, -20.0, -30.0]) == 0\n    assert candidate([-1.0, -2.0, 8.0]) == 0\n    assert candidate([0.2, 3.0, 5.0]) == 34\n    assert candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165\n\ndef test_check():\n    check(double_the_difference)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function double_the_difference(lst)\n    local sum = 0\n    for _, i in ipairs(lst) do\n        if i > 0 and i%2~=0 and math.floor(i) == i then\n            sum = sum + i^2\n        end\n    end\n    return sum\nend\n\n### Explanation\n\nThis program defines a function `double_the_difference` that takes a list as input. The function then iterates over the list, and for each element `i` that is a positive odd integer, it adds `i^2` to a running sum. The function then returns twice the sum of these values.\n\n### Python version\n\nfrom typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "py",
    "prompt": "from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, '2,3') == '2,3'\n    assert candidate('5,1', '6') == '6'\n    assert candidate('1', '2') == '2'\n    assert candidate('1', 1) == None\n\ndef test_check():\n    check(compare_one)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function compare_one(a, b)\n  local temp_a, temp_b = a, b\n  if type(temp_a) == 'string' then temp_a = temp_a:gsub(',', '.') end\n  if type(temp_b) == 'string' then temp_b = temp_b:gsub(',', '.') end\n  if tonumber(temp_a) == tonumber(temp_b) then return nil end\n  return tonumber(temp_a) > tonumber(temp_b) and a or b\nend\n\n### Explanation\n\nThis program defines a function `compare_one` that takes two arguments `a` and `b`. The function first creates local variables `temp_a` and `temp_b` that are set to the values of `a` and `b`, respectively. If either of these values is a string, then the function replaces any commas with periods. The function then compares the two values as numbers. If they are equal, then the function returns `nil`. Otherwise, it returns the argument that has the greater numeric value.\n\n### Python version\n\nfrom typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "py",
    "prompt": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n\ndef test_check():\n    check(below_zero)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function below_zero(operations)\n    local balance = 0\n\n    for _, op in ipairs(operations) do\n        balance = balance + op\n        if balance < 0 then\n            return true\n        end\n    end\n\n    return false\nend\n\n### Explanation\n\nThis program defines a function `below_zero` that takes a list of numbers called `operations` as input. It then iterates over each number in the list, adding it to a variable called `balance`. If the balance ever goes below zero, the function returns `true`. Otherwise, if it makes it through the entire list without going below zero, it returns `false`.\n\n### Python version\n\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "py",
    "prompt": "def greatest_common_divisor(a: int, b: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n\ndef test_check():\n    check(greatest_common_divisor)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function greatest_common_divisor(a, b)\n    while b ~= 0 do\n        a, b = b, a % b\n    end\n    return a\nend\n\n### Explanation\n\nThis program defines a function `greatest_common_divisor` which takes two arguments `a` and `b`. The function calculates the greatest common divisor of `a` and `b` using the Euclidean algorithm. The function returns the greatest common divisor.\n\n### Python version\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "py",
    "prompt": "from typing import List\n\ndef f(n: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n\ndef test_check():\n    check(f)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function f(n)\n    local ret = {}\n    for i=1,n do\n        if i%2 == 0 then\n            local x = 1\n            for j=1,i do x = x*j end\n            table.insert(ret, x)\n        else\n            local x = 0\n            for j=1,i do x = x+j end\n            table.insert(ret, x)\n        end\n    end\n    return ret\nend\n\n### Explanation\n\nThis program defines a function `f` which takes an integer `n` as input. The function returns a table of length `n` where each element is either the sum of the first `i` integers or the product of the first `i` integers, depending on whether `i` is odd or even. The program uses the `math` library to compute factorials.\n\n### Python version\n\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "py",
    "prompt": "from typing import List\n\ndef monotonic(l: List[int]) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\ndef test_check():\n    check(monotonic)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function monotonic(l)\n    local is_increasing = true\n    local is_decreasing = true\n    for i=2, #l do\n        if l[i] < l[i-1] then\n            is_increasing = false\n        end\n        if l[i] > l[i-1] then\n            is_decreasing = false\n        end\n    end\n    return is_increasing or is_decreasing\nend\n\n### Explanation\n\nThis program defines a function `monotonic` that takes a list `l` as input. The function returns `true` if the list is monotonic, i.e., if it is either entirely non-increasing or entirely non-decreasing. Otherwise, it returns `false`. The function first initializes two boolean variables `is_increasing` and `is_decreasing` to `true`. It then iterates over the list `l` from the second element to the last element. For each element, it checks if it is less than the previous element, and if so, sets `is_increasing` to `false`. Similarly, if the element is greater than the previous element, it sets `is_decreasing` to `false`. Finally, the function returns `true` if either `is_increasing` or `is_decreasing` is `true`, and `false` otherwise.\n\n### Python version\n\nfrom typing import List\n\ndef monotonic(l: List[int]) -> bool:\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "py",
    "prompt": "from typing import List\n\ndef by_length(arr: List[int]) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == ['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']\n    assert candidate([]) == []\n    assert candidate([1, -1, 55]) == ['One']\n    assert candidate([1, -1, 3, 2]) == ['Three', 'Two', 'One']\n    assert candidate([9, 4, 8]) == ['Nine', 'Eight', 'Four']\n\ndef test_check():\n    check(by_length)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function by_length(arr)\n    local dic = {\n        [1] = \"One\",\n        [2] = \"Two\",\n        [3] = \"Three\",\n        [4] = \"Four\",\n        [5] = \"Five\",\n        [6] = \"Six\",\n        [7] = \"Seven\",\n        [8] = \"Eight\",\n        [9] = \"Nine\",\n    }\n    table.sort(arr, function(a, b) return a > b end)\n    local new_arr = {}\n    for i, var in ipairs(arr) do\n        if dic[var] then\n            table.insert(new_arr, dic[var])\n        end\n    end\n    return new_arr\nend\n\n### Explanation\n\nThis Lua program defines a function `by_length` that takes an array of integers and returns a new array of strings. The new array contains the English names of the integers in the input array, sorted by length of the name. The function first defines a dictionary mapping integers to their English names. It then sorts the input array in descending order, and iterates over it, adding the English name of each integer to the new array if it is in the dictionary. The function then returns the new array.\n\n### Python version\n\nfrom typing import List\n\ndef by_length(arr: List[int]) -> List[str]:\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "py",
    "prompt": "def remove_vowels(text: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('abcdef\\nghijklm') == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\ndef test_check():\n    check(remove_vowels)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function remove_vowels(text)\n    return text:gsub(\"[aeiouAEIOU]\", \"\")\nend\n\n### Explanation\n\nThis program defines a function called `remove_vowels` that takes a string as input and returns a new string with all vowels removed. The `math` library is imported, but not used. The `:gsub` method is called on the input string, which replaces all vowels with an empty string. The resulting string is returned.\n\n### Python version\n\ndef remove_vowels(text: str) -> str:\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "py",
    "prompt": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('apple') == False\n    assert candidate('apple pi e') == True\n    assert candidate('eeeee') == False\n    assert candidate('A') == True\n    assert candidate('Pumpkin pie ') == False\n    assert candidate('Pumpkin pie 1') == False\n    assert candidate('') == False\n    assert candidate('eeeee e ') == False\n    assert candidate('apple pie') == False\n    assert candidate('apple pi e ') == False\n\ndef test_check():\n    check(check_if_last_char_is_a_letter)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function check_if_last_char_is_a_letter(txt)\n    local check = txt:match(\"%a%a*$\")\n    return check ~= nil and #check == 1\nend\n\n### Explanation\n\nThis program defines a function `check_if_last_char_is_a_letter` which takes a string as input and returns a boolean. The function checks if the last character of the string is a letter, and if it is, it returns `true`. Otherwise, it returns `false`. The function uses the `string.match` function to find the last sequence of letters in the string, and then checks if that sequence has length 1. The program also imports the `math` module, but does not use it.\n\n### Python version\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "py",
    "prompt": "def iscube(a: int) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(1) == True\n    assert candidate(2) == False\n    assert candidate(-1) == True\n    assert candidate(64) == True\n    assert candidate(180) == False\n    assert candidate(1000) == True\n    assert candidate(0) == True\n    assert candidate(1729) == False\n\ndef test_check():\n    check(iscube)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function iscube(a)\n    a = math.abs(a)\n    return math.floor(a^(1/3) + 0.5)^3 == a\nend\n\n### Explanation\n\nThis program defines a function `iscube` that takes an argument `a`. The function returns `true` if `a` is a perfect cube, and `false` otherwise. The function first takes the absolute value of `a`, then computes the cube root of `a` using the `^(1/3)` operator. It then rounds this value to the nearest integer using `math.floor` and `+ 0.5`, cubes the result using the `^` operator, and checks if the result is equal to the absolute value of `a`. The `math` module is used to provide the `abs`, `floor`, and `sqrt` functions.\n\n### Python version\n\ndef iscube(a: int) -> bool:\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "py",
    "prompt": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1.0, 2.0]) == 0.5\n    assert candidate([1.0, 2.0, 3.0, 4.0]) == 1.0\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2\n\ndef test_check():\n    check(mean_absolute_deviation)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function mean_absolute_deviation(numbers)\n    local mean = 0\n    for _, v in ipairs(numbers) do\n        mean = mean + v\n    end\n    mean = mean / #numbers\n    local sum = 0\n    for _, v in ipairs(numbers) do\n        sum = sum + math.abs(v - mean)\n    end\n    return sum / #numbers\nend\n\n### Explanation\n\nThis program defines a function `mean_absolute_deviation` that takes a list of numbers as input. It calculates the mean of the input list, and then calculates the sum of the absolute differences between each element in the list and the mean. Finally, it returns the average of these absolute differences, which is the mean absolute deviation of the input list.\n\n### Python version\n\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "py",
    "prompt": "def correct_bracketing(brackets: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('<>') == True\n    assert candidate('<<><>>') == True\n    assert candidate('<><><<><>><>') == True\n    assert candidate('<><><<<><><>><>><<><><<>>>') == True\n    assert candidate('<<<><>>>>') == False\n    assert candidate('><<>') == False\n    assert candidate('<') == False\n    assert candidate('<<<<') == False\n    assert candidate('>') == False\n    assert candidate('<<>') == False\n    assert candidate('<><><<><>><>><<>') == False\n    assert candidate('<><><<><>><>>><>') == False\n\ndef test_check():\n    check(correct_bracketing)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for b in brackets:gmatch(\".\") do\n        if b == \"<\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThis program defines a function `correct_bracketing` that takes a string of brackets as input and returns a boolean indicating whether the brackets are correctly balanced. The function iterates over each character in the input string and increments a counter for each opening bracket it encounters and decrements the counter for each closing bracket. If the counter ever becomes negative, the function returns false, indicating that the brackets are unbalanced. If the counter is zero at the end of the iteration, the function returns true, indicating that the brackets are balanced.\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "py",
    "prompt": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n\ndef test_check():\n    check(rescale_to_unit)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function rescale_to_unit(numbers)\n    local min_number = math.min(table.unpack(numbers))\n    local max_number = math.max(table.unpack(numbers))\n    local result = {}\n    for i, x in ipairs(numbers) do\n        result[i] = (x - min_number) / (max_number - min_number)\n    end\n    return result\nend\n\n### Explanation\n\nThis program defines a function called `rescale_to_unit` that takes a list of numbers as input. The function returns a new list where each element is rescaled to be between 0 and 1. The rescaling is done by subtracting the minimum value from each element and dividing by the range of the input list. The `math` library is used to find the minimum and maximum values in the input list.\n\n### Python version\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "py",
    "prompt": "from typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate((1, 2), (2, 3)) == 'NO'\n    assert candidate((-1, 1), (0, 4)) == 'NO'\n    assert candidate((-3, -1), (-5, 5)) == 'YES'\n    assert candidate((-2, 2), (-4, 0)) == 'YES'\n    assert candidate((-11, 2), (-1, -1)) == 'NO'\n    assert candidate((1, 2), (3, 5)) == 'NO'\n    assert candidate((1, 2), (1, 2)) == 'NO'\n    assert candidate((-2, -2), (-3, -2)) == 'NO'\n\ndef test_check():\n    check(intersection)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function intersection(interval1, interval2)\n    local function is_prime(num)\n        if num == 1 or num == 0 then\n            return false\n        end\n        if num == 2 then\n            return true\n        end\n        for i=2,num-1 do\n            if num%i == 0 then\n                return false\n            end\n        end\n        return true\n    end\n\n    local l = math.max(interval1[1], interval2[1])\n    local r = math.min(interval1[2], interval2[2])\n    local length = r - l\n    if length > 0 and is_prime(length) then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThis program defines a function called `intersection` that takes two intervals as input. An interval is defined as a table with two numbers. The function first defines an inner function called `is_prime` that returns true if the input number is prime and false otherwise. The function then calculates the intersection of the two intervals by finding the maximum of the left endpoints and the minimum of the right endpoints. If the resulting interval has a positive length that is prime, the function returns \"YES\". Otherwise, it returns \"NO\".\n\n### Python version\n\nfrom typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "py",
    "prompt": "def hex_key(num: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('AB') == 1\n    assert candidate('1077E') == 2\n    assert candidate('ABED1A33') == 4\n    assert candidate('2020') == 2\n    assert candidate('123456789ABCDEF0') == 6\n    assert candidate('112233445566778899AABBCCDDEEFF00') == 12\n\ndef test_check():\n    check(hex_key)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function hex_key(num)\n    local primes = {'2', '3', '5', '7', 'B', 'D'}\n    local total = 0\n    for i = 1, #num do\n        if table.concat(primes):find(num:sub(i, i)) then\n            total = total + 1\n        end\n    end\n    return total\nend\n\n### Explanation\n\nThis program defines a function `hex_key` which takes a string `num` as input. The function returns the number of characters in `num` that are present in a list of hexadecimal digits. The list of hexadecimal digits is defined in the `primes` table. The function first imports the `math` library. It then initializes a variable `total` to 0. It then loops through each character in the input string `num`. If the character is present in the `primes` table, the `total` variable is incremented by 1. Finally, the function returns the `total` variable.\n\n### Python version\n\ndef hex_key(num: str) -> int:\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "py",
    "prompt": "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\ndef test_check():\n    check(strange_sort_list)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function strange_sort_list(lst)\n    local res, switch = {}, true\n    while #lst > 0 do\n        if switch then\n            table.insert(res, math.min(table.unpack(lst)))\n        else\n            table.insert(res, math.max(table.unpack(lst)))\n        end\n        local index = 0\n        for i, v in ipairs(lst) do\n            if v == res[#res] then\n                index = i\n                break\n            end\n        end\n        table.remove(lst, index)\n        switch = not switch\n    end\n    return res\nend\n\n### Explanation\n\nThis program defines a function called `strange_sort_list` that takes a list as input and returns a new list that is sorted in a strange way. The function works by iterating over the input list and alternately selecting the smallest and largest remaining element. The selected element is then removed from the input list and added to the output list. The process continues until all elements have been selected. The strange part of the sorting is that the order of the elements in the output list is not strictly increasing or decreasing, but rather alternates between the two. The function makes use of the `math.min` and `math.max` functions to find the smallest and largest elements in the input list, respectively. The `table.unpack` function is used to pass the elements of the input list as separate arguments to these functions. Finally, the function returns the sorted list.\n\n### Python version\n\nfrom typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "py",
    "prompt": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n\ndef test_check():\n    check(all_prefixes)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function all_prefixes(string)\n    local result = {}\n\n    for i=1, #string do\n        table.insert(result, string:sub(1, i))\n    end\n    return result\nend\n\n### Explanation\n\nThis program defines a function `all_prefixes` which takes a string as input and returns a list of all prefixes of the string. A prefix is a string that starts at the beginning of the input string and includes all characters up to a certain point. The function works by iterating over the input string and appending each prefix to a list. The list is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "py",
    "prompt": "def how_many_times(string: str, substring: str) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n\ndef test_check():\n    check(how_many_times)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function how_many_times(string, substring)\n  local times = 0\n  for i = 1, #string - #substring + 1 do\n    if string:sub(i, i + #substring - 1) == substring then\n      times = times + 1\n    end\n  end\n  return times\nend\n\n### Explanation\n\nThis program defines a function `how_many_times` that takes two string arguments, `string` and `substring`. The function returns the number of times `substring` appears in `string`. The function does this by iterating over each character in `string`, comparing the substring starting at that character to the `substring` argument. If the two are equal, the function increments a counter. Finally, the function returns the counter. The `math` module is imported but not used in this program.\n\n### Python version\n\ndef how_many_times(string: str, substring: str) -> int:\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "py",
    "prompt": "from typing import List\n\ndef solution(lst: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([5, 8, 7, 1]) == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\ndef test_check():\n    check(solution)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function solution(lst)\n  local sum = 0\n  for idx, x in ipairs(lst) do\n    if idx%2==1 and x%2==1 then\n      sum = sum + x\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThis program defines a function `solution` that takes a list of integers as input. It then iterates over the list, and for each odd-indexed element that is also odd, it adds the element to a running total. Finally, it returns the total.\n\n### Python version\n\nfrom typing import List\n\ndef solution(lst: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "py",
    "prompt": "from typing import List\n\ndef search(lst: List[int]) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\ndef test_check():\n    check(search)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function search(lst)\n    local frq = {}\n    for i=1, math.max(table.unpack(lst)) do\n        frq[i] = 0\n    end\n    for i=1, #lst do\n        frq[lst[i]] = frq[lst[i]] + 1\n    end\n\n    local ans = -1\n    for i=1, #frq do\n        if frq[i] >= i then\n            ans = i\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThis program defines a function `search` that takes a list of integers as input. It then creates a table `frq` with the same length as the maximum value in the input list, and initializes all its elements to zero. It then loops over the input list and increments the corresponding element in `frq` for each value in the input list. Finally, it loops over `frq` and returns the largest index `i` such that `frq[i] >= i`, or `-1` if no such index exists.\n\n### Python version\n\nfrom typing import List\n\ndef search(lst: List[int]) -> int:\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "py",
    "prompt": "from typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([4, 2, 3]) == [2, 1]\n    assert candidate([1, 2, 3]) == [2, 1]\n    assert candidate([]) == []\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n    assert candidate([5, 4, 8, 4, 8]) == [4, 1]\n    assert candidate([7, 6, 7, 1]) == [6, 1]\n    assert candidate([7, 9, 7, 1]) == []\n\ndef test_check():\n    check(pluck)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function pluck(arr)\n    if(#arr == 0) then return {} end\n    local evens = {}\n    for _, v in ipairs(arr) do\n        if(v%2 == 0) then table.insert(evens, v) end\n    end\n    if(#evens == 0) then return {} end\n    local min_val = math.min(table.unpack(evens))\n    for i, v in ipairs(arr) do\n        if(v == min_val) then return {min_val, i-1} end\n    end\nend\n\n### Explanation\n\nThis program defines a function `pluck` which takes an array of integers as input and returns an array containing the minimum even integer in the input array and its index. If there are no even integers in the input array, the function returns an empty array. If there are even integers but none of them are minimum, the function returns an empty array. The function uses the `math` library to find the minimum value in the array and the `table` library to manipulate arrays.\n\n### Python version\n\nfrom typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "py",
    "prompt": "from typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\ndef test_check():\n    check(pairs_sum_to_zero)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function pairs_sum_to_zero(l)\n  for i, l1 in ipairs(l) do\n    for j = i + 1, #l do\n      if l1 + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis program defines a function `pairs_sum_to_zero` that takes a list `l` as input. The function iterates over all pairs of elements in `l` and returns `true` if it finds a pair that sums to zero. Otherwise, it returns `false`.\n\n### Python version\n\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "py",
    "prompt": "def make_palindrome(string: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n\ndef test_check():\n    check(make_palindrome)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function make_palindrome(string)\n    if not string then\n        return ''\n    end\n\n    local beginning_of_suffix = 0\n\n    while string:sub(beginning_of_suffix+1) ~= string:sub(beginning_of_suffix+1):reverse() do\n        beginning_of_suffix = beginning_of_suffix + 1\n    end\n\n    return string .. string:sub(1, beginning_of_suffix):reverse()\nend\n\n### Explanation\n\nThis program defines a function `make_palindrome` that takes a string as input and returns a palindrome. If the input string is nil, it returns an empty string. The function first initializes a variable `beginning_of_suffix` to 0. It then enters a loop that continues until the substring starting at `beginning_of_suffix+1` is equal to its reverse. In each iteration, `beginning_of_suffix` is incremented by 1. Finally, the function returns the input string concatenated with the substring of the input string from the beginning up to `beginning_of_suffix`, reversed.\n\n### Python version\n\ndef make_palindrome(string: str) -> str:\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "py",
    "prompt": "def starts_one_ends(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\ndef test_check():\n    check(starts_one_ends)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function starts_one_ends(n)\n  if n == 1 then return 1 end\n  return 18 * (10 ^ (n - 2))\nend\n\n### Explanation\n\nThis program defines a function `starts_one_ends` that takes a number `n` and returns a number. If `n` is equal to 1, it returns 1. Otherwise, it returns 18 times 10 to the power of `n - 2`.\n\n### Python version\n\ndef starts_one_ends(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "py",
    "prompt": "from typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\ndef test_check():\n    check(get_positive)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function get_positive(l)\n  local res = {}\n  for _, e in ipairs(l) do\n    if e > 0 then\n      table.insert(res, e)\n    end\n  end\n  return res\nend\n\n### Explanation\n\nThis program defines a function `get_positive` that takes a list of numbers as input and returns a new list containing only the positive numbers. The function first creates an empty list `res`, then iterates over each element of the input list `l`. If the element is greater than zero, it is added to the `res` list using the `table.insert` function. Finally, the `res` list is returned.\n\n### Python version\n\nfrom typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "py",
    "prompt": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n\ndef test_check():\n    check(concatenate)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function concatenate(strings)\n  return table.concat(strings)\nend\n\n### Explanation\n\nThis program imports the math library and defines a function called concatenate that takes a table of strings and returns a single string that is the concatenation of all the strings in the table.\n\n### Python version\n\nfrom typing import List\n\ndef concatenate(strings: List[str]) -> str:\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "py",
    "prompt": "def is_nested(string: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('[[]]') == True\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate('[]') == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n    assert candidate('') == False\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\ndef test_check():\n    check(is_nested)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function is_nested(string)\n    local opening_bracket_index = {}\n    local closing_bracket_index = {}\n    for i=1, #string do\n        if string:sub(i,i) == '[' then\n            table.insert(opening_bracket_index, i)\n        else\n            table.insert(closing_bracket_index, i)\n        end\n    end\n    table.sort(closing_bracket_index, function(a,b) return a>b end)\n    local cnt = 0\n    local i = 1\n    local l = #closing_bracket_index\n    for _, idx in ipairs(opening_bracket_index) do\n        if i <= l and idx < closing_bracket_index[i] then\n            cnt = cnt + 1\n            i = i + 1\n        end\n    end\n    return cnt >= 2\nend\n\n### Explanation\n\nThis Lua program defines a function `is_nested` that takes a string as input and returns a boolean indicating whether the string contains at least two nested square brackets. The function first creates two empty tables, `opening_bracket_index` and `closing_bracket_index`, which will be used to keep track of the indices of opening and closing square brackets in the input string. It then iterates over the string, adding the index of each opening bracket to `opening_bracket_index` and the index of each closing bracket to `closing_bracket_index`. The function then sorts `closing_bracket_index` in descending order, so that we can easily find the innermost closing bracket for each opening bracket. Finally, the function iterates over `opening_bracket_index` and checks whether there is a corresponding closing bracket that comes after it and is not already used by a previous opening bracket. If there are at least two such pairs of brackets, the function returns `true`, otherwise it returns `false`.\n\n### Python version\n\ndef is_nested(string: str) -> bool:\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "py",
    "prompt": "def is_palindrome(text: str) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\ndef test_check():\n    check(is_palindrome)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function is_palindrome(text)\n    for i=1, #text do\n        if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function called `is_palindrome` that takes a string as input and returns `true` if the string is a palindrome (i.e. reads the same forwards and backwards) and `false` otherwise. The function iterates over the string, comparing the first and last characters, then the second and second-to-last characters, and so on, until the middle of the string is reached. If any of these pairs of characters are not equal, the function returns `false`. If all pairs are equal, the function returns `true`. The program also imports the `math` library, but does not use it in this function.\n\n### Python version\n\ndef is_palindrome(text: str) -> bool:\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "py",
    "prompt": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(57) == [3, 19]\n    assert candidate(3249) == [3, 3, 19, 19]\n    assert candidate(185193) == [3, 3, 3, 19, 19, 19]\n    assert candidate(20577) == [3, 19, 19, 19]\n    assert candidate(18) == [2, 3, 3]\n\ndef test_check():\n    check(factorize)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function factorize(n)\n    local fact = {}\n    local i = 2\n    while i <= math.sqrt(n) + 1 do\n        if n % i == 0 then\n            table.insert(fact, i)\n            n = n / i\n        else\n            i = i + 1\n        end\n    end\n    if n > 1 then\n        table.insert(fact, n)\n    end\n    return fact\nend\n\n### Explanation\n\nThis program defines a function `factorize` that takes an integer `n` as input and returns a list of its prime factors. The function initializes an empty list `fact` and a counter `i` to 2. It then loops while `i` is less than or equal to the square root of `n` plus 1. If `n` is divisible by `i`, it appends `i` to `fact` and divides `n` by `i`. Otherwise, it increments `i` by 1. If `n` is greater than 1 after the loop, it appends `n` to `fact`. Finally, it returns `fact`.\n\n### Python version\n\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "py",
    "prompt": "def largest_prime_factor(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\ndef test_check():\n    check(largest_prime_factor)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function largest_prime_factor(n)\n  local function is_prime(k)\n    if k < 2 then\n      return false\n    end\n    for i = 2, k - 1 do\n      if k % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local largest = 1\n  for j = 2, n + 1 do\n    if n % j == 0 and is_prime(j) then\n      largest = math.max(largest, j)\n    end\n  end\n  return largest\nend\n\n### Explanation\n\nThis program defines a function `largest_prime_factor(n)` that takes an integer `n` as input and returns the largest prime factor of `n`. The function first defines a nested function `is_prime(k)` that returns `true` if `k` is prime and `false` otherwise. The function then initializes a variable `largest` to 1 and loops over all integers `j` from 2 to `n + 1`. For each `j`, the function checks if `n` is divisible by `j` and if `j` is prime. If both conditions are true, the function updates `largest` to be the maximum of `largest` and `j`. Finally, the function returns `largest`.\n\n### Python version\n\ndef largest_prime_factor(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "py",
    "prompt": "def get_max_triples(n: int) -> int:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n\ndef test_check():\n    check(get_max_triples)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function get_max_triples(n)\n  local A = {}\n  for i=1,n do\n    A[i] = i*i - i + 1\n  end\n  local ans = {}\n  for i=1,n do\n    for j=i+1,n do\n      for k=j+1,n do\n        if (A[i]+A[j]+A[k])%3 == 0 then\n          table.insert(ans, {A[i],A[j],A[k]})\n        end\n      end\n    end\n  end\n  return #ans\nend\n\n### Explanation\n\nThis Lua program defines a function called `get_max_triples` that takes an integer `n` as input. It then creates an array `A` of length `n`, where each element is the result of `i*i - i + 1` for `i` from 1 to `n`. It then creates an empty array `ans`. It then loops through all possible combinations of three elements of `A` and checks if their sum is divisible by 3. If so, it adds the triple to `ans`. Finally, it returns the length of `ans`.\n\n### Python version\n\ndef get_max_triples(n: int) -> int:\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "py",
    "prompt": "def anti_shuffle(s: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n\ndef test_check():\n    check(anti_shuffle)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function anti_shuffle(s)\n    local t = {}\n    for i in s:gmatch('%S+') do\n        local u = {}\n        for j = 1, #i do\n            u[j] = i:sub(j, j)\n        end\n        table.sort(u)\n        t[#t + 1] = table.concat(u)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThis program defines a function `anti_shuffle` that takes a string `s` as input. The function splits the string into words, sorts the letters in each word alphabetically, and then concatenates the words back together with spaces in between. The resulting string is returned.\n\n### Python version\n\ndef anti_shuffle(s: str) -> str:\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "py",
    "prompt": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\ndef test_check():\n    check(minPath)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function minPath(grid, k)\n    local n = #grid\n    local val = n * n + 1\n    for i = 1, n do\n        for j = 1, n do\n            if grid[i][j] == 1 then\n                local temp = {}\n                if i ~= 1 then\n                    table.insert(temp, grid[i-1][j])\n                end\n\n                if j ~= 1 then\n                    table.insert(temp, grid[i][j-1])\n                end\n\n                if i ~= n then\n                    table.insert(temp, grid[i+1][j])\n                end\n\n                if j ~= n then\n                    table.insert(temp, grid[i][j+1])\n                end\n\n                val = math.min(table.unpack(temp))\n            end\n        end\n    end\n\n    local ans = {}\n    for i = 1, k do\n        if i % 2 == 1 then\n            table.insert(ans, 1)\n        else\n            table.insert(ans, val)\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThis program takes a 2D grid of integers and an integer k as input. It then finds the minimum value of all the adjacent cells for each cell that has a value of 1. It then returns a list of length k, where the odd indices are 1 and the even indices are the minimum value found in the previous step.\n\n### Python version\n\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "py",
    "prompt": "def encrypt(s: str) -> str:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate('hi') == 'lm'\n    assert candidate('asdfghjkl') == 'ewhjklnop'\n    assert candidate('gf') == 'kj'\n    assert candidate('et') == 'ix'\n    assert candidate('faewfawefaewg') == 'jeiajeaijeiak'\n    assert candidate('hellomyfriend') == 'lippsqcjvmirh'\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') == 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n    assert candidate('a') == 'e'\n\ndef test_check():\n    check(encrypt)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function encrypt(s)\n    local d = 'abcdefghijklmnopqrstuvwxyz'\n    local out = ''\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if d:find(c) then\n            out = out .. d:sub((d:find(c) + 2*2 - 1) % 26 + 1, (d:find(c) + 2*2 - 1) % 26 + 1)\n        else\n            out = out .. c\n        end\n    end\n    return out\nend\n\n### Explanation\n\nThis Lua program defines a function `encrypt` that takes a string `s` as input and returns an encrypted version of the string. The encryption works by shifting each letter in the string two positions to the right in the alphabet, wrapping around from 'z' to 'a' if necessary. Non-letter characters are left unchanged. The function uses the `math` library to perform arithmetic operations. To rewrite this program in Python, you would need to replace the `local` keyword with `def`, remove the `math` library import, and use Python's built-in string methods instead of Lua's `string` library. Here's an example Python implementation:\n\n### Python version\n\ndef encrypt(s: str) -> str:\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "py",
    "prompt": "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(3) == [3, 5, 7]\n    assert candidate(4) == [4, 6, 8, 10]\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\ndef test_check():\n    check(make_a_pile)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function make_a_pile(n)\n  local pile = {}\n  for i = 0, n-1 do\n    pile[i+1] = n + 2*i\n  end\n  return pile\nend\n\n### Explanation\n\nThis program defines a function `make_a_pile` that takes an integer `n` as input and returns a list of integers. The list contains `n` elements, where the `i`-th element is equal to `n + 2*i`. The function uses the `math` library to perform arithmetic operations.\n\n### Python version\n\nfrom typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "py",
    "prompt": "def is_prime(n: int) -> bool:\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(85) == False\n    assert candidate(77) == False\n    assert candidate(255379) == False\n\ndef test_check():\n    check(is_prime)\n\ntest_check()\n",
    "stop_tokens": [
      "\ndef",
      "\n#",
      "\nif",
      "\nclass"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Python?\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis program defines a function `even_odd_palindrome` which takes a number `n` as input. The function then defines another function `is_palindrome` which checks if a number is a palindrome. The function then initializes two variables `even_palindrome_count` and `odd_palindrome_count` to zero. It then loops from 1 to `n` and checks if the current number is a palindrome and if it is even or odd. If the number is odd and a palindrome, it increments `odd_palindrome_count` by 1. If the number is even and a palindrome, it increments `even_palindrome_count` by 1. Finally, the function returns a table with the two counts.\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_sorted` that takes an array of numbers and returns `true` if the array is sorted in non-descending order and each number appears at most twice in the array. Otherwise, it returns `false`. The function first counts the number of occurrences of each digit in the array using a table `count_digit`. It then checks that each digit appears at most twice in the array and that the array is sorted in non-descending order. If either of these conditions is not met, the function returns `false`. Otherwise, it returns `true`.\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis Lua program defines a function called `separate_paren_groups` that takes a string of parentheses and returns a table of strings that represent groups of parentheses separated by the outermost parentheses. For example, if the input string is `\"((a)(b))((c)(d))\"`, the output table would be `{\"((a)(b))\", \"((c)(d))\"}`. The function works by iterating over each character in the input string and keeping track of the current depth of parentheses. Whenever a closing parenthesis is encountered that brings the depth back to zero, the current string is added to the result table and a new current string is started.\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis program defines a function called `sort_array` that takes an array as input. If the array is empty, it returns an empty array. If the sum of the first and last element of the array is even, it sorts the array in descending order. Otherwise, it sorts the array in ascending order. The sorted array is then returned.\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    if len(array) == 0:\n        return []\n    else:\n        if (array[0] + array[-1]) % 2 == 0:\n            array = sorted(array, reverse=True)\n        else:\n            array = sorted(array)\n        return array\n\n### Lua version\n\nmath = require('math')\nlocal function is_prime(n)\n    if n < 2 then\n        return false\n    end\n    for k=2, n-1 do\n        if n % k == 0 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis program defines a function `is_prime` which takes an integer `n` as input and returns `true` if `n` is prime, and `false` otherwise. The function first checks if `n` is less than 2, in which case it returns `false`. Otherwise, it checks if `n` is divisible by any integer between 2 and `n-1`, inclusive. If `n` is divisible by any such integer, the function returns `false`. Otherwise, the function returns `true`. The program uses the `math` library to perform arithmetic operations.\n\n### Python version\n\ndef is_prime(n: int) -> bool:\n"
  }
]