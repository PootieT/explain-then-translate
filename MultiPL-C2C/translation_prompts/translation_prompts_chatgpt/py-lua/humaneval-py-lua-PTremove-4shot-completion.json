[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function correct_bracketing(brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = correct_bracketing\n    lu.assertEquals(candidate('()'), true)\n    lu.assertEquals(candidate('(()())'), true)\n    lu.assertEquals(candidate('()()(()())()'), true)\n    lu.assertEquals(candidate('()()((()()())())(()()(()))'), true)\n    lu.assertEquals(candidate('((()())))'), false)\n    lu.assertEquals(candidate(')(()'), false)\n    lu.assertEquals(candidate('('), false)\n    lu.assertEquals(candidate('(((('), false)\n    lu.assertEquals(candidate(')'), false)\n    lu.assertEquals(candidate('(()'), false)\n    lu.assertEquals(candidate('()()(()())())(()'), false)\n    lu.assertEquals(candidate('()()(()())()))()'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function triangle_area(a, h)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triangle_area\n    lu.assertEquals(candidate(5, 3), 7.5)\n    lu.assertEquals(candidate(2, 2), 2.0)\n    lu.assertEquals(candidate(10, 8), 40.0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef triangle_area(a: int, h: int) -> float:\n    return a * h / 2.0\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, h)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function special_factorial(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = special_factorial\n    lu.assertEquals(candidate(4), 288)\n    lu.assertEquals(candidate(5), 34560)\n    lu.assertEquals(candidate(7), 125411328000)\n    lu.assertEquals(candidate(1), 1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef special_factorial(n: int) -> int:\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n### Lua version\n\nmath = require('math')\nlocal function special_factorial(n)\n"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function largest_smallest_integers(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_136_largest_smallest_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7, 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}), {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}), {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n    lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\ndef largest_smallest_integers(lst: List[int]) -> Tuple[Optional[int], Optional[int]]:\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n\n### Lua version\n\nmath = require('math')\nlocal function largest_smallest_integers(lst)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function move_one_ball(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = move_one_ball\n    lu.assertEquals(candidate({3, 4, 5, 1, 2}), true)\n    lu.assertEquals(candidate({3, 5, 10, 1, 2}), true)\n    lu.assertEquals(candidate({4, 3, 1, 2}), false)\n    lu.assertEquals(candidate({3, 5, 4, 1, 2}), false)\n    lu.assertEquals(candidate({}), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef move_one_ball(arr: List[int]) -> bool:\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function move_one_ball(arr)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function digits(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = digits\n    lu.assertEquals(candidate(5), 5)\n    lu.assertEquals(candidate(54), 5)\n    lu.assertEquals(candidate(120), 1)\n    lu.assertEquals(candidate(5014), 5)\n    lu.assertEquals(candidate(98765), 315)\n    lu.assertEquals(candidate(5576543), 2625)\n    lu.assertEquals(candidate(2468), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef digits(n: int) -> int:\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n\n### Lua version\n\nmath = require('math')\nlocal function digits(n)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function fib4(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib4\n    lu.assertEquals(candidate(5), 4)\n    lu.assertEquals(candidate(8), 28)\n    lu.assertEquals(candidate(10), 104)\n    lu.assertEquals(candidate(12), 386)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef fib4(n: int) -> int:\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n\n### Lua version\n\nmath = require('math')\nlocal function fib4(n)\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sort_even(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_even\n    lu.assertEquals(candidate({1, 2, 3}), {1, 2, 3})\n    lu.assertEquals(candidate({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123})\n    lu.assertEquals(candidate({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_even(l: List[int]) -> List[int]:\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n\n### Lua version\n\nmath = require('math')\nlocal function sort_even(l)\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function order_by_points(nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = order_by_points\n    lu.assertEquals(candidate({1, 11, -1, -11, -12}), {-1, -11, 1, -12, 11})\n    lu.assertEquals(candidate({1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -11, -32, 43, 54, -98, 2, -3}), {-3, -32, -98, -11, 1, 2, 43, 54})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9})\n    lu.assertEquals(candidate({0, 6, 6, -76, -21, 23, 4}), {-76, -21, 0, 4, 23, 6, 6})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n\n### Lua version\n\nmath = require('math')\nlocal function order_by_points(nums)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_happy(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_happy\n    lu.assertEquals(candidate('a'), false)\n    lu.assertEquals(candidate('aa'), false)\n    lu.assertEquals(candidate('abcd'), true)\n    lu.assertEquals(candidate('aabb'), false)\n    lu.assertEquals(candidate('adb'), true)\n    lu.assertEquals(candidate('xyy'), false)\n    lu.assertEquals(candidate('iopaxpoi'), true)\n    lu.assertEquals(candidate('iopaxioi'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_happy(s: str) -> bool:\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function is_happy(s)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function circular_shift(x, shift)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = circular_shift\n    lu.assertEquals(candidate(100, 2), '001')\n    lu.assertEquals(candidate(12, 2), '12')\n    lu.assertEquals(candidate(97, 8), '79')\n    lu.assertEquals(candidate(12, 1), '21')\n    lu.assertEquals(candidate(11, 101), '11')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef circular_shift(x: int, shift: int) -> str:\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n\n### Lua version\n\nmath = require('math')\nlocal function circular_shift(x, shift)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function max_fill(grid, capacity)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}}, 5), 0)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nimport math\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n\n### Lua version\n\nmath = require('math')\nlocal function max_fill(grid, capacity)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function has_close_elements(numbers, threshold)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = has_close_elements\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), true)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), false)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function has_close_elements(numbers, threshold)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function numerical_letter_grade(grades)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = numerical_letter_grade\n    lu.assertEquals(candidate({4.0, 3, 1.7, 2, 3.5}), {'A+', 'B', 'C-', 'C', 'A-'})\n    lu.assertEquals(candidate({1.2}), {'D+'})\n    lu.assertEquals(candidate({0.5}), {'D-'})\n    lu.assertEquals(candidate({0.0}), {'E'})\n    lu.assertEquals(candidate({1.0, 0.3, 1.5, 2.8, 3.3}), {'D', 'D-', 'C-', 'B', 'B+'})\n    lu.assertEquals(candidate({0.0, 0.7}), {'E', 'D-'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n\n### Lua version\n\nmath = require('math')\nlocal function numerical_letter_grade(grades)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function x_or_y(n, x, y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = x_or_y\n    lu.assertEquals(candidate(7, 34, 12), 34)\n    lu.assertEquals(candidate(15, 8, 5), 5)\n    lu.assertEquals(candidate(3, 33, 5212), 33)\n    lu.assertEquals(candidate(1259, 3, 52), 3)\n    lu.assertEquals(candidate(7919, -1, 12), -1)\n    lu.assertEquals(candidate(3609, 1245, 583), 583)\n    lu.assertEquals(candidate(91, 56, 129), 129)\n    lu.assertEquals(candidate(6, 34, 1234), 1234)\n    lu.assertEquals(candidate(1, 2, 0), 0)\n    lu.assertEquals(candidate(2, 2, 0), 2)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef x_or_y(n: int, x: int, y: int) -> int:\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n\n### Lua version\n\nmath = require('math')\nlocal function x_or_y(n, x, y)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function specialFilter(nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = specialFilter\n    lu.assertEquals(candidate({5, -2, 1, -5}), 0)\n    lu.assertEquals(candidate({15, -73, 14, -15}), 1)\n    lu.assertEquals(candidate({33, -2, -3, 45, 21, 109}), 2)\n    lu.assertEquals(candidate({43, -12, 93, 125, 121, 109}), 4)\n    lu.assertEquals(candidate({71, -2, -33, 75, 21, 19}), 3)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({}), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count\n\n### Lua version\n\nmath = require('math')\nlocal function specialFilter(nums)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function parse_music(music_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_music\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('o o o o'), {4, 4, 4, 4})\n    lu.assertEquals(candidate('.| .| .| .|'), {1, 1, 1, 1})\n    lu.assertEquals(candidate('o| o| .| .| o o o o'), {2, 2, 1, 1, 4, 4, 4, 4})\n    lu.assertEquals(candidate('o| .| o| .| o o| o o|'), {2, 1, 2, 1, 4, 2, 4, 2})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n\n### Lua version\n\nmath = require('math')\nlocal function parse_music(music_string)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function split_words(txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = split_words\n    lu.assertEquals(candidate('Hello world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello,world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello world,!'), {'Hello', 'world,!'})\n    lu.assertEquals(candidate('Hello,Hello,world !'), {'Hello,Hello,world', '!'})\n    lu.assertEquals(candidate('abcdef'), 3)\n    lu.assertEquals(candidate('aaabb'), 2)\n    lu.assertEquals(candidate('aaaBb'), 1)\n    lu.assertEquals(candidate(''), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\nfrom typing import Union\n\ndef split_words(txt: str) -> Union[List[str], int]:\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n\n### Lua version\n\nmath = require('math')\nlocal function split_words(txt)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function count_distinct_characters(string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_distinct_characters\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('abcde'), 5)\n    lu.assertEquals(candidate('abcdecadeCADE'), 5)\n    lu.assertEquals(candidate('aaaaAAAAaaaa'), 1)\n    lu.assertEquals(candidate('Jerry jERRY JeRRRY'), 5)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n\n### Lua version\n\nmath = require('math')\nlocal function count_distinct_characters(string)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function bf(planet1, planet2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter', 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Tuple\n\ndef bf(planet1: str, planet2: str) -> Tuple[str, ...]:\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n\n### Lua version\n\nmath = require('math')\nlocal function bf(planet1, planet2)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function digitSum(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = digitSum\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('abAB'), 131)\n    lu.assertEquals(candidate('abcCd'), 67)\n    lu.assertEquals(candidate('helloE'), 69)\n    lu.assertEquals(candidate('woArBld'), 131)\n    lu.assertEquals(candidate('aAaaaXa'), 153)\n    lu.assertEquals(candidate(' How are yOu?'), 151)\n    lu.assertEquals(candidate('You arE Very Smart'), 327)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef digitSum(s: str) -> int:\n    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n\n### Lua version\n\nmath = require('math')\nlocal function digitSum(s)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sum_squares(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n    lu.assertEquals(candidate({1, 2, 3}), 6)\n    lu.assertEquals(candidate({1, 4, 9}), 14)\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 1, 1, 1, 1, 1, 1}), 9)\n    lu.assertEquals(candidate({-1, -1, -1, -1, -1, -1, -1, -1, -1}), -3)\n    lu.assertEquals(candidate({0}), 0)\n    lu.assertEquals(candidate({-1, -5, 2, -1, -5}), -126)\n    lu.assertEquals(candidate({-56, -99, 1, 0, -2}), 3030)\n    lu.assertEquals(candidate({-1, 0, 0, 0, 0, 0, 0, 0, -1}), 0)\n    lu.assertEquals(candidate({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), -14196)\n    lu.assertEquals(candidate({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), -1448)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[int]) -> int:\n    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function count_up_to(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_up_to\n    lu.assertEquals(candidate(5), {2, 3})\n    lu.assertEquals(candidate(6), {2, 3, 5})\n    lu.assertEquals(candidate(7), {2, 3, 5})\n    lu.assertEquals(candidate(10), {2, 3, 5, 7})\n    lu.assertEquals(candidate(0), {})\n    lu.assertEquals(candidate(22), {2, 3, 5, 7, 11, 13, 17, 19})\n    lu.assertEquals(candidate(1), {})\n    lu.assertEquals(candidate(18), {2, 3, 5, 7, 11, 13, 17})\n    lu.assertEquals(candidate(47), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})\n    lu.assertEquals(candidate(101), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef count_up_to(n: int) -> List[int]:\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n### Lua version\n\nmath = require('math')\nlocal function count_up_to(n)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sum_squares(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_squares\n    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0}), 14)\n    lu.assertEquals(candidate({1.0, 3.0, 5.0, 7.0}), 84)\n    lu.assertEquals(candidate({1.4, 4.2, 0.0}), 29)\n    lu.assertEquals(candidate({-2.4, 1.0, 1.0}), 6)\n    lu.assertEquals(candidate({100.0, 1.0, 15.0, 2.0}), 10230)\n    lu.assertEquals(candidate({10000.0, 10000.0}), 200000000)\n    lu.assertEquals(candidate({-1.4, 4.6, 6.3}), 75)\n    lu.assertEquals(candidate({-1.4, 17.9, 18.9, 19.9}), 1086)\n    lu.assertEquals(candidate({0.0}), 0)\n    lu.assertEquals(candidate({-1.0}), 1)\n    lu.assertEquals(candidate({-1.0, 1.0, 0.0}), 2)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function unique(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = unique\n    lu.assertEquals(candidate({5, 3, 5, 2, 3, 3, 9, 0, 123}), {0, 2, 3, 5, 9, 123})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    return sorted(list(set(l)))\n\n### Lua version\n\nmath = require('math')\nlocal function unique(l)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function fib(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fib\n    lu.assertEquals(candidate(10), 55)\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(8), 21)\n    lu.assertEquals(candidate(11), 89)\n    lu.assertEquals(candidate(12), 144)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef fib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n### Lua version\n\nmath = require('math')\nlocal function fib(n)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function fizz_buzz(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fizz_buzz\n    lu.assertEquals(candidate(50), 0)\n    lu.assertEquals(candidate(78), 2)\n    lu.assertEquals(candidate(79), 3)\n    lu.assertEquals(candidate(100), 3)\n    lu.assertEquals(candidate(200), 6)\n    lu.assertEquals(candidate(4000), 192)\n    lu.assertEquals(candidate(10000), 639)\n    lu.assertEquals(candidate(100000), 8026)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef fizz_buzz(n: int) -> int:\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n\n### Lua version\n\nmath = require('math')\nlocal function fizz_buzz(n)\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function Strongest_Extension(class_name, extensions)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = Strongest_Extension\n    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')\n    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}), 'Boku123.YEs.WeCaNe')\n    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')\n    lu.assertEquals(candidate('K', {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')\n    lu.assertEquals(candidate('__HAHA', {'Tab', '123', '781345', '-_-'}), '__HAHA.123')\n    lu.assertEquals(candidate('YameRore', {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')\n    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')\n    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')\n    lu.assertEquals(candidate('Sp', {'671235', 'Bb'}), 'Sp.671235')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n### Lua version\n\nmath = require('math')\nlocal function Strongest_Extension(class_name, extensions)\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function find_closest_elements(numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n    lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n\n### Lua version\n\nmath = require('math')\nlocal function find_closest_elements(numbers)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function valid_date(date)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = valid_date\n    lu.assertEquals(candidate('03-11-2000'), true)\n    lu.assertEquals(candidate('15-01-2012'), false)\n    lu.assertEquals(candidate('04-0-2040'), false)\n    lu.assertEquals(candidate('06-04-2020'), true)\n    lu.assertEquals(candidate('01-01-2007'), true)\n    lu.assertEquals(candidate('03-32-2011'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('04-31-3000'), false)\n    lu.assertEquals(candidate('06-06-2005'), true)\n    lu.assertEquals(candidate('21-31-2000'), false)\n    lu.assertEquals(candidate('04-12-2003'), true)\n    lu.assertEquals(candidate('04122003'), false)\n    lu.assertEquals(candidate('20030412'), false)\n    lu.assertEquals(candidate('2003-04'), false)\n    lu.assertEquals(candidate('2003-04-12'), false)\n    lu.assertEquals(candidate('04-2003'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef valid_date(date: str) -> bool:\n    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function valid_date(date)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function add(x, y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add\n    lu.assertEquals(candidate(0, 1), 1)\n    lu.assertEquals(candidate(1, 0), 1)\n    lu.assertEquals(candidate(2, 3), 5)\n    lu.assertEquals(candidate(5, 7), 12)\n    lu.assertEquals(candidate(7, 5), 12)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef add(x: int, y: int) -> int:\n    return x + y\n\n### Lua version\n\nmath = require('math')\nlocal function add(x, y)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function triples_sum_to_zero(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triples_sum_to_zero\n    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1, 3, 5, -1}), false)\n    lu.assertEquals(candidate({1, 3, -2, 1}), true)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({1, 2, 5, 7}), false)\n    lu.assertEquals(candidate({2, 4, -5, 3, 9, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({1, 3, 5, -100}), false)\n    lu.assertEquals(candidate({100, 3, 5, -100}), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function triples_sum_to_zero(l)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function largest_divisor(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_divisor\n    lu.assertEquals(candidate(3), 1)\n    lu.assertEquals(candidate(7), 1)\n    lu.assertEquals(candidate(10), 5)\n    lu.assertEquals(candidate(100), 50)\n    lu.assertEquals(candidate(49), 7)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef largest_divisor(n: int) -> int:\n    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n\n### Lua version\n\nmath = require('math')\nlocal function largest_divisor(n)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sort_numbers(numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_numbers\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('three'), 'three')\n    lu.assertEquals(candidate('three five nine'), 'three five nine')\n    lu.assertEquals(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')\n    lu.assertEquals(candidate('six five four three two one zero'), 'zero one two three four five six')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n\n### Lua version\n\nmath = require('math')\nlocal function sort_numbers(numbers)\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function smallest_change(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = smallest_change\n    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)\n    lu.assertEquals(candidate({1, 2, 3, 4, 3, 2, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)\n    lu.assertEquals(candidate({3, 1, 1, 3}), 0)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({0, 1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef smallest_change(arr: List[int]) -> int:\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n\n### Lua version\n\nmath = require('math')\nlocal function smallest_change(arr)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function below_threshold(l, t)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = below_threshold\n    lu.assertEquals(candidate({1, 2, 4, 10}, 100), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 5), false)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 21), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}, 22), true)\n    lu.assertEquals(candidate({1, 8, 4, 10}, 11), true)\n    lu.assertEquals(candidate({1, 8, 4, 10}, 10), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef below_threshold(l: List[int], t: int) -> bool:\n    for e in l:\n        if e >= t:\n            return False\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function below_threshold(l, t)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function prod_signs(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prod_signs\n    lu.assertEquals(candidate({1, 2, 2, -4}), -9)\n    lu.assertEquals(candidate({0, 1}), 0)\n    lu.assertEquals(candidate({1, 1, 1, 2, 3, -1, 1}), -10)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({2, 4, 1, 2, -1, -1, 9}), 20)\n    lu.assertEquals(candidate({-1, 1, -1, 1}), 4)\n    lu.assertEquals(candidate({-1, 1, 1, 1}), -4)\n    lu.assertEquals(candidate({-1, 1, 1, 0}), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef prod_signs(arr: List[int]) -> Optional[int]:\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n\n### Lua version\n\nmath = require('math')\nlocal function prod_signs(arr)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function modp(n, p)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef modp(n: int, p: int) -> int:\n    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n\n### Lua version\n\nmath = require('math')\nlocal function modp(n, p)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function count_upper(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_upper\n    lu.assertEquals(candidate('aBCdEf'), 1)\n    lu.assertEquals(candidate('abcdefg'), 0)\n    lu.assertEquals(candidate('dBBE'), 0)\n    lu.assertEquals(candidate('B'), 0)\n    lu.assertEquals(candidate('U'), 1)\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('EEEE'), 2)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef count_upper(s: str) -> int:\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n\n### Lua version\n\nmath = require('math')\nlocal function count_upper(s)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function multiply(a, b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = multiply\n    lu.assertEquals(candidate(148, 412), 16)\n    lu.assertEquals(candidate(19, 28), 72)\n    lu.assertEquals(candidate(2020, 1851), 0)\n    lu.assertEquals(candidate(14, -15), 20)\n    lu.assertEquals(candidate(76, 67), 42)\n    lu.assertEquals(candidate(17, 27), 49)\n    lu.assertEquals(candidate(0, 1), 0)\n    lu.assertEquals(candidate(0, 0), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef multiply(a: int, b: int) -> int:\n    return abs(a % 10) * abs(b % 10)\n\n### Lua version\n\nmath = require('math')\nlocal function multiply(a, b)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function unique_digits(x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = unique_digits\n    lu.assertEquals(candidate({15, 33, 1422, 1}), {1, 15, 33})\n    lu.assertEquals(candidate({152, 323, 1422, 10}), {})\n    lu.assertEquals(candidate({12345, 2033, 111, 151}), {111, 151})\n    lu.assertEquals(candidate({135, 103, 31}), {31, 135})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n\n### Lua version\n\nmath = require('math')\nlocal function unique_digits(x)\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function will_it_fly(q, w)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = will_it_fly\n    lu.assertEquals(candidate({3, 2, 3}, 9), true)\n    lu.assertEquals(candidate({1, 2}, 5), false)\n    lu.assertEquals(candidate({3}, 5), true)\n    lu.assertEquals(candidate({3, 2, 3}, 1), false)\n    lu.assertEquals(candidate({1, 2, 3}, 6), false)\n    lu.assertEquals(candidate({5}, 5), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef will_it_fly(q: List[int], w: int) -> bool:\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function will_it_fly(q, w)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_multiply_prime(a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_multiply_prime\n    lu.assertEquals(candidate(5), false)\n    lu.assertEquals(candidate(30), true)\n    lu.assertEquals(candidate(8), true)\n    lu.assertEquals(candidate(10), false)\n    lu.assertEquals(candidate(125), true)\n    lu.assertEquals(candidate(105), true)\n    lu.assertEquals(candidate(126), false)\n    lu.assertEquals(candidate(729), false)\n    lu.assertEquals(candidate(891), false)\n    lu.assertEquals(candidate(1001), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef is_multiply_prime(a: int) -> bool:\n    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_multiply_prime(a)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function maximum(arr, k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4, -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1), {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n    lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4, -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n    lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n\n### Lua version\n\nmath = require('math')\nlocal function maximum(arr, k)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function filter_integers(values)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_integers\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({4, {}, {}, 23.2, 9, 'adasd'}), {4, 9})\n    lu.assertEquals(candidate({3, 'c', 3, 3, 'a', 'b'}), {3, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]\n\n### Lua version\n\nmath = require('math')\nlocal function filter_integers(values)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function skjkasdkd(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = skjkasdkd\n    lu.assertEquals(candidate({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), 10)\n    lu.assertEquals(candidate({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), 25)\n    lu.assertEquals(candidate({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), 13)\n    lu.assertEquals(candidate({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), 11)\n    lu.assertEquals(candidate({0, 81, 12, 3, 1, 21}), 3)\n    lu.assertEquals(candidate({0, 8, 1, 2, 1, 7}), 7)\n    lu.assertEquals(candidate({8191}), 19)\n    lu.assertEquals(candidate({8191, 123456, 127, 7}), 19)\n    lu.assertEquals(candidate({127, 97, 8192}), 10)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function skjkasdkd(lst)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function total_match(lst1, lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = total_match\n    lu.assertEquals(candidate({}, {}), {})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hi', 'hi'}), {'hi', 'hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'}), {'hi', 'admin'})\n    lu.assertEquals(candidate({'4'}, {'1', '2', '3', '4', '5'}), {'4'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'Hi'}), {'hI', 'Hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'hi', 'hi'}), {'hI', 'hi', 'hi'})\n    lu.assertEquals(candidate({'hi', 'admin'}, {'hI', 'hi', 'hii'}), {'hi', 'admin'})\n    lu.assertEquals(candidate({}, {'this'}), {})\n    lu.assertEquals(candidate({'this'}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n\n### Lua version\n\nmath = require('math')\nlocal function total_match(lst1, lst2)\n"
  },
  {
    "name": "HumanEval_162_string_to_md5",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function string_to_md5(text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_162_string_to_md5.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_to_md5\n    lu.assertEquals(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')\n    lu.assertEquals(candidate(''), None)\n    lu.assertEquals(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')\n    lu.assertEquals(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Optional\n\ndef string_to_md5(text: str) -> Optional[str]:\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n\n### Lua version\n\nmath = require('math')\nlocal function string_to_md5(text)\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function car_race_collision(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = car_race_collision\n    lu.assertEquals(candidate(2), 4)\n    lu.assertEquals(candidate(3), 9)\n    lu.assertEquals(candidate(4), 16)\n    lu.assertEquals(candidate(8), 64)\n    lu.assertEquals(candidate(10), 100)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef car_race_collision(n: int) -> int:\n    return n**2\n\n### Lua version\n\nmath = require('math')\nlocal function car_race_collision(n)\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_simple_power(x, n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_simple_power\n    lu.assertEquals(candidate(16, 2), true)\n    lu.assertEquals(candidate(143214, 16), false)\n    lu.assertEquals(candidate(4, 2), true)\n    lu.assertEquals(candidate(9, 3), true)\n    lu.assertEquals(candidate(16, 4), true)\n    lu.assertEquals(candidate(24, 2), false)\n    lu.assertEquals(candidate(128, 4), false)\n    lu.assertEquals(candidate(12, 6), false)\n    lu.assertEquals(candidate(1, 1), true)\n    lu.assertEquals(candidate(1, 12), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef is_simple_power(x: int, n: int) -> bool:\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x)\n\n### Lua version\n\nmath = require('math')\nlocal function is_simple_power(x, n)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function encode(message)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'), 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef encode(message: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n\n### Lua version\n\nmath = require('math')\nlocal function encode(message)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function incr_list(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = incr_list\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({3, 2, 1}), {4, 3, 2})\n    lu.assertEquals(candidate({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef incr_list(l: List[int]) -> List[int]:\n    return [(e + 1) for e in l]\n\n### Lua version\n\nmath = require('math')\nlocal function incr_list(l)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function flip_case(string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = flip_case\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hello!'), 'hELLO!')\n    lu.assertEquals(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef flip_case(string: str) -> str:\n    return string.swapcase()\n\n### Lua version\n\nmath = require('math')\nlocal function flip_case(string)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function vowels_count(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = vowels_count\n    lu.assertEquals(candidate('abcde'), 2)\n    lu.assertEquals(candidate('Alone'), 3)\n    lu.assertEquals(candidate('key'), 2)\n    lu.assertEquals(candidate('bye'), 1)\n    lu.assertEquals(candidate('keY'), 2)\n    lu.assertEquals(candidate('bYe'), 1)\n    lu.assertEquals(candidate('ACEDY'), 3)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef vowels_count(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n\n### Lua version\n\nmath = require('math')\nlocal function vowels_count(s)\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sorted_list_sum(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sorted_list_sum\n    lu.assertEquals(candidate({'aa', 'a', 'aaa'}), {'aa'})\n    lu.assertEquals(candidate({'school', 'AI', 'asdf', 'b'}), {'AI', 'asdf', 'school'})\n    lu.assertEquals(candidate({'d', 'b', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'d', 'dcba', 'abcd', 'a'}), {'abcd', 'dcba'})\n    lu.assertEquals(candidate({'AI', 'ai', 'au'}), {'AI', 'ai', 'au'})\n    lu.assertEquals(candidate({'a', 'b', 'b', 'c', 'c', 'a'}), {})\n    lu.assertEquals(candidate({'aaaa', 'bbbb', 'dd', 'cc'}), {'cc', 'dd', 'aaaa', 'bbbb'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef sorted_list_sum(lst: List[str]) -> List[str]:\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n\n### Lua version\n\nmath = require('math')\nlocal function sorted_list_sum(lst)\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function words_string(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = words_string\n    lu.assertEquals(candidate('Hi, my name is John'), {'Hi', 'my', 'name', 'is', 'John'})\n    lu.assertEquals(candidate('One, two, three, four, five, six'), {'One', 'two', 'three', 'four', 'five', 'six'})\n    lu.assertEquals(candidate('Hi, my name'), {'Hi', 'my', 'name'})\n    lu.assertEquals(candidate('One,, two, three, four, five, six,'), {'One', 'two', 'three', 'four', 'five', 'six'})\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('ahmed     , gamal'), {'ahmed', 'gamal'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef words_string(s: str) -> List[str]:\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n\n### Lua version\n\nmath = require('math')\nlocal function words_string(s)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function triangle_area(a, b, c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = triangle_area\n    lu.assertEquals(candidate(3, 4, 5), 6.0)\n    lu.assertEquals(candidate(1, 2, 10), -1)\n    lu.assertEquals(candidate(4, 8, 5), 8.18)\n    lu.assertEquals(candidate(2, 2, 2), 1.73)\n    lu.assertEquals(candidate(1, 2, 3), -1)\n    lu.assertEquals(candidate(10, 5, 7), 16.25)\n    lu.assertEquals(candidate(2, 6, 3), -1)\n    lu.assertEquals(candidate(1, 1, 1), 0.43)\n    lu.assertEquals(candidate(2, 2, 10), -1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef triangle_area(a: int, b: int, c: int) -> float:\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, b, c)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function check_dict_case(dict)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_dict_case\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['b'] = 'banana'}), true)\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['A'] = 'banana', ['B'] = 'banana'}), false)\n    lu.assertEquals(candidate({['p'] = 'pineapple', ['5'] = 'banana', ['a'] = 'apple'}), false)\n    lu.assertEquals(candidate({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'}), false)\n    lu.assertEquals(candidate({['STATE'] = 'NC', ['ZIP'] = '12345'}), true)\n    lu.assertEquals(candidate({['fruit'] = 'Orange', ['taste'] = 'Sweet'}), true)\n    lu.assertEquals(candidate({}), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Dict\n\ndef check_dict_case(dict: Dict[str, str]) -> bool:\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                continue\n        return state == \"upper\" or state == \"lower\"\n\n### Lua version\n\nmath = require('math')\nlocal function check_dict_case(dict)\n"
  },
  {
    "name": "HumanEval_130_tri",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function tri(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_130_tri.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = tri\n    lu.assertEquals(candidate(3), {1, 3, 2, 8})\n    lu.assertEquals(candidate(4), {1, 3, 2, 8, 3})\n    lu.assertEquals(candidate(5), {1, 3, 2, 8, 3, 15})\n    lu.assertEquals(candidate(6), {1, 3, 2, 8, 3, 15, 4})\n    lu.assertEquals(candidate(7), {1, 3, 2, 8, 3, 15, 4, 24})\n    lu.assertEquals(candidate(8), {1, 3, 2, 8, 3, 15, 4, 24, 5})\n    lu.assertEquals(candidate(9), {1, 3, 2, 8, 3, 15, 4, 24, 5, 35})\n    lu.assertEquals(candidate(20), {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11})\n    lu.assertEquals(candidate(0), {1})\n    lu.assertEquals(candidate(1), {1, 3})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef tri(n: int) -> List[int]:\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n\n### Lua version\n\nmath = require('math')\nlocal function tri(n)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function median(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10, 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6, 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef median(l: List[int]) -> float:\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n\n### Lua version\n\nmath = require('math')\nlocal function median(l)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function change_base(x, base)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = change_base\n    lu.assertEquals(candidate(8, 3), '22')\n    lu.assertEquals(candidate(9, 3), '100')\n    lu.assertEquals(candidate(234, 2), '11101010')\n    lu.assertEquals(candidate(16, 2), '10000')\n    lu.assertEquals(candidate(8, 2), '1000')\n    lu.assertEquals(candidate(7, 2), '111')\n    lu.assertEquals(candidate(2, 3), '2')\n    lu.assertEquals(candidate(3, 4), '3')\n    lu.assertEquals(candidate(4, 5), '4')\n    lu.assertEquals(candidate(5, 6), '5')\n    lu.assertEquals(candidate(6, 7), '6')\n    lu.assertEquals(candidate(7, 8), '7')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef change_base(x: int, base: int) -> str:\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\n### Lua version\n\nmath = require('math')\nlocal function change_base(x, base)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function longest(strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = longest\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({'x', 'y', 'z'}), 'x')\n    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc'}), 'zzzz')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n### Lua version\n\nmath = require('math')\nlocal function longest(strings)\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sort_array(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n    lu.assertEquals(candidate({1, 5, 2, 3, 4}), {1, 2, 4, 3, 5})\n    lu.assertEquals(candidate({-2, -3, -4, -5, -6}), {-4, -2, -6, -5, -3})\n    lu.assertEquals(candidate({1, 0, 2, 3, 4}), {0, 1, 2, 4, 3})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77})\n    lu.assertEquals(candidate({3, 6, 44, 12, 32, 5}), {32, 3, 5, 6, 12, 44})\n    lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})\n    lu.assertEquals(candidate({2, 4, 8, 16, 32}), {2, 4, 8, 16, 32})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(arr)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function common(l1, l2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = common\n    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}), {1, 5, 653})\n    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})\n    lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 8}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n\n### Lua version\n\nmath = require('math')\nlocal function common(l1, l2)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function cycpattern_check(a, b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = cycpattern_check\n    lu.assertEquals(candidate('xyzw', 'xyw'), false)\n    lu.assertEquals(candidate('yello', 'ell'), true)\n    lu.assertEquals(candidate('whattup', 'ptut'), false)\n    lu.assertEquals(candidate('efef', 'fee'), true)\n    lu.assertEquals(candidate('abab', 'aabb'), false)\n    lu.assertEquals(candidate('winemtt', 'tinem'), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef cycpattern_check(a: str , b: str) -> bool:\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function cycpattern_check(a, b)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function minSubArraySum(nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minSubArraySum\n    lu.assertEquals(candidate({2, 3, 4, 1, 2, 4}), 1)\n    lu.assertEquals(candidate({-1, -2, -3}), -6)\n    lu.assertEquals(candidate({-1, -2, -3, 2, -10}), -14)\n    lu.assertEquals(candidate({-9999999999999999}), -9999999999999999)\n    lu.assertEquals(candidate({0, 10, 20, 1000000}), 0)\n    lu.assertEquals(candidate({-1, -2, -3, 10, -5}), -6)\n    lu.assertEquals(candidate({100, -1, -2, -3, 10, -5}), -6)\n    lu.assertEquals(candidate({10, 11, 13, 8, 3, 4}), 3)\n    lu.assertEquals(candidate({100, -33, 32, -1, 0, -2}), -33)\n    lu.assertEquals(candidate({-10}), -10)\n    lu.assertEquals(candidate({7}), 7)\n    lu.assertEquals(candidate({1, -1}), -1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n\n### Lua version\n\nmath = require('math')\nlocal function minSubArraySum(nums)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function histogram(test)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = histogram\n    lu.assertEquals(candidate('a b b a'), {['a'] = 2, ['b'] = 2})\n    lu.assertEquals(candidate('a b c a b'), {['a'] = 2, ['b'] = 2})\n    lu.assertEquals(candidate('a b c d g'), {['a'] = 1, ['b'] = 1, ['c'] = 1, ['d'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate('b b b b a'), {['b'] = 4})\n    lu.assertEquals(candidate('r t g'), {['r'] = 1, ['t'] = 1, ['g'] = 1})\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('a'), {['a'] = 1})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Dict\n\ndef histogram(test: str) -> Dict[str, int]:\n    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n\n### Lua version\n\nmath = require('math')\nlocal function histogram(test)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function get_odd_collatz(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_odd_collatz\n    lu.assertEquals(candidate(14), {1, 5, 7, 11, 13, 17})\n    lu.assertEquals(candidate(5), {1, 5})\n    lu.assertEquals(candidate(12), {1, 3, 5})\n    lu.assertEquals(candidate(1), {1})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef get_odd_collatz(n: int) -> List[int]:\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n\n### Lua version\n\nmath = require('math')\nlocal function get_odd_collatz(n)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function derivative(xs)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = derivative\n    lu.assertEquals(candidate({3, 1, 2, 4, 5}), {1, 4, 12, 20})\n    lu.assertEquals(candidate({1, 2, 3}), {2, 6})\n    lu.assertEquals(candidate({3, 2, 1}), {2, 2})\n    lu.assertEquals(candidate({3, 2, 1, 0, 4}), {2, 2, 0, 16})\n    lu.assertEquals(candidate({1}), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef derivative(xs: List[int]) -> List[int]:\n    return [(i * x) for i, x in enumerate(xs)][1:]\n\n### Lua version\n\nmath = require('math')\nlocal function derivative(xs)\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function fibfib(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fibfib\n    lu.assertEquals(candidate(2), 1)\n    lu.assertEquals(candidate(1), 0)\n    lu.assertEquals(candidate(5), 4)\n    lu.assertEquals(candidate(8), 24)\n    lu.assertEquals(candidate(10), 81)\n    lu.assertEquals(candidate(12), 274)\n    lu.assertEquals(candidate(14), 927)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n\n### Lua version\n\nmath = require('math')\nlocal function fibfib(n)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function truncate_number(number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25), 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef truncate_number(number: float) -> float:\n    return number % 1.0\n\n### Lua version\n\nmath = require('math')\nlocal function truncate_number(number)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function max_element(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_element\n    lu.assertEquals(candidate({1, 2, 3}), 3)\n    lu.assertEquals(candidate({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), 124)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef max_element(l: List[int]) -> int:\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n\n### Lua version\n\nmath = require('math')\nlocal function max_element(l)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function closest_integer(value)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef closest_integer(value: str) -> int:\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n### Lua version\n\nmath = require('math')\nlocal function closest_integer(value)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function prime_fib(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prime_fib\n    lu.assertEquals(candidate(1), 2)\n    lu.assertEquals(candidate(2), 3)\n    lu.assertEquals(candidate(3), 5)\n    lu.assertEquals(candidate(4), 13)\n    lu.assertEquals(candidate(5), 89)\n    lu.assertEquals(candidate(6), 233)\n    lu.assertEquals(candidate(7), 1597)\n    lu.assertEquals(candidate(8), 28657)\n    lu.assertEquals(candidate(9), 514229)\n    lu.assertEquals(candidate(10), 433494437)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef prime_fib(n: int) -> int:\n    import math\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n\n### Lua version\n\nmath = require('math')\nlocal function prime_fib(n)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sum_product(numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_product\n    lu.assertEquals(candidate({}), {0, 1})\n    lu.assertEquals(candidate({1, 1, 1}), {3, 1})\n    lu.assertEquals(candidate({100, 0}), {100, 0})\n    lu.assertEquals(candidate({3, 5, 7}), {15, 105})\n    lu.assertEquals(candidate({10}), {10, 10})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n\n### Lua version\n\nmath = require('math')\nlocal function sum_product(numbers)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function select_words(s, n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = select_words\n    lu.assertEquals(candidate('Mary had a little lamb', 4), {'little'})\n    lu.assertEquals(candidate('Mary had a little lamb', 3), {'Mary', 'lamb'})\n    lu.assertEquals(candidate('simple white space', 2), {})\n    lu.assertEquals(candidate('Hello world', 4), {'world'})\n    lu.assertEquals(candidate('Uncle sam', 3), {'Uncle'})\n    lu.assertEquals(candidate('', 4), {})\n    lu.assertEquals(candidate('a b c d e f', 1), {'b', 'c', 'd', 'f'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function select_words(s, n)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function add_elements(arr, k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add_elements\n    lu.assertEquals(candidate({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), -4)\n    lu.assertEquals(candidate({111, 121, 3, 4000, 5, 6}, 2), 0)\n    lu.assertEquals(candidate({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), 125)\n    lu.assertEquals(candidate({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), 24)\n    lu.assertEquals(candidate({1}, 1), 1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef add_elements(arr: List[int], k: int) -> int:\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n\n### Lua version\n\nmath = require('math')\nlocal function add_elements(arr, k)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function eat(number, need, remaining)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = eat\n    lu.assertEquals(candidate(5, 6, 10), {11, 4})\n    lu.assertEquals(candidate(4, 8, 9), {12, 1})\n    lu.assertEquals(candidate(1, 10, 10), {11, 0})\n    lu.assertEquals(candidate(2, 11, 5), {7, 0})\n    lu.assertEquals(candidate(4, 5, 7), {9, 2})\n    lu.assertEquals(candidate(4, 5, 1), {5, 0})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef eat(number: int, need: int, remaining: int) -> List[int]:\n    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n\n### Lua version\n\nmath = require('math')\nlocal function eat(number, need, remaining)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function odd_count(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = odd_count\n    lu.assertEquals(candidate({'1234567'}), {'the number of odd elements 4n the str4ng 4 of the 4nput.'})\n    lu.assertEquals(candidate({'3', '11111111'}), {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'})\n    lu.assertEquals(candidate({'271', '137', '314'}), {'the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef odd_count(lst: List[str]) -> List[str]:\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n\n### Lua version\n\nmath = require('math')\nlocal function odd_count(lst)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function next_smallest(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5, 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1, 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1, 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\nfrom typing import Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n\n### Lua version\n\nmath = require('math')\nlocal function next_smallest(lst)\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function get_row(lst, x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\nfrom typing import Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n\n### Lua version\n\nmath = require('math')\nlocal function get_row(lst, x)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function filter_by_prefix(strings, prefix)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_prefix\n    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [x for x in strings if x.startswith(prefix)]\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_prefix(strings, prefix)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function choose_num(x, y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = choose_num\n    lu.assertEquals(candidate(12, 15), 14)\n    lu.assertEquals(candidate(13, 12), -1)\n    lu.assertEquals(candidate(33, 12354), 12354)\n    lu.assertEquals(candidate(5234, 5233), -1)\n    lu.assertEquals(candidate(6, 29), 28)\n    lu.assertEquals(candidate(27, 10), -1)\n    lu.assertEquals(candidate(7, 7), -1)\n    lu.assertEquals(candidate(546, 546), 546)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef choose_num(x: int, y: int) -> int:\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n\n### Lua version\n\nmath = require('math')\nlocal function choose_num(x, y)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function prime_length(string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = prime_length\n    lu.assertEquals(candidate('Hello'), true)\n    lu.assertEquals(candidate('abcdcba'), true)\n    lu.assertEquals(candidate('kittens'), true)\n    lu.assertEquals(candidate('orange'), false)\n    lu.assertEquals(candidate('wow'), true)\n    lu.assertEquals(candidate('world'), true)\n    lu.assertEquals(candidate('MadaM'), true)\n    lu.assertEquals(candidate('Wow'), true)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('HI'), true)\n    lu.assertEquals(candidate('go'), true)\n    lu.assertEquals(candidate('gogo'), false)\n    lu.assertEquals(candidate('aaaaaaaaaaaaaaa'), false)\n    lu.assertEquals(candidate('Madam'), true)\n    lu.assertEquals(candidate('M'), false)\n    lu.assertEquals(candidate('0'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef prime_length(string: str) -> bool:\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function prime_length(string)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sum_to_n(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_to_n\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(6), 21)\n    lu.assertEquals(candidate(11), 66)\n    lu.assertEquals(candidate(30), 465)\n    lu.assertEquals(candidate(100), 5050)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef sum_to_n(n: int) -> int:\n    return sum(range(n + 1))\n\n### Lua version\n\nmath = require('math')\nlocal function sum_to_n(n)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function fix_spaces(text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fix_spaces\n    lu.assertEquals(candidate('Example'), 'Example')\n    lu.assertEquals(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')\n    lu.assertEquals(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')\n    lu.assertEquals(candidate('Exa   mple'), 'Exa-mple')\n    lu.assertEquals(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef fix_spaces(text: str) -> str:\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n\n### Lua version\n\nmath = require('math')\nlocal function fix_spaces(text)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function rolling_max(numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rolling_max\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})\n    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function rolling_max(numbers)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function words_in_sentence(sentence)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = words_in_sentence\n    lu.assertEquals(candidate('This is a test'), 'is')\n    lu.assertEquals(candidate('lets go for swimming'), 'go for')\n    lu.assertEquals(candidate('there is no place available here'), 'there is no place')\n    lu.assertEquals(candidate('Hi I am Hussein'), 'Hi am Hussein')\n    lu.assertEquals(candidate('go for it'), 'go for it')\n    lu.assertEquals(candidate('here'), '')\n    lu.assertEquals(candidate('here is'), 'is')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef words_in_sentence(sentence: str) -> str:\n    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n\n### Lua version\n\nmath = require('math')\nlocal function words_in_sentence(sentence)\n"
  },
  {
    "name": "HumanEval_160_do_algebra",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function do_algebra(operator, operand)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_160_do_algebra.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = do_algebra\n    lu.assertEquals(candidate({'**', '*', '+'}, {2, 3, 4, 5}), 37)\n    lu.assertEquals(candidate({'+', '*', '-'}, {2, 3, 4, 5}), 9)\n    lu.assertEquals(candidate({'//', '*'}, {7, 3, 4}), 8)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n\n### Lua version\n\nmath = require('math')\nlocal function do_algebra(operator, operand)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function get_closest_vowel(word)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_closest_vowel\n    lu.assertEquals(candidate('yogurt'), 'u')\n    lu.assertEquals(candidate('full'), 'u')\n    lu.assertEquals(candidate('easy'), '')\n    lu.assertEquals(candidate('eAsy'), '')\n    lu.assertEquals(candidate('ali'), '')\n    lu.assertEquals(candidate('bad'), 'a')\n    lu.assertEquals(candidate('most'), 'o')\n    lu.assertEquals(candidate('ab'), '')\n    lu.assertEquals(candidate('ba'), '')\n    lu.assertEquals(candidate('quick'), '')\n    lu.assertEquals(candidate('anime'), 'i')\n    lu.assertEquals(candidate('Asia'), '')\n    lu.assertEquals(candidate('Above'), 'o')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef get_closest_vowel(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n\n### Lua version\n\nmath = require('math')\nlocal function get_closest_vowel(word)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function compare(game, guess)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = compare\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2}), {0, 0, 0, 0, 3, 3})\n    lu.assertEquals(candidate({0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}), {0, 0, 0, 0, 0, 0})\n    lu.assertEquals(candidate({1, 2, 3}, {-1, -2, -3}), {2, 4, 6})\n    lu.assertEquals(candidate({1, 2, 3, 5}, {-1, 2, 3, 4}), {2, 0, 0, 1})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef compare(game: List[int],guess: List[int]) -> List[int]:\n    return [abs(x-y) for x,y in zip(game,guess)]\n\n### Lua version\n\nmath = require('math')\nlocal function compare(game, guess)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function remove_duplicates(numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_duplicates\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({1, 2, 3, 2, 4, 3, 5}), {1, 4, 5})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n\n### Lua version\n\nmath = require('math')\nlocal function remove_duplicates(numbers)\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function same_chars(s0, s1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = same_chars\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)\n    lu.assertEquals(candidate('abcd', 'dddddddabc'), true)\n    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)\n    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)\n    lu.assertEquals(candidate('abcd', 'dddddddabcf'), false)\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), false)\n    lu.assertEquals(candidate('aabb', 'aaccc'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n\n### Lua version\n\nmath = require('math')\nlocal function same_chars(s0, s1)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function parse_nested_parens(paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_nested_parens\n    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})\n    lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})\n    lu.assertEquals(candidate('(()(())((())))'), {4})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n\n### Lua version\n\nmath = require('math')\nlocal function parse_nested_parens(paren_string)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function even_odd_count(num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = even_odd_count\n    lu.assertEquals(candidate(7), {0, 1})\n    lu.assertEquals(candidate(-78), {1, 1})\n    lu.assertEquals(candidate(3452), {2, 2})\n    lu.assertEquals(candidate(346211), {3, 3})\n    lu.assertEquals(candidate(-345821), {3, 3})\n    lu.assertEquals(candidate(-2), {1, 0})\n    lu.assertEquals(candidate(-45347), {2, 3})\n    lu.assertEquals(candidate(0), {1, 0})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Tuple \n\ndef even_odd_count(num: int) -> Tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_count(num)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function fruit_distribution(s, n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fruit_distribution\n    lu.assertEquals(candidate('5 apples and 6 oranges', 19), 8)\n    lu.assertEquals(candidate('5 apples and 6 oranges', 21), 10)\n    lu.assertEquals(candidate('0 apples and 1 oranges', 3), 2)\n    lu.assertEquals(candidate('1 apples and 0 oranges', 3), 2)\n    lu.assertEquals(candidate('2 apples and 3 oranges', 100), 95)\n    lu.assertEquals(candidate('2 apples and 3 oranges', 5), 0)\n    lu.assertEquals(candidate('1 apples and 100 oranges', 120), 19)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef fruit_distribution(s: str, n: int) -> int:\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n\n### Lua version\n\nmath = require('math')\nlocal function fruit_distribution(s, n)\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function string_xor(a, b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n\n### Lua version\n\nmath = require('math')\nlocal function string_xor(a, b)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function strlen(string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strlen\n    lu.assertEquals(candidate(''), 0)\n    lu.assertEquals(candidate('x'), 1)\n    lu.assertEquals(candidate('asdasnakj'), 9)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef strlen(string: str) -> int:\n    return len(string)\n\n### Lua version\n\nmath = require('math')\nlocal function strlen(string)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function string_sequence(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_sequence\n    lu.assertEquals(candidate(0), '0')\n    lu.assertEquals(candidate(3), '0 1 2 3')\n    lu.assertEquals(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])\n\n### Lua version\n\nmath = require('math')\nlocal function string_sequence(n)\n"
  },
  {
    "name": "HumanEval_141_file_name_check",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function file_name_check(file_name)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_141_file_name_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = file_name_check\n    lu.assertEquals(candidate('example.txt'), 'Yes')\n    lu.assertEquals(candidate('1example.dll'), 'No')\n    lu.assertEquals(candidate('s1sdf3.asd'), 'No')\n    lu.assertEquals(candidate('K.dll'), 'Yes')\n    lu.assertEquals(candidate('MY16FILE3.exe'), 'Yes')\n    lu.assertEquals(candidate('His12FILE94.exe'), 'No')\n    lu.assertEquals(candidate('_Y.txt'), 'No')\n    lu.assertEquals(candidate('?aREYA.exe'), 'No')\n    lu.assertEquals(candidate('/this_is_valid.dll'), 'No')\n    lu.assertEquals(candidate('this_is_valid.wow'), 'No')\n    lu.assertEquals(candidate('this_is_valid.txt'), 'Yes')\n    lu.assertEquals(candidate('this_is_valid.txtexe'), 'No')\n    lu.assertEquals(candidate('#this2_i4s_5valid.ten'), 'No')\n    lu.assertEquals(candidate('@this1_is6_valid.exe'), 'No')\n    lu.assertEquals(candidate('this_is_12valid.6exe4.txt'), 'No')\n    lu.assertEquals(candidate('all.exe.txt'), 'No')\n    lu.assertEquals(candidate('I563_No.exe'), 'Yes')\n    lu.assertEquals(candidate('Is3youfault.txt'), 'Yes')\n    lu.assertEquals(candidate('no_one#knows.dll'), 'Yes')\n    lu.assertEquals(candidate('1I563_Yes3.exe'), 'No')\n    lu.assertEquals(candidate('I563_Yes3.txtt'), 'No')\n    lu.assertEquals(candidate('final..txt'), 'No')\n    lu.assertEquals(candidate('final132'), 'No')\n    lu.assertEquals(candidate('_f4indsartal132.'), 'No')\n    lu.assertEquals(candidate('.txt'), 'No')\n    lu.assertEquals(candidate('s.'), 'No')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef file_name_check(file_name: str) -> str:\n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n\n### Lua version\n\nmath = require('math')\nlocal function file_name_check(file_name)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function can_arrange(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = can_arrange\n    lu.assertEquals(candidate({1, 2, 4, 3, 5}), 3)\n    lu.assertEquals(candidate({1, 2, 4, 5}), -1)\n    lu.assertEquals(candidate({1, 4, 2, 5, 6, 7, 8, 9, 10}), 2)\n    lu.assertEquals(candidate({4, 8, 5, 7, 3}), 4)\n    lu.assertEquals(candidate({}), -1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef can_arrange(arr: List[int]) -> int:\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n\n### Lua version\n\nmath = require('math')\nlocal function can_arrange(arr)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function add(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = add\n    lu.assertEquals(candidate({4, 88}), 88)\n    lu.assertEquals(candidate({4, 5, 6, 7, 2, 122}), 122)\n    lu.assertEquals(candidate({4, 0, 6, 7}), 0)\n    lu.assertEquals(candidate({4, 4, 6, 8}), 12)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef add(lst: List[int]) -> int:\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n\n### Lua version\n\nmath = require('math')\nlocal function add(lst)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function intersperse(numbers, delimeter)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6, 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2), {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function intersperse(numbers, delimeter)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function match_parens(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n\n### Lua version\n\nmath = require('math')\nlocal function match_parens(lst)\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function any_int(x, y, z)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = any_int\n    lu.assertEquals(candidate(2, 3, 1), true)\n    lu.assertEquals(candidate(2.5, 2, 3), false)\n    lu.assertEquals(candidate(1.5, 5, 3.5), false)\n    lu.assertEquals(candidate(2, 6, 2), false)\n    lu.assertEquals(candidate(4, 2, 2), true)\n    lu.assertEquals(candidate(2.2, 2.2, 2.2), false)\n    lu.assertEquals(candidate(-4, 6, 2), true)\n    lu.assertEquals(candidate(2, 1, 1), true)\n    lu.assertEquals(candidate(3, 4, 7), true)\n    lu.assertEquals(candidate(3.0, 4, 7), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef any_int(x: float, y: float, z: float) -> bool:\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function any_int(x, y, z)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function filter_by_substring(strings, substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_substring\n    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\n    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'}, 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})\n    lu.assertEquals(candidate({'grunt', 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [x for x in strings if substring in x]\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_substring(strings, substring)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function find_max(words)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_max\n    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')\n    lu.assertEquals(candidate({'name', 'enam', 'game'}), 'enam')\n    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}), 'aaaaaaa')\n    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')\n    lu.assertEquals(candidate({'play', 'this', 'game', 'of', 'footbott'}), 'footbott')\n    lu.assertEquals(candidate({'we', 'are', 'gonna', 'rock'}), 'gonna')\n    lu.assertEquals(candidate({'we', 'are', 'a', 'mad', 'nation'}), 'nation')\n    lu.assertEquals(candidate({'this', 'is', 'a', 'prrk'}), 'this')\n    lu.assertEquals(candidate({'b'}), 'b')\n    lu.assertEquals(candidate({'play', 'play', 'play'}), 'play')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef find_max(words: List[str]) -> str:\n    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n\n### Lua version\n\nmath = require('math')\nlocal function find_max(words)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function generate_integers(a, b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = generate_integers\n    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})\n    lu.assertEquals(candidate(10, 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(17, 89), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n\n### Lua version\n\nmath = require('math')\nlocal function generate_integers(a, b)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function exchange(lst1, lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = exchange\n    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 2, 3, 4}), 'YES')\n    lu.assertEquals(candidate({1, 2, 3, 4}, {1, 5, 3, 4}), 'NO')\n    lu.assertEquals(candidate({1, 2, 3, 4}, {2, 1, 4, 3}), 'YES')\n    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 4}), 'YES')\n    lu.assertEquals(candidate({5, 7, 3}, {2, 6, 3}), 'NO')\n    lu.assertEquals(candidate({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}), 'NO')\n    lu.assertEquals(candidate({100, 200}, {200, 200}), 'YES')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n\n### Lua version\n\nmath = require('math')\nlocal function exchange(lst1, lst2)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function int_to_mini_roman(number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef int_to_mini_roman(number: int) -> str:\n    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n\n### Lua version\n\nmath = require('math')\nlocal function int_to_mini_roman(number)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_equal_to_sum_even(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_equal_to_sum_even\n    lu.assertEquals(candidate(4), false)\n    lu.assertEquals(candidate(6), false)\n    lu.assertEquals(candidate(8), true)\n    lu.assertEquals(candidate(10), true)\n    lu.assertEquals(candidate(11), false)\n    lu.assertEquals(candidate(12), true)\n    lu.assertEquals(candidate(13), false)\n    lu.assertEquals(candidate(16), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef is_equal_to_sum_even(n: int) -> bool:\n    return n%2 == 0 and n >= 8\n\n### Lua version\n\nmath = require('math')\nlocal function is_equal_to_sum_even(n)\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function decimal_to_binary(decimal)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = decimal_to_binary\n    lu.assertEquals(candidate(0), 'db0db')\n    lu.assertEquals(candidate(32), 'db100000db')\n    lu.assertEquals(candidate(103), 'db1100111db')\n    lu.assertEquals(candidate(15), 'db1111db')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef decimal_to_binary(decimal: int) -> str:\n    return \"db\" + bin(decimal)[2:] + \"db\"\n\n### Lua version\n\nmath = require('math')\nlocal function decimal_to_binary(decimal)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function sort_third(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_third\n    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5})\n    lu.assertEquals(candidate({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5})\n    lu.assertEquals(candidate({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5})\n    lu.assertEquals(candidate({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_third(l: List[int]) -> List[int]:\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n\n### Lua version\n\nmath = require('math')\nlocal function sort_third(l)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function simplify(x, n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = simplify\n    lu.assertEquals(candidate('1/5', '5/1'), true)\n    lu.assertEquals(candidate('1/6', '2/1'), false)\n    lu.assertEquals(candidate('5/1', '3/1'), true)\n    lu.assertEquals(candidate('7/10', '10/2'), false)\n    lu.assertEquals(candidate('2/10', '50/10'), true)\n    lu.assertEquals(candidate('7/2', '4/2'), true)\n    lu.assertEquals(candidate('11/6', '6/1'), true)\n    lu.assertEquals(candidate('2/3', '5/2'), false)\n    lu.assertEquals(candidate('5/2', '3/5'), false)\n    lu.assertEquals(candidate('2/4', '8/4'), true)\n    lu.assertEquals(candidate('2/4', '4/2'), true)\n    lu.assertEquals(candidate('1/5', '5/1'), true)\n    lu.assertEquals(candidate('1/5', '1/5'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef simplify(x: str, n: str) -> bool:\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function simplify(x, n)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function solve(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solve\n    lu.assertEquals(candidate('AsDf'), 'aSdF')\n    lu.assertEquals(candidate('1234'), '4321')\n    lu.assertEquals(candidate('ab'), 'AB')\n    lu.assertEquals(candidate('#a@C'), '#A@c')\n    lu.assertEquals(candidate('#AsdfW^45'), '#aSDFw^45')\n    lu.assertEquals(candidate('#6@2'), '2@6#')\n    lu.assertEquals(candidate('#$a^D'), '#$A^d')\n    lu.assertEquals(candidate('#ccc'), '#CCC')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef solve(s: str) -> str:\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n\n### Lua version\n\nmath = require('math')\nlocal function solve(s)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function right_angle_triangle(a, b, c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = right_angle_triangle\n    lu.assertEquals(candidate(3, 4, 5), true)\n    lu.assertEquals(candidate(1, 2, 3), false)\n    lu.assertEquals(candidate(10, 6, 8), true)\n    lu.assertEquals(candidate(2, 2, 2), false)\n    lu.assertEquals(candidate(7, 24, 25), true)\n    lu.assertEquals(candidate(10, 5, 7), false)\n    lu.assertEquals(candidate(5, 12, 13), true)\n    lu.assertEquals(candidate(15, 8, 17), true)\n    lu.assertEquals(candidate(48, 55, 73), true)\n    lu.assertEquals(candidate(1, 1, 1), false)\n    lu.assertEquals(candidate(2, 2, 10), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef right_angle_triangle(a: int, b: int, c: int) -> bool:\n    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n\n### Lua version\n\nmath = require('math')\nlocal function right_angle_triangle(a, b, c)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function double_the_difference(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = double_the_difference\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({5.0, 4.0}), 25)\n    lu.assertEquals(candidate({0.1, 0.2, 0.3}), 0)\n    lu.assertEquals(candidate({-10.0, -20.0, -30.0}), 0)\n    lu.assertEquals(candidate({-1.0, -2.0, 8.0}), 0)\n    lu.assertEquals(candidate({0.2, 3.0, 5.0}), 34)\n    lu.assertEquals(candidate({-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), 165)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef double_the_difference(lst: List[float]) -> int:\n    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n\n### Lua version\n\nmath = require('math')\nlocal function double_the_difference(lst)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function compare_one(a, b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = compare_one\n    lu.assertEquals(candidate(1, 2), 2)\n    lu.assertEquals(candidate(1, 2.5), 2.5)\n    lu.assertEquals(candidate(2, 3), 3)\n    lu.assertEquals(candidate(5, 6), 6)\n    lu.assertEquals(candidate(1, '2,3'), '2,3')\n    lu.assertEquals(candidate('5,1', '6'), '6')\n    lu.assertEquals(candidate('1', '2'), '2')\n    lu.assertEquals(candidate('1', 1), None)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b\n\n### Lua version\n\nmath = require('math')\nlocal function compare_one(a, b)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function below_zero(operations)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = below_zero\n    lu.assertEquals(candidate({}), false)\n    lu.assertEquals(candidate({1, 2, -3, 1, 2, -3}), false)\n    lu.assertEquals(candidate({1, 2, -4, 5, 6}), true)\n    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -4}), false)\n    lu.assertEquals(candidate({1, -1, 2, -2, 5, -5, 4, -5}), true)\n    lu.assertEquals(candidate({1, -2, 2, -2, 5, -5, 4, -4}), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function below_zero(operations)\n"
  },
  {
    "name": "HumanEval_103_rounded_avg",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function rounded_avg(n, m)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_103_rounded_avg.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rounded_avg\n    lu.assertEquals(candidate(1, 5), '0b11')\n    lu.assertEquals(candidate(7, 13), '0b1010')\n    lu.assertEquals(candidate(964, 977), '0b1111001010')\n    lu.assertEquals(candidate(996, 997), '0b1111100100')\n    lu.assertEquals(candidate(560, 851), '0b1011000010')\n    lu.assertEquals(candidate(185, 546), '0b101101110')\n    lu.assertEquals(candidate(362, 496), '0b110101101')\n    lu.assertEquals(candidate(350, 902), '0b1001110010')\n    lu.assertEquals(candidate(197, 233), '0b11010111')\n    lu.assertEquals(candidate(7, 5), -1)\n    lu.assertEquals(candidate(5, 1), -1)\n    lu.assertEquals(candidate(5, 5), '0b101')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Union\n\ndef rounded_avg(n: int, m: int) -> Union[str, int]:\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n\n### Lua version\n\nmath = require('math')\nlocal function rounded_avg(n, m)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function greatest_common_divisor(a, b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = greatest_common_divisor\n    lu.assertEquals(candidate(3, 7), 1)\n    lu.assertEquals(candidate(10, 15), 5)\n    lu.assertEquals(candidate(49, 14), 7)\n    lu.assertEquals(candidate(144, 60), 12)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n\n### Lua version\n\nmath = require('math')\nlocal function greatest_common_divisor(a, b)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function f(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = f\n    lu.assertEquals(candidate(5), {1, 2, 6, 24, 15})\n    lu.assertEquals(candidate(7), {1, 2, 6, 24, 15, 720, 28})\n    lu.assertEquals(candidate(1), {1})\n    lu.assertEquals(candidate(3), {1, 2, 6})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n\n### Lua version\n\nmath = require('math')\nlocal function f(n)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function monotonic(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = monotonic\n    lu.assertEquals(candidate({1, 2, 4, 10}), true)\n    lu.assertEquals(candidate({1, 2, 4, 20}), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}), false)\n    lu.assertEquals(candidate({4, 1, 0, -10}), true)\n    lu.assertEquals(candidate({4, 1, 1, 0}), true)\n    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)\n    lu.assertEquals(candidate({9, 9, 9, 9}), true)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef monotonic(l: List[int]) -> bool:\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function monotonic(l)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function by_length(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = by_length\n    lu.assertEquals(candidate({2, 1, 1, 4, 5, 8, 2, 3}), {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -1, 55}), {'One'})\n    lu.assertEquals(candidate({1, -1, 3, 2}), {'Three', 'Two', 'One'})\n    lu.assertEquals(candidate({9, 4, 8}), {'Nine', 'Eight', 'Four'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef by_length(arr: List[int]) -> List[str]:\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n\n### Lua version\n\nmath = require('math')\nlocal function by_length(arr)\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function remove_vowels(text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_vowels\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('abcdef\\nghijklm'), 'bcdf\\nghjklm')\n    lu.assertEquals(candidate('fedcba'), 'fdcb')\n    lu.assertEquals(candidate('eeeee'), '')\n    lu.assertEquals(candidate('acBAA'), 'cB')\n    lu.assertEquals(candidate('EcBOO'), 'cB')\n    lu.assertEquals(candidate('ybcd'), 'ybcd')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef remove_vowels(text: str) -> str:\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n\n### Lua version\n\nmath = require('math')\nlocal function remove_vowels(text)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function check_if_last_char_is_a_letter(txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = check_if_last_char_is_a_letter\n    lu.assertEquals(candidate('apple'), false)\n    lu.assertEquals(candidate('apple pi e'), true)\n    lu.assertEquals(candidate('eeeee'), false)\n    lu.assertEquals(candidate('A'), true)\n    lu.assertEquals(candidate('Pumpkin pie '), false)\n    lu.assertEquals(candidate('Pumpkin pie 1'), false)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('eeeee e '), false)\n    lu.assertEquals(candidate('apple pie'), false)\n    lu.assertEquals(candidate('apple pi e '), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef check_if_last_char_is_a_letter(txt: str) -> bool:\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n\n### Lua version\n\nmath = require('math')\nlocal function check_if_last_char_is_a_letter(txt)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function iscube(a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = iscube\n    lu.assertEquals(candidate(1), true)\n    lu.assertEquals(candidate(2), false)\n    lu.assertEquals(candidate(-1), true)\n    lu.assertEquals(candidate(64), true)\n    lu.assertEquals(candidate(180), false)\n    lu.assertEquals(candidate(1000), true)\n    lu.assertEquals(candidate(0), true)\n    lu.assertEquals(candidate(1729), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef iscube(a: int) -> bool:\n    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n\n### Lua version\n\nmath = require('math')\nlocal function iscube(a)\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function reverse_delete(s, c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef', 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc', true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a', 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba', true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma', 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Tuple\n\ndef reverse_delete(s: str,c: str) -> Tuple[str, bool]:\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n\n### Lua version\n\nmath = require('math')\nlocal function reverse_delete(s, c)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function mean_absolute_deviation(numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = mean_absolute_deviation\n    lu.assertEquals(candidate({1.0, 2.0}), 0.5)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0}), 1.0)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), 1.2)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n### Lua version\n\nmath = require('math')\nlocal function mean_absolute_deviation(numbers)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function correct_bracketing(brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = correct_bracketing\n    lu.assertEquals(candidate('<>'), true)\n    lu.assertEquals(candidate('<<><>>'), true)\n    lu.assertEquals(candidate('<><><<><>><>'), true)\n    lu.assertEquals(candidate('<><><<<><><>><>><<><><<>>>'), true)\n    lu.assertEquals(candidate('<<<><>>>>'), false)\n    lu.assertEquals(candidate('><<>'), false)\n    lu.assertEquals(candidate('<'), false)\n    lu.assertEquals(candidate('<<<<'), false)\n    lu.assertEquals(candidate('>'), false)\n    lu.assertEquals(candidate('<<>'), false)\n    lu.assertEquals(candidate('<><><<><>><>><<>'), false)\n    lu.assertEquals(candidate('<><><<><>><>>><>'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function rescale_to_unit(numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0, 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0, 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0, 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n\n### Lua version\n\nmath = require('math')\nlocal function rescale_to_unit(numbers)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function intersection(interval1, interval2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1, 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11, 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2, -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import Tuple\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n\n### Lua version\n\nmath = require('math')\nlocal function intersection(interval1, interval2)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function hex_key(num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = hex_key\n    lu.assertEquals(candidate('AB'), 1)\n    lu.assertEquals(candidate('1077E'), 2)\n    lu.assertEquals(candidate('ABED1A33'), 4)\n    lu.assertEquals(candidate('2020'), 2)\n    lu.assertEquals(candidate('123456789ABCDEF0'), 6)\n    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'), 12)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef hex_key(num: str) -> int:\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n\n### Lua version\n\nmath = require('math')\nlocal function hex_key(num)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function strange_sort_list(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}), {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5, 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3, 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5, -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n\n### Lua version\n\nmath = require('math')\nlocal function strange_sort_list(lst)\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_bored(S)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_bored\n    lu.assertEquals(candidate('Hello world'), 0)\n    lu.assertEquals(candidate('Is the sky blue?'), 0)\n    lu.assertEquals(candidate('I love It !'), 1)\n    lu.assertEquals(candidate('bIt'), 0)\n    lu.assertEquals(candidate('I feel good today. I will be productive. will kill It'), 2)\n    lu.assertEquals(candidate('You and I are going for a walk'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef is_bored(S: str) -> int:\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n\n### Lua version\n\nmath = require('math')\nlocal function is_bored(S)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function all_prefixes(string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = all_prefixes\n    lu.assertEquals(candidate(''), {})\n    lu.assertEquals(candidate('asdfgh'), {'a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'})\n    lu.assertEquals(candidate('WWW'), {'W', 'WW', 'WWW'})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function all_prefixes(string)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function how_many_times(string, substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = how_many_times\n    lu.assertEquals(candidate('', 'x'), 0)\n    lu.assertEquals(candidate('xyxyxyx', 'x'), 4)\n    lu.assertEquals(candidate('cacacacac', 'cac'), 4)\n    lu.assertEquals(candidate('john doe', 'john'), 1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef how_many_times(string: str, substring: str) -> int:\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n### Lua version\n\nmath = require('math')\nlocal function how_many_times(string, substring)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function solution(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solution\n    lu.assertEquals(candidate({5, 8, 7, 1}), 12)\n    lu.assertEquals(candidate({3, 3, 3, 3, 3}), 9)\n    lu.assertEquals(candidate({30, 13, 24, 321}), 0)\n    lu.assertEquals(candidate({5, 9}), 5)\n    lu.assertEquals(candidate({2, 4, 8}), 0)\n    lu.assertEquals(candidate({30, 13, 23, 32}), 23)\n    lu.assertEquals(candidate({3, 13, 2, 9}), 3)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef solution(lst: List[int]) -> int:\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n\n### Lua version\n\nmath = require('math')\nlocal function solution(lst)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function search(lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = search\n    lu.assertEquals(candidate({5, 5, 5, 5, 1}), 1)\n    lu.assertEquals(candidate({4, 1, 4, 1, 4, 4}), 4)\n    lu.assertEquals(candidate({3, 3}), -1)\n    lu.assertEquals(candidate({8, 8, 8, 8, 8, 8, 8, 8}), 8)\n    lu.assertEquals(candidate({2, 3, 3, 2, 2}), 2)\n    lu.assertEquals(candidate({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), 1)\n    lu.assertEquals(candidate({3, 2, 8, 2}), 2)\n    lu.assertEquals(candidate({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), 1)\n    lu.assertEquals(candidate({8, 8, 3, 6, 5, 6, 4}), -1)\n    lu.assertEquals(candidate({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), 1)\n    lu.assertEquals(candidate({1, 9, 10, 1, 3}), 1)\n    lu.assertEquals(candidate({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), 5)\n    lu.assertEquals(candidate({1}), 1)\n    lu.assertEquals(candidate({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), 4)\n    lu.assertEquals(candidate({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), 2)\n    lu.assertEquals(candidate({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), 1)\n    lu.assertEquals(candidate({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), 4)\n    lu.assertEquals(candidate({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), 4)\n    lu.assertEquals(candidate({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), 2)\n    lu.assertEquals(candidate({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), -1)\n    lu.assertEquals(candidate({10}), -1)\n    lu.assertEquals(candidate({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), 2)\n    lu.assertEquals(candidate({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), 1)\n    lu.assertEquals(candidate({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), 1)\n    lu.assertEquals(candidate({3, 10, 10, 9, 2}), -1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef search(lst: List[int]) -> int:\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n\n### Lua version\n\nmath = require('math')\nlocal function search(lst)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function pluck(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pluck\n    lu.assertEquals(candidate({4, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({1, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({5, 0, 3, 0, 4, 2}), {0, 1})\n    lu.assertEquals(candidate({1, 2, 3, 0, 5, 3}), {0, 3})\n    lu.assertEquals(candidate({5, 4, 8, 4, 8}), {4, 1})\n    lu.assertEquals(candidate({7, 6, 7, 1}), {6, 1})\n    lu.assertEquals(candidate({7, 9, 7, 1}), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n\n### Lua version\n\nmath = require('math')\nlocal function pluck(arr)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function pairs_sum_to_zero(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pairs_sum_to_zero\n    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1, 3, -2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({2, 4, -5, 3, 5, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 30}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 31}), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n\n### Lua version\n\nmath = require('math')\nlocal function pairs_sum_to_zero(l)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function make_palindrome(string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while string[beginning_of_suffix:] != string[beginning_of_suffix:][::-1]:\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n\n### Lua version\n\nmath = require('math')\nlocal function make_palindrome(string)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function starts_one_ends(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n    lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef starts_one_ends(n: int) -> int:\n    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n\n### Lua version\n\nmath = require('math')\nlocal function starts_one_ends(n)\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function get_positive(l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_positive\n    lu.assertEquals(candidate({-1, -2, 4, 5, 6}), {4, 5, 6})\n    lu.assertEquals(candidate({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), {5, 3, 2, 3, 3, 9, 123, 1})\n    lu.assertEquals(candidate({-1, -2}), {})\n    lu.assertEquals(candidate({}), {})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n    return [e for e in l if e > 0]\n\n### Lua version\n\nmath = require('math')\nlocal function get_positive(l)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function concatenate(strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = concatenate\n    lu.assertEquals(candidate({}), '')\n    lu.assertEquals(candidate({'x', 'y', 'z'}), 'xyz')\n    lu.assertEquals(candidate({'x', 'y', 'z', 'w', 'k'}), 'xyzwk')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)\n\n### Lua version\n\nmath = require('math')\nlocal function concatenate(strings)\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_nested(string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_nested\n    lu.assertEquals(candidate('[[]]'), true)\n    lu.assertEquals(candidate('[]]]]]]][[[[[]'), false)\n    lu.assertEquals(candidate('[][]'), false)\n    lu.assertEquals(candidate('[]'), false)\n    lu.assertEquals(candidate('[[[[]]]]'), true)\n    lu.assertEquals(candidate('[]]]]]]]]]]'), false)\n    lu.assertEquals(candidate('[][][[]]'), true)\n    lu.assertEquals(candidate('[[]'), false)\n    lu.assertEquals(candidate('[]]'), false)\n    lu.assertEquals(candidate('[[]][['), true)\n    lu.assertEquals(candidate('[[][]]'), true)\n    lu.assertEquals(candidate(''), false)\n    lu.assertEquals(candidate('[[[[[[[['), false)\n    lu.assertEquals(candidate(']]]]]]]]'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef is_nested(string: str) -> bool:\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n### Lua version\n\nmath = require('math')\nlocal function is_nested(string)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_palindrome(text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_palindrome\n    lu.assertEquals(candidate(''), true)\n    lu.assertEquals(candidate('aba'), true)\n    lu.assertEquals(candidate('aaaaa'), true)\n    lu.assertEquals(candidate('zbcd'), false)\n    lu.assertEquals(candidate('xywyx'), true)\n    lu.assertEquals(candidate('xywyz'), false)\n    lu.assertEquals(candidate('xywzx'), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef is_palindrome(text: str) -> bool:\n    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function is_palindrome(text)\n"
  },
  {
    "name": "HumanEval_108_count_nums",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function count_nums(arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_108_count_nums.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_nums\n    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({-1, -2, 0}), 0)\n    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)\n    lu.assertEquals(candidate({1, 6, 9, -6, 0, 1, 5}), 5)\n    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}), 4)\n    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)\n    lu.assertEquals(candidate({0, 1}), 1)\n    lu.assertEquals(candidate({1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef count_nums(arr: List[int]) -> int:\n    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n\n### Lua version\n\nmath = require('math')\nlocal function count_nums(arr)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function factorize(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = factorize\n    lu.assertEquals(candidate(2), {2})\n    lu.assertEquals(candidate(4), {2, 2})\n    lu.assertEquals(candidate(8), {2, 2, 2})\n    lu.assertEquals(candidate(57), {3, 19})\n    lu.assertEquals(candidate(3249), {3, 3, 19, 19})\n    lu.assertEquals(candidate(185193), {3, 3, 3, 19, 19, 19})\n    lu.assertEquals(candidate(20577), {3, 19, 19, 19})\n    lu.assertEquals(candidate(18), {2, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n### Lua version\n\nmath = require('math')\nlocal function factorize(n)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function largest_prime_factor(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_prime_factor\n    lu.assertEquals(candidate(15), 5)\n    lu.assertEquals(candidate(27), 3)\n    lu.assertEquals(candidate(63), 7)\n    lu.assertEquals(candidate(330), 11)\n    lu.assertEquals(candidate(13195), 29)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef largest_prime_factor(n: int) -> int:\n    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n\n### Lua version\n\nmath = require('math')\nlocal function largest_prime_factor(n)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function get_max_triples(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_max_triples\n    lu.assertEquals(candidate(5), 1)\n    lu.assertEquals(candidate(6), 4)\n    lu.assertEquals(candidate(10), 36)\n    lu.assertEquals(candidate(100), 53361)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef get_max_triples(n: int) -> int:\n    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n\n### Lua version\n\nmath = require('math')\nlocal function get_max_triples(n)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function anti_shuffle(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = anti_shuffle\n    lu.assertEquals(candidate('Hi'), 'Hi')\n    lu.assertEquals(candidate('hello'), 'ehllo')\n    lu.assertEquals(candidate('number'), 'bemnru')\n    lu.assertEquals(candidate('abcd'), 'abcd')\n    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef anti_shuffle(s: str) -> str:\n    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n\n### Lua version\n\nmath = require('math')\nlocal function anti_shuffle(s)\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function solve(N)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = solve\n    lu.assertEquals(candidate(1000), '1')\n    lu.assertEquals(candidate(150), '110')\n    lu.assertEquals(candidate(147), '1100')\n    lu.assertEquals(candidate(333), '1001')\n    lu.assertEquals(candidate(963), '10010')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef solve(N: int) -> str:\n    return bin(sum(int(i) for i in str(N)))[2:]\n\n### Lua version\n\nmath = require('math')\nlocal function solve(N)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function minPath(grid, k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minPath\n    lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})\n    lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})\n    lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4), {1, 2, 1, 2})\n    lu.assertEquals(candidate({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})\n    lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5), {1, 7, 1, 7, 1})\n    lu.assertEquals(candidate({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1, 6, 1})\n    lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})\n    lu.assertEquals(candidate({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})\n    lu.assertEquals(candidate({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})\n    lu.assertEquals(candidate({{1, 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})\n    lu.assertEquals(candidate({{1, 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n\n### Lua version\n\nmath = require('math')\nlocal function minPath(grid, k)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function encrypt(s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encrypt\n    lu.assertEquals(candidate('hi'), 'lm')\n    lu.assertEquals(candidate('asdfghjkl'), 'ewhjklnop')\n    lu.assertEquals(candidate('gf'), 'kj')\n    lu.assertEquals(candidate('et'), 'ix')\n    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')\n    lu.assertEquals(candidate('hellomyfriend'), 'lippsqcjvmirh')\n    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')\n    lu.assertEquals(candidate('a'), 'e')\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef encrypt(s: str) -> str:\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n\n### Lua version\n\nmath = require('math')\nlocal function encrypt(s)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function make_a_pile(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_a_pile\n    lu.assertEquals(candidate(3), {3, 5, 7})\n    lu.assertEquals(candidate(4), {4, 6, 8, 10})\n    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})\n    lu.assertEquals(candidate(6), {6, 8, 10, 12, 14, 16})\n    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16, 18, 20, 22})\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\nfrom typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    return [n + 2*i for i in range(n)]\n\n### Lua version\n\nmath = require('math')\nlocal function make_a_pile(n)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "lua",
    "prompt": "math = require('math')\nlocal function is_prime(n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_prime\n    lu.assertEquals(candidate(6), false)\n    lu.assertEquals(candidate(101), true)\n    lu.assertEquals(candidate(11), true)\n    lu.assertEquals(candidate(13441), true)\n    lu.assertEquals(candidate(61), true)\n    lu.assertEquals(candidate(4), false)\n    lu.assertEquals(candidate(1), false)\n    lu.assertEquals(candidate(5), true)\n    lu.assertEquals(candidate(11), true)\n    lu.assertEquals(candidate(17), true)\n    lu.assertEquals(candidate(85), false)\n    lu.assertEquals(candidate(77), false)\n    lu.assertEquals(candidate(255379), false)\nend\n\nos.exit(lu.LuaUnit.run())",
    "stop_tokens": [
      "\n--",
      "\n#",
      "\nend"
    ],
    "translation_prompt": "You are a helpful and faithful compiler that transpiles Python code to Lua code. Please translate the following Python code to Lua?\n\n### Python version\n\nfrom typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Python version\n\nfrom typing import List\n\ndef is_sorted(lst: List[int]) -> bool:\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i = 1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for _, v in pairs(count_digit) do\n        if v > 2 then\n            return false\n        end\n    end\n    for i = 2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Python version\n\nfrom typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Python version\n\nfrom typing import List\n\ndef sort_array(array: List[int]) -> List[int]:\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Python version\n\ndef is_prime(n:int) -> bool:\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n### Lua version\n\nmath = require('math')\nlocal function is_prime(n)\n"
  }
]