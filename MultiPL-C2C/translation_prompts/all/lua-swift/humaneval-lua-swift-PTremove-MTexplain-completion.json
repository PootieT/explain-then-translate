[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc correct_bracketing(brackets: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for i=1, #brackets do\n        if brackets:sub(i,i) == \"(\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc correct_bracketing(brackets: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc triangle_area(a: Int, h: Int) -> Double {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 5, h: 3) == 7.5)\nassert(triangle_area(a: 2, h: 2) == 2.0)\nassert(triangle_area(a: 10, h: 8) == 40.0)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, h)\n    return a * h / 2\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc triangle_area(a: Int, h: Int) -> Double {\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc special_factorial(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function special_factorial(n)\n  local fact_i = 1\n  local special_fact = 1\n  for i=1, n do\n    fact_i = fact_i * i\n    special_fact = special_fact * fact_i\n  end\n  return special_fact\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc special_factorial(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc move_one_ball(arr: [Int]) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)\nassert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)\nassert(move_one_ball(arr: [4, 3, 1, 2]) == false)\nassert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)\nassert(move_one_ball(arr: [] as [Int]) == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function move_one_ball(arr)\n  if #arr==0 then\n    return true\n  end\n  local sorted_array = {}\n  for i=1,#arr do\n    sorted_array[i]=arr[i]\n  end\n  table.sort(sorted_array)\n  local my_arr = {}\n  local min_value = math.min(table.unpack(arr))\n  local min_index = 1\n  for i=1,#arr do\n    if arr[i]==min_value then\n      min_index = i\n      break\n    end\n  end\n  for i=min_index,#arr do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,min_index-1 do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,#arr do\n    if my_arr[i]~=sorted_array[i] then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc move_one_ball(arr: [Int]) -> Bool {\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc digits(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digits(n: 5) == 5)\nassert(digits(n: 54) == 5)\nassert(digits(n: 120) == 1)\nassert(digits(n: 5014) == 5)\nassert(digits(n: 98765) == 315)\nassert(digits(n: 5576543) == 2625)\nassert(digits(n: 2468) == 0)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function digits(n)\n    local product = 1\n    local odd_count = 0\n    for digit in tostring(n):gmatch(\"%d\") do\n        local int_digit = tonumber(digit)\n        if int_digit%2 == 1 then\n            product= product*int_digit\n            odd_count=odd_count+1\n        end\n    end\n    if odd_count ==0 then\n        return 0\n    else\n        return product\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc digits(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc fib4(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib4(n: 5) == 4)\nassert(fib4(n: 8) == 28)\nassert(fib4(n: 10) == 104)\nassert(fib4(n: 12) == 386)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function fib4(n)\n  local results = {0, 0, 2, 0}\n  if n < 4 then\n    return results[n]\n  end\n\n  for i = 4, n do\n    table.insert(results, results[#results] + results[#results - 1] + results[#results - 2] + results[#results - 3])\n    table.remove(results, 1)\n  end\n\n  return results[#results]\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc fib4(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sort_even(l: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_even(l)\n    local evens = {}\n    local odds = {}\n    for i = 1, #l, 2 do\n        table.insert(evens, l[i])\n    end\n    for i = 2, #l, 2 do\n        table.insert(odds, l[i])\n    end\n    table.sort(evens)\n    local ans = {}\n    for i = 1, math.min(#evens, #odds) do\n        table.insert(ans, evens[i])\n        table.insert(ans, odds[i])\n    end\n    if #evens > #odds then\n        table.insert(ans, evens[#evens])\n    end\n    return ans\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sort_even(l: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_happy(s: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_happy(s)\n  if #s < 3 then\n    return false\n  end\n\n  for i = 1, #s - 2 do\n    if s:sub(i,i) == s:sub(i+1,i+1) or s:sub(i+1,i+1) == s:sub(i+2,i+2) or s:sub(i,i) == s:sub(i+2,i+2) then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_happy(s: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc circular_shift(x: Int, shift: Int) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(circular_shift(x: 100, shift: 2) == \"001\")\nassert(circular_shift(x: 12, shift: 2) == \"12\")\nassert(circular_shift(x: 97, shift: 8) == \"79\")\nassert(circular_shift(x: 12, shift: 1) == \"21\")\nassert(circular_shift(x: 11, shift: 101) == \"11\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function circular_shift(x, shift)\n    local s = tostring(x)\n    if shift > #s then\n        return s:reverse()\n    else\n        return s:sub(#s-shift+1) .. s:sub(1, #s-shift)\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc circular_shift(x: Int, shift: Int) -> String {\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function max_fill(grid, capacity)\n  local sum = 0\n  for i=1, #grid do\n    local row_sum = 0\n    for j=1, #grid[i] do\n      row_sum = row_sum + grid[i][j]\n    end\n    sum = sum + math.ceil(row_sum/capacity)\n  end\n  return sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function has_close_elements(numbers, threshold)\n  for idx, elem in ipairs(numbers) do\n    for idx2, elem2 in ipairs(numbers) do\n      if idx ~= idx2 then\n        local distance = math.abs(elem - elem2)\n        if distance < threshold then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\nassert(numerical_letter_grade(grades: [1.2]) == [\"D+\"])\nassert(numerical_letter_grade(grades: [0.5]) == [\"D-\"])\nassert(numerical_letter_grade(grades: [0.0]) == [\"E\"])\nassert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\nassert(numerical_letter_grade(grades: [0.0, 0.7]) == [\"E\", \"D-\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function numerical_letter_grade(grades)\n    letter_grade = {}\n    for i, gpa in ipairs(grades) do\n        if gpa == 4.0 then\n            table.insert(letter_grade, \"A+\")\n        elseif gpa > 3.7 then\n            table.insert(letter_grade, \"A\")\n        elseif gpa > 3.3 then\n            table.insert(letter_grade, \"A-\")\n        elseif gpa > 3.0 then\n            table.insert(letter_grade, \"B+\")\n        elseif gpa > 2.7 then\n            table.insert(letter_grade, \"B\")\n        elseif gpa > 2.3 then\n            table.insert(letter_grade, \"B-\")\n        elseif gpa > 2.0 then\n            table.insert(letter_grade, \"C+\")\n        elseif gpa > 1.7 then\n            table.insert(letter_grade, \"C\")\n        elseif gpa > 1.3 then\n            table.insert(letter_grade, \"C-\")\n        elseif gpa > 1.0 then\n            table.insert(letter_grade, \"D+\")\n        elseif gpa > 0.7 then\n            table.insert(letter_grade, \"D\")\n        elseif gpa > 0.0 then\n            table.insert(letter_grade, \"D-\")\n        else\n            table.insert(letter_grade, \"E\")\n        end\n    end\n    return letter_grade\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(x_or_y(n: 7, x: 34, y: 12) == 34)\nassert(x_or_y(n: 15, x: 8, y: 5) == 5)\nassert(x_or_y(n: 3, x: 33, y: 5212) == 33)\nassert(x_or_y(n: 1259, x: 3, y: 52) == 3)\nassert(x_or_y(n: 7919, x: -1, y: 12) == -1)\nassert(x_or_y(n: 3609, x: 1245, y: 583) == 583)\nassert(x_or_y(n: 91, x: 56, y: 129) == 129)\nassert(x_or_y(n: 6, x: 34, y: 1234) == 1234)\nassert(x_or_y(n: 1, x: 2, y: 0) == 0)\nassert(x_or_y(n: 2, x: 2, y: 0) == 2)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function x_or_y(n, x, y)\n    if n == 1 then\n        return y\n    end\n    for i=2, n-1 do\n        if n%i == 0 then\n            return y\n        end\n    end\n    return x\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc specialFilter(nums: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(specialFilter(nums: [5, -2, 1, -5]) == 0)\nassert(specialFilter(nums: [15, -73, 14, -15]) == 1)\nassert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)\nassert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)\nassert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)\nassert(specialFilter(nums: [1]) == 0)\nassert(specialFilter(nums: [] as [Int]) == 0)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function specialFilter(nums)\n    local count = 0\n    for _, num in ipairs(nums) do\n        if num > 10 then\n            local odd_digits = {1, 3, 5, 7, 9}\n            local number_as_string = tostring(num)\n            if math.floor(num / 10^(#number_as_string - 1)) % 2 == 1 and num % 10 % 2 == 1 then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc specialFilter(nums: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc parse_music(music_string: String) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function parse_music(music_string)\n    local note_map = {o=4, ['o|']=2, ['.|']=1}\n    local notes = {}\n    for x in music_string:gmatch(\"%S+\") do\n        table.insert(notes, note_map[x])\n    end\n    return notes\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc parse_music(music_string: String) -> [Int] {\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\n\nextension Int: Error {}\nfunc split_words(txt: String) -> Result<[String], Int> {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function split_words(txt)\n    if string.find(txt, \" \") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt, \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    elseif string.find(txt, \",\") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt:gsub(\",\", \" \"), \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    else\n        local count = 0\n        for i = 1, #txt do\n            if string.match(txt:sub(i, i), \"%l\") and string.byte(txt:sub(i, i)) % 2 == 0 then\n                count = count + 1\n            end\n        end\n        return count\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\n\nextension Int: Error {}\nfunc split_words(txt: String) -> Result<[String], Int> {\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc count_distinct_characters(string: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_distinct_characters(string: \"\") == 0)\nassert(count_distinct_characters(string: \"abcde\") == 5)\nassert(count_distinct_characters(string: \"abcdecadeCADE\") == 5)\nassert(count_distinct_characters(string: \"aaaaAAAAaaaa\") == 1)\nassert(count_distinct_characters(string: \"Jerry jERRY JeRRRY\") == 5)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function count_distinct_characters(string)\n    local set = {}\n    for i=1, #string do\n        set[string:sub(i, i):lower()] = true\n    end\n    local count = 0\n    for k, v in pairs(set) do\n        count = count + 1\n    end\n    return count\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc count_distinct_characters(string: String) -> Int {\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc bf(planet1: String, planet2: String) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function bf(planet1, planet2)\n    local planet_names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    if not (table.concat(planet_names, ','):find(planet1) and table.concat(planet_names, ','):find(planet2)) or planet1 == planet2 then\n        return {}\n    end\n    local planet1_index = 0\n    local planet2_index = 0\n    for i, planet in ipairs(planet_names) do\n        if planet == planet1 then\n            planet1_index = i\n        elseif planet == planet2 then\n            planet2_index = i\n        end\n    end\n    if planet1_index < planet2_index then\n        return {table.unpack(planet_names, planet1_index + 1, planet2_index - 1)}\n    else\n        return {table.unpack(planet_names, planet2_index + 1, planet1_index - 1)}\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc bf(planet1: String, planet2: String) -> [String] {\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc digitSum(s: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digitSum(s: \"\") == 0)\nassert(digitSum(s: \"abAB\") == 131)\nassert(digitSum(s: \"abcCd\") == 67)\nassert(digitSum(s: \"helloE\") == 69)\nassert(digitSum(s: \"woArBld\") == 131)\nassert(digitSum(s: \"aAaaaXa\") == 153)\nassert(digitSum(s: \" How are yOu?\") == 151)\nassert(digitSum(s: \"You arE Very Smart\") == 327)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function digitSum(s)\n    if s == \"\" then return 0 end\n    local sum = 0\n    for char in s:gmatch(\".\") do\n        sum = sum + (char:match(\"%u\") and string.byte(char) or 0)\n    end\n    return sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc digitSum(s: String) -> Int {\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sum_squares(lst: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_squares(lst: [1, 2, 3]) == 6)\nassert(sum_squares(lst: [1, 4, 9]) == 14)\nassert(sum_squares(lst: [] as [Int]) == 0)\nassert(sum_squares(lst: [1, 1, 1, 1, 1, 1, 1, 1, 1]) == 9)\nassert(sum_squares(lst: [-1, -1, -1, -1, -1, -1, -1, -1, -1]) == -3)\nassert(sum_squares(lst: [0]) == 0)\nassert(sum_squares(lst: [-1, -5, 2, -1, -5]) == -126)\nassert(sum_squares(lst: [-56, -99, 1, 0, -2]) == 3030)\nassert(sum_squares(lst: [-1, 0, 0, 0, 0, 0, 0, 0, -1]) == 0)\nassert(sum_squares(lst: [-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196)\nassert(sum_squares(lst: [-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n    local result = {}\n    for i=1, #lst do\n        if i % 3 == 1 then\n            result[#result+1] = lst[i]^2\n        elseif i % 4 == 1 and i % 3 ~= 1 then\n            result[#result+1] = lst[i]^3\n        else\n            result[#result+1] = lst[i]\n        end\n    end\n    local sum = 0\n    for i=1, #result do\n        sum = sum + result[i]\n    end\n    return sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sum_squares(lst: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc count_up_to(n: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_up_to(n: 5) == [2, 3])\nassert(count_up_to(n: 6) == [2, 3, 5])\nassert(count_up_to(n: 7) == [2, 3, 5])\nassert(count_up_to(n: 10) == [2, 3, 5, 7])\nassert(count_up_to(n: 0) == [] as [Int])\nassert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])\nassert(count_up_to(n: 1) == [] as [Int])\nassert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])\nassert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\nassert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function count_up_to(n)\n  local primes = {}\n  for i = 2, n - 1 do\n    local is_prime = true\n    for j = 2, i - 1 do\n      if i % j == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(primes, i)\n    end\n  end\n  return primes\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc count_up_to(n: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sum_squares(lst: [Double]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)\nassert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)\nassert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)\nassert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)\nassert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)\nassert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)\nassert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)\nassert(sum_squares(lst: [0.0]) == 0)\nassert(sum_squares(lst: [-1.0]) == 1)\nassert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n  local squared = 0\n  for _, i in ipairs(lst) do\n    squared = squared + math.ceil(i)^2\n  end\n  return squared\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sum_squares(lst: [Double]) -> Int {\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc unique(l: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function unique(l)\n  local s = {}\n  for _, v in ipairs(l) do\n    s[v] = true\n  end\n  local r = {}\n  for k, _ in pairs(s) do\n    table.insert(r, k)\n  end\n  table.sort(r)\n  return r\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc unique(l: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc fib(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib(n: 10) == 55)\nassert(fib(n: 1) == 1)\nassert(fib(n: 8) == 21)\nassert(fib(n: 11) == 89)\nassert(fib(n: 12) == 144)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function fib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc fib(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc fizz_buzz(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fizz_buzz(n: 50) == 0)\nassert(fizz_buzz(n: 78) == 2)\nassert(fizz_buzz(n: 79) == 3)\nassert(fizz_buzz(n: 100) == 3)\nassert(fizz_buzz(n: 200) == 6)\nassert(fizz_buzz(n: 4000) == 192)\nassert(fizz_buzz(n: 10000) == 639)\nassert(fizz_buzz(n: 100000) == 8026)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function fizz_buzz(n)\n  local ns = {}\n  for i = 0, n - 1 do\n    if i % 11 == 0 or i % 13 == 0 then\n      table.insert(ns, i)\n    end\n  end\n  local s = table.concat(ns)\n  local ans = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '7' then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc fizz_buzz(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function Strongest_Extension(class_name, extensions)\n    local strong = extensions[1]\n    local my_val = #extensions[1]:gsub('[^%a]', ''):gsub('[^%u]', '') - #extensions[1]:gsub('[^%a]', ''):gsub('[^%l]', '')\n    for i = 2, #extensions do\n        local s = extensions[i]\n        local val = #s:gsub('[^%a]', ''):gsub('[^%u]', '') - #s:gsub('[^%a]', ''):gsub('[^%l]', '')\n        if val > my_val then\n            strong = s\n            my_val = val\n        end\n    end\n    return class_name .. '.' .. strong\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function find_closest_elements(numbers)\n    local closest_pair = nil\n    local distance = nil\n\n    for idx, elem in ipairs(numbers) do\n        for idx2, elem2 in ipairs(numbers) do\n            if idx ~= idx2 then\n                if distance == nil then\n                    distance = math.abs(elem - elem2)\n                    closest_pair = {elem, elem2}\n                else\n                    new_distance = math.abs(elem - elem2)\n                    if new_distance < distance then\n                        distance = new_distance\n                        closest_pair = {elem, elem2}\n                    end\n                end\n            end\n        end\n    end\n\n    table.sort(closest_pair)\n    return closest_pair\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc valid_date(date: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(valid_date(date: \"03-11-2000\") == true)\nassert(valid_date(date: \"15-01-2012\") == false)\nassert(valid_date(date: \"04-0-2040\") == false)\nassert(valid_date(date: \"06-04-2020\") == true)\nassert(valid_date(date: \"01-01-2007\") == true)\nassert(valid_date(date: \"03-32-2011\") == false)\nassert(valid_date(date: \"\") == false)\nassert(valid_date(date: \"04-31-3000\") == false)\nassert(valid_date(date: \"06-06-2005\") == true)\nassert(valid_date(date: \"21-31-2000\") == false)\nassert(valid_date(date: \"04-12-2003\") == true)\nassert(valid_date(date: \"04122003\") == false)\nassert(valid_date(date: \"20030412\") == false)\nassert(valid_date(date: \"2003-04\") == false)\nassert(valid_date(date: \"2003-04-12\") == false)\nassert(valid_date(date: \"04-2003\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function valid_date(date)\n    local month, day, year = date:match(\"(%d+)-(%d+)-(%d+)\")\n    if not month or not day or not year then\n        return false\n    end\n    month, day, year = tonumber(month), tonumber(day), tonumber(year)\n    if month < 1 or month > 12 then\n        return false\n    end\n    if month == 2 and (day < 1 or day > 29) then\n        return false\n    end\n    if month == 4 or month == 6 or month == 9 or month == 11 then\n        if day < 1 or day > 30 then\n            return false\n        end\n    else\n        if day < 1 or day > 31 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc valid_date(date: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc add(x: Int, y: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(x: 0, y: 1) == 1)\nassert(add(x: 1, y: 0) == 1)\nassert(add(x: 2, y: 3) == 5)\nassert(add(x: 5, y: 7) == 12)\nassert(add(x: 7, y: 5) == 12)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function add(x, y)\n  return x + y\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc add(x: Int, y: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)\nassert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)\nassert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)\nassert(triples_sum_to_zero(l: [1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)\nassert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function triples_sum_to_zero(l)\n  for i = 1, #l do\n    for j = i + 1, #l do\n      for k = j + 1, #l do\n        if l[i] + l[j] + l[k] == 0 then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc largest_divisor(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_divisor(n: 3) == 1)\nassert(largest_divisor(n: 7) == 1)\nassert(largest_divisor(n: 10) == 5)\nassert(largest_divisor(n: 100) == 50)\nassert(largest_divisor(n: 49) == 7)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function largest_divisor(n)\n    for i=n-1, 1, -1 do\n        if n % i == 0 then\n            return i\n        end\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc largest_divisor(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sort_numbers(numbers: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_numbers(numbers: \"\") == \"\")\nassert(sort_numbers(numbers: \"three\") == \"three\")\nassert(sort_numbers(numbers: \"three five nine\") == \"three five nine\")\nassert(sort_numbers(numbers: \"five zero four seven nine eight\") == \"zero four five seven eight nine\")\nassert(sort_numbers(numbers: \"six five four three two one zero\") == \"zero one two three four five six\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_numbers(numbers)\n    local value_map = {\n        zero = 0,\n        one = 1,\n        two = 2,\n        three = 3,\n        four = 4,\n        five = 5,\n        six = 6,\n        seven = 7,\n        eight = 8,\n        nine = 9\n    }\n    local words = {}\n    for word in numbers:gmatch(\"%w+\") do\n        table.insert(words, word)\n    end\n    table.sort(words, function(a, b) return value_map[a] < value_map[b] end)\n    return table.concat(words, ' ')\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sort_numbers(numbers: String) -> String {\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc smallest_change(arr: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)\nassert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)\nassert(smallest_change(arr: [3, 1, 1, 3]) == 0)\nassert(smallest_change(arr: [1]) == 0)\nassert(smallest_change(arr: [0, 1]) == 1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function smallest_change(arr)\n  local ans = 0\n  for i = 1, math.floor(#arr / 2) do\n    if arr[i] ~= arr[#arr - i + 1] then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc smallest_change(arr: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)\nassert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function below_threshold(l, t)\n  for _, e in ipairs(l) do\n    if e >= t then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc prod_signs(arr: [Int]) -> Int? {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n    local prod = 0\n    local neg_count = 0\n    for i = 1, #arr do\n        if arr[i] == 0 then\n            return 0\n        end\n        if arr[i] < 0 then\n            neg_count = neg_count + 1\n        end\n    end\n    prod = math.pow(-1, neg_count)\n    local sum = 0\n    for i = 1, #arr do\n        sum = sum + math.abs(arr[i])\n    end\n    return prod * sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc prod_signs(arr: [Int]) -> Int? {\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc modp(n: Int, p: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function modp(n, p)\n    local ret = 1\n    for i=1, n do\n        ret = (2 * ret) % p\n    end\n    return ret\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc modp(n: Int, p: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc count_upper(s: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function count_upper(s)\n    local count = 0\n    for i = 1, #s, 2 do\n        if s:sub(i, i):match(\"[AEIOU]\") then\n            count = count + 1\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc count_upper(s: String) -> Int {\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc multiply(a: Int, b: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply(a: 148, b: 412) == 16)\nassert(multiply(a: 19, b: 28) == 72)\nassert(multiply(a: 2020, b: 1851) == 0)\nassert(multiply(a: 14, b: -15) == 20)\nassert(multiply(a: 76, b: 67) == 42)\nassert(multiply(a: 17, b: 27) == 49)\nassert(multiply(a: 0, b: 1) == 0)\nassert(multiply(a: 0, b: 0) == 0)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function multiply(a, b)\n  return math.abs(a % 10) * math.abs(b % 10)\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc multiply(a: Int, b: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc unique_digits(x: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])\nassert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])\nassert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])\nassert(unique_digits(x: [135, 103, 31]) == [31, 135])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function unique_digits(x)\n    local odd_digit_elements = {}\n    for i=1, #x do\n        if string.match(tostring(x[i]), '^[13579]+$') then\n            table.insert(odd_digit_elements, x[i])\n        end\n    end\n    table.sort(odd_digit_elements)\n    return odd_digit_elements\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc unique_digits(x: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_multiply_prime(a: Int) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_multiply_prime(a: 5) == false)\nassert(is_multiply_prime(a: 30) == true)\nassert(is_multiply_prime(a: 8) == true)\nassert(is_multiply_prime(a: 10) == false)\nassert(is_multiply_prime(a: 125) == true)\nassert(is_multiply_prime(a: 105) == true)\nassert(is_multiply_prime(a: 126) == false)\nassert(is_multiply_prime(a: 729) == false)\nassert(is_multiply_prime(a: 891) == false)\nassert(is_multiply_prime(a: 1001) == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_multiply_prime(a)\n  local function is_prime(n)\n    for j = 2, n-1 do\n      if n%j == 0 then\n        return false\n      end\n    end\n    return true\n  end\n\n  for i = 2, 100 do\n    if not is_prime(i) then goto continue1 end\n    for j = 2, 100 do\n      if not is_prime(j) then goto continue2 end\n      for k = 2, 100 do\n        if not is_prime(k) then goto continue3 end\n        if i*j*k == a then return true end\n        ::continue3::\n      end\n      ::continue2::\n    end\n    ::continue1::\n  end\n  return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_multiply_prime(a: Int) -> Bool {\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function maximum(arr, k)\n    if k == 0 then\n        return {}\n    end\n    table.sort(arr)\n    local ans = {}\n    for i=#arr-k+1, #arr do\n        table.insert(ans, arr[i])\n    end\n    return ans\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc separate_paren_groups(paren_string: String) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc separate_paren_groups(paren_string: String) -> [String] {\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])\nassert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, \"adasd\"]) == [4, 9])\nassert(filter_integers(values: [3, \"c\", 3, 3, \"a\", \"b\"]) == [3, 3, 3])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_integers(values)\n  local result = {}\n  for _, x in ipairs(values) do\n    if type(x) == 'number' and math.floor(x) == x then\n      table.insert(result, x)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc skjkasdkd(lst: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)\nassert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)\nassert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)\nassert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)\nassert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)\nassert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)\nassert(skjkasdkd(lst: [8191]) == 19)\nassert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)\nassert(skjkasdkd(lst: [127, 97, 8192]) == 10)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function skjkasdkd(lst)\n  local function isPrime(n)\n    for i = 2, math.floor(n^0.5) do\n      if n % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local maxx = 0\n  local i = 1\n  while i <= #lst do\n    if lst[i] > maxx and isPrime(lst[i]) then\n      maxx = lst[i]\n    end\n    i = i + 1\n  end\n  local result = 0\n  for digit in tostring(maxx):gmatch('%d') do\n    result = result + tonumber(digit)\n  end\n  return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc skjkasdkd(lst: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"]) == [\"4\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [] as [String], lst2: [\"this\"]) == [] as [String])\nassert(total_match(lst1: [\"this\"], lst2: [] as [String]) == [] as [String])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function total_match(lst1, lst2)\n    local l1 = 0\n    for i = 1, #lst1 do\n        l1 = l1 + #lst1[i]\n    end\n\n    local l2 = 0\n    for i = 1, #lst2 do\n        l2 = l2 + #lst2[i]\n    end\n\n    if l1 <= l2 then\n        return lst1\n    else\n        return lst2\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc car_race_collision(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(car_race_collision(n: 2) == 4)\nassert(car_race_collision(n: 3) == 9)\nassert(car_race_collision(n: 4) == 16)\nassert(car_race_collision(n: 8) == 64)\nassert(car_race_collision(n: 10) == 100)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function car_race_collision(n)\n    return n^2\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc car_race_collision(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_simple_power(x: 16, n: 2) == true)\nassert(is_simple_power(x: 143214, n: 16) == false)\nassert(is_simple_power(x: 4, n: 2) == true)\nassert(is_simple_power(x: 9, n: 3) == true)\nassert(is_simple_power(x: 16, n: 4) == true)\nassert(is_simple_power(x: 24, n: 2) == false)\nassert(is_simple_power(x: 128, n: 4) == false)\nassert(is_simple_power(x: 12, n: 6) == false)\nassert(is_simple_power(x: 1, n: 1) == true)\nassert(is_simple_power(x: 1, n: 12) == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_simple_power(x, n)\n    if n == 1 then\n        return x == 1\n    end\n    local power = 1\n    while power < x do\n        power = power * n\n    end\n    return power == x\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc encode(message: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function encode(message)\n  local vowels = \"aeiouAEIOU\"\n  local vowels_replace = {}\n  for i = 1, #vowels do\n    vowels_replace[vowels:sub(i, i)] = string.char(string.byte(vowels:sub(i, i)) + 2)\n  end\n  message = message:gsub(\"%a\", function(c)\n    return c == c:upper() and c:lower() or c:upper()\n  end)\n  return message:gsub(\".\", function(c)\n    return vowels_replace[c] or c\n  end)\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc encode(message: String) -> String {\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc incr_list(l: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function incr_list(l)\n  local res = {}\n  for i = 1, #l do\n    res[i] = l[i] + 1\n  end\n  return res\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc incr_list(l: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc flip_case(string: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(flip_case(string: \"\") == \"\")\nassert(flip_case(string: \"Hello!\") == \"hELLO!\")\nassert(flip_case(string: \"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function flip_case(string)\n    return string:gsub(\"%a\", function(c) return c:match(\"%l\") and c:upper() or c:lower() end)\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc flip_case(string: String) -> String {\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc vowels_count(s: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(vowels_count(s: \"abcde\") == 2)\nassert(vowels_count(s: \"Alone\") == 3)\nassert(vowels_count(s: \"key\") == 2)\nassert(vowels_count(s: \"bye\") == 1)\nassert(vowels_count(s: \"keY\") == 2)\nassert(vowels_count(s: \"bYe\") == 1)\nassert(vowels_count(s: \"ACEDY\") == 3)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function vowels_count(s)\n  local vowels = \"aeiouAEIOU\"\n  local n_vowels = 0\n  for i = 1, #s do\n    if string.find(vowels, s:sub(i, i), 1, true) then\n      n_vowels = n_vowels + 1\n    end\n  end\n  if s:sub(-1) == 'y' or s:sub(-1) == 'Y' then\n    n_vowels = n_vowels + 1\n  end\n  return n_vowels\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc vowels_count(s: String) -> Int {\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc words_string(s: String) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_string(s: \"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\nassert(words_string(s: \"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"Hi, my name\") == [\"Hi\", \"my\", \"name\"])\nassert(words_string(s: \"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"\") == [] as [String])\nassert(words_string(s: \"ahmed     , gamal\") == [\"ahmed\", \"gamal\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function words_string(s)\n    if not s then\n        return {}\n    end\n\n    local s_list = {}\n\n    for i=1, #s do\n        local letter = s:sub(i, i)\n        if letter == ',' then\n            table.insert(s_list, ' ')\n        else\n            table.insert(s_list, letter)\n        end\n    end\n\n    s_list = table.concat(s_list)\n    local words = {}\n    for word in s_list:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n    return words\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc words_string(s: String) -> [String] {\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_palindrome(n: 123) == (8, 13))\nassert(even_odd_palindrome(n: 12) == (4, 6))\nassert(even_odd_palindrome(n: 3) == (1, 2))\nassert(even_odd_palindrome(n: 63) == (6, 8))\nassert(even_odd_palindrome(n: 25) == (5, 6))\nassert(even_odd_palindrome(n: 19) == (4, 6))\nassert(even_odd_palindrome(n: 9) == (4, 5))\nassert(even_odd_palindrome(n: 1) == (0, 1))",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 3, b: 4, c: 5) == 6.0)\nassert(triangle_area(a: 1, b: 2, c: 10) == -1)\nassert(triangle_area(a: 4, b: 8, c: 5) == 8.18)\nassert(triangle_area(a: 2, b: 2, c: 2) == 1.73)\nassert(triangle_area(a: 1, b: 2, c: 3) == -1)\nassert(triangle_area(a: 10, b: 5, c: 7) == 16.25)\nassert(triangle_area(a: 2, b: 6, c: 3) == -1)\nassert(triangle_area(a: 1, b: 1, c: 1) == 0.43)\nassert(triangle_area(a: 2, b: 2, c: 10) == -1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, b, c)\n    if a + b <= c or a + c <= b or b + c <= a then\n        return -1 \n    end\n    s = (a + b + c)/2    \n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = math.floor(area * 100 + 0.5) / 100\n    return area\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc check_dict_case(dict: [String : String]) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_dict_case(dict: [\"p\" : \"pineapple\", \"b\" : \"banana\"]) == true)\nassert(check_dict_case(dict: [\"p\" : \"pineapple\", \"A\" : \"banana\", \"B\" : \"banana\"]) == false)\nassert(check_dict_case(dict: [\"p\" : \"pineapple\", \"5\" : \"banana\", \"a\" : \"apple\"]) == false)\nassert(check_dict_case(dict: [\"Name\" : \"John\", \"Age\" : \"36\", \"City\" : \"Houston\"]) == false)\nassert(check_dict_case(dict: [\"STATE\" : \"NC\", \"ZIP\" : \"12345\"]) == true)\nassert(check_dict_case(dict: [\"fruit\" : \"Orange\", \"taste\" : \"Sweet\"]) == true)\nassert(check_dict_case(dict: [:] as [String : String]) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function check_dict_case(dict)\n    if next(dict) == nil then\n        return false\n    else\n        local state = \"start\"\n        for key, value in pairs(dict) do\n            if type(key) ~= \"string\" then\n                state = \"mixed\"\n                break\n            end\n            if state == \"start\" then\n                if key:upper() == key then\n                    state = \"upper\"\n                elseif key:lower() == key then\n                    state = \"lower\"\n                else\n                    break\n                end\n            elseif (state == \"upper\" and key:upper() ~= key) or (state == \"lower\" and key:lower() ~= key) then\n                state = \"mixed\"\n                break\n            end\n        end\n        return state == \"upper\" or state == \"lower\"\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc check_dict_case(dict: [String : String]) -> Bool {\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc median(l: [Int]) -> Double {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function median(l)\n  table.sort(l)\n  if #l % 2 == 1 then\n    return l[math.floor(#l / 2) + 1]\n  else\n    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n  end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc median(l: [Int]) -> Double {\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc change_base(x: Int, base: Int) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(change_base(x: 8, base: 3) == \"22\")\nassert(change_base(x: 9, base: 3) == \"100\")\nassert(change_base(x: 234, base: 2) == \"11101010\")\nassert(change_base(x: 16, base: 2) == \"10000\")\nassert(change_base(x: 8, base: 2) == \"1000\")\nassert(change_base(x: 7, base: 2) == \"111\")\nassert(change_base(x: 2, base: 3) == \"2\")\nassert(change_base(x: 3, base: 4) == \"3\")\nassert(change_base(x: 4, base: 5) == \"4\")\nassert(change_base(x: 5, base: 6) == \"5\")\nassert(change_base(x: 6, base: 7) == \"6\")\nassert(change_base(x: 7, base: 8) == \"7\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function change_base(x, base)\n  local ret = \"\"\n  while x > 0 do\n    ret = tostring(x % base) .. ret\n    x = math.floor(x / base)\n  end\n  return ret\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc change_base(x: Int, base: Int) -> String {\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc longest(strings: [String]) -> String? {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function longest(strings)\n    if not strings then\n        return nil\n    end\n\n    local maxlen = 0\n    for _, s in ipairs(strings) do\n        maxlen = math.max(maxlen, #s)\n    end\n\n    for _, s in ipairs(strings) do\n        if #s == maxlen then\n            return s\n        end\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc longest(strings: [String]) -> String? {\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function common(l1, l2)\n    local ret = {}\n    local set_l2 = {}\n    for i=1, #l2 do\n        set_l2[l2[i]] = true\n    end\n    for i=1, #l1 do\n        if set_l2[l1[i]] then\n            table.insert(ret, l1[i])\n        end\n    end\n    table.sort(ret)\n    return ret\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc cycpattern_check(a: String, b: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cycpattern_check(a: \"xyzw\", b: \"xyw\") == false)\nassert(cycpattern_check(a: \"yello\", b: \"ell\") == true)\nassert(cycpattern_check(a: \"whattup\", b: \"ptut\") == false)\nassert(cycpattern_check(a: \"efef\", b: \"fee\") == true)\nassert(cycpattern_check(a: \"abab\", b: \"aabb\") == false)\nassert(cycpattern_check(a: \"winemtt\", b: \"tinem\") == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function cycpattern_check(a, b)\n  local l = #b\n  local pat = b .. b\n  for i = 1, #a - l + 1 do\n    for j = 1, l + 1 do\n      if a:sub(i, i + l - 1) == pat:sub(j, j + l - 1) then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc cycpattern_check(a: String, b: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc minSubArraySum(nums: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)\nassert(minSubArraySum(nums: [-1, -2, -3]) == -6)\nassert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)\nassert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)\nassert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)\nassert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)\nassert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)\nassert(minSubArraySum(nums: [-10]) == -10)\nassert(minSubArraySum(nums: [7]) == 7)\nassert(minSubArraySum(nums: [1, -1]) == -1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function minSubArraySum(nums)\n    local max_sum = 0\n    local s = 0\n    for i=1, #nums do\n        s = s - nums[i]\n        if s < 0 then\n            s = 0\n        end\n        max_sum = math.max(s, max_sum)\n    end\n    if max_sum == 0 then\n        max_sum = -math.huge\n        for i=1, #nums do\n            max_sum = math.max(max_sum, -nums[i])\n        end\n    end\n    local min_sum = -max_sum\n    return min_sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc minSubArraySum(nums: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sort_array(array: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(array: [] as [Int]) == [] as [Int])\nassert(sort_array(array: [5]) == [5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\nassert(sort_array(array: [2, 1]) == [1, 2])\nassert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\nassert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sort_array(array: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc histogram(test: String) -> [String : Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function histogram(test)\n    local dict1 = {}\n    local list1 = {}\n    for word in test:gmatch(\"%w+\") do\n        table.insert(list1, word)\n    end\n    local t = 0\n    for i=1, #list1 do\n        if list1[i] ~= '' and list1[i] ~= nil then\n            if list1.count == nil then\n                list1.count = function(list, value)\n                    local count = 0\n                    for i=1, #list do\n                        if list[i] == value then\n                            count = count + 1\n                        end\n                    end\n                    return count\n                end\n            end\n            if list1:count(list1[i]) > t then\n                t = list1:count(list1[i])\n            end\n        end\n    end\n    if t > 0 then\n        for i=1, #list1 do\n            if list1[i] ~= '' and list1[i] ~= nil then\n                if list1:count(list1[i]) == t then\n                    dict1[list1[i]] = t\n                end\n            end\n        end\n    end\n    return dict1\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc histogram(test: String) -> [String : Int] {\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc get_odd_collatz(n: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function get_odd_collatz(n)\n    local odd_collatz = (n%2==0) and {} or {n}\n    while n > 1 do\n        if n % 2 == 0 then\n            n = n/2\n        else\n            n = n*3 + 1\n        end\n        if n%2 == 1 then\n            table.insert(odd_collatz, math.floor(n))\n        end\n    end\n    table.sort(odd_collatz)\n    return odd_collatz\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc get_odd_collatz(n: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc derivative(xs: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])\nassert(derivative(xs: [1, 2, 3]) == [2, 6])\nassert(derivative(xs: [3, 2, 1]) == [2, 2])\nassert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])\nassert(derivative(xs: [1]) == [] as [Int])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function derivative(xs)\n    local result = {}\n    for i=1, #xs-1 do\n        result[i] = i * xs[i+1]\n    end\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc derivative(xs: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc fibfib(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fibfib(n: 2) == 1)\nassert(fibfib(n: 1) == 0)\nassert(fibfib(n: 5) == 4)\nassert(fibfib(n: 8) == 24)\nassert(fibfib(n: 10) == 81)\nassert(fibfib(n: 12) == 274)\nassert(fibfib(n: 14) == 927)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function fibfib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    end\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc fibfib(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc truncate_number(number: Double) -> Double {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function truncate_number(number)\n    return number % 1\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc truncate_number(number: Double) -> Double {\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc max_element(l: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function max_element(l)\n    local m = l[1]\n    for i=2, #l do\n        if l[i] > m then\n            m = l[i]\n        end\n    end\n    return m\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc max_element(l: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc closest_integer(value: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if value:find('%.5$') then\n        if num > 0 then\n            return math.ceil(num)\n        else\n            return math.floor(num)\n        end\n    elseif #value > 0 then\n        return math.floor(num + 0.5)\n    else\n        return 0\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc closest_integer(value: String) -> Int {\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc prime_fib(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_fib(n: 1) == 2)\nassert(prime_fib(n: 2) == 3)\nassert(prime_fib(n: 3) == 5)\nassert(prime_fib(n: 4) == 13)\nassert(prime_fib(n: 5) == 89)\nassert(prime_fib(n: 6) == 233)\nassert(prime_fib(n: 7) == 1597)\nassert(prime_fib(n: 8) == 28657)\nassert(prime_fib(n: 9) == 514229)\nassert(prime_fib(n: 10) == 433494437)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function prime_fib(n)\n  local function is_prime(p)\n    if p < 2 then\n      return false\n    end\n    for k = 2, math.min(math.sqrt(p) + 1, p - 1) do\n      if p % k == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local f = {0, 1}\n  while true do\n    table.insert(f, f[#f] + f[#f - 1])\n    if is_prime(f[#f]) then\n      n = n - 1\n    end\n    if n == 0 then\n      return f[#f]\n    end\n  end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc prime_fib(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_product(numbers: [] as [Int]) == (0, 1))\nassert(sum_product(numbers: [1, 1, 1]) == (3, 1))\nassert(sum_product(numbers: [100, 0]) == (100, 0))\nassert(sum_product(numbers: [3, 5, 7]) == (15, 105))\nassert(sum_product(numbers: [10]) == (10, 10))",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_product(numbers)\n    local sum_value = 0\n    local prod_value = 1\n\n    for _, n in ipairs(numbers) do\n        sum_value = sum_value + n\n        prod_value = prod_value * n\n    end\n    return {sum_value, prod_value}\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc select_words(s: String, n: Int) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function select_words(s, n)\n  local result = {}\n  for word in s:gmatch(\"%S+\") do\n    local n_consonants = 0\n    for i = 1, #word do\n      if not word:sub(i,i):lower():find(\"[aeiou]\") then\n        n_consonants = n_consonants + 1\n      end\n    end\n    if n_consonants == n then\n      table.insert(result, word)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc select_words(s: String, n: Int) -> [String] {\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc add_elements(arr: [Int], k: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)\nassert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)\nassert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)\nassert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)\nassert(add_elements(arr: [1], k: 1) == 1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function add_elements(arr, k)\n  local sum = 0\n  for i = 1, k do\n    if #tostring(arr[i]) <= 2 then\n      sum = sum + arr[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc add_elements(arr: [Int], k: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function eat(number, need, remaining)\n    if need <= remaining then\n        return {number + need, remaining - need}\n    else\n        return {number + remaining, 0}\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc odd_count(lst: [String]) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_count(lst: [\"1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\nassert(odd_count(lst: [\"3\", \"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\nassert(odd_count(lst: [\"271\", \"137\", \"314\"]) == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function odd_count(lst)\n  local res = {}\n  for _, arr in ipairs(lst) do\n    local n = 0\n    for d in arr:gmatch('%d') do\n      if math.fmod(tonumber(d), 2) == 1 then\n        n = n + 1\n      end\n    end\n    table.insert(res, \"the number of odd elements \" .. n .. \"n the str\" .. n .. \"ng \" .. n .. \" of the \" .. n .. \"nput.\")\n  end\n  return res\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc odd_count(lst: [String]) -> [String] {\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc next_smallest(lst: [Int]) -> Int? {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function next_smallest(lst)\n    table.sort(lst)\n    for i = 2, #lst do\n        if lst[i] > lst[1] then\n            return lst[i]\n        end\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc next_smallest(lst: [Int]) -> Int? {\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_prefix(strings, prefix)\n    local res = {}\n    for _, x in ipairs(strings) do\n        if string.sub(x, 1, #prefix) == prefix then\n            table.insert(res, x)\n        end\n    end\n    return res\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc choose_num(x: Int, y: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(choose_num(x: 12, y: 15) == 14)\nassert(choose_num(x: 13, y: 12) == -1)\nassert(choose_num(x: 33, y: 12354) == 12354)\nassert(choose_num(x: 5234, y: 5233) == -1)\nassert(choose_num(x: 6, y: 29) == 28)\nassert(choose_num(x: 27, y: 10) == -1)\nassert(choose_num(x: 7, y: 7) == -1)\nassert(choose_num(x: 546, y: 546) == 546)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function choose_num(x, y)\n    if x > y then\n        return -1\n    end\n    if y % 2 == 0 then\n        return y\n    end\n    if x == y then\n        return -1\n    end\n    return y - 1\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc choose_num(x: Int, y: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc prime_length(string: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_length(string: \"Hello\") == true)\nassert(prime_length(string: \"abcdcba\") == true)\nassert(prime_length(string: \"kittens\") == true)\nassert(prime_length(string: \"orange\") == false)\nassert(prime_length(string: \"wow\") == true)\nassert(prime_length(string: \"world\") == true)\nassert(prime_length(string: \"MadaM\") == true)\nassert(prime_length(string: \"Wow\") == true)\nassert(prime_length(string: \"\") == false)\nassert(prime_length(string: \"HI\") == true)\nassert(prime_length(string: \"go\") == true)\nassert(prime_length(string: \"gogo\") == false)\nassert(prime_length(string: \"aaaaaaaaaaaaaaa\") == false)\nassert(prime_length(string: \"Madam\") == true)\nassert(prime_length(string: \"M\") == false)\nassert(prime_length(string: \"0\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function prime_length(string)\n  local l = #string\n  if l == 0 or l == 1 then\n    return false\n  end\n  for i = 2, l - 1 do\n    if l % i == 0 then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc prime_length(string: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sum_to_n(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_to_n(n: 1) == 1)\nassert(sum_to_n(n: 6) == 21)\nassert(sum_to_n(n: 11) == 66)\nassert(sum_to_n(n: 30) == 465)\nassert(sum_to_n(n: 100) == 5050)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_to_n(n)\n  return (n * (n + 1)) / 2\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sum_to_n(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc fix_spaces(text: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fix_spaces(text: \"Example\") == \"Example\")\nassert(fix_spaces(text: \"Mudasir Hanif \") == \"Mudasir_Hanif_\")\nassert(fix_spaces(text: \"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\")\nassert(fix_spaces(text: \"Exa   mple\") == \"Exa-mple\")\nassert(fix_spaces(text: \"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function fix_spaces(text)\n    local new_text = \"\"\n    local i = 1\n    local start, _end = 1, 1\n    while i <= #text do\n        local c = text:sub(i, i)\n        if c == \" \" then\n            _end = _end + 1\n        else\n            if _end - start > 2 then\n                new_text = new_text .. \"-\" .. c\n            elseif _end - start > 0 then\n                new_text = new_text .. (\"_\"):rep(_end - start) .. c\n            else\n                new_text = new_text .. c\n            end\n            start, _end = i+1, i+1\n        end\n        i = i + 1\n    end\n    if _end - start > 2 then\n        new_text = new_text .. \"-\"\n    elseif _end - start > 0 then\n        new_text = new_text .. \"_\"\n    end\n    return new_text\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc fix_spaces(text: String) -> String {\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc rolling_max(numbers: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function rolling_max(numbers)\n    local running_max = nil\n    local result = {}\n\n    for _, n in ipairs(numbers) do\n        if running_max == nil then\n            running_max = n\n        else\n            running_max = math.max(running_max, n)\n        end\n\n        table.insert(result, running_max)\n    end\n\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc rolling_max(numbers: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc words_in_sentence(sentence: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function words_in_sentence(sentence)\n    local new_lst = {}\n    for word in sentence:gmatch(\"%S+\") do\n        local flg = 0\n        if #word == 1 then\n            flg = 1\n        end\n        for i=2, #word-1 do\n            if #word%i == 0 then\n                flg = 1\n            end\n        end\n        if flg == 0 or #word == 2 then\n            table.insert(new_lst, word)\n        end\n    end\n    return table.concat(new_lst, \" \")\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc words_in_sentence(sentence: String) -> String {\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc get_closest_vowel(word: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function get_closest_vowel(word)\n    if #word < 3 then\n        return \"\"\n    end\n\n    local vowels = {a=true, e=true, i=true, o=true, u=true, A=true, E=true, I=true, O=true, U=true}\n    for i=#word-1, 2, -1 do\n        if vowels[word:sub(i, i)] then\n            if not (vowels[word:sub(i-1, i-1)] or vowels[word:sub(i+1, i+1)]) then\n                return word:sub(i, i)\n            end\n        end\n    end\n    return \"\"\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc get_closest_vowel(word: String) -> String {\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])\nassert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])\nassert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])\nassert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function compare(game, guess)\n  local result = {}\n  for i = 1, #game do\n    result[i] = math.abs(game[i] - guess[i])\n  end\n  return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function remove_duplicates(numbers)\n  local c = {}\n  for _, n in ipairs(numbers) do\n    c[n] = (c[n] or 0) + 1\n  end\n  local result = {}\n  for _, n in ipairs(numbers) do\n    if c[n] <= 1 then\n      table.insert(result, n)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc same_chars(s0: String, s1: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\") == true)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabc\") == true)\nassert(same_chars(s0: \"dddddddabc\", s1: \"abcd\") == true)\nassert(same_chars(s0: \"eabcd\", s1: \"dddddddabc\") == false)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabcf\") == false)\nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\") == false)\nassert(same_chars(s0: \"aabb\", s1: \"aaccc\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function same_chars(s0, s1)\n    local set0, set1 = {}, {}\n    for i=1, #s0 do set0[s0:sub(i,i)] = true end\n    for i=1, #s1 do set1[s1:sub(i,i)] = true end\n    for k in pairs(set0) do if not set1[k] then return false end end\n    for k in pairs(set1) do if not set0[k] then return false end end\n    return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc same_chars(s0: String, s1: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function parse_nested_parens(paren_string)\n    local function parse_paren_group(s)\n        local depth = 0\n        local max_depth = 0\n        for c in s:gmatch('.') do\n            if c == '(' then\n                depth = depth + 1\n                max_depth = math.max(depth, max_depth)\n            else\n                depth = depth - 1\n            end\n        end\n        return max_depth\n    end\n    local res = {}\n    for x in paren_string:gmatch('%S+') do\n        table.insert(res, parse_paren_group(x))\n    end\n    return res\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc even_odd_count(num: Int) -> (Int, Int) {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_count(num: 7) == (0, 1))\nassert(even_odd_count(num: -78) == (1, 1))\nassert(even_odd_count(num: 3452) == (2, 2))\nassert(even_odd_count(num: 346211) == (3, 3))\nassert(even_odd_count(num: -345821) == (3, 3))\nassert(even_odd_count(num: -2) == (1, 0))\nassert(even_odd_count(num: -45347) == (2, 3))\nassert(even_odd_count(num: 0) == (1, 0))",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_count(num)\n    local even_count = 0\n    local odd_count = 0\n    for i in tostring(math.abs(num)):gmatch(\".\") do\n        if tonumber(i)%2==0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n    end\n    return {even_count, odd_count}\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc even_odd_count(num: Int) -> (Int, Int) {\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc fruit_distribution(s: String, n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 19) == 8)\nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 21) == 10)\nassert(fruit_distribution(s: \"0 apples and 1 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"1 apples and 0 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 100) == 95)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 5) == 0)\nassert(fruit_distribution(s: \"1 apples and 100 oranges\", n: 120) == 19)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function fruit_distribution(s, n)\n    local sum = 0\n    for i in string.gmatch(s, \"%d+\") do\n        sum = sum + tonumber(i)\n    end\n    return n - sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc fruit_distribution(s: String, n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc string_xor(a: String, b: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function string_xor(a, b)\n    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result = result .. '0'\n        else\n            result = result .. '1'\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc string_xor(a: String, b: String) -> String {\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc strlen(string: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strlen(string: \"\") == 0)\nassert(strlen(string: \"x\") == 1)\nassert(strlen(string: \"asdasnakj\") == 9)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function strlen(string)\n    return #string\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc strlen(string: String) -> Int {\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc string_sequence(n: Int) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_sequence(n: 0) == \"0\")\nassert(string_sequence(n: 3) == \"0 1 2 3\")\nassert(string_sequence(n: 10) == \"0 1 2 3 4 5 6 7 8 9 10\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function string_sequence(n)\n    local t = {}\n    for i = 0, n do\n        t[#t + 1] = tostring(i)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc string_sequence(n: Int) -> String {\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc can_arrange(arr: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function can_arrange(arr)\n    local ind=-1\n    local i=1\n    while i<#arr do\n      if arr[i]>arr[i+1] then\n        ind=i\n      end\n      i=i+1\n    end\n    return ind\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc can_arrange(arr: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc add(lst: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(lst: [4, 88]) == 88)\nassert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)\nassert(add(lst: [4, 0, 6, 7]) == 0)\nassert(add(lst: [4, 4, 6, 8]) == 12)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function add(lst)\n  local sum = 0\n  for i = 2, #lst, 2 do\n    if lst[i]%2 == 0 then\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc add(lst: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function intersperse(numbers, delimeter)\n    if not numbers then\n        return {}\n    end\n\n    local result = {}\n\n    for i=1, #numbers-1 do\n        table.insert(result, numbers[i])\n        table.insert(result, delimeter)\n    end\n\n    table.insert(result, numbers[#numbers])\n\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc match_parens(lst: [String]) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function match_parens(lst)\n    local function check(s)\n        local val = 0\n        for i=1, #s do\n            if s:sub(i, i) == '(' then\n                val = val + 1\n            else\n                val = val - 1\n            end\n            if val < 0 then\n                return false\n            end\n        end\n        return val == 0\n    end\n\n    local S1 = lst[1]..lst[2]\n    local S2 = lst[2]..lst[1]\n    if check(S1) or check(S2) then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc match_parens(lst: [String]) -> String {\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc any_int(x: Double, y: Double, z: Double) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(any_int(x: 2, y: 3, z: 1) == true)\nassert(any_int(x: 2.5, y: 2, z: 3) == false)\nassert(any_int(x: 1.5, y: 5, z: 3.5) == false)\nassert(any_int(x: 2, y: 6, z: 2) == false)\nassert(any_int(x: 4, y: 2, z: 2) == true)\nassert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)\nassert(any_int(x: -4, y: 6, z: 2) == true)\nassert(any_int(x: 2, y: 1, z: 1) == true)\nassert(any_int(x: 3, y: 4, z: 7) == true)\nassert(any_int(x: 3.0, y: 4, z: 7) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function any_int(x, y, z)\n    if math.type(x) == \"integer\" and math.type(y) == \"integer\" and math.type(z) == \"integer\" then\n        if (x+y==z) or (x+z==y) or (y+z==x) then\n            return true\n        end\n        return false\n    end\n    return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc any_int(x: Double, y: Double, z: Double) -> Bool {\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_substring(strings, substring)\n    local result = {}\n    for _, v in pairs(strings) do\n        if string.find(v, substring) then\n            table.insert(result, v)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc find_max(words: [String]) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function find_max(words)\n    table.sort(words, function(a, b)\n        if #a ~= #b then\n            return #a > #b\n        else\n            return a < b\n        end\n    end)\n\n    local max_word = words[1]\n    local max_count = 0\n\n    for i=1, #words do\n        local count = 0\n        local char_set = {}\n\n        for j=1, #words[i] do\n            if not char_set[words[i]:sub(j, j)] then\n                count = count + 1\n                char_set[words[i]:sub(j, j)] = true\n            end\n        end\n\n        if count > max_count then\n            max_count = count\n            max_word = words[i]\n        end\n    end\n\n    return max_word\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc find_max(words: [String]) -> String {\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])\nassert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 17, b: 89) == [] as [Int])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function generate_integers(a, b)\n    local lower = math.max(2, math.min(a, b))\n    local upper = math.min(8, math.max(a, b))\n\n    local result = {}\n    for i=lower, upper do\n        if i%2 == 0 then\n            table.insert(result, i)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == \"YES\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == \"NO\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == \"NO\")\nassert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == \"NO\")\nassert(exchange(lst1: [100, 200], lst2: [200, 200]) == \"YES\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function exchange(lst1, lst2)\n    local odd = 0\n    local even = 0\n    for i=1, #lst1 do\n        if lst1[i]%2 == 1 then\n            odd = odd + 1\n        end\n    end\n    for i=1, #lst2 do\n        if lst2[i]%2 == 0 then\n            even = even + 1\n        end\n    end\n    if even >= odd then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc int_to_mini_roman(number: Int) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function int_to_mini_roman(number)\n    local num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}\n    local sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\n    local i = 13\n    local res = \"\"\n    while number > 0 do\n        local div = math.floor(number / num[i])\n        number = number % num[i]\n        while div > 0 do\n            res = res .. sym[i]\n            div = div - 1\n        end\n        i = i - 1\n    end\n    return string.lower(res)\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc int_to_mini_roman(number: Int) -> String {\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_equal_to_sum_even(n: 4) == false)\nassert(is_equal_to_sum_even(n: 6) == false)\nassert(is_equal_to_sum_even(n: 8) == true)\nassert(is_equal_to_sum_even(n: 10) == true)\nassert(is_equal_to_sum_even(n: 11) == false)\nassert(is_equal_to_sum_even(n: 12) == true)\nassert(is_equal_to_sum_even(n: 13) == false)\nassert(is_equal_to_sum_even(n: 16) == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_equal_to_sum_even(n)\n  return n%2 == 0 and n >= 8\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc sort_third(l: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])\nassert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])\nassert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])\nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_third(l)\n    l = {table.unpack(l)}\n    for i = 3, #l, 3 do\n        local j = i\n        while j > 1 and l[j - 3 + 1] > l[j + 1] do\n            l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]\n            j = j - 3\n        end\n    end\n    return l\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc sort_third(l: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc simplify(x: String, n: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(simplify(x: \"1/5\", n: \"5/1\") == true)\nassert(simplify(x: \"1/6\", n: \"2/1\") == false)\nassert(simplify(x: \"5/1\", n: \"3/1\") == true)\nassert(simplify(x: \"7/10\", n: \"10/2\") == false)\nassert(simplify(x: \"2/10\", n: \"50/10\") == true)\nassert(simplify(x: \"7/2\", n: \"4/2\") == true)\nassert(simplify(x: \"11/6\", n: \"6/1\") == true)\nassert(simplify(x: \"2/3\", n: \"5/2\") == false)\nassert(simplify(x: \"5/2\", n: \"3/5\") == false)\nassert(simplify(x: \"2/4\", n: \"8/4\") == true)\nassert(simplify(x: \"2/4\", n: \"4/2\") == true)\nassert(simplify(x: \"1/5\", n: \"5/1\") == true)\nassert(simplify(x: \"1/5\", n: \"1/5\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function simplify(x, n)\n  local a, b = x:match(\"([^/]+)/([^/]+)\")\n  local c, d = n:match(\"([^/]+)/([^/]+)\")\n  local numerator = tonumber(a) * tonumber(c)\n  local denom = tonumber(b) * tonumber(d)\n  if (numerator/denom == math.floor(numerator/denom)) then\n    return true\n  end\n  return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc simplify(x: String, n: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc solve(s: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function solve(s)\n    local flg = 0\n    local idx = 1\n    local new_str = {}\n    for i=1, #s do\n        if string.match(s:sub(i,i), '%a') then\n            new_str[idx] = string.match(s:sub(i,i), '%a'):upper() == s:sub(i,i) and string.match(s:sub(i,i), '%a'):lower() or string.match(s:sub(i,i), '%a'):upper()\n            flg = 1\n        else\n            new_str[idx] = s:sub(i,i)\n        end\n        idx = idx + 1\n    end\n    s = table.concat(new_str)\n    if flg == 0 then\n        return s:reverse()\n    end\n    return s\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc solve(s: String) -> String {\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(right_angle_triangle(a: 3, b: 4, c: 5) == true)\nassert(right_angle_triangle(a: 1, b: 2, c: 3) == false)\nassert(right_angle_triangle(a: 10, b: 6, c: 8) == true)\nassert(right_angle_triangle(a: 2, b: 2, c: 2) == false)\nassert(right_angle_triangle(a: 7, b: 24, c: 25) == true)\nassert(right_angle_triangle(a: 10, b: 5, c: 7) == false)\nassert(right_angle_triangle(a: 5, b: 12, c: 13) == true)\nassert(right_angle_triangle(a: 15, b: 8, c: 17) == true)\nassert(right_angle_triangle(a: 48, b: 55, c: 73) == true)\nassert(right_angle_triangle(a: 1, b: 1, c: 1) == false)\nassert(right_angle_triangle(a: 2, b: 2, c: 10) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function right_angle_triangle(a, b, c)\n  return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc double_the_difference(lst: [Double]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(double_the_difference(lst: [] as [Double]) == 0)\nassert(double_the_difference(lst: [5.0, 4.0]) == 25)\nassert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)\nassert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)\nassert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)\nassert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)\nassert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function double_the_difference(lst)\n    local sum = 0\n    for _, i in ipairs(lst) do\n        if i > 0 and i%2~=0 and math.floor(i) == i then\n            sum = sum + i^2\n        end\n    end\n    return sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc double_the_difference(lst: [Double]) -> Int {\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\n\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case doubleValue(Double)\n    case stringValue(String)\n}\n\n            func compare_one(a: Value, b: Value) -> Value? {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function compare_one(a, b)\n  local temp_a, temp_b = a, b\n  if type(temp_a) == 'string' then temp_a = temp_a:gsub(',', '.') end\n  if type(temp_b) == 'string' then temp_b = temp_b:gsub(',', '.') end\n  if tonumber(temp_a) == tonumber(temp_b) then return nil end\n  return tonumber(temp_a) > tonumber(temp_b) and a or b\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\n\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case doubleValue(Double)\n    case stringValue(String)\n}\n\n            func compare_one(a: Value, b: Value) -> Value? {\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc below_zero(operations: [Int]) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_zero(operations: [] as [Int]) == false)\nassert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)\nassert(below_zero(operations: [1, 2, -4, 5, 6]) == true)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)\nassert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function below_zero(operations)\n    local balance = 0\n\n    for _, op in ipairs(operations) do\n        balance = balance + op\n        if balance < 0 then\n            return true\n        end\n    end\n\n    return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc below_zero(operations: [Int]) -> Bool {\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(greatest_common_divisor(a: 3, b: 7) == 1)\nassert(greatest_common_divisor(a: 10, b: 15) == 5)\nassert(greatest_common_divisor(a: 49, b: 14) == 7)\nassert(greatest_common_divisor(a: 144, b: 60) == 12)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function greatest_common_divisor(a, b)\n    while b ~= 0 do\n        a, b = b, a % b\n    end\n    return a\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc f(n: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 5) == [1, 2, 6, 24, 15])\nassert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])\nassert(f(n: 1) == [1])\nassert(f(n: 3) == [1, 2, 6])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function f(n)\n    local ret = {}\n    for i=1,n do\n        if i%2 == 0 then\n            local x = 1\n            for j=1,i do x = x*j end\n            table.insert(ret, x)\n        else\n            local x = 0\n            for j=1,i do x = x+j end\n            table.insert(ret, x)\n        end\n    end\n    return ret\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc f(n: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc monotonic(l: [Int]) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function monotonic(l)\n    local is_increasing = true\n    local is_decreasing = true\n\n    for i=2, #l do\n        if l[i] > l[i-1] then\n            is_decreasing = false\n        elseif l[i] < l[i-1] then\n            is_increasing = false\n        end\n    end\n\n    return is_increasing or is_decreasing\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc monotonic(l: [Int]) -> Bool {\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc by_length(arr: [Int]) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\nassert(by_length(arr: [] as [Int]) == [] as [String])\nassert(by_length(arr: [1, -1, 55]) == [\"One\"])\nassert(by_length(arr: [1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\nassert(by_length(arr: [9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function by_length(arr)\n    local dic = {\n        [1] = \"One\",\n        [2] = \"Two\",\n        [3] = \"Three\",\n        [4] = \"Four\",\n        [5] = \"Five\",\n        [6] = \"Six\",\n        [7] = \"Seven\",\n        [8] = \"Eight\",\n        [9] = \"Nine\",\n    }\n    table.sort(arr, function(a, b) return a > b end)\n    local new_arr = {}\n    for i, var in ipairs(arr) do\n        if dic[var] then\n            table.insert(new_arr, dic[var])\n        end\n    end\n    return new_arr\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc by_length(arr: [Int]) -> [String] {\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc remove_vowels(text: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_vowels(text: \"\") == \"\")\nassert(remove_vowels(text: \"abcdef\\nghijklm\") == \"bcdf\\nghjklm\")\nassert(remove_vowels(text: \"fedcba\") == \"fdcb\")\nassert(remove_vowels(text: \"eeeee\") == \"\")\nassert(remove_vowels(text: \"acBAA\") == \"cB\")\nassert(remove_vowels(text: \"EcBOO\") == \"cB\")\nassert(remove_vowels(text: \"ybcd\") == \"ybcd\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function remove_vowels(text)\n    return text:gsub(\"[aeiouAEIOU]\", \"\")\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc remove_vowels(text: String) -> String {\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_if_last_char_is_a_letter(txt: \"apple\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"A\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie 1\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee e \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pie\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e \") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function check_if_last_char_is_a_letter(txt)\n    local check = txt:match(\"%a%a*$\")\n    return check ~= nil and #check == 1\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc iscube(a: Int) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(iscube(a: 1) == true)\nassert(iscube(a: 2) == false)\nassert(iscube(a: -1) == true)\nassert(iscube(a: 64) == true)\nassert(iscube(a: 180) == false)\nassert(iscube(a: 1000) == true)\nassert(iscube(a: 0) == true)\nassert(iscube(a: 1729) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function iscube(a)\n    a = math.abs(a)\n    return math.floor(a^(1/3) + 0.5)^3 == a\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc iscube(a: Int) -> Bool {\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function mean_absolute_deviation(numbers)\n    local mean = 0\n    for _, v in ipairs(numbers) do\n        mean = mean + v\n    end\n    mean = mean / #numbers\n    local sum = 0\n    for _, v in ipairs(numbers) do\n        sum = sum + math.abs(v - mean)\n    end\n    return sum / #numbers\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc correct_bracketing(brackets: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for b in brackets:gmatch(\".\") do\n        if b == \"<\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc correct_bracketing(brackets: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function rescale_to_unit(numbers)\n    local min_number = math.min(table.unpack(numbers))\n    local max_number = math.max(table.unpack(numbers))\n    local result = {}\n    for i, x in ipairs(numbers) do\n        result[i] = (x - min_number) / (max_number - min_number)\n    end\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersection(interval1: (1, 2), interval2: (2, 3)) == \"NO\")\nassert(intersection(interval1: (-1, 1), interval2: (0, 4)) == \"NO\")\nassert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == \"YES\")\nassert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == \"YES\")\nassert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (3, 5)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (1, 2)) == \"NO\")\nassert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == \"NO\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function intersection(interval1, interval2)\n    local function is_prime(num)\n        if num == 1 or num == 0 then\n            return false\n        end\n        if num == 2 then\n            return true\n        end\n        for i=2,num-1 do\n            if num%i == 0 then\n                return false\n            end\n        end\n        return true\n    end\n\n    local l = math.max(interval1[1], interval2[1])\n    local r = math.min(interval1[2], interval2[2])\n    local length = r - l\n    if length > 0 and is_prime(length) then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc hex_key(num: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function hex_key(num)\n    local primes = {'2', '3', '5', '7', 'B', 'D'}\n    local total = 0\n    for i = 1, #num do\n        if table.concat(primes):find(num:sub(i, i)) then\n            total = total + 1\n        end\n    end\n    return total\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc hex_key(num: String) -> Int {\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function strange_sort_list(lst)\n    local res, switch = {}, true\n    while #lst > 0 do\n        if switch then\n            table.insert(res, math.min(table.unpack(lst)))\n        else\n            table.insert(res, math.max(table.unpack(lst)))\n        end\n        local index = 0\n        for i, v in ipairs(lst) do\n            if v == res[#res] then\n                index = i\n                break\n            end\n        end\n        table.remove(lst, index)\n        switch = not switch\n    end\n    return res\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc all_prefixes(string: String) -> [String] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function all_prefixes(string)\n    local result = {}\n\n    for i=1, #string do\n        table.insert(result, string:sub(1, i))\n    end\n    return result\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc all_prefixes(string: String) -> [String] {\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc how_many_times(string: String, substring: String) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function how_many_times(string, substring)\n  local times = 0\n  for i = 1, #string - #substring + 1 do\n    if string:sub(i, i + #substring - 1) == substring then\n      times = times + 1\n    end\n  end\n  return times\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc how_many_times(string: String, substring: String) -> Int {\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc solution(lst: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solution(lst: [5, 8, 7, 1]) == 12)\nassert(solution(lst: [3, 3, 3, 3, 3]) == 9)\nassert(solution(lst: [30, 13, 24, 321]) == 0)\nassert(solution(lst: [5, 9]) == 5)\nassert(solution(lst: [2, 4, 8]) == 0)\nassert(solution(lst: [30, 13, 23, 32]) == 23)\nassert(solution(lst: [3, 13, 2, 9]) == 3)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function solution(lst)\n  local sum = 0\n  for idx, x in ipairs(lst) do\n    if idx%2==1 and x%2==1 then\n      sum = sum + x\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc solution(lst: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_sorted(lst: [Int]) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_sorted(lst: [Int]) -> Bool {\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc search(lst: [Int]) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(lst: [5, 5, 5, 5, 1]) == 1)\nassert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)\nassert(search(lst: [3, 3]) == -1)\nassert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)\nassert(search(lst: [2, 3, 3, 2, 2]) == 2)\nassert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\nassert(search(lst: [3, 2, 8, 2]) == 2)\nassert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\nassert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)\nassert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\nassert(search(lst: [1, 9, 10, 1, 3]) == 1)\nassert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\nassert(search(lst: [1]) == 1)\nassert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\nassert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\nassert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\nassert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)\nassert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\nassert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\nassert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\nassert(search(lst: [10]) == -1)\nassert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\nassert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\nassert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\nassert(search(lst: [3, 10, 10, 9, 2]) == -1)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function search(lst)\n    local frq = {}\n    for i=1, math.max(table.unpack(lst)) do\n        frq[i] = 0\n    end\n    for i=1, #lst do\n        frq[lst[i]] = frq[lst[i]] + 1\n    end\n\n    local ans = -1\n    for i=1, #frq do\n        if frq[i] >= i then\n            ans = i\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc search(lst: [Int]) -> Int {\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc pluck(arr: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function pluck(arr)\n    if(#arr == 0) then return {} end\n    local evens = {}\n    for _, v in ipairs(arr) do\n        if(v%2 == 0) then table.insert(evens, v) end\n    end\n    if(#evens == 0) then return {} end\n    local min_val = math.min(table.unpack(evens))\n    for i, v in ipairs(arr) do\n        if(v == min_val) then return {min_val, i-1} end\n    end\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc pluck(arr: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)\nassert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)\nassert(pairs_sum_to_zero(l: [1]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function pairs_sum_to_zero(l)\n  for i, l1 in ipairs(l) do\n    for j = i + 1, #l do\n      if l1 + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc make_palindrome(string: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function make_palindrome(string)\n    if not string then\n        return ''\n    end\n\n    local beginning_of_suffix = 0\n\n    while string:sub(beginning_of_suffix+1) ~= string:sub(beginning_of_suffix+1):reverse() do\n        beginning_of_suffix = beginning_of_suffix + 1\n    end\n\n    return string .. string:sub(1, beginning_of_suffix):reverse()\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc make_palindrome(string: String) -> String {\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc starts_one_ends(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n: 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4) == 1800)\nassert(starts_one_ends(n: 5) == 18000)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function starts_one_ends(n)\n  if n == 1 then return 1 end\n  return 18 * (10 ^ (n - 2))\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc starts_one_ends(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc get_positive(l: [Int]) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])\nassert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\nassert(get_positive(l: [-1, -2]) == [] as [Int])\nassert(get_positive(l: [] as [Int]) == [] as [Int])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function get_positive(l)\n  local res = {}\n  for _, e in ipairs(l) do\n    if e > 0 then\n      table.insert(res, e)\n    end\n  end\n  return res\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc get_positive(l: [Int]) -> [Int] {\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc concatenate(strings: [String]) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(concatenate(strings: [] as [String]) == \"\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\"]) == \"xyz\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\", \"w\", \"k\"]) == \"xyzwk\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function concatenate(strings)\n  return table.concat(strings)\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc concatenate(strings: [String]) -> String {\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_nested(string: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_nested(string)\n    local opening_bracket_index = {}\n    local closing_bracket_index = {}\n    for i=1, #string do\n        if string:sub(i,i) == '[' then\n            table.insert(opening_bracket_index, i)\n        else\n            table.insert(closing_bracket_index, i)\n        end\n    end\n    table.sort(closing_bracket_index, function(a,b) return a>b end)\n    local cnt = 0\n    local i = 1\n    local l = #closing_bracket_index\n    for _, idx in ipairs(opening_bracket_index) do\n        if i <= l and idx < closing_bracket_index[i] then\n            cnt = cnt + 1\n            i = i + 1\n        end\n    end\n    return cnt >= 2\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_nested(string: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_palindrome(text: String) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_palindrome(text: \"\") == true)\nassert(is_palindrome(text: \"aba\") == true)\nassert(is_palindrome(text: \"aaaaa\") == true)\nassert(is_palindrome(text: \"zbcd\") == false)\nassert(is_palindrome(text: \"xywyx\") == true)\nassert(is_palindrome(text: \"xywyz\") == false)\nassert(is_palindrome(text: \"xywzx\") == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_palindrome(text)\n    for i=1, #text do\n        if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_palindrome(text: String) -> Bool {\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc factorize(n: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function factorize(n)\n    local fact = {}\n    local i = 2\n    while i <= math.sqrt(n) + 1 do\n        if n % i == 0 then\n            table.insert(fact, i)\n            n = n / i\n        else\n            i = i + 1\n        end\n    end\n    if n > 1 then\n        table.insert(fact, n)\n    end\n    return fact\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc factorize(n: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc largest_prime_factor(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function largest_prime_factor(n)\n  local function is_prime(k)\n    if k < 2 then\n      return false\n    end\n    for i = 2, k - 1 do\n      if k % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local largest = 1\n  for j = 2, n + 1 do\n    if n % j == 0 and is_prime(j) then\n      largest = math.max(largest, j)\n    end\n  end\n  return largest\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc largest_prime_factor(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc get_max_triples(n: Int) -> Int {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_max_triples(n: 5) == 1)\nassert(get_max_triples(n: 6) == 4)\nassert(get_max_triples(n: 10) == 36)\nassert(get_max_triples(n: 100) == 53361)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function get_max_triples(n)\n  local A = {}\n  for i=1,n do\n    A[i] = i*i - i + 1\n  end\n  local ans = {}\n  for i=1,n do\n    for j=i+1,n do\n      for k=j+1,n do\n        if (A[i]+A[j]+A[k])%3 == 0 then\n          table.insert(ans, {A[i],A[j],A[k]})\n        end\n      end\n    end\n  end\n  return #ans\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc get_max_triples(n: Int) -> Int {\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc anti_shuffle(s: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function anti_shuffle(s)\n    local t = {}\n    for i in s:gmatch('%S+') do\n        local u = {}\n        for j = 1, #i do\n            u[j] = i:sub(j, j)\n        end\n        table.sort(u)\n        t[#t + 1] = table.concat(u)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc anti_shuffle(s: String) -> String {\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])\nassert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])\nassert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])\nassert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])\nassert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])\nassert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\nassert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\nassert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])\nassert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])\nassert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\nassert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function minPath(grid, k)\n    local n = #grid\n    local val = n * n + 1\n    for i = 1, n do\n        for j = 1, n do\n            if grid[i][j] == 1 then\n                local temp = {}\n                if i ~= 1 then\n                    table.insert(temp, grid[i-1][j])\n                end\n\n                if j ~= 1 then\n                    table.insert(temp, grid[i][j-1])\n                end\n\n                if i ~= n then\n                    table.insert(temp, grid[i+1][j])\n                end\n\n                if j ~= n then\n                    table.insert(temp, grid[i][j+1])\n                end\n\n                val = math.min(table.unpack(temp))\n            end\n        end\n    end\n\n    local ans = {}\n    for i = 1, k do\n        if i % 2 == 1 then\n            table.insert(ans, 1)\n        else\n            table.insert(ans, val)\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc encrypt(s: String) -> String {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") == \"e\")",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function encrypt(s)\n    local d = 'abcdefghijklmnopqrstuvwxyz'\n    local out = ''\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if d:find(c) then\n            out = out .. d:sub((d:find(c) + 2*2 - 1) % 26 + 1, (d:find(c) + 2*2 - 1) % 26 + 1)\n        else\n            out = out .. c\n        end\n    end\n    return out\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc encrypt(s: String) -> String {\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc make_a_pile(n: Int) -> [Int] {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n: 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function make_a_pile(n)\n  local pile = {}\n  for i = 0, n-1 do\n    pile[i+1] = n + 2*i\n  end\n  return pile\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc make_a_pile(n: Int) -> [Int] {\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "swift",
    "prompt": "import Swift\nimport Foundation\nfunc is_prime(n: Int) -> Bool {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_prime(n: 6) == false)\nassert(is_prime(n: 101) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 13441) == true)\nassert(is_prime(n: 61) == true)\nassert(is_prime(n: 4) == false)\nassert(is_prime(n: 1) == false)\nassert(is_prime(n: 5) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 17) == true)\nassert(is_prime(n: 85) == false)\nassert(is_prime(n: 77) == false)\nassert(is_prime(n: 255379) == false)",
    "stop_tokens": [
      "\n}"
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does with a couple of sentences? The goal with the explanation, is so that a reader can easily rewrite the program in Swift.\n\n### Lua version\n\nmath = require('math')\nlocal function is_prime(n)\n    if n < 2 then\n        return false\n    end\n    for k=2, n-1 do\n        if n % k == 0 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThis{{{TOFILL}}}\n\n### Swift version\n\nimport Swift\nimport Foundation\nfunc is_prime(n: Int) -> Bool {\n"
  }
]