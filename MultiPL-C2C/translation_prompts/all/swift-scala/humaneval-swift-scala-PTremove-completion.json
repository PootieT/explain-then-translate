[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def correctBracketing(brackets : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"()\")) == (true));\n    assert(correctBracketing((\"(()())\")) == (true));\n    assert(correctBracketing((\"()()(()())()\")) == (true));\n    assert(correctBracketing((\"()()((()()())())(()()(()))\")) == (true));\n    assert(correctBracketing((\"((()())))\")) == (false));\n    assert(correctBracketing((\")(()\")) == (false));\n    assert(correctBracketing((\"(\")) == (false));\n    assert(correctBracketing((\"((((\")) == (false));\n    assert(correctBracketing((\")\")) == (false));\n    assert(correctBracketing((\"(()\")) == (false));\n    assert(correctBracketing((\"()()(()())())(()\")) == (false));\n    assert(correctBracketing((\"()()(()())()))()\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc correct_bracketing(brackets: String) -> Bool {\n    var depth = 0\n    for b in brackets {\n        if b == \"(\" {\n            depth += 1\n        } else {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def correctBracketing(brackets : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def triangleArea(a : Long, h : Long) : Float = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(triangleArea((5l), (3l)) == (7.5f));\n    assert(triangleArea((2l), (2l)) == (2.0f));\n    assert(triangleArea((10l), (8l)) == (40.0f));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc triangle_area(a: Int, h: Int) -> Double {\n    return Double(a * h) / 2.0\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def triangleArea(a : Long, h : Long) : Float = {\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def specialFactorial(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(specialFactorial((4l)) == (288l));\n    assert(specialFactorial((5l)) == (34560l));\n    assert(specialFactorial((7l)) == (125411328000l));\n    assert(specialFactorial((1l)) == (1l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc special_factorial(n: Int) -> Int {\n    var fact_i = 1\n    var special_fact = 1\n    for i in 1...n {\n        fact_i *= i\n        special_fact *= fact_i\n    }\n    return special_fact\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def specialFactorial(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_136_largest_smallest_integers",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_136_largest_smallest_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n    let smallest = lst.filter { $0 < 0 }\n    let largest = lst.filter { $0 > 0 }\n    return (smallest.max(), largest.min())\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def moveOneBall(arr : List[Long]) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]())) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc move_one_ball(arr: [Int]) -> Bool {\n    if arr.isEmpty {\n        return true\n    }\n    let sortedArray = arr.sorted()\n    var myArr = [Int]()\n    let minValue = arr.min()!\n    let minIndex = arr.firstIndex(of: minValue)!\n    myArr = Array(arr[minIndex...]) + Array(arr[0..<minIndex])\n    for i in 0..<arr.count {\n        if myArr[i] != sortedArray[i] {\n            return false\n        }\n    }\n    return true\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def moveOneBall(arr : List[Long]) : Boolean = {\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def digits(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l)) == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l)) == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc digits(n: Int) -> Int {\n    var product = 1\n    var oddCount = 0\n\n    for digit in String(n) {\n        let intDigit = Int(String(digit))!\n\n        if intDigit % 2 == 1 {\n            product *= intDigit\n            oddCount += 1\n        }\n    }\n\n    return oddCount == 0 ? 0 : product\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def digits(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fib4(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(fib4((5l)) == (4l));\n    assert(fib4((8l)) == (28l));\n    assert(fib4((10l)) == (104l));\n    assert(fib4((12l)) == (386l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc fib4(n: Int) -> Int {\n    var results = [0, 0, 2, 0]\n    if n < 4 {\n        return results[n]\n    }\n\n    for _ in 4...n {\n        results.append(results[3] + results[2] + results[1] + results[0])\n        results.removeFirst()\n    }\n\n    return results[3]\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fib4(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortEven(l : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));\n    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));\n    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sort_even(l: [Int]) -> [Int] {\n    let evens = l.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted()\n    let odds = l.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element }\n    var ans = [Int]()\n    for (e, o) in zip(evens, odds) {\n        ans.append(e)\n        ans.append(o)\n    }\n    if evens.count > odds.count {\n        ans.append(evens.last!)\n    }\n    return ans\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortEven(l : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_145_order_by_points",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def orderByPoints(nums : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_145_order_by_points.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));\n    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));\n    assert(orderByPoints((List[Long]())).equals((List[Long]())));\n    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));\n    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));\n    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc order_by_points(nums: [Int]) -> [Int] {\n    func digits_sum(n: Int) -> Int {\n        let neg = n < 0 ? -1 : 1\n        var n = String(n).compactMap{ Int(String($0)) }\n        n[0] *= neg\n        return n.reduce(0, +)\n    }\n    return nums.sorted(by: { digits_sum(n: $0) < digits_sum(n: $1) })\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def orderByPoints(nums : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isHappy(s : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isHappy((\"a\")) == (false));\n    assert(isHappy((\"aa\")) == (false));\n    assert(isHappy((\"abcd\")) == (true));\n    assert(isHappy((\"aabb\")) == (false));\n    assert(isHappy((\"adb\")) == (true));\n    assert(isHappy((\"xyy\")) == (false));\n    assert(isHappy((\"iopaxpoi\")) == (true));\n    assert(isHappy((\"iopaxioi\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc is_happy(s: String) -> Bool {\n    if s.count < 3 {\n        return false\n    }\n    for i in 0..<(s.count - 2) {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 2)\n        if s[start] == s[s.index(after: start)] || s[s.index(after: start)] == s[end] || s[start] == s[end] {\n            return false\n        }\n    }\n    return true\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isHappy(s : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def circularShift(x : Long, shift : Long) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(circularShift((100l), (2l)).equals((\"001\")));\n    assert(circularShift((12l), (2l)).equals((\"12\")));\n    assert(circularShift((97l), (8l)).equals((\"79\")));\n    assert(circularShift((12l), (1l)).equals((\"21\")));\n    assert(circularShift((11l), (101l)).equals((\"11\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc circular_shift(x: Int, shift: Int) -> String {\n    let s = String(x)\n    if shift > s.count {\n        return String(s.reversed())\n    } else {\n        return String(s.suffix(shift)) + String(s.prefix(s.count - shift))\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def circularShift(x : Long, shift : Long) : String = {\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n    return grid.reduce(0) { $0 + Int(ceil(Double($1.reduce(0, +))/Double(capacity))) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n    for idx in numbers.indices {\n        for idx2 in numbers.indices {\n            if idx != idx2 {\n                let distance = abs(numbers[idx] - numbers[idx2])\n                if distance < threshold {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def numericalLetterGrade(grades : List[Float]) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](\"A+\", \"B\", \"C-\", \"C\", \"A-\"))));\n    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](\"D+\"))));\n    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](\"D-\"))));\n    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](\"E\"))));\n    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](\"D\", \"D-\", \"C-\", \"B\", \"B+\"))));\n    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](\"E\", \"D-\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n    var letter_grade = [String]()\n    for gpa in grades {\n        if gpa == 4.0 {\n            letter_grade.append(\"A+\")\n        } else if gpa > 3.7 {\n            letter_grade.append(\"A\")\n        } else if gpa > 3.3 {\n            letter_grade.append(\"A-\")\n        } else if gpa > 3.0 {\n            letter_grade.append(\"B+\")\n        } else if gpa > 2.7 {\n            letter_grade.append(\"B\")\n        } else if gpa > 2.3 {\n            letter_grade.append(\"B-\")\n        } else if gpa > 2.0 {\n            letter_grade.append(\"C+\")\n        } else if gpa > 1.7 {\n            letter_grade.append(\"C\")\n        } else if gpa > 1.3 {\n            letter_grade.append(\"C-\")\n        } else if gpa > 1.0 {\n            letter_grade.append(\"D+\")\n        } else if gpa > 0.7 {\n            letter_grade.append(\"D\")\n        } else if gpa > 0.0 {\n            letter_grade.append(\"D-\")\n        } else {\n            letter_grade.append(\"E\")\n        }\n    }\n    return letter_grade\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def numericalLetterGrade(grades : List[Float]) : List[String] = {\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def xOrY(n : Long, x : Long, y : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(xOrY((7l), (34l), (12l)) == (34l));\n    assert(xOrY((15l), (8l), (5l)) == (5l));\n    assert(xOrY((3l), (33l), (5212l)) == (33l));\n    assert(xOrY((1259l), (3l), (52l)) == (3l));\n    assert(xOrY((7919l), (-1l), (12l)) == (-1l));\n    assert(xOrY((3609l), (1245l), (583l)) == (583l));\n    assert(xOrY((91l), (56l), (129l)) == (129l));\n    assert(xOrY((6l), (34l), (1234l)) == (1234l));\n    assert(xOrY((1l), (2l), (0l)) == (0l));\n    assert(xOrY((2l), (2l), (0l)) == (2l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n    if n == 1 {\n        return y\n    }\n    for i in 2..<n {\n        if n % i == 0 {\n            return y\n        }\n    }\n    return x\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def xOrY(n : Long, x : Long, y : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def specialFilter(nums : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));\n    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));\n    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));\n    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));\n    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));\n    assert(specialFilter((List[Long](1l.toLong))) == (0l));\n    assert(specialFilter((List[Long]())) == (0l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc specialFilter(nums: [Int]) -> Int {\n    var count = 0\n    let oddDigits = [1, 3, 5, 7, 9]\n    for num in nums {\n        if num > 10 {\n            let numberAsString = String(num)\n            if oddDigits.contains(Int(String(numberAsString.first!))!) && oddDigits.contains(Int(String(numberAsString.last!))!) {\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def specialFilter(nums : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def parseMusic(music_string : String) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc parse_music(music_string: String) -> [Int] {\n    let note_map = [\"o\": 4, \"o|\": 2, \".|\": 1]\n    return music_string.split(separator: \" \").map { note_map[String($0)]! }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def parseMusic(music_string : String) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def splitWords(txt : String) : Either[List[String], Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(splitWords((\"Hello world!\")).equals(List[String](\"Hello\", \"world!\")));\n    assert(splitWords((\"Hello,world!\")).equals(List[String](\"Hello\", \"world!\")));\n    assert(splitWords((\"Hello world,!\")).equals(List[String](\"Hello\", \"world,!\")));\n    assert(splitWords((\"Hello,Hello,world !\")).equals(List[String](\"Hello,Hello,world\", \"!\")));\n    assert(splitWords((\"abcdef\")).equals(3l));\n    assert(splitWords((\"aaabb\")).equals(2l));\n    assert(splitWords((\"aaaBb\")).equals(1l));\n    assert(splitWords((\"\")).equals(0l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nextension Int: Error {}\nfunc split_words(txt: String) -> Result<[String], Int> {\n    if txt.contains(\" \") {\n        return .success(txt.split(separator: \" \").map(String.init))\n    } else if txt.contains(\",\") {\n        return .success(txt.split(separator: \",\").map(String.init))\n    } else {\n        let count = txt.filter { $0.isLowercase && $0.asciiValue! % 2 == 0 }.count\n        return .failure(count)\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def splitWords(txt : String) : Either[List[String], Long] = {\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def countDistinctCharacters(string : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countDistinctCharacters((\"\")) == (0l));\n    assert(countDistinctCharacters((\"abcde\")) == (5l));\n    assert(countDistinctCharacters((\"abcdecadeCADE\")) == (5l));\n    assert(countDistinctCharacters((\"aaaaAAAAaaaa\")) == (1l));\n    assert(countDistinctCharacters((\"Jerry jERRY JeRRRY\")) == (5l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc count_distinct_characters(string: String) -> Int {\n    return Set(string.lowercased()).count\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def countDistinctCharacters(string : String) : Long = {\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def bf(planet1 : String, planet2 : String) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc bf(planet1: String, planet2: String) -> [String] {\n    let planetNames = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    guard planetNames.contains(planet1), planetNames.contains(planet2), planet1 != planet2 else {\n        return []\n    }\n    let planet1Index = planetNames.firstIndex(of: planet1)!\n    let planet2Index = planetNames.firstIndex(of: planet2)!\n    if planet1Index < planet2Index {\n        return Array(planetNames[planet1Index + 1 ..< planet2Index])\n    } else {\n        return Array(planetNames[planet2Index + 1 ..< planet1Index])\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def bf(planet1 : String, planet2 : String) : List[String] = {\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def digitSum(s : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(digitSum((\"\")) == (0l));\n    assert(digitSum((\"abAB\")) == (131l));\n    assert(digitSum((\"abcCd\")) == (67l));\n    assert(digitSum((\"helloE\")) == (69l));\n    assert(digitSum((\"woArBld\")) == (131l));\n    assert(digitSum((\"aAaaaXa\")) == (153l));\n    assert(digitSum((\" How are yOu?\")) == (151l));\n    assert(digitSum((\"You arE Very Smart\")) == (327l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc digitSum(s: String) -> Int {\n    if s == \"\" { return 0 }\n    return s.reduce(0) { $0 + ($1.isUppercase ? Int($1.asciiValue!) : 0) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def digitSum(s : String) : Long = {\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumSquares(lst : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));\n    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));\n    assert(sumSquares((List[Long]())) == (0l));\n    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));\n    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));\n    assert(sumSquares((List[Long](0l.toLong))) == (0l));\n    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));\n    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));\n    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));\n    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));\n    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sum_squares(lst: [Int]) -> Int {\n    var result = [Int]()\n    for i in 0..<lst.count {\n        if i % 3 == 0 {\n            result.append(lst[i]*lst[i])\n        } else if i % 4 == 0 && i % 3 != 0 {\n            result.append(lst[i]*lst[i]*lst[i])\n        } else {\n            result.append(lst[i])\n        }\n    }\n    return result.reduce(0, +)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumSquares(lst : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumSquares(lst : List[Float]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));\n    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));\n    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));\n    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));\n    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));\n    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));\n    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));\n    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));\n    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));\n    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Foundation\nimport Swift\nfunc sum_squares(lst: [Double]) -> Int {\n    var squared = 0\n    for i in lst {\n        squared += Int(ceil(i)) * Int(ceil(i))\n    }\n    return squared\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumSquares(lst : List[Float]) : Long = {\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def unique(l : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc unique(l: [Int]) -> [Int] {\n    return Array(Set(l)).sorted()\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def unique(l : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fizzBuzz(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(fizzBuzz((50l)) == (0l));\n    assert(fizzBuzz((78l)) == (2l));\n    assert(fizzBuzz((79l)) == (3l));\n    assert(fizzBuzz((100l)) == (3l));\n    assert(fizzBuzz((200l)) == (6l));\n    assert(fizzBuzz((4000l)) == (192l));\n    assert(fizzBuzz((10000l)) == (639l));\n    assert(fizzBuzz((100000l)) == (8026l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc fizz_buzz(n: Int) -> Int {\n    var ns: [Int] = []\n    for i in 0..<n {\n        if i % 11 == 0 || i % 13 == 0 {\n            ns.append(i)\n        }\n    }\n    let s = ns.map(String.init).joined()\n    return s.filter { $0 == \"7\" }.count\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fizzBuzz(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def StrongestExtension(class_name : String, extensions : List[String]) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n    var strong = extensions[0]\n    var my_val = extensions[0].filter { $0.isUppercase }.count - extensions[0].filter { $0.isLowercase }.count\n    for s in extensions {\n        let val = s.filter { $0.isUppercase }.count - s.filter { $0.isLowercase }.count\n        if val > my_val {\n            strong = s\n            my_val = val\n        }\n    }\n    let ans = class_name + \".\" + strong\n    return ans\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def StrongestExtension(class_name : String, extensions : List[String]) : String = {\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var closestPair: (Double, Double)?\n    var distance: Double?\n\n    for (idx, elem) in numbers.enumerated() {\n        for (idx2, elem2) in numbers.enumerated() {\n            if idx != idx2 {\n                if distance == nil {\n                    distance = abs(elem - elem2)\n                    closestPair = (min(elem, elem2), max(elem, elem2))\n                } else {\n                    let newDistance = abs(elem - elem2)\n                    if newDistance < distance! {\n                        distance = newDistance\n                        closestPair = (min(elem, elem2), max(elem, elem2))\n                    }\n                }\n            }\n        }\n    }\n\n    return closestPair!\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def validDate(date : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(validDate((\"03-11-2000\")) == (true));\n    assert(validDate((\"15-01-2012\")) == (false));\n    assert(validDate((\"04-0-2040\")) == (false));\n    assert(validDate((\"06-04-2020\")) == (true));\n    assert(validDate((\"01-01-2007\")) == (true));\n    assert(validDate((\"03-32-2011\")) == (false));\n    assert(validDate((\"\")) == (false));\n    assert(validDate((\"04-31-3000\")) == (false));\n    assert(validDate((\"06-06-2005\")) == (true));\n    assert(validDate((\"21-31-2000\")) == (false));\n    assert(validDate((\"04-12-2003\")) == (true));\n    assert(validDate((\"04122003\")) == (false));\n    assert(validDate((\"20030412\")) == (false));\n    assert(validDate((\"2003-04\")) == (false));\n    assert(validDate((\"2003-04-12\")) == (false));\n    assert(validDate((\"04-2003\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc valid_date(date: String) -> Bool {\n    let components = date.split(separator: \"-\").map { Int($0)! }\n    guard components.count == 3 else { return false }\n    let month = components[0], day = components[1], year = components[2]\n\n    if month < 1 || month > 12 {\n        return false\n    }\n    if month == 2 {\n        if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {\n            if day < 1 || day > 29 {\n                return false\n            }\n        } else {\n            if day < 1 || day > 28 {\n                return false\n            }\n        }\n    } else if [4, 6, 9, 11].contains(month) {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n\n    return true\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def validDate(date : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def add(x : Long, y : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(add((0l), (1l)) == (1l));\n    assert(add((1l), (0l)) == (1l));\n    assert(add((2l), (3l)) == (5l));\n    assert(add((5l), (7l)) == (12l));\n    assert(add((7l), (5l)) == (12l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc add(x: Int, y: Int) -> Int {\n    return x + y\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def add(x : Long, y : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def triplesSumToZero(l : List[Long]) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n    for i in 0..<l.count {\n        for j in i+1..<l.count {\n            for k in j+1..<l.count {\n                if l[i] + l[j] + l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def triplesSumToZero(l : List[Long]) : Boolean = {\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def largestDivisor(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(largestDivisor((3l)) == (1l));\n    assert(largestDivisor((7l)) == (1l));\n    assert(largestDivisor((10l)) == (5l));\n    assert(largestDivisor((100l)) == (50l));\n    assert(largestDivisor((49l)) == (7l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc largest_divisor(n: Int) -> Int {\n    for i in (0..<n).reversed() {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 0\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def largestDivisor(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortNumbers(numbers : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortNumbers((\"\")).equals((\"\")));\n    assert(sortNumbers((\"three\")).equals((\"three\")));\n    assert(sortNumbers((\"three five nine\")).equals((\"three five nine\")));\n    assert(sortNumbers((\"five zero four seven nine eight\")).equals((\"zero four five seven eight nine\")));\n    assert(sortNumbers((\"six five four three two one zero\")).equals((\"zero one two three four five six\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sort_numbers(numbers: String) -> String {\n    let value_map = [\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    ]\n    return numbers.split(separator: \" \").filter({ $0 != \"\" }).sorted(by: { value_map[String($0)]! < value_map[String($1)]! }).joined(separator: \" \")\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortNumbers(numbers : String) : String = {\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def smallestChange(arr : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc smallest_change(arr: [Int]) -> Int {\n    var ans = 0\n    for i in 0..<arr.count/2 {\n        if arr[i] != arr[arr.count-i-1] {\n            ans += 1\n        }\n    }\n    return ans\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def smallestChange(arr : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def belowThreshold(l : List[Long], t : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));\n    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n    return l.allSatisfy { $0 < t }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def belowThreshold(l : List[Long], t : Long) : Boolean = {\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def prodSigns(arr : List[Long]) : Option[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc prod_signs(arr: [Int]) -> Int? {\n    if arr.isEmpty { return nil }\n    let prod = arr.contains(0) ? 0 : pow(-1, Double(arr.filter { $0 < 0 }.count))\n    return Int(prod) * arr.map(abs).reduce(0, +)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def prodSigns(arr : List[Long]) : Option[Long] = {\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def modp(n : Long, p : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc modp(n: Int, p: Int) -> Int {\n    var ret = 1\n    for _ in 0..<n {\n        ret = (2 * ret) % p\n    }\n    return ret\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def modp(n : Long, p : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def countUpper(s : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countUpper((\"aBCdEf\")) == (1l));\n    assert(countUpper((\"abcdefg\")) == (0l));\n    assert(countUpper((\"dBBE\")) == (0l));\n    assert(countUpper((\"B\")) == (0l));\n    assert(countUpper((\"U\")) == (1l));\n    assert(countUpper((\"\")) == (0l));\n    assert(countUpper((\"EEEE\")) == (2l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc count_upper(s: String) -> Int {\n    var count = 0\n    for i in stride(from: 0, to: s.count, by: 2) {\n        if \"AEIOU\".contains(s[s.index(s.startIndex, offsetBy: i)]) {\n            count += 1\n        }\n    }\n    return count\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def countUpper(s : String) : Long = {\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def multiply(a : Long, b : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc multiply(a: Int, b: Int) -> Int {\n    return abs(a % 10) * abs(b % 10)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def multiply(a : Long, b : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def uniqueDigits(x : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));\n    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));\n    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));\n    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc unique_digits(x: [Int]) -> [Int] {\n    var odd_digit_elements = [Int]()\n    for i in x {\n        if String(i).allSatisfy({ Int(String($0))! % 2 == 1 }) {\n            odd_digit_elements.append(i)\n        }\n    }\n    return odd_digit_elements.sorted()\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def uniqueDigits(x : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_72_will_it_fly",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_72_will_it_fly.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc will_it_fly(q: [Int], w: Int) -> Bool {\n    if q.reduce(0, +) > w {\n        return false\n    }\n    var i = 0, j = q.count-1\n    while i<j {\n        if q[i] != q[j] {\n            return false\n        }\n        i+=1\n        j-=1\n    }\n    return true\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isMultiplyPrime(a : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isMultiplyPrime((5l)) == (false));\n    assert(isMultiplyPrime((30l)) == (true));\n    assert(isMultiplyPrime((8l)) == (true));\n    assert(isMultiplyPrime((10l)) == (false));\n    assert(isMultiplyPrime((125l)) == (true));\n    assert(isMultiplyPrime((105l)) == (true));\n    assert(isMultiplyPrime((126l)) == (false));\n    assert(isMultiplyPrime((729l)) == (false));\n    assert(isMultiplyPrime((891l)) == (false));\n    assert(isMultiplyPrime((1001l)) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc is_multiply_prime(a: Int) -> Bool {\n    func is_prime(n: Int) -> Bool {\n        for j in 2..<n {\n            if n%j == 0 {\n                return false\n            }\n        }\n        return true\n    }\n\n    for i in 2..<101 {\n        if !is_prime(n: i) { continue }\n        for j in 2..<101 {\n            if !is_prime(n: j) { continue }\n            for k in 2..<101 {\n                if !is_prime(n: k) { continue }\n                if i*j*k == a { return true }\n            }\n        }\n    }\n    return false\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isMultiplyPrime(a : Long) : Boolean = {\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n    if k == 0 {\n        return []\n    }\n    var ans = arr.sorted().suffix(k)\n    return Array(ans)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def separateParenGroups(paren_string : String) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc separate_paren_groups(paren_string: String) -> [String] {\n    var result: [String] = []\n    var currentString: [Character] = []\n    var currentDepth = 0\n\n    for c in paren_string {\n        if c == \"(\" {\n            currentDepth += 1\n            currentString.append(c)\n        } else if c == \")\" {\n            currentDepth -= 1\n            currentString.append(c)\n\n            if currentDepth == 0 {\n                result.append(String(currentString))\n                currentString.removeAll()\n            }\n        }\n    }\n\n    return result\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def separateParenGroups(paren_string : String) : List[String] = {\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def filterIntegers(values : List[Any]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(filterIntegers((List[Any]())).equals((List[Long]())));\n    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, \"adasd\"))).equals((List[Long](4l.toLong, 9l.toLong))));\n    assert(filterIntegers((List[Any](3l, \"c\", 3l, 3l, \"a\", \"b\"))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n    return values.compactMap { $0 as? Int }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def filterIntegers(values : List[Any]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def skjkasdkd(lst : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));\n    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));\n    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));\n    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));\n    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));\n    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));\n    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc skjkasdkd(lst: [Int]) -> Int {\n    func isPrime(n: Int) -> Bool {\n        guard n >= 2 else { return false }\n        for i in 2..<Int(sqrt(Double(n))) + 1 {\n            if n % i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n\n    var maxx = 0\n    for i in lst {\n        if i > maxx && isPrime(n: i) {\n            maxx = i\n        }\n    }\n\n    return String(maxx).compactMap { Int(String($0)) }.reduce(0, +)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def skjkasdkd(lst : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\"))).equals((List[String](\"hi\", \"hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hi\", \"hi\", \"admin\", \"project\"))).equals((List[String](\"hi\", \"admin\"))));\n    assert(totalMatch((List[String](\"4\")), (List[String](\"1\", \"2\", \"3\", \"4\", \"5\"))).equals((List[String](\"4\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"Hi\"))).equals((List[String](\"hI\", \"Hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hi\"))).equals((List[String](\"hI\", \"hi\", \"hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hii\"))).equals((List[String](\"hi\", \"admin\"))));\n    assert(totalMatch((List[String]()), (List[String](\"this\"))).equals((List[String]())));\n    assert(totalMatch((List[String](\"this\")), (List[String]())).equals((List[String]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n    let l1 = lst1.reduce(0, { $0 + $1.count })\n    let l2 = lst2.reduce(0, { $0 + $1.count })\n\n    return l1 <= l2 ? lst1 : lst2\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def carRaceCollision(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc car_race_collision(n: Int) -> Int {\n    return n * n\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def carRaceCollision(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isSimplePower(x : Long, n : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n    if (n == 1) {\n        return (x == 1)\n    }\n    var power = 1\n    while (power < x) {\n        power = power * n\n    }\n    return (power == x)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isSimplePower(x : Long, n : Long) : Boolean = {\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def incrList(l : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc incr_list(l: [Int]) -> [Int] {\n    return l.map { $0 + 1 }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def incrList(l : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def flipCase(string : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(flipCase((\"\")).equals((\"\")));\n    assert(flipCase((\"Hello!\")).equals((\"hELLO!\")));\n    assert(flipCase((\"These violent delights have violent ends\")).equals((\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc flip_case(string: String) -> String {\n    return String(string.map { $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) })\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def flipCase(string : String) : String = {\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def vowelsCount(s : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(vowelsCount((\"abcde\")) == (2l));\n    assert(vowelsCount((\"Alone\")) == (3l));\n    assert(vowelsCount((\"key\")) == (2l));\n    assert(vowelsCount((\"bye\")) == (1l));\n    assert(vowelsCount((\"keY\")) == (2l));\n    assert(vowelsCount((\"bYe\")) == (1l));\n    assert(vowelsCount((\"ACEDY\")) == (3l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc vowels_count(s: String) -> Int {\n    let vowels = \"aeiouAEIOU\"\n    var n_vowels = s.filter { vowels.contains($0) }.count\n    if s.last == \"y\" || s.last == \"Y\" {\n        n_vowels += 1\n    }\n    return n_vowels\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def vowelsCount(s : String) : Long = {\n"
  },
  {
    "name": "HumanEval_149_sorted_list_sum",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortedListSum(lst : List[String]) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_149_sorted_list_sum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortedListSum((List[String](\"aa\", \"a\", \"aaa\"))).equals((List[String](\"aa\"))));\n    assert(sortedListSum((List[String](\"school\", \"AI\", \"asdf\", \"b\"))).equals((List[String](\"AI\", \"asdf\", \"school\"))));\n    assert(sortedListSum((List[String](\"d\", \"b\", \"c\", \"a\"))).equals((List[String]())));\n    assert(sortedListSum((List[String](\"d\", \"dcba\", \"abcd\", \"a\"))).equals((List[String](\"abcd\", \"dcba\"))));\n    assert(sortedListSum((List[String](\"AI\", \"ai\", \"au\"))).equals((List[String](\"AI\", \"ai\", \"au\"))));\n    assert(sortedListSum((List[String](\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"))).equals((List[String]())));\n    assert(sortedListSum((List[String](\"aaaa\", \"bbbb\", \"dd\", \"cc\"))).equals((List[String](\"cc\", \"dd\", \"aaaa\", \"bbbb\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sorted_list_sum(lst: [String]) -> [String] {\n    var lst = lst\n    lst.sort()\n    var new_lst = [String]()\n    for i in lst {\n        if i.count % 2 == 0 {\n            new_lst.append(i)\n        }\n    }\n    return new_lst.sorted { $0.count < $1.count }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortedListSum(lst : List[String]) : List[String] = {\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def wordsString(s : String) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(wordsString((\"Hi, my name is John\")).equals((List[String](\"Hi\", \"my\", \"name\", \"is\", \"John\"))));\n    assert(wordsString((\"One, two, three, four, five, six\")).equals((List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))));\n    assert(wordsString((\"Hi, my name\")).equals((List[String](\"Hi\", \"my\", \"name\"))));\n    assert(wordsString((\"One,, two, three, four, five, six,\")).equals((List[String](\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))));\n    assert(wordsString((\"\")).equals((List[String]())));\n    assert(wordsString((\"ahmed     , gamal\")).equals((List[String](\"ahmed\", \"gamal\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc words_string(s: String) -> [String] {\n    if s.isEmpty {\n        return []\n    }\n\n    var s_list = \"\"\n\n    for letter in s {\n        if letter == \",\" {\n            s_list.append(\" \")\n        } else {\n            s_list.append(letter)\n        }\n    }\n\n    return s_list.split(separator: \" \").map { String($0) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def wordsString(s : String) : List[String] = {\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n    func is_palindrome(_ n: Int) -> Bool {\n        return String(n) == String(String(n).reversed())\n    }\n\n    var even_palindrome_count = 0\n    var odd_palindrome_count = 0\n\n    for i in 1...n {\n        if i%2 == 1 && is_palindrome(i) {\n            odd_palindrome_count += 1\n        } else if i%2 == 0 && is_palindrome(i) {\n            even_palindrome_count += 1\n        }\n    }\n\n    return (even_palindrome_count, odd_palindrome_count)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def triangleArea(a : Long, b : Long, c : Long) : Float = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(triangleArea((3l), (4l), (5l)) == (6.0f));\n    assert(triangleArea((1l), (2l), (10l)) == -1l);\n    assert(triangleArea((4l), (8l), (5l)) == (8.18f));\n    assert(triangleArea((2l), (2l), (2l)) == (1.73f));\n    assert(triangleArea((1l), (2l), (3l)) == -1l);\n    assert(triangleArea((10l), (5l), (7l)) == (16.25f));\n    assert(triangleArea((2l), (6l), (3l)) == -1l);\n    assert(triangleArea((1l), (1l), (1l)) == (0.43f));\n    assert(triangleArea((2l), (2l), (10l)) == -1l);\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n    if a + b <= c || a + c <= b || b + c <= a {\n        return -1\n    }\n    let s = Double(a + b + c)/2\n    let area = (s * (s - Double(a)) * (s - Double(b)) * (s - Double(c))).squareRoot()\n    return Double(round(100*area)/100)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def triangleArea(a : Long, b : Long, c : Long) : Float = {\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc check_dict_case(dict: [String : String]) -> Bool {\n    if dict.keys.count == 0 {\n        return false\n    } else {\n        var state = \"start\"\n        for key in dict.keys {\n            if key is String == false {\n                state = \"mixed\"\n                break\n            }\n            if state == \"start\" {\n                if key.uppercased() == key {\n                    state = \"upper\"\n                } else if key.lowercased() == key {\n                    state = \"lower\"\n                } else {\n                    break\n                }\n            } else if (state == \"upper\" && key.uppercased() != key) || (state == \"lower\" && key.lowercased() != key) {\n                state = \"mixed\"\n                break\n            } else {\n                continue\n            }\n        }\n        return state == \"upper\" || state == \"lower\"\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def median(l : List[Long]) : Float = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);\n    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));\n    assert(median((List[Long](5l.toLong))) == 5l);\n    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));\n    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc median(l: [Int]) -> Double {\n    var l = l.sorted()\n    if l.count % 2 == 1 {\n        return Double(l[l.count / 2])\n    } else {\n        return Double(l[l.count / 2 - 1] + l[l.count / 2]) / 2.0\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def median(l : List[Long]) : Float = {\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def changeBase(x : Long, base : Long) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(changeBase((8l), (3l)).equals((\"22\")));\n    assert(changeBase((9l), (3l)).equals((\"100\")));\n    assert(changeBase((234l), (2l)).equals((\"11101010\")));\n    assert(changeBase((16l), (2l)).equals((\"10000\")));\n    assert(changeBase((8l), (2l)).equals((\"1000\")));\n    assert(changeBase((7l), (2l)).equals((\"111\")));\n    assert(changeBase((2l), (3l)).equals((\"2\")));\n    assert(changeBase((3l), (4l)).equals((\"3\")));\n    assert(changeBase((4l), (5l)).equals((\"4\")));\n    assert(changeBase((5l), (6l)).equals((\"5\")));\n    assert(changeBase((6l), (7l)).equals((\"6\")));\n    assert(changeBase((7l), (8l)).equals((\"7\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc change_base(x: Int, base: Int) -> String {\n    var ret = \"\"\n    var x = x\n    while x > 0 {\n        ret = \"\\(x % base)\" + ret\n        x /= base\n    }\n    return ret\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def changeBase(x : Long, base : Long) : String = {\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def longest(strings : List[String]) : Option[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc longest(strings: [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n    let maxlen = strings.map { $0.count }.max()!\n    for s in strings {\n        if s.count == maxlen {\n            return s\n        }\n    }\n    return nil\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def longest(strings : List[String]) : Option[String] = {\n"
  },
  {
    "name": "HumanEval_116_sort_array",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortArray(arr : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_116_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted().sorted { String($0, radix: 2).filter { $0 == \"1\" }.count < String($1, radix: 2).filter { $0 == \"1\" }.count }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortArray(arr : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var ret = Set<Int>()\n    for e1 in l1 {\n        for e2 in l2 {\n            if e1 == e2 {\n                ret.insert(e1)\n            }\n        }\n    }\n    return ret.sorted()\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def cycpatternCheck(a : String, b : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(cycpatternCheck((\"xyzw\"), (\"xyw\")) == (false));\n    assert(cycpatternCheck((\"yello\"), (\"ell\")) == (true));\n    assert(cycpatternCheck((\"whattup\"), (\"ptut\")) == (false));\n    assert(cycpatternCheck((\"efef\"), (\"fee\")) == (true));\n    assert(cycpatternCheck((\"abab\"), (\"aabb\")) == (false));\n    assert(cycpatternCheck((\"winemtt\"), (\"tinem\")) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc cycpattern_check(a: String, b: String) -> Bool {\n    let l = b.count\n    let pat = b + b\n    for i in 0...a.count - l {\n        for j in 0...l {\n            if a[a.index(a.startIndex, offsetBy: i)..<a.index(a.startIndex, offsetBy: i+l)] == pat[pat.index(pat.startIndex, offsetBy: j)..<pat.index(pat.startIndex, offsetBy: j+l)] {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def cycpatternCheck(a : String, b : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def minSubArraySum(nums : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));\n    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));\n    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));\n    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));\n    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));\n    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));\n    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));\n    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc minSubArraySum(nums: [Int]) -> Int {\n    var max_sum = 0\n    var s = 0\n    for num in nums {\n        s += -num\n        if s < 0 {\n            s = 0\n        }\n        max_sum = max(s, max_sum)\n    }\n    if max_sum == 0 {\n        max_sum = nums.map { -$0 }.max()!\n    }\n    let min_sum = -max_sum\n    return min_sum\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def minSubArraySum(nums : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortArray(array : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sort_array(array: [Int]) -> [Int] {\n    return array.isEmpty ? [] : array.sorted(by: { (array[0] + array[array.count-1]) % 2 == 0 ? $0 > $1 : $0 < $1 })\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortArray(array : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def histogram(test : String) : Map[String,Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(histogram((\"a b b a\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"a b c a b\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"a b c d g\")).equals((Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l, \"d\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"b b b b a\")).equals((Map[String,Long](\"b\" -> 4l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"\")).equals((Map[String,Long]())));\n    assert(histogram((\"a\")).equals((Map[String,Long](\"a\" -> 1l))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc histogram(test: String) -> [String : Int] {\n    var dict1 = [String : Int]()\n    let list1 = test.split(separator: \" \")\n    var t = 0\n    for i in list1 {\n        if(list1.filter{$0 == i}.count > t) && i != \"\" {\n            t = list1.filter{$0 == i}.count\n        }\n    }\n    if t > 0 {\n        for i in list1 {\n            if(list1.filter{$0 == i}.count == t) {\n                dict1[String(i)] = t\n            }\n        }\n    }\n    return dict1\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def histogram(test : String) : Map[String,Long] = {\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getOddCollatz(n : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));\n    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));\n    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var odd_collatz: [Int] = n % 2 == 0 ? [] : [n]\n    var m = n\n    while m > 1 {\n        if m % 2 == 0 {\n            m /= 2\n        } else {\n            m = m * 3 + 1\n        }\n        if m % 2 == 1 {\n            odd_collatz.append(m)\n        }\n    }\n    return odd_collatz.sorted()\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getOddCollatz(n : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def derivative(xs : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));\n    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));\n    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));\n    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc derivative(xs: [Int]) -> [Int] {\n    return Array(xs.enumerated().map { $0 * $1 }[1...])\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def derivative(xs : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fibfib(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(fibfib((2l)) == (1l));\n    assert(fibfib((1l)) == (0l));\n    assert(fibfib((5l)) == (4l));\n    assert(fibfib((8l)) == (24l));\n    assert(fibfib((10l)) == (81l));\n    assert(fibfib((12l)) == (274l));\n    assert(fibfib((14l)) == (927l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc fibfib(n: Int) -> Int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    return fibfib(n: n - 1) + fibfib(n: n - 2) + fibfib(n: n - 3)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fibfib(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def truncateNumber(number : Float) : Float = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc truncate_number(number: Double) -> Double {\n    return number.truncatingRemainder(dividingBy: 1.0)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def truncateNumber(number : Float) : Float = {\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def maxElement(l : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));\n    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc max_element(l: [Int]) -> Int {\n    var m = l[0]\n    for e in l {\n        if e > m {\n            m = e\n        }\n    }\n    return m\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def maxElement(l : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def closestInteger(value : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc closest_integer(value: String) -> Int {\n    let num = Double(value)!\n    if value.suffix(2) == \".5\" {\n        if num > 0 {\n            return Int(ceil(num))\n        } else {\n            return Int(floor(num))\n        }\n    } else if value.count > 0 {\n        return Int(round(num))\n    } else {\n        return 0\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def closestInteger(value : String) : Long = {\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sumProduct((List[Long]())).equals(((0l, 1l))));\n    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));\n    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));\n    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));\n    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n    var sumValue = 0\n    var prodValue = 1\n\n    for n in numbers {\n        sumValue += n\n        prodValue *= n\n    }\n    return (sumValue, prodValue)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def selectWords(s : String, n : Long) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(selectWords((\"Mary had a little lamb\"), (4l)).equals((List[String](\"little\"))));\n    assert(selectWords((\"Mary had a little lamb\"), (3l)).equals((List[String](\"Mary\", \"lamb\"))));\n    assert(selectWords((\"simple white space\"), (2l)).equals((List[String]())));\n    assert(selectWords((\"Hello world\"), (4l)).equals((List[String](\"world\"))));\n    assert(selectWords((\"Uncle sam\"), (3l)).equals((List[String](\"Uncle\"))));\n    assert(selectWords((\"\"), (4l)).equals((List[String]())));\n    assert(selectWords((\"a b c d e f\"), (1l)).equals((List[String](\"b\", \"c\", \"d\", \"f\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n    for word in s.split(separator: \" \") {\n        var n_consonants = 0\n        for char in word.lowercased() {\n            if ![\"a\",\"e\",\"i\",\"o\",\"u\"].contains(char) {\n                n_consonants += 1 \n            }\n        }\n        if n_consonants == n {\n            result.append(String(word))\n        }\n    }\n    return result\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def selectWords(s : String, n : Long) : List[String] = {\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def addElements(arr : List[Long], k : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));\n    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));\n    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));\n    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));\n    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc add_elements(arr: [Int], k: Int) -> Int {\n    return arr.prefix(k).filter { $0 <= 99 }.reduce(0, +)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def addElements(arr : List[Long], k : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if need <= remaining {\n        return [number + need, remaining - need]\n    } else {\n        return [number + remaining, 0]\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def nextSmallest(lst : List[Long]) : Option[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long]())).equals(None));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(1l));\n    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(-35l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc next_smallest(lst: [Int]) -> Int? {\n    var lst = Set(lst).sorted()\n    return lst.count < 2 ? nil : lst[1]\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def nextSmallest(lst : List[Long]) : Option[Long] = {\n"
  },
  {
    "name": "HumanEval_87_get_row",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_87_get_row.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var coords: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                coords.append((i, j))\n            }\n        }\n    }\n    return coords.sorted(by: { $0.1 > $1.1 }).sorted(by: { $0.0 < $1.0 })\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(filterByPrefix((List[String]()), (\"john\")).equals((List[String]())));\n    assert(filterByPrefix((List[String](\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"xxx\", \"xxxAAA\", \"xxx\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def chooseNum(x : Long, y : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(chooseNum((12l), (15l)) == (14l));\n    assert(chooseNum((13l), (12l)) == (-1l));\n    assert(chooseNum((33l), (12354l)) == (12354l));\n    assert(chooseNum((5234l), (5233l)) == (-1l));\n    assert(chooseNum((6l), (29l)) == (28l));\n    assert(chooseNum((27l), (10l)) == (-1l));\n    assert(chooseNum((7l), (7l)) == (-1l));\n    assert(chooseNum((546l), (546l)) == (546l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc choose_num(x: Int, y: Int) -> Int {\n    if x > y {\n        return -1\n    }\n    if y % 2 == 0 {\n        return y\n    }\n    if x == y {\n        return -1\n    }\n    return y - 1\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def chooseNum(x : Long, y : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def primeLength(string : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(primeLength((\"Hello\")) == (true));\n    assert(primeLength((\"abcdcba\")) == (true));\n    assert(primeLength((\"kittens\")) == (true));\n    assert(primeLength((\"orange\")) == (false));\n    assert(primeLength((\"wow\")) == (true));\n    assert(primeLength((\"world\")) == (true));\n    assert(primeLength((\"MadaM\")) == (true));\n    assert(primeLength((\"Wow\")) == (true));\n    assert(primeLength((\"\")) == (false));\n    assert(primeLength((\"HI\")) == (true));\n    assert(primeLength((\"go\")) == (true));\n    assert(primeLength((\"gogo\")) == (false));\n    assert(primeLength((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(primeLength((\"Madam\")) == (true));\n    assert(primeLength((\"M\")) == (false));\n    assert(primeLength((\"0\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc prime_length(string: String) -> Bool {\n    let l = string.count\n    if l == 0 || l == 1 {\n        return false\n    }\n    for i in 2..<l {\n        if l % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def primeLength(string : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumToN(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sumToN((1l)) == (1l));\n    assert(sumToN((6l)) == (21l));\n    assert(sumToN((11l)) == (66l));\n    assert(sumToN((30l)) == (465l));\n    assert(sumToN((100l)) == (5050l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sum_to_n(n: Int) -> Int {\n    return (0...n).reduce(0, +)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sumToN(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fixSpaces(text : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(fixSpaces((\"Example\")).equals((\"Example\")));\n    assert(fixSpaces((\"Mudasir Hanif \")).equals((\"Mudasir_Hanif_\")));\n    assert(fixSpaces((\"Yellow Yellow  Dirty  Fellow\")).equals((\"Yellow_Yellow__Dirty__Fellow\")));\n    assert(fixSpaces((\"Exa   mple\")).equals((\"Exa-mple\")));\n    assert(fixSpaces((\"   Exa 1 2 2 mple\")).equals((\"-Exa_1_2_2_mple\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc fix_spaces(text: String) -> String {\n    var new_text = \"\"\n    var i = 0\n    var start = 0, end = 0\n    while i < text.count {\n        let index = text.index(text.startIndex, offsetBy: i)\n        if text[index] == \" \" {\n            end += 1\n        } else {\n            if end - start > 2 {\n                new_text += \"-\\(text[index])\"\n            } else if end - start > 0 {\n                new_text += String(repeating: \"_\", count: end - start) + \"\\(text[index])\"\n            } else {\n                new_text += \"\\(text[index])\"\n            }\n            start = i + 1\n            end = i + 1\n        }\n        i += 1\n    }\n    if end - start > 2 {\n        new_text += \"-\"\n    } else if end - start > 0 {\n        new_text += \"_\"\n    }\n    return new_text\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fixSpaces(text : String) : String = {\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc rolling_max(numbers: [Int]) -> [Int] {\n    var running_max: Int? = nil\n    var result = [Int]()\n    for n in numbers {\n        if running_max == nil {\n            running_max = n\n        } else {\n            running_max = max(running_max!, n)\n        }\n        result.append(running_max!)\n    }\n    return result\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getClosestVowel(word : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc get_closest_vowel(word: String) -> String {\n    if word.count < 3 {\n        return \"\"\n    }\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"O\", \"U\", \"I\"]\n    for i in stride(from: word.count - 2, to: 0, by: -1) {\n        let index = word.index(word.startIndex, offsetBy: i)\n        if vowels.contains(word[index]) {\n            if !vowels.contains(word[word.index(after: index)]) && !vowels.contains(word[word.index(before: index)]) {\n                return String(word[index])\n            }\n        }\n    }\n    return \"\"\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getClosestVowel(word : String) : String = {\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n    return zip(game, guess).map { abs($0 - $1) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n    let c = NSCountedSet(array: numbers)\n    return numbers.filter { c.count(for: $0) <= 1 }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sameChars(s0 : String, s1 : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(sameChars((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(sameChars((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(sameChars((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(sameChars((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(sameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(sameChars((\"aabb\"), (\"aaccc\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc same_chars(s0: String, s1: String) -> Bool {\n    return Set(s0) == Set(s1)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sameChars(s0 : String, s1 : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def parseNestedParens(paren_string : String) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n    func parse_paren_group(s: String) -> Int {\n        var depth = 0\n        var max_depth = 0\n        for c in s {\n            if c == \"(\" {\n                depth += 1\n                max_depth = max(depth, max_depth)\n            } else {\n                depth -= 1\n            }\n        }\n        return max_depth\n    }\n    return paren_string.split(separator: \" \").map { parse_paren_group(s: String($0)) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def parseNestedParens(paren_string : String) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def evenOddCount(num : Long) : Tuple2[Long, Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(evenOddCount((7l)).equals(((0l, 1l))));\n    assert(evenOddCount((-78l)).equals(((1l, 1l))));\n    assert(evenOddCount((3452l)).equals(((2l, 2l))));\n    assert(evenOddCount((346211l)).equals(((3l, 3l))));\n    assert(evenOddCount((-345821l)).equals(((3l, 3l))));\n    assert(evenOddCount((-2l)).equals(((1l, 0l))));\n    assert(evenOddCount((-45347l)).equals(((2l, 3l))));\n    assert(evenOddCount((0l)).equals(((1l, 0l))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc even_odd_count(num: Int) -> (Int, Int) {\n    var even_count = 0\n    var odd_count = 0\n    for i in String(abs(num)) {\n        if Int(String(i))!%2 == 0 {\n            even_count += 1\n        } else {\n            odd_count += 1\n        }\n    }\n    return (even_count, odd_count)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def evenOddCount(num : Long) : Tuple2[Long, Long] = {\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fruitDistribution(s : String, n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(fruitDistribution((\"5 apples and 6 oranges\"), (19l)) == (8l));\n    assert(fruitDistribution((\"5 apples and 6 oranges\"), (21l)) == (10l));\n    assert(fruitDistribution((\"0 apples and 1 oranges\"), (3l)) == (2l));\n    assert(fruitDistribution((\"1 apples and 0 oranges\"), (3l)) == (2l));\n    assert(fruitDistribution((\"2 apples and 3 oranges\"), (100l)) == (95l));\n    assert(fruitDistribution((\"2 apples and 3 oranges\"), (5l)) == (0l));\n    assert(fruitDistribution((\"1 apples and 100 oranges\"), (120l)) == (19l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc fruit_distribution(s: String, n: Int) -> Int {\n    var lis = [Int]()\n    for i in s.split(separator: \" \") {\n        if let i = Int(i) {\n            lis.append(i)\n        }\n    }\n    return n - lis.reduce(0, +)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def fruitDistribution(s : String, n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def stringXor(a : String, b : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc string_xor(a: String, b: String) -> String {\n    func xor(i: Character, j: Character) -> String {\n        if i == j {\n            return \"0\"\n        } else {\n            return \"1\"\n        }\n    }\n    return zip(a, b).map { xor(i: $0, j: $1) }.joined()\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def stringXor(a : String, b : String) : String = {\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def strlen(string : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(strlen((\"\")) == (0l));\n    assert(strlen((\"x\")) == (1l));\n    assert(strlen((\"asdasnakj\")) == (9l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc strlen(string: String) -> Int {\n    return string.count\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def strlen(string : String) : Long = {\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def stringSequence(n : Long) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(stringSequence((0l)).equals((\"0\")));\n    assert(stringSequence((3l)).equals((\"0 1 2 3\")));\n    assert(stringSequence((10l)).equals((\"0 1 2 3 4 5 6 7 8 9 10\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc string_sequence(n: Int) -> String {\n    return (0...n).map{String($0)}.joined(separator: \" \")\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def stringSequence(n : Long) : String = {\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def canArrange(arr : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) == (-1l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc can_arrange(arr: [Int]) -> Int {\n    var ind = -1\n    var i = 1\n    while i < arr.count {\n        if arr[i] < arr[i-1] {\n            ind = i\n        }\n        i += 1\n    }\n    return ind\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def canArrange(arr : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def add(lst : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));\n    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));\n    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));\n    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc add(lst: [Int]) -> Int {\n    return lst.enumerated().filter { $0.offset % 2 != 0 && $0.element % 2 == 0 }.reduce(0) { $0 + $1.element }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def add(lst : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n    for n in numbers.dropLast() {\n        result.append(n)\n        result.append(delimeter)\n    }\n    result.append(numbers.last!)\n    return result\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def matchParens(lst : List[String]) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc match_parens(lst: [String]) -> String {\n    func check(s: String) -> Bool {\n        var val = 0\n        for i in s {\n            if i == \"(\" {\n                val += 1\n            } else {\n                val -= 1\n            }\n            if val < 0 {\n                return false\n            }\n        }\n        return val == 0 ? true : false\n    }\n\n    let S1 = lst[0] + lst[1]\n    let S2 = lst[1] + lst[0]\n    return check(s: S1) || check(s: S2) ? \"Yes\" : \"No\"\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def matchParens(lst : List[String]) : String = {\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def filterBySubstring(strings : List[String], substring : String) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(filterBySubstring((List[String]()), (\"john\")).equals((List[String]())));\n    assert(filterBySubstring((List[String](\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"xxx\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xx\")).equals((List[String](\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"grunt\", \"trumpet\", \"prune\", \"gruesome\")), (\"run\")).equals((List[String](\"grunt\", \"prune\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter { $0.contains(substring) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def filterBySubstring(strings : List[String], substring : String) : List[String] = {\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def findMax(words : List[String]) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(findMax((List[String](\"name\", \"of\", \"string\"))).equals((\"string\")));\n    assert(findMax((List[String](\"name\", \"enam\", \"game\"))).equals((\"enam\")));\n    assert(findMax((List[String](\"aaaaaaa\", \"bb\", \"cc\"))).equals((\"aaaaaaa\")));\n    assert(findMax((List[String](\"abc\", \"cba\"))).equals((\"abc\")));\n    assert(findMax((List[String](\"play\", \"this\", \"game\", \"of\", \"footbott\"))).equals((\"footbott\")));\n    assert(findMax((List[String](\"we\", \"are\", \"gonna\", \"rock\"))).equals((\"gonna\")));\n    assert(findMax((List[String](\"we\", \"are\", \"a\", \"mad\", \"nation\"))).equals((\"nation\")));\n    assert(findMax((List[String](\"this\", \"is\", \"a\", \"prrk\"))).equals((\"this\")));\n    assert(findMax((List[String](\"b\"))).equals((\"b\")));\n    assert(findMax((List[String](\"play\", \"play\", \"play\"))).equals((\"play\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc find_max(words: [String]) -> String {\n    return words.sorted(by: { if Set($0).count == Set($1).count { return $0 < $1 } else { return Set($0).count > Set($1).count } })[0]\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def findMax(words : List[String]) : String = {\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def generateIntegers(a : Long, b : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));\n    assert(generateIntegers((17l), (89l)).equals((List[Long]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n    let lower = max(2, min(a, b))\n    let upper = min(8, max(a, b))\n\n    return Array(stride(from: lower, through: upper, by: 2))\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def generateIntegers(a : Long, b : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n    let odd = lst1.filter { $0 % 2 == 1 }.count\n    let even = lst2.filter { $0 % 2 == 0 }.count\n    return even >= odd ? \"YES\" : \"NO\"\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def intToMiniRoman(number : Long) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc int_to_mini_roman(number: Int) -> String {\n    let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    let sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    var i = 12\n    var res = \"\"\n    var n = number\n    while n != 0 {\n        let div = n / num[i]\n        n %= num[i]\n        var j = div\n        while j != 0 {\n            res += sym[i]\n            j -= 1\n        }\n        i -= 1\n    }\n    return res.lowercased()\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def intToMiniRoman(number : Long) : String = {\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isEqualToSumEven(n : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isEqualToSumEven((4l)) == (false));\n    assert(isEqualToSumEven((6l)) == (false));\n    assert(isEqualToSumEven((8l)) == (true));\n    assert(isEqualToSumEven((10l)) == (true));\n    assert(isEqualToSumEven((11l)) == (false));\n    assert(isEqualToSumEven((12l)) == (true));\n    assert(isEqualToSumEven((13l)) == (false));\n    assert(isEqualToSumEven((16l)) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n    return n%2 == 0 && n >= 8\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isEqualToSumEven(n : Long) : Boolean = {\n"
  },
  {
    "name": "HumanEval_79_decimal_to_binary",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def decimalToBinary(decimal : Long) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_79_decimal_to_binary.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc decimal_to_binary(decimal: Int) -> String {\n    return \"db\" + String(decimal, radix: 2) + \"db\"\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def decimalToBinary(decimal : Long) : String = {\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortThird(l : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc sort_third(l: [Int]) -> [Int] {\n    var l = l\n    l.enumerated().filter { $0.offset % 3 == 0 }.map { $0.element }.sorted().enumerated().forEach { l[$0.offset * 3] = $0.element }\n    return l\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def sortThird(l : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def simplify(x : String, n : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(simplify((\"1/5\"), (\"5/1\")) == (true));\n    assert(simplify((\"1/6\"), (\"2/1\")) == (false));\n    assert(simplify((\"5/1\"), (\"3/1\")) == (true));\n    assert(simplify((\"7/10\"), (\"10/2\")) == (false));\n    assert(simplify((\"2/10\"), (\"50/10\")) == (true));\n    assert(simplify((\"7/2\"), (\"4/2\")) == (true));\n    assert(simplify((\"11/6\"), (\"6/1\")) == (true));\n    assert(simplify((\"2/3\"), (\"5/2\")) == (false));\n    assert(simplify((\"5/2\"), (\"3/5\")) == (false));\n    assert(simplify((\"2/4\"), (\"8/4\")) == (true));\n    assert(simplify((\"2/4\"), (\"4/2\")) == (true));\n    assert(simplify((\"1/5\"), (\"5/1\")) == (true));\n    assert(simplify((\"1/5\"), (\"1/5\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc simplify(x: String, n: String) -> Bool {\n    let parts1 = x.split(separator: \"/\").map { Int($0)! }\n    let parts2 = n.split(separator: \"/\").map { Int($0)! }\n    let numerator = parts1[0] * parts2[0]\n    let denom = parts1[1] * parts2[1]\n    return numerator % denom == 0\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def simplify(x : String, n : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def solve(s : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(solve((\"AsDf\")).equals((\"aSdF\")));\n    assert(solve((\"1234\")).equals((\"4321\")));\n    assert(solve((\"ab\")).equals((\"AB\")));\n    assert(solve((\"#a@C\")).equals((\"#A@c\")));\n    assert(solve((\"#AsdfW^45\")).equals((\"#aSDFw^45\")));\n    assert(solve((\"#6@2\")).equals((\"2@6#\")));\n    assert(solve((\"#$a^D\")).equals((\"#$A^d\")));\n    assert(solve((\"#ccc\")).equals((\"#CCC\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc solve(s: String) -> String {\n    var flg = 0\n    var idx = 0\n    var newStr = Array(s)\n    for i in s {\n        if i.isLetter {\n            newStr[idx] = i.isUppercase ? Character(i.lowercased()) : Character(i.uppercased())\n            flg = 1\n        }\n        idx += 1\n    }\n    if flg == 0 {\n        return String(newStr.reversed())\n    }\n    return String(newStr)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def solve(s : String) : String = {\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));\n    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));\n    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));\n    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));\n    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));\n    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));\n    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));\n    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));\n    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));\n    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));\n    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n    return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def belowZero(operations : List[Long]) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(belowZero((List[Long]())) == (false));\n    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));\n    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));\n    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));\n    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc below_zero(operations: [Int]) -> Bool {\n    var balance = 0\n    for op in operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def belowZero(operations : List[Long]) : Boolean = {\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def greatestCommonDivisor(a : Long, b : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(greatestCommonDivisor((3l), (7l)) == (1l));\n    assert(greatestCommonDivisor((10l), (15l)) == (5l));\n    assert(greatestCommonDivisor((49l), (14l)) == (7l));\n    assert(greatestCommonDivisor((144l), (60l)) == (12l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        (a, b) = (b, a % b)\n    }\n    return a\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def greatestCommonDivisor(a : Long, b : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def f(n : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));\n    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));\n    assert(f((1l)).equals((List[Long](1l.toLong))));\n    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc f(n: Int) -> [Int] {\n    var ret = [Int]()\n    for i in 1...n {\n        if i%2 == 0 {\n            var x = 1\n            for j in 1...i { x *= j }\n            ret += [x]\n        } else {\n            var x = 0\n            for j in 1...i { x += j }\n            ret += [x]\n        }\n    }\n    return ret\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def f(n : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def monotonic(l : List[Long]) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));\n    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));\n    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));\n    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));\n    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc monotonic(l: [Int]) -> Bool {\n    return l == l.sorted() || l == l.sorted(by: >)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def monotonic(l : List[Long]) : Boolean = {\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def removeVowels(text : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(removeVowels((\"\")).equals((\"\")));\n    assert(removeVowels((\"abcdef\\nghijklm\")).equals((\"bcdf\\nghjklm\")));\n    assert(removeVowels((\"fedcba\")).equals((\"fdcb\")));\n    assert(removeVowels((\"eeeee\")).equals((\"\")));\n    assert(removeVowels((\"acBAA\")).equals((\"cB\")));\n    assert(removeVowels((\"EcBOO\")).equals((\"cB\")));\n    assert(removeVowels((\"ybcd\")).equals((\"ybcd\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc remove_vowels(text: String) -> String {\n    return text.filter { !\"aeiouAEIOU\".contains($0) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def removeVowels(text : String) : String = {\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def checkIfLastCharIsALetter(txt : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(checkIfLastCharIsALetter((\"apple\")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pi e\")) == (true));\n    assert(checkIfLastCharIsALetter((\"eeeee\")) == (false));\n    assert(checkIfLastCharIsALetter((\"A\")) == (true));\n    assert(checkIfLastCharIsALetter((\"Pumpkin pie \")) == (false));\n    assert(checkIfLastCharIsALetter((\"Pumpkin pie 1\")) == (false));\n    assert(checkIfLastCharIsALetter((\"\")) == (false));\n    assert(checkIfLastCharIsALetter((\"eeeee e \")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pie\")) == (false));\n    assert(checkIfLastCharIsALetter((\"apple pi e \")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n    let check = txt.components(separatedBy: \" \").last!\n    return check.count == 1 && (97...122).contains(Int(check.lowercased().unicodeScalars.first!.value))\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def checkIfLastCharIsALetter(txt : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def iscube(a : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(iscube((1l)) == (true));\n    assert(iscube((2l)) == (false));\n    assert(iscube((-1l)) == (true));\n    assert(iscube((64l)) == (true));\n    assert(iscube((180l)) == (false));\n    assert(iscube((1000l)) == (true));\n    assert(iscube((0l)) == (true));\n    assert(iscube((1729l)) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc iscube(a: Int) -> Bool {\n    let a = abs(a)\n    return Int(round(pow(Double(a), 1.0/3.0))) * Int(round(pow(Double(a), 1.0/3.0))) * Int(round(pow(Double(a), 1.0/3.0))) == a\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def iscube(a : Long) : Boolean = {\n"
  },
  {
    "name": "HumanEval_112_reverse_delete",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_112_reverse_delete.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(reverseDelete((\"abcde\"), (\"ae\")).equals(((\"bcd\", false))));\n    assert(reverseDelete((\"abcdef\"), (\"b\")).equals(((\"acdef\", false))));\n    assert(reverseDelete((\"abcdedcba\"), (\"ab\")).equals(((\"cdedc\", true))));\n    assert(reverseDelete((\"dwik\"), (\"w\")).equals(((\"dik\", false))));\n    assert(reverseDelete((\"a\"), (\"a\")).equals(((\"\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"\")).equals(((\"abcdedcba\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"v\")).equals(((\"abcdedcba\", true))));\n    assert(reverseDelete((\"vabba\"), (\"v\")).equals(((\"abba\", true))));\n    assert(reverseDelete((\"mamma\"), (\"mia\")).equals(((\"\", true))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc reverse_delete(s: String, c: String) -> (String, Bool) {\n    let s = s.filter { !c.contains($0) }\n    return (s, String(s.reversed()) == s)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));\n    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n    let mean = numbers.reduce(0, +) / Double(numbers.count)\n    return numbers.reduce(0) { $0 + abs($1 - mean) } / Double(numbers.count)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def correctBracketing(brackets : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"<>\")) == (true));\n    assert(correctBracketing((\"<<><>>\")) == (true));\n    assert(correctBracketing((\"<><><<><>><>\")) == (true));\n    assert(correctBracketing((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(correctBracketing((\"<<<><>>>>\")) == (false));\n    assert(correctBracketing((\"><<>\")) == (false));\n    assert(correctBracketing((\"<\")) == (false));\n    assert(correctBracketing((\"<<<<\")) == (false));\n    assert(correctBracketing((\">\")) == (false));\n    assert(correctBracketing((\"<<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>><<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>>><>\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc correct_bracketing(brackets: String) -> Bool {\n    var depth = 0\n    for b in brackets {\n        if b == \"<\" {\n            depth += 1\n        } else {\n            depth -= 1\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def correctBracketing(brackets : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rescaleToUnit(numbers : List[Float]) : List[Float] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n    let minNumber = numbers.min()!\n    let maxNumber = numbers.max()!\n    return numbers.map { ($0 - minNumber) / (maxNumber - minNumber) }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def rescaleToUnit(numbers : List[Float]) : List[Float] = {\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n    func isPrime(num: Int) -> Bool {\n        if num == 1 || num == 0 {\n            return false\n        }\n        if num == 2 {\n            return true\n        }\n        for i in 2..<num {\n            if num%i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n\n    let l = max(interval1.0, interval2.0)\n    let r = min(interval1.1, interval2.1)\n    let length = r - l\n    if length > 0 && isPrime(num: length) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def hexKey(num : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc hex_key(num: String) -> Int {\n    let primes = \"2357BD\"\n    var total = 0\n    for i in num {\n        if primes.contains(i) {\n            total += 1\n        }\n    }\n    return total\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def hexKey(num : String) : Long = {\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def strangeSortList(lst : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long]())).equals((List[Long]())));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n    var res: [Int] = [], switcher = true\n    var lst = lst\n    while !lst.isEmpty {\n        res.append(switcher ? lst.min()! : lst.max()!)\n        lst.remove(at: lst.firstIndex(of: res.last!)!)\n        switcher.toggle()\n    }\n    return res\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def strangeSortList(lst : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_91_is_bored",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isBored(S : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_91_is_bored.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isBored((\"Hello world\")) == (0l));\n    assert(isBored((\"Is the sky blue?\")) == (0l));\n    assert(isBored((\"I love It !\")) == (1l));\n    assert(isBored((\"bIt\")) == (0l));\n    assert(isBored((\"I feel good today. I will be productive. will kill It\")) == (2l));\n    assert(isBored((\"You and I are going for a walk\")) == (0l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc is_bored(S: String) -> Int {\n    let sentences = S.components(separatedBy: CharacterSet(charactersIn: \".?!\")).map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n    return sentences.filter { $0.hasPrefix(\"I \") }.count\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isBored(S : String) : Long = {\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def allPrefixes(string : String) : List[String] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(allPrefixes((\"\")).equals((List[String]())));\n    assert(allPrefixes((\"asdfgh\")).equals((List[String](\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"))));\n    assert(allPrefixes((\"WWW\")).equals((List[String](\"W\", \"WW\", \"WWW\"))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc all_prefixes(string: String) -> [String] {\n    var result = [String]()\n\n    for i in 0..<string.count {\n        result.append(String(string.prefix(i+1)))\n    }\n    return result\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def allPrefixes(string : String) : List[String] = {\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def howManyTimes(string : String, substring : String) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(howManyTimes((\"\"), (\"x\")) == (0l));\n    assert(howManyTimes((\"xyxyxyx\"), (\"x\")) == (4l));\n    assert(howManyTimes((\"cacacacac\"), (\"cac\")) == (4l));\n    assert(howManyTimes((\"john doe\"), (\"john\")) == (1l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc how_many_times(string: String, substring: String) -> Int {\n    var times = 0\n    for i in 0..<string.count - substring.count + 1 {\n        let start = string.index(string.startIndex, offsetBy: i)\n        let end = string.index(start, offsetBy: substring.count)\n        if string[start..<end] == substring {\n            times += 1\n        }\n    }\n    return times\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def howManyTimes(string : String, substring : String) : Long = {\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def solution(lst : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));\n    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));\n    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));\n    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));\n    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc solution(lst: [Int]) -> Int {\n    return lst.enumerated().reduce(0) { $1.offset % 2 == 0 && $1.element % 2 == 1 ? $0 + $1.element : $0 }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def solution(lst : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isSorted(lst : List[Long]) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isSorted((List[Long](5l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));\n    assert(isSorted((List[Long]())) == (true));\n    assert(isSorted((List[Long](1l.toLong))) == (true));\n    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc is_sorted(lst: [Int]) -> Bool {\n    var count_digit = [Int: Int]()\n    for i in lst {\n        count_digit[i, default: 0] += 1\n    }\n    if lst.contains(where: { count_digit[$0]! > 2 }) {\n        return false\n    }\n    if lst.indices.dropFirst().allSatisfy({ lst[$0-1] <= lst[$0] }) {\n        return true\n    } else {\n        return false\n    }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isSorted(lst : List[Long]) : Boolean = {\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def search(lst : List[Long]) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong))) == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc search(lst: [Int]) -> Int {\n    var frq = [Int](repeating: 0, count: lst.max()! + 1)\n    for i in lst {\n        frq[i] += 1\n    }\n    var ans = -1\n    for i in 1..<frq.count {\n        if frq[i] >= i {\n            ans = i\n        }\n    }\n    return ans\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def search(lst : List[Long]) : Long = {\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def pluck(arr : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty { return [] }\n    let evens = arr.filter { $0 % 2 == 0 }\n    if evens.isEmpty { return [] }\n    return [evens.min()!, arr.firstIndex(of: evens.min()!)!]\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def pluck(arr : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def pairsSumToZero(l : List[Long]) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n    for i in 0..<l.count {\n        for j in i+1..<l.count {\n            if l[i] + l[j] == 0 {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def pairsSumToZero(l : List[Long]) : Boolean = {\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def makePalindrome(string : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty {\n        return \"\"\n    }\n    var beginning_of_suffix = 0\n    while string.suffix(from: string.index(string.startIndex, offsetBy: beginning_of_suffix)) != String(string.suffix(from: string.index(string.startIndex, offsetBy: beginning_of_suffix)).reversed()) {\n        beginning_of_suffix += 1\n    }\n    return string + String(string.prefix(beginning_of_suffix).reversed())\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def makePalindrome(string : String) : String = {\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def startsOneEnds(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(startsOneEnds((1l)) == (1l));\n    assert(startsOneEnds((2l)) == (18l));\n    assert(startsOneEnds((3l)) == (180l));\n    assert(startsOneEnds((4l)) == (1800l));\n    assert(startsOneEnds((5l)) == (18000l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc starts_one_ends(n: Int) -> Int {\n    if n == 1 { return 1 }\n    return 18 * Int(pow(10, Double(n - 2)))\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def startsOneEnds(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getPositive(l : List[Long]) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));\n    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));\n    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));\n    assert(getPositive((List[Long]())).equals((List[Long]())));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc get_positive(l: [Int]) -> [Int] {\n    return l.filter { $0 > 0 }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getPositive(l : List[Long]) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def concatenate(strings : List[String]) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(concatenate((List[String]())).equals((\"\")));\n    assert(concatenate((List[String](\"x\", \"y\", \"z\"))).equals((\"xyz\")));\n    assert(concatenate((List[String](\"x\", \"y\", \"z\", \"w\", \"k\"))).equals((\"xyzwk\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc concatenate(strings: [String]) -> String {\n    return strings.joined()\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def concatenate(strings : List[String]) : String = {\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isNested(string : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isNested((\"[[]]\")) == (true));\n    assert(isNested((\"[]]]]]]][[[[[]\")) == (false));\n    assert(isNested((\"[][]\")) == (false));\n    assert(isNested((\"[]\")) == (false));\n    assert(isNested((\"[[[[]]]]\")) == (true));\n    assert(isNested((\"[]]]]]]]]]]\")) == (false));\n    assert(isNested((\"[][][[]]\")) == (true));\n    assert(isNested((\"[[]\")) == (false));\n    assert(isNested((\"[]]\")) == (false));\n    assert(isNested((\"[[]][[\")) == (true));\n    assert(isNested((\"[[][]]\")) == (true));\n    assert(isNested((\"\")) == (false));\n    assert(isNested((\"[[[[[[[[\")) == (false));\n    assert(isNested((\"]]]]]]]]\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc is_nested(string: String) -> Bool {\n    var opening_bracket_index = [Int]()\n    var closing_bracket_index = [Int]()\n    for (i, char) in string.enumerated() {\n        if char == \"[\" {\n            opening_bracket_index.append(i)\n        } else if char == \"]\" {\n            closing_bracket_index.append(i)\n        }\n    }\n    closing_bracket_index.reverse()\n    var cnt = 0\n    var i = 0\n    let l = closing_bracket_index.count\n    for idx in opening_bracket_index {\n        if i < l && idx < closing_bracket_index[i] {\n            cnt += 1\n            i += 1\n        }\n    }\n    return cnt >= 2\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isNested(string : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isPalindrome(text : String) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isPalindrome((\"\")) == (true));\n    assert(isPalindrome((\"aba\")) == (true));\n    assert(isPalindrome((\"aaaaa\")) == (true));\n    assert(isPalindrome((\"zbcd\")) == (false));\n    assert(isPalindrome((\"xywyx\")) == (true));\n    assert(isPalindrome((\"xywyz\")) == (false));\n    assert(isPalindrome((\"xywzx\")) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc is_palindrome(text: String) -> Bool {\n    return text.enumerated().allSatisfy { $0.element == text[text.index(text.startIndex, offsetBy: text.count - 1 - $0.offset)] }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isPalindrome(text : String) : Boolean = {\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def factorize(n : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(factorize((2l)).equals((List[Long](2l.toLong))));\n    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));\n    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));\n    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc factorize(n: Int) -> [Int] {\n    var fact: [Int] = []\n    var i = 2\n    var n = n\n    while i <= Int(sqrt(Double(n)) + 1) {\n        if n % i == 0 {\n            fact.append(i)\n            n /= i\n        } else {\n            i += 1\n        }\n    }\n\n    if n > 1 {\n        fact.append(n)\n    }\n    return fact\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def factorize(n : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def largestPrimeFactor(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(largestPrimeFactor((15l)) == (5l));\n    assert(largestPrimeFactor((27l)) == (3l));\n    assert(largestPrimeFactor((63l)) == (7l));\n    assert(largestPrimeFactor((330l)) == (11l));\n    assert(largestPrimeFactor((13195l)) == (29l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc largest_prime_factor(n: Int) -> Int {\n    func is_prime(k: Int) -> Bool {\n        if k < 2 {\n            return false\n        }\n        for i in 2..<k {\n            if k % i == 0 {\n                return false\n            }\n        }\n        return true\n    }\n    var largest = 1\n    for j in 2...n {\n        if n % j == 0 && is_prime(k: j) {\n            largest = max(largest, j)\n        }\n    }\n    return largest\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def largestPrimeFactor(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getMaxTriples(n : Long) : Long = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getMaxTriples((5l)) == (1l));\n    assert(getMaxTriples((6l)) == (4l));\n    assert(getMaxTriples((10l)) == (36l));\n    assert(getMaxTriples((100l)) == (53361l));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc get_max_triples(n: Int) -> Int {\n    let A = (1...n).map { $0 * $0 - $0 + 1 }\n    var ans = [(Int, Int, Int)]()\n    for i in 0..<n {\n        for j in (i+1)..<n {\n            for k in (j+1)..<n {\n                if (A[i]+A[j]+A[k])%3 == 0 {\n                    ans.append((A[i],A[j],A[k]))\n                }\n            }\n        }\n    }\n    return ans.count\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def getMaxTriples(n : Long) : Long = {\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def antiShuffle(s : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(antiShuffle((\"Hi\")).equals((\"Hi\")));\n    assert(antiShuffle((\"hello\")).equals((\"ehllo\")));\n    assert(antiShuffle((\"number\")).equals((\"bemnru\")));\n    assert(antiShuffle((\"abcd\")).equals((\"abcd\")));\n    assert(antiShuffle((\"Hello World!!!\")).equals((\"Hello !!!Wdlor\")));\n    assert(antiShuffle((\"\")).equals((\"\")));\n    assert(antiShuffle((\"Hi. My name is Mister Robot. How are you?\")).equals((\".Hi My aemn is Meirst .Rboot How aer ?ouy\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc anti_shuffle(s: String) -> String {\n    return s.split(separator: \" \").map { String($0.sorted()) }.joined(separator: \" \")\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def antiShuffle(s : String) : String = {\n"
  },
  {
    "name": "HumanEval_84_solve",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def solve(N : Long) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_84_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc solve(N: Int) -> String {\n    let sum = String(N).reduce(0) { $0 + Int(String($1))! }\n    return String(sum, radix: 2)\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def solve(N : Long) : String = {\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n    let n = grid.count\n    var val = n * n + 1\n    for i in 0..<n {\n        for j in 0..<n {\n            if grid[i][j] == 1 {\n                var temp = [Int]()\n                if i != 0 {\n                    temp.append(grid[i - 1][j])\n                }\n                if j != 0 {\n                    temp.append(grid[i][j - 1])\n                }\n                if i != n - 1 {\n                    temp.append(grid[i + 1][j])\n                }\n                if j != n - 1 {\n                    temp.append(grid[i][j + 1])\n                }\n                val = temp.min()!\n            }\n        }\n    }\n    var ans = [Int]()\n    for i in 0..<k {\n        if i % 2 == 0 {\n            ans.append(1)\n        } else {\n            ans.append(val)\n        }\n    }\n    return ans\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def encrypt(s : String) : String = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\")).equals((\"e\")));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nimport Swift\nimport Foundation\nfunc encrypt(s: String) -> String {\n    let d = \"abcdefghijklmnopqrstuvwxyz\"\n    var out = \"\"\n\n    for c in s {\n        if let index = d.firstIndex(of: c) {\n            let newIndex = (d.distance(from: d.startIndex, to: index) + 4) % 26\n            out.append(d[d.index(d.startIndex, offsetBy: newIndex)])\n        } else {\n            out.append(c)\n        }\n    }\n\n    return out\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def encrypt(s : String) : String = {\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def makeAPile(n : Long) : List[Long] = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc make_a_pile(n: Int) -> [Int] {\n    return (0..<n).map { n + 2*$0 }\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def makeAPile(n : Long) : List[Long] = {\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "scala",
    "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isPrime(n : Long) : Boolean = {\n",
    "doctests": "keep",
    "original": "/Users/zilutang/Projects/code_translation/explain-then-translate/MultiPL-C2C/datasets/../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "    }\n    def main(args: Array[String]) = {\n    assert(isPrime((6l)) == (false));\n    assert(isPrime((101l)) == (true));\n    assert(isPrime((11l)) == (true));\n    assert(isPrime((13441l)) == (true));\n    assert(isPrime((61l)) == (true));\n    assert(isPrime((4l)) == (false));\n    assert(isPrime((1l)) == (false));\n    assert(isPrime((5l)) == (true));\n    assert(isPrime((11l)) == (true));\n    assert(isPrime((17l)) == (true));\n    assert(isPrime((85l)) == (false));\n    assert(isPrime((77l)) == (false));\n    assert(isPrime((255379l)) == (false));\n    }\n\n}\n",
    "stop_tokens": [
      "\n    }\n"
    ],
    "translation_prompt": "### Swift version\n\nfunc is_prime(n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    for k in 2..<n {\n        if n % k == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n### Scala version\n\nimport scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    def isPrime(n : Long) : Boolean = {\n"
  }
]