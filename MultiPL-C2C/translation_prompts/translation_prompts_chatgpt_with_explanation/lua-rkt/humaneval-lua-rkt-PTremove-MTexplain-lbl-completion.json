[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"()\") #t 0.001)\n    (check-within (candidate \"(()())\") #t 0.001)\n    (check-within (candidate \"()()(()())()\") #t 0.001)\n    (check-within (candidate \"()()((()()())())(()()(()))\") #t 0.001)\n    (check-within (candidate \"((()())))\") #f 0.001)\n    (check-within (candidate \")(()\") #f 0.001)\n    (check-within (candidate \"(\") #f 0.001)\n    (check-within (candidate \"((((\") #f 0.001)\n    (check-within (candidate \")\") #f 0.001)\n    (check-within (candidate \"(()\") #f 0.001)\n    (check-within (candidate \"()()(()())())(()\") #f 0.001)\n    (check-within (candidate \"()()(()())()))()\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for i=1, #brackets do\n        if brackets:sub(i,i) == \"(\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if a string of brackets is correctly balanced. The function takes a string of brackets as input and returns true if the brackets are balanced and false otherwise.\n\nThe first line of the code imports the math library.\n\nThe second line of the code defines a function called `correct_bracketing` that takes a string of brackets as input.\n\nThe third line of the code initializes a variable called `depth` to 0.\n\nThe fourth line of the code starts a loop that iterates over each character in the string of brackets.\n\nThe fifth line of the code checks if the current character is an opening bracket. If it is, then the `depth` variable is incremented by 1.\n\nThe sixth line of the code checks if the current character is a closing bracket. If it is, then the `depth` variable is decremented by 1.\n\nThe seventh line of the code checks if the `depth` variable is negative. If it is, then the brackets are not balanced and the function returns false.\n\nThe eighth line of the code checks if the loop has finished iterating over all the characters in the string of brackets and if the `depth` variable is 0. If both conditions are true, then the brackets are balanced and the function returns true. Otherwise, the brackets are not balanced and the function returns false.\n\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a h)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 5 3) 7.5 0.001)\n    (check-within (candidate 2 2) 2.0 0.001)\n    (check-within (candidate 10 8) 40.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, h)\n    return a * h / 2\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates the area of a triangle. The function takes two arguments, the base of the triangle `a` and the height of the triangle `h`. The area of a triangle is calculated as `a * h / 2`. \n\nThe first line of the code imports the math library. This library provides a set of mathematical functions that can be used in the program. The `require` function is used to load the library.\n\nThe second line of the code defines the function `triangle_area` that takes two arguments, `a` and `h`. The function calculates the area of a triangle using the formula `a * h / 2`. The `return` statement is used to return the result of the calculation.\n\nThe `local` keyword is used to define the function within the scope of the current block. This means that the function is only accessible within the block of code where it is defined.\n\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a h)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (special_factorial n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate special_factorial))\n    (check-within (candidate 4) 288 0.001)\n    (check-within (candidate 5) 34560 0.001)\n    (check-within (candidate 7) 125411328000 0.001)\n    (check-within (candidate 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function special_factorial(n)\n  local fact_i = 1\n  local special_fact = 1\n  for i=1, n do\n    fact_i = fact_i * i\n    special_fact = special_fact * fact_i\n  end\n  return special_fact\nend\n\n### Explanation\n\nThe code is an implementation of a special factorial function. The function takes an integer `n` as input and returns the product of factorials of all integers from 1 to `n`. \n\nThe first line of the code imports the `math` module which provides mathematical functions for Lua.\n\nThe second line of the code defines a function `special_factorial` which takes an integer `n` as input. \n\nThe third line of the code initializes two local variables `fact_i` and `special_fact` to 1. \n\nThe fourth line of the code starts a loop which iterates from 1 to `n`. \n\nThe fifth line of the code multiplies `fact_i` by the current value of `i`. \n\nThe sixth line of the code multiplies `special_fact` by the current value of `fact_i`. \n\nThe seventh line of the code returns the value of `special_fact` after the loop has completed. \n\n\n### Racket version\n\n#lang racket\n\n(define (special_factorial n)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (move_one_ball arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate move_one_ball))\n    (check-within (candidate (list 3 4 5 1 2)) #t 0.001)\n    (check-within (candidate (list 3 5 10 1 2)) #t 0.001)\n    (check-within (candidate (list 4 3 1 2)) #f 0.001)\n    (check-within (candidate (list 3 5 4 1 2)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function move_one_ball(arr)\n  if #arr==0 then\n    return true\n  end\n  local sorted_array = {}\n  for i=1,#arr do\n    sorted_array[i]=arr[i]\n  end\n  table.sort(sorted_array)\n  local my_arr = {}\n  local min_value = math.min(table.unpack(arr))\n  local min_index = 1\n  for i=1,#arr do\n    if arr[i]==min_value then\n      min_index = i\n      break\n    end\n  end\n  for i=min_index,#arr do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,min_index-1 do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,#arr do\n    if my_arr[i]~=sorted_array[i] then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function called `move_one_ball` that takes an array of integers as input and returns a boolean value. The function checks if it is possible to move one ball from one position in the array to another position in the array such that the resulting array is sorted in ascending order.\n\n\n### Racket version\n\n#lang racket\n\n(define (move_one_ball arr)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digits n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 54) 5 0.001)\n    (check-within (candidate 120) 1 0.001)\n    (check-within (candidate 5014) 5 0.001)\n    (check-within (candidate 98765) 315 0.001)\n    (check-within (candidate 5576543) 2625 0.001)\n    (check-within (candidate 2468) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function digits(n)\n    local product = 1\n    local odd_count = 0\n    for digit in tostring(n):gmatch(\"%d\") do\n        local int_digit = tonumber(digit)\n        if int_digit%2 == 1 then\n            product= product*int_digit\n            odd_count=odd_count+1\n        end\n    end\n    if odd_count ==0 then\n        return 0\n    else\n        return product\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `digits(n)` that takes an integer `n` and returns the product of all odd digits in `n`. If `n` has no odd digits, the function returns 0.\n\n\n### Racket version\n\n#lang racket\n\n(define (digits n)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib4 n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib4))\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 28 0.001)\n    (check-within (candidate 10) 104 0.001)\n    (check-within (candidate 12) 386 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fib4(n)\n  local results = {0, 0, 2, 0}\n  if n < 4 then\n    return results[n]\n  end\n\n  for i = 4, n do\n    table.insert(results, results[#results] + results[#results - 1] + results[#results - 2] + results[#results - 3])\n    table.remove(results, 1)\n  end\n\n  return results[#results]\nend\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence using a technique called \"rolling array\". The `fib4` function takes an integer `n` and returns the `n`th number in the Fibonacci sequence.\n\nThe first line of the program imports the `math` library, which provides mathematical functions.\n\nThe second line defines the `fib4` function. It takes an integer `n` as input.\n\nThe third line creates an array called `results` with four elements: 0, 0, 2, and 0. These are the first four numbers in the Fibonacci sequence.\n\nThe fourth line checks if `n` is less than 4. If it is, the function returns the `n`th element of the `results` array.\n\nThe fifth line starts a loop that runs from 4 to `n`. This loop calculates the next number in the Fibonacci sequence by adding the last four numbers in the `results` array. It then appends this new number to the end of the array and removes the first element of the array (i.e., the oldest number in the sequence).\n\nThe final line returns the last element of the `results` array, which is the `n`th number in the Fibonacci sequence.\n\n\n### Racket version\n\n#lang racket\n\n(define (fib4 n)\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_even l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_even))\n    (check-within (candidate (list 1 2 3)) (list 1 2 3) 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123) 0.001)\n    (check-within (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_even(l)\n    local evens = {}\n    local odds = {}\n    for i = 1, #l, 2 do\n        table.insert(evens, l[i])\n    end\n    for i = 2, #l, 2 do\n        table.insert(odds, l[i])\n    end\n    table.sort(evens)\n    local ans = {}\n    for i = 1, math.min(#evens, #odds) do\n        table.insert(ans, evens[i])\n        table.insert(ans, odds[i])\n    end\n    if #evens > #odds then\n        table.insert(ans, evens[#evens])\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function `sort_even` that takes a list of integers and sorts the even numbers in ascending order, while keeping the odd numbers in their original order. \n\n\n### Racket version\n\n#lang racket\n\n(define (sort_even l)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_happy s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n    (check-within (candidate \"a\") #f 0.001)\n    (check-within (candidate \"aa\") #f 0.001)\n    (check-within (candidate \"abcd\") #t 0.001)\n    (check-within (candidate \"aabb\") #f 0.001)\n    (check-within (candidate \"adb\") #t 0.001)\n    (check-within (candidate \"xyy\") #f 0.001)\n    (check-within (candidate \"iopaxpoi\") #t 0.001)\n    (check-within (candidate \"iopaxioi\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_happy(s)\n  if #s < 3 then\n    return false\n  end\n\n  for i = 1, #s - 2 do\n    if s:sub(i,i) == s:sub(i+1,i+1) or s:sub(i+1,i+1) == s:sub(i+2,i+2) or s:sub(i,i) == s:sub(i+2,i+2) then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_happy` that takes a string `s` as input and returns `true` if the string is \"happy\" and `false` otherwise. A string is considered \"happy\" if it does not contain any consecutive identical characters and has at least three characters.\n\nThe first line of the code imports the `math` module.\n\nThe second line defines a local function `is_happy` that takes a string `s` as input.\n\nThe third line checks if the length of the string `s` is less than 3. If it is, the function returns `false`.\n\nThe fourth line starts a `for` loop that iterates over the indices of the string `s` from 1 to the second-to-last index.\n\nThe fifth line checks if any of the three pairs of consecutive characters in the string `s` are identical. If any of them are, the function returns `false`.\n\nThe sixth line returns `true` if the function has not yet returned `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_happy s)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (circular_shift x shift)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n    (check-within (candidate 100 2) \"001\" 0.001)\n    (check-within (candidate 12 2) \"12\" 0.001)\n    (check-within (candidate 97 8) \"79\" 0.001)\n    (check-within (candidate 12 1) \"21\" 0.001)\n    (check-within (candidate 11 101) \"11\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function circular_shift(x, shift)\n    local s = tostring(x)\n    if shift > #s then\n        return s:reverse()\n    else\n        return s:sub(#s-shift+1) .. s:sub(1, #s-shift)\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a circular shift function. The function takes two arguments, `x` and `shift`. `x` is the number to be shifted and `shift` is the number of digits to shift `x` by. \n\nThe first line of the code imports the `math` module. This module provides a set of mathematical functions that can be used in Lua programs.\n\nThe second line of the code defines a function called `circular_shift`. The function takes two arguments, `x` and `shift`. \n\nThe third line of the code converts the number `x` to a string and assigns it to the variable `s`.\n\nThe fourth line of the code checks if the value of `shift` is greater than the length of the string `s`. If it is, the function returns the reverse of the string `s`. This is because if `shift` is greater than the length of the string `s`, the circular shift will be equivalent to a reverse of the string.\n\nThe fifth line of the code is executed if the value of `shift` is less than or equal to the length of the string `s`. The function returns a concatenation of two substrings of the string `s`. The first substring is the last `shift` characters of the string `s` and the second substring is the remaining characters of the string `s`.\n\n\n### Racket version\n\n#lang racket\n\n(define (circular_shift x shift)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_fill grid capacity)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_fill))\n    (check-within (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function max_fill(grid, capacity)\n  local sum = 0\n  for i=1, #grid do\n    local row_sum = 0\n    for j=1, #grid[i] do\n      row_sum = row_sum + grid[i][j]\n    end\n    sum = sum + math.ceil(row_sum/capacity)\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `max_fill` that takes two arguments: `grid` and `capacity`. The function returns the maximum number of containers that can be filled with the contents of the grid, given that each container has a capacity of `capacity`.\n\nThe first line of the code imports the `math` module, which provides mathematical functions.\n\nThe second line defines the `max_fill` function with two arguments: `grid` and `capacity`. The `local` keyword indicates that the function is local to the current scope.\n\nThe third line initializes a variable `sum` to zero.\n\nThe fourth line starts a loop that iterates over the rows of the `grid` table. The loop uses the `#` operator to get the length of the `grid` table, which is the number of rows. The loop variable `i` is initialized to 1 and incremented by 1 in each iteration until it reaches the length of the `grid` table.\n\nThe fifth line initializes a variable `row_sum` to zero.\n\nThe sixth line starts a nested loop that iterates over the columns of the current row of the `grid` table. The loop uses the `#` operator to get the length of the current row, which is the number of columns. The loop variable `j` is initialized to 1 and incremented by 1 in each iteration until it reaches the length of the current row.\n\nThe seventh line adds the value of the current cell of the `grid` table to the `row_sum` variable.\n\nThe eighth line adds the ceiling of the division of `row_sum` by `capacity` to the `sum` variable. The `math.ceil` function is used to round up the result of the division to the nearest integer.\n\nThe ninth line ends the nested loop.\n\nThe tenth line ends the outer loop.\n\nThe eleventh line returns the value of the `sum` variable as the result of the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (max_fill grid capacity)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (has_close_elements numbers threshold)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function has_close_elements(numbers, threshold)\n  for idx, elem in ipairs(numbers) do\n    for idx2, elem2 in ipairs(numbers) do\n      if idx ~= idx2 then\n        local distance = math.abs(elem - elem2)\n        if distance < threshold then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `has_close_elements` that takes two arguments: `numbers` and `threshold`. The function returns `true` if there are two elements in `numbers` that are closer than `threshold` and `false` otherwise.\n\nThe first line of the code imports the `math` module, which provides mathematical functions.\n\nThe second line of the code defines a local function `has_close_elements` that takes two arguments: `numbers` and `threshold`. The `local` keyword means that the function is only accessible within the scope of the block it is defined in.\n\nThe function uses a nested loop to iterate over all pairs of elements in `numbers`. The `ipairs` function is used to iterate over the elements of `numbers` using their indices. The `for` loop syntax is `for var_1, ..., var_n in iterator do ... end`.\n\nThe `if` statement checks if the two indices `idx` and `idx2` are different. If they are, it calculates the absolute difference between the two elements and checks if it is less than `threshold`. If it is, the function returns `true`.\n\nIf the function has iterated over all pairs of elements and has not found any that are closer than `threshold`, it returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (has_close_elements numbers threshold)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (numerical_letter_grade grades)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numerical_letter_grade))\n    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list \"A+\" \"B\" \"C-\" \"C\" \"A-\") 0.001)\n    (check-within (candidate (list 1.2)) (list \"D+\") 0.001)\n    (check-within (candidate (list 0.5)) (list \"D-\") 0.001)\n    (check-within (candidate (list 0.0)) (list \"E\") 0.001)\n    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list \"D\" \"D-\" \"C-\" \"B\" \"B+\") 0.001)\n    (check-within (candidate (list 0.0 0.7)) (list \"E\" \"D-\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function numerical_letter_grade(grades)\n    letter_grade = {}\n    for i, gpa in ipairs(grades) do\n        if gpa == 4.0 then\n            table.insert(letter_grade, \"A+\")\n        elseif gpa > 3.7 then\n            table.insert(letter_grade, \"A\")\n        elseif gpa > 3.3 then\n            table.insert(letter_grade, \"A-\")\n        elseif gpa > 3.0 then\n            table.insert(letter_grade, \"B+\")\n        elseif gpa > 2.7 then\n            table.insert(letter_grade, \"B\")\n        elseif gpa > 2.3 then\n            table.insert(letter_grade, \"B-\")\n        elseif gpa > 2.0 then\n            table.insert(letter_grade, \"C+\")\n        elseif gpa > 1.7 then\n            table.insert(letter_grade, \"C\")\n        elseif gpa > 1.3 then\n            table.insert(letter_grade, \"C-\")\n        elseif gpa > 1.0 then\n            table.insert(letter_grade, \"D+\")\n        elseif gpa > 0.7 then\n            table.insert(letter_grade, \"D\")\n        elseif gpa > 0.0 then\n            table.insert(letter_grade, \"D-\")\n        else\n            table.insert(letter_grade, \"E\")\n        end\n    end\n    return letter_grade\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numerical grades and returns a list of letter grades. The function is called `numerical_letter_grade` and takes one argument, `grades`.\n\nThe first line of the function imports the `math` module. This module provides mathematical functions and constants.\n\nThe second line of the function defines a local function called `numerical_letter_grade`. The `local` keyword means that the function is only accessible within the scope of the current block of code.\n\nThe next line initializes an empty table called `letter_grade`.\n\nThe `for` loop iterates over the `grades` list using the `ipairs` function. The `ipairs` function returns an iterator function that iterates over the indices and values of a table.\n\nFor each value in the `grades` list, the function checks if the value is equal to 4.0. If it is, the function inserts the string \"A+\" into the `letter_grade` table using the `table.insert` function.\n\nIf the value is not equal to 4.0, the function checks if it is greater than 3.7. If it is, the function inserts the string \"A\" into the `letter_grade` table.\n\nThe function continues to check each value against a series of conditions, inserting the appropriate letter grade into the `letter_grade` table using the `table.insert` function.\n\nFinally, the function returns the `letter_grade` table.\n\n\n### Racket version\n\n#lang racket\n\n(define (numerical_letter_grade grades)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (x_or_y n x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate x_or_y))\n    (check-within (candidate 7 34 12) 34 0.001)\n    (check-within (candidate 15 8 5) 5 0.001)\n    (check-within (candidate 3 33 5212) 33 0.001)\n    (check-within (candidate 1259 3 52) 3 0.001)\n    (check-within (candidate 7919 -1 12) -1 0.001)\n    (check-within (candidate 3609 1245 583) 583 0.001)\n    (check-within (candidate 91 56 129) 129 0.001)\n    (check-within (candidate 6 34 1234) 1234 0.001)\n    (check-within (candidate 1 2 0) 0 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function x_or_y(n, x, y)\n    if n == 1 then\n        return y\n    end\n    for i=2, n-1 do\n        if n%i == 0 then\n            return y\n        end\n    end\n    return x\nend\n\n### Explanation\n\nThe code is an implementation of a function `x_or_y` that takes three arguments: `n`, `x`, and `y`. The function returns `y` if `n` is divisible by any number other than 1 and itself, and `x` otherwise.\n\nThe first line imports the `math` module, which provides mathematical functions.\n\nThe second line defines the function `x_or_y` with three arguments: `n`, `x`, and `y`. The function is defined as a local function, which means it is only accessible within the scope of the file or block it is defined in.\n\nThe `if` statement checks if `n` is equal to 1. If it is, the function returns `y`.\n\nThe `for` loop iterates over the numbers from 2 to `n-1`. For each number `i`, the `if` statement checks if `n` is divisible by `i`. If it is, the function returns `y`.\n\nIf the `for` loop completes without returning, the function returns `x`.\n\n\n### Racket version\n\n#lang racket\n\n(define (x_or_y n x y)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (specialFilter nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)\n    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)\n    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)\n    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)\n    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function specialFilter(nums)\n    local count = 0\n    for _, num in ipairs(nums) do\n        if num > 10 then\n            local odd_digits = {1, 3, 5, 7, 9}\n            local number_as_string = tostring(num)\n            if math.floor(num / 10^(#number_as_string - 1)) % 2 == 1 and num % 10 % 2 == 1 then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of a function called `specialFilter` that takes a list of numbers and returns the count of numbers that are greater than 10 and have an odd digit in the ones place and an odd digit in the tens place.\n\n\n### Racket version\n\n#lang racket\n\n(define (specialFilter nums)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_music music_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_music))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"o o o o\") (list 4 4 4 4) 0.001)\n    (check-within (candidate \".| .| .| .|\") (list 1 1 1 1) 0.001)\n    (check-within (candidate \"o| o| .| .| o o o o\") (list 2 2 1 1 4 4 4 4) 0.001)\n    (check-within (candidate \"o| .| o| .| o o| o o|\") (list 2 1 2 1 4 2 4 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function parse_music(music_string)\n    local note_map = {o=4, ['o|']=2, ['.|']=1}\n    local notes = {}\n    for x in music_string:gmatch(\"%S+\") do\n        table.insert(notes, note_map[x])\n    end\n    return notes\nend\n\n### Explanation\n\nThe code is an implementation of a function called `parse_music` that takes a string as input and returns a list of integers. The function is defined on line 2 and takes a single argument called `music_string`.\n\nOn line 1, the `math` module is imported.\n\nOn line 3, a table called `note_map` is defined. The table maps certain strings to integers. The keys of the table are strings and the values are integers. The table is used to convert certain strings to integers.\n\nOn line 4, an empty list called `notes` is defined.\n\nOn line 5, a for loop is started. The loop iterates over each non-space string in the `music_string` input. The `gmatch` function is used to split the input string into non-space strings. The `%S+` pattern matches any non-space character one or more times. The `for` loop variable `x` is assigned each non-space string in turn.\n\nOn line 6, the `note_map` table is used to convert the current string `x` to an integer. The integer is then appended to the `notes` list using the `table.insert` function.\n\nOn line 8, the `notes` list is returned.\n\n\n### Racket version\n\n#lang racket\n\n(define (parse_music music_string)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (split_words txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n    (check-within (candidate \"Hello world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello,world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello world,!\") (list \"Hello\" \"world,!\") 0.001)\n    (check-within (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\" \"!\") 0.001)\n    (check-within (candidate \"abcdef\") 3 0.001)\n    (check-within (candidate \"aaabb\") 2 0.001)\n    (check-within (candidate \"aaaBb\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function split_words(txt)\n    if string.find(txt, \" \") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt, \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    elseif string.find(txt, \",\") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt:gsub(\",\", \" \"), \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    else\n        local count = 0\n        for i = 1, #txt do\n            if string.match(txt:sub(i, i), \"%l\") and string.byte(txt:sub(i, i)) % 2 == 0 then\n                count = count + 1\n            end\n        end\n        return count\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `split_words` that takes a string `txt` as input and returns either a list of words or a count of lowercase letters with even ASCII values. \n\n\n### Racket version\n\n#lang racket\n\n(define (split_words txt)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_distinct_characters string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_distinct_characters))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abcde\") 5 0.001)\n    (check-within (candidate \"abcdecadeCADE\") 5 0.001)\n    (check-within (candidate \"aaaaAAAAaaaa\") 1 0.001)\n    (check-within (candidate \"Jerry jERRY JeRRRY\") 5 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function count_distinct_characters(string)\n    local set = {}\n    for i=1, #string do\n        set[string:sub(i, i):lower()] = true\n    end\n    local count = 0\n    for k, v in pairs(set) do\n        count = count + 1\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of a function `count_distinct_characters` that takes a string as input and returns the number of distinct characters in the string. \n\nThe first line of the code imports the math module.\n\n\n### Racket version\n\n#lang racket\n\n(define (count_distinct_characters string)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (bf planet1 planet2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate bf))\n    (check-within (candidate \"Jupiter\" \"Neptune\") (list \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Mercury\") (list \"Venus\") 0.001)\n    (check-within (candidate \"Mercury\" \"Uranus\") (list \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\") 0.001)\n    (check-within (candidate \"Neptune\" \"Venus\") (list \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Mars\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Jupiter\" \"Makemake\") (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function bf(planet1, planet2)\n    local planet_names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    if not (table.concat(planet_names, ','):find(planet1) and table.concat(planet_names, ','):find(planet2)) or planet1 == planet2 then\n        return {}\n    end\n    local planet1_index = 0\n    local planet2_index = 0\n    for i, planet in ipairs(planet_names) do\n        if planet == planet1 then\n            planet1_index = i\n        elseif planet == planet2 then\n            planet2_index = i\n        end\n    end\n    if planet1_index < planet2_index then\n        return {table.unpack(planet_names, planet1_index + 1, planet2_index - 1)}\n    else\n        return {table.unpack(planet_names, planet2_index + 1, planet1_index - 1)}\n    end\nend\n\n### Explanation\n\nThe code is an implementation of the \"Between Planets\" problem. The function `bf` takes two strings as input, which are the names of two planets. The function returns a list of the names of the planets that are between the two input planets in the solar system. The planets are ordered by their distance from the sun.\n\nThe first line of the code imports the `math` module, which provides mathematical functions.\n\nThe second line defines a function called `bf` that takes two parameters, `planet1` and `planet2`.\n\nThe third line defines a list of the names of the planets in the solar system.\n\nThe fourth line checks if both `planet1` and `planet2` are in the list of planet names, and that they are not the same planet. If either of these conditions is not met, an empty list is returned.\n\nThe fifth line initializes two variables, `planet1_index` and `planet2_index`, to 0.\n\nThe sixth line loops through the list of planet names, and sets the value of `planet1_index` to the index of `planet1` in the list, and sets the value of `planet2_index` to the index of `planet2` in the list.\n\nThe seventh line checks if `planet1` comes before `planet2` in the list. If it does, the function returns a list of the planets between `planet1` and `planet2` in the list. If it does not, the function returns a list of the planets between `planet2` and `planet1` in the list. The `table.unpack` function is used to extract a range of elements from the `planet_names` list. The range is specified by the indices of the planets that are being searched for. The `+1` and `-1` are used to exclude the planets that were searched for from the returned list. \n\n\n### Racket version\n\n#lang racket\n\n(define (bf planet1 planet2)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digitSum s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abAB\") 131 0.001)\n    (check-within (candidate \"abcCd\") 67 0.001)\n    (check-within (candidate \"helloE\") 69 0.001)\n    (check-within (candidate \"woArBld\") 131 0.001)\n    (check-within (candidate \"aAaaaXa\") 153 0.001)\n    (check-within (candidate \" How are yOu?\") 151 0.001)\n    (check-within (candidate \"You arE Very Smart\") 327 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function digitSum(s)\n    if s == \"\" then return 0 end\n    local sum = 0\n    for char in s:gmatch(\".\") do\n        sum = sum + (char:match(\"%u\") and string.byte(char) or 0)\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function called `digitSum` that takes a string as input and returns the sum of the ASCII values of all uppercase letters in the string. \n\nThe first line of the program imports the math library.\n\n\n### Racket version\n\n#lang racket\n\n(define (digitSum s)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 1 4 9)) 14 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) 9 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1)) -3 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list -1 -5 2 -1 -5)) -126 0.001)\n    (check-within (candidate (list -56 -99 1 0 -2)) 3030 0.001)\n    (check-within (candidate (list -1 0 0 0 0 0 0 0 -1)) 0 0.001)\n    (check-within (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37)) -14196 0.001)\n    (check-within (candidate (list -1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10)) -1448 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n    local result = {}\n    for i=1, #lst do\n        if i % 3 == 1 then\n            result[#result+1] = lst[i]^2\n        elseif i % 4 == 1 and i % 3 ~= 1 then\n            result[#result+1] = lst[i]^3\n        else\n            result[#result+1] = lst[i]\n        end\n    end\n    local sum = 0\n    for i=1, #result do\n        sum = sum + result[i]\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `sum_squares` that takes a list of numbers and returns the sum of squares of some of the numbers in the list. The function works as follows:\n\n1. The `math` module is imported.\n2. The `sum_squares` function is defined with a single parameter `lst`.\n3. A local variable `result` is initialized to an empty list.\n4. A loop is started that iterates over the indices of the list `lst` from 1 to the length of the list.\n5. For each index `i`, the following conditions are checked:\n   - If `i` is divisible by 3 with a remainder of 1, then the square of the number at index `i` is added to the `result` list.\n   - If `i` is divisible by 4 with a remainder of 1 and `i` is not divisible by 3 with a remainder of 1, then the cube of the number at index `i` is added to the `result` list.\n   - Otherwise, the number at index `i` is added to the `result` list.\n6. A local variable `sum` is initialized to 0.\n7. A loop is started that iterates over the indices of the `result` list from 1 to the length of the list.\n8. For each index `i`, the number at index `i` is added to the `sum` variable.\n9. The `sum` variable is returned as the result of the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_up_to n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_up_to))\n    (check-within (candidate 5) (list 2 3) 0.001)\n    (check-within (candidate 6) (list 2 3 5) 0.001)\n    (check-within (candidate 7) (list 2 3 5) 0.001)\n    (check-within (candidate 10) (list 2 3 5 7) 0.001)\n    (check-within (candidate 0) (list ) 0.001)\n    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)\n    (check-within (candidate 1) (list ) 0.001)\n    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)\n    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)\n    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function count_up_to(n)\n  local primes = {}\n  for i = 2, n - 1 do\n    local is_prime = true\n    for j = 2, i - 1 do\n      if i % j == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(primes, i)\n    end\n  end\n  return primes\nend\n\n### Explanation\n\nThe code is an implementation of the Sieve of Eratosthenes algorithm. It counts all the prime numbers up to a given number `n`. \n\nThe first line imports the `math` library.\n\nThe second line defines a function `count_up_to` that takes an integer `n` as input. \n\nThe third line initializes an empty table `primes`.\n\nThe fourth line starts a loop that iterates over all integers from 2 to `n-1`. \n\nThe fifth line initializes a boolean variable `is_prime` to `true`.\n\nThe sixth line starts a nested loop that iterates over all integers from 2 to `i-1`.\n\nThe seventh line checks if `i` is divisible by `j`. If it is, then `is_prime` is set to `false` and the inner loop is broken.\n\nThe eighth line checks if `is_prime` is still `true`. If it is, then `i` is a prime number and it is added to the `primes` table using the `table.insert` function.\n\nThe ninth line returns the `primes` table.\n\n\n### Racket version\n\n#lang racket\n\n(define (count_up_to n)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)\n    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)\n    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)\n    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)\n    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)\n    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)\n    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)\n    (check-within (candidate (list 0.0)) 0 0.001)\n    (check-within (candidate (list -1.0)) 1 0.001)\n    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n  local squared = 0\n  for _, i in ipairs(lst) do\n    squared = squared + math.ceil(i)^2\n  end\n  return squared\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns the sum of their squares, rounded up to the nearest integer. Here's a line-by-line explanation:\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique))\n    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function unique(l)\n  local s = {}\n  for _, v in ipairs(l) do\n    s[v] = true\n  end\n  local r = {}\n  for k, _ in pairs(s) do\n    table.insert(r, k)\n  end\n  table.sort(r)\n  return r\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns a sorted list of unique numbers. Here is a line-by-line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (unique l)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n    (check-within (candidate 10) 55 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 8) 21 0.001)\n    (check-within (candidate 11) 89 0.001)\n    (check-within (candidate 12) 144 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nend\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence. The sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. In this implementation, the sequence starts with 0 and 1, and the function returns the nth number in the sequence.\n\nThe first line imports the math library, which is used later in the function.\n\nThe second line defines a function called `fib` that takes a single argument `n`.\n\nThe next three lines are an if-else statement that checks if `n` is equal to 0 or 1. If `n` is 0, the function returns 0. If `n` is 1, the function returns 1.\n\nThe final line is the recursive step of the function. If `n` is not 0 or 1, the function calls itself twice with `n-1` and `n-2` as arguments, and returns the sum of those two calls.\n\n\n### Racket version\n\n#lang racket\n\n(define (fib n)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fizz_buzz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n    (check-within (candidate 50) 0 0.001)\n    (check-within (candidate 78) 2 0.001)\n    (check-within (candidate 79) 3 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 200) 6 0.001)\n    (check-within (candidate 4000) 192 0.001)\n    (check-within (candidate 10000) 639 0.001)\n    (check-within (candidate 100000) 8026 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fizz_buzz(n)\n  local ns = {}\n  for i = 0, n - 1 do\n    if i % 11 == 0 or i % 13 == 0 then\n      table.insert(ns, i)\n    end\n  end\n  local s = table.concat(ns)\n  local ans = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '7' then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (Strongest_Extension class_name extensions)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n    (check-within (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\")) \"Watashi.eIGHt8OKe\" 0.001)\n    (check-within (candidate \"Boku123\" (list \"nani\" \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\" 0.001)\n    (check-within (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\" \"123NoooneB321\")) \"__YESIMHERE.NuLl__\" 0.001)\n    (check-within (candidate \"K\" (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\" 0.001)\n    (check-within (candidate \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\" 0.001)\n    (check-within (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"-_-\")) \"YameRore.okIWILL123\" 0.001)\n    (check-within (candidate \"finNNalLLly\" (list \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\" 0.001)\n    (check-within (candidate \"_\" (list \"Bb\" \"91245\")) \"_.Bb\" 0.001)\n    (check-within (candidate \"Sp\" (list \"671235\" \"Bb\")) \"Sp.671235\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function Strongest_Extension(class_name, extensions)\n    local strong = extensions[1]\n    local my_val = #extensions[1]:gsub('[^%a]', ''):gsub('[^%u]', '') - #extensions[1]:gsub('[^%a]', ''):gsub('[^%l]', '')\n    for i = 2, #extensions do\n        local s = extensions[i]\n        local val = #s:gsub('[^%a]', ''):gsub('[^%u]', '') - #s:gsub('[^%a]', ''):gsub('[^%l]', '')\n        if val > my_val then\n            strong = s\n            my_val = val\n        end\n    end\n    return class_name .. '.' .. strong\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_closest_elements numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function find_closest_elements(numbers)\n    local closest_pair = nil\n    local distance = nil\n\n    for idx, elem in ipairs(numbers) do\n        for idx2, elem2 in ipairs(numbers) do\n            if idx ~= idx2 then\n                if distance == nil then\n                    distance = math.abs(elem - elem2)\n                    closest_pair = {elem, elem2}\n                else\n                    new_distance = math.abs(elem - elem2)\n                    if new_distance < distance then\n                        distance = new_distance\n                        closest_pair = {elem, elem2}\n                    end\n                end\n            end\n        end\n    end\n\n    table.sort(closest_pair)\n    return closest_pair\nend\n\n### Explanation\n\nThe code is an implementation of a function called `find_closest_elements` that takes a list of numbers and returns the pair of numbers that are closest to each other. \n\n\n### Racket version\n\n#lang racket\n\n(define (find_closest_elements numbers)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (valid_date date)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_date))\n    (check-within (candidate \"03-11-2000\") #t 0.001)\n    (check-within (candidate \"15-01-2012\") #f 0.001)\n    (check-within (candidate \"04-0-2040\") #f 0.001)\n    (check-within (candidate \"06-04-2020\") #t 0.001)\n    (check-within (candidate \"01-01-2007\") #t 0.001)\n    (check-within (candidate \"03-32-2011\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"04-31-3000\") #f 0.001)\n    (check-within (candidate \"06-06-2005\") #t 0.001)\n    (check-within (candidate \"21-31-2000\") #f 0.001)\n    (check-within (candidate \"04-12-2003\") #t 0.001)\n    (check-within (candidate \"04122003\") #f 0.001)\n    (check-within (candidate \"20030412\") #f 0.001)\n    (check-within (candidate \"2003-04\") #f 0.001)\n    (check-within (candidate \"2003-04-12\") #f 0.001)\n    (check-within (candidate \"04-2003\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function valid_date(date)\n    local month, day, year = date:match(\"(%d+)-(%d+)-(%d+)\")\n    if not month or not day or not year then\n        return false\n    end\n    month, day, year = tonumber(month), tonumber(day), tonumber(year)\n    if month < 1 or month > 12 then\n        return false\n    end\n    if month == 2 and (day < 1 or day > 29) then\n        return false\n    end\n    if month == 4 or month == 6 or month == 9 or month == 11 then\n        if day < 1 or day > 30 then\n            return false\n        end\n    else\n        if day < 1 or day > 31 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `valid_date` that takes a string argument `date` and returns a boolean indicating whether the date is valid or not. \n\nThe first line imports the `math` module.\n\n\n### Racket version\n\n#lang racket\n\n(define (valid_date date)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate 0 1) 1 0.001)\n    (check-within (candidate 1 0) 1 0.001)\n    (check-within (candidate 2 3) 5 0.001)\n    (check-within (candidate 5 7) 12 0.001)\n    (check-within (candidate 7 5) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function add(x, y)\n  return x + y\nend\n\n### Explanation\n\nThe code is an implementation of a function that adds two numbers. The first line imports the math library, which provides a set of mathematical functions. The second line defines a function called `add` that takes two arguments, `x` and `y`. The function returns the sum of the two arguments. The `local` keyword means that the function is only visible within the current scope.\n\n\n### Racket version\n\n#lang racket\n\n(define (add x y)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triples_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -1)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 1 2 5 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 9 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -100)) #f 0.001)\n    (check-within (candidate (list 100 3 5 -100)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function triples_sum_to_zero(l)\n  for i = 1, #l do\n    for j = i + 1, #l do\n      for k = j + 1, #l do\n        if l[i] + l[j] + l[k] == 0 then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `triples_sum_to_zero` that takes a list of numbers as input and returns `true` if there are three numbers in the list that sum to zero, and `false` otherwise.\n\nThe first line of the code imports the `math` module, which provides mathematical functions and constants.\n\nThe second line defines the `triples_sum_to_zero` function using the `local` keyword, which limits the scope of the function to the current block of code. The function takes a single argument `l`, which is expected to be a list of numbers.\n\nThe next three lines define nested loops that iterate over all possible combinations of three elements in the list. The outer loop iterates over the indices of the list from 1 to the length of the list, inclusive. The middle loop iterates over the indices of the list from the current index of the outer loop plus one to the length of the list, inclusive. The inner loop iterates over the indices of the list from the current index of the middle loop plus one to the length of the list, inclusive.\n\nInside the innermost loop, the code checks if the sum of the three elements at the current indices is equal to zero. If it is, the function returns `true`. If no such combination of three elements is found, the function returns `false` after all the loops have completed.\n\n\n### Racket version\n\n#lang racket\n\n(define (triples_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_divisor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_divisor))\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 10) 5 0.001)\n    (check-within (candidate 100) 50 0.001)\n    (check-within (candidate 49) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function largest_divisor(n)\n    for i=n-1, 1, -1 do\n        if n % i == 0 then\n            return i\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function that finds the largest divisor of a given number.\n\n\n### Racket version\n\n#lang racket\n\n(define (largest_divisor n)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_numbers numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"three\") \"three\" 0.001)\n    (check-within (candidate \"three five nine\") \"three five nine\" 0.001)\n    (check-within (candidate \"five zero four seven nine eight\") \"zero four five seven eight nine\" 0.001)\n    (check-within (candidate \"six five four three two one zero\") \"zero one two three four five six\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_numbers(numbers)\n    local value_map = {\n        zero = 0,\n        one = 1,\n        two = 2,\n        three = 3,\n        four = 4,\n        five = 5,\n        six = 6,\n        seven = 7,\n        eight = 8,\n        nine = 9\n    }\n    local words = {}\n    for word in numbers:gmatch(\"%w+\") do\n        table.insert(words, word)\n    end\n    table.sort(words, function(a, b) return value_map[a] < value_map[b] end)\n    return table.concat(words, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (smallest_change arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallest_change))\n    (check-within (candidate (list 1 2 3 5 4 7 9 6)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 3 2 2)) 1 0.001)\n    (check-within (candidate (list 1 4 2)) 1 0.001)\n    (check-within (candidate (list 1 4 4 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 3 1 1 3)) 0 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function smallest_change(arr)\n  local ans = 0\n  for i = 1, math.floor(#arr / 2) do\n    if arr[i] ~= arr[#arr - i + 1] then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an array of integers and returns the number of changes required to make the array a palindrome. A palindrome is a sequence of characters that reads the same backward as forward.\n\nThe function first requires the math library.\n\n\n### Racket version\n\n#lang racket\n\n(define (smallest_change arr)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_threshold l t)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_threshold))\n    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)\n    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function below_threshold(l, t)\n  for _, e in ipairs(l) do\n    if e >= t then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function called `below_threshold` that takes two arguments, a list `l` and a threshold `t`. The function returns `true` if all elements in the list are less than the threshold, and `false` otherwise.\n\nThe first line imports the `math` module, which provides mathematical functions.\n\nThe second line defines a function called `below_threshold` that takes two arguments, a list `l` and a threshold `t`. The `local` keyword means that the function is only visible in the current scope.\n\nThe `for` loop iterates over each element in the list `l`. The `_` variable is used to ignore the index of the element, since it is not needed in this case. The `ipairs` function is used to iterate over the list in order.\n\nThe `if` statement checks if the current element `e` is greater than or equal to the threshold `t`. If it is, the function returns `false`.\n\nIf the loop completes without returning `false`, the function returns `true`. \n\n\n### Racket version\n\n#lang racket\n\n(define (below_threshold l t)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prod_signs arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-within (candidate (list 1 2 2 -4)) -9 0.001)\n    (check-within (candidate (list 0 1)) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 3 -1 1)) -10 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 2 4 1 2 -1 -1 9)) 20 0.001)\n    (check-within (candidate (list -1 1 -1 1)) 4 0.001)\n    (check-within (candidate (list -1 1 1 1)) -4 0.001)\n    (check-within (candidate (list -1 1 1 0)) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n    local prod = 0\n    local neg_count = 0\n    for i = 1, #arr do\n        if arr[i] == 0 then\n            return 0\n        end\n        if arr[i] < 0 then\n            neg_count = neg_count + 1\n        end\n    end\n    prod = math.pow(-1, neg_count)\n    local sum = 0\n    for i = 1, #arr do\n        sum = sum + math.abs(arr[i])\n    end\n    return prod * sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `prod_signs` that takes an array of integers as input and returns the product of the absolute values of the integers in the array, multiplied by -1 raised to the power of the number of negative integers in the array. If the array contains a 0, the function returns 0.\n\n- `math = require('math')` imports the math library, which provides mathematical functions and constants.\n- `local function prod_signs(arr)` defines the function `prod_signs` that takes an array `arr` as input.\n- `if #arr == 0 then return nil end` checks if the length of the array is 0. If it is, the function returns `nil`.\n- `local prod = 0` initializes the variable `prod` to 0.\n- `local neg_count = 0` initializes the variable `neg_count` to 0.\n- `for i = 1, #arr do` starts a loop that iterates over the elements of the array.\n- `if arr[i] == 0 then return 0 end` checks if the current element is 0. If it is, the function returns 0.\n- `if arr[i] < 0 then neg_count = neg_count + 1 end` checks if the current element is negative. If it is, `neg_count` is incremented by 1.\n- `prod = math.pow(-1, neg_count)` calculates the value of `prod` as -1 raised to the power of `neg_count`.\n- `local sum = 0` initializes the variable `sum` to 0.\n- `for i = 1, #arr do` starts a loop that iterates over the elements of the array.\n- `sum = sum + math.abs(arr[i])` adds the absolute value of the current element to `sum`.\n- `return prod * sum` returns the product of `prod` and `sum`. This is the final result of the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (prod_signs arr)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (modp n p)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n    (check-within (candidate 3 5) 3 0.001)\n    (check-within (candidate 1101 101) 2 0.001)\n    (check-within (candidate 0 101) 1 0.001)\n    (check-within (candidate 3 11) 8 0.001)\n    (check-within (candidate 100 101) 1 0.001)\n    (check-within (candidate 30 5) 4 0.001)\n    (check-within (candidate 31 5) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function modp(n, p)\n    local ret = 1\n    for i=1, n do\n        ret = (2 * ret) % p\n    end\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of modular exponentiation. It computes 2^n mod p, where n and p are inputs to the function. \n\nThe first line imports the math library.\n\nThe second line defines a function called modp that takes two arguments, n and p. \n\nThe third line initializes a variable called ret to 1.\n\nThe fourth line starts a loop that runs n times. \n\nThe fifth line updates the value of ret to be 2 times the current value of ret, modulo p. \n\nThe sixth line returns the final value of ret.\n\n\n### Racket version\n\n#lang racket\n\n(define (modp n p)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_upper s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n    (check-within (candidate \"aBCdEf\") 1 0.001)\n    (check-within (candidate \"abcdefg\") 0 0.001)\n    (check-within (candidate \"dBBE\") 0 0.001)\n    (check-within (candidate \"B\") 0 0.001)\n    (check-within (candidate \"U\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"EEEE\") 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function count_upper(s)\n    local count = 0\n    for i = 1, #s, 2 do\n        if s:sub(i, i):match(\"[AEIOU]\") then\n            count = count + 1\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of a function `count_upper` that takes a string `s` as input and returns the number of uppercase vowels in the string. The function is defined using the `local` keyword, which means that it is only available within the scope of the current block of code.\n\nThe first line of the function imports the `math` module, which provides mathematical functions and constants. However, this module is not actually used in the function.\n\nThe next line defines the function `count_upper` with a single parameter `s`. The function initializes a variable `count` to 0, which will be used to keep track of the number of uppercase vowels in the string.\n\nThe function then enters a `for` loop that iterates over the characters in the string `s`. The loop uses the `#` operator to get the length of the string, and the `i` variable is used to index into the string. The loop increments `i` by 2 on each iteration, which means that it only looks at every other character in the string.\n\nInside the loop, the function uses the `sub` method of the string to get a substring of length 1 starting at index `i`. The `match` method is then called on this substring with a regular expression pattern that matches uppercase vowels. If the substring matches the pattern, the `count` variable is incremented.\n\nFinally, the function returns the value of `count`.\n\n\n### Racket version\n\n#lang racket\n\n(define (count_upper s)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (multiply a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate multiply))\n    (check-within (candidate 148 412) 16 0.001)\n    (check-within (candidate 19 28) 72 0.001)\n    (check-within (candidate 2020 1851) 0 0.001)\n    (check-within (candidate 14 -15) 20 0.001)\n    (check-within (candidate 76 67) 42 0.001)\n    (check-within (candidate 17 27) 49 0.001)\n    (check-within (candidate 0 1) 0 0.001)\n    (check-within (candidate 0 0) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function multiply(a, b)\n  return math.abs(a % 10) * math.abs(b % 10)\nend\n\n### Explanation\n\nThe code is an implementation of a function that multiplies the last digit of two numbers. \n\n\n### Racket version\n\n#lang racket\n\n(define (multiply a b)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique_digits x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_digits))\n    (check-within (candidate (list 15 33 1422 1)) (list 1 15 33) 0.001)\n    (check-within (candidate (list 152 323 1422 10)) (list ) 0.001)\n    (check-within (candidate (list 12345 2033 111 151)) (list 111 151) 0.001)\n    (check-within (candidate (list 135 103 31)) (list 31 135) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function unique_digits(x)\n    local odd_digit_elements = {}\n    for i=1, #x do\n        if string.match(tostring(x[i]), '^[13579]+$') then\n            table.insert(odd_digit_elements, x[i])\n        end\n    end\n    table.sort(odd_digit_elements)\n    return odd_digit_elements\nend\n\n### Explanation\n\nThe code is an implementation of a function called `unique_digits` that takes an array of integers and returns a sorted array of integers that only contain odd digits. \n\nThe first line of the code imports the `math` module. The `math` module provides a set of mathematical functions that can be used in Lua programs.\n\nThe second line of the code defines a function called `unique_digits` that takes an array of integers as input. \n\nThe third line of the code creates an empty table called `odd_digit_elements` that will be used to store the odd digit elements of the input array.\n\nThe fourth line of the code starts a for loop that iterates over the input array. The loop variable `i` takes on the values 1 through the length of the input array.\n\nThe fifth line of the code checks if the `i`th element of the input array contains only odd digits. This is done by converting the integer to a string using `tostring` and then checking if the string matches the regular expression `'^[13579]+$'`. The regular expression matches strings that contain only the digits 1, 3, 5, 7, and 9.\n\nThe sixth line of the code adds the `i`th element of the input array to the `odd_digit_elements` table if it contains only odd digits.\n\nThe seventh line of the code sorts the `odd_digit_elements` table in ascending order.\n\nThe eighth line of the code returns the sorted `odd_digit_elements` table.\n\n\n### Racket version\n\n#lang racket\n\n(define (unique_digits x)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_multiply_prime a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_multiply_prime))\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #f 0.001)\n    (check-within (candidate 125) #t 0.001)\n    (check-within (candidate 105) #t 0.001)\n    (check-within (candidate 126) #f 0.001)\n    (check-within (candidate 729) #f 0.001)\n    (check-within (candidate 891) #f 0.001)\n    (check-within (candidate 1001) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_multiply_prime(a)\n  local function is_prime(n)\n    for j = 2, n-1 do\n      if n%j == 0 then\n        return false\n      end\n    end\n    return true\n  end\n\n  for i = 2, 100 do\n    if not is_prime(i) then goto continue1 end\n    for j = 2, 100 do\n      if not is_prime(j) then goto continue2 end\n      for k = 2, 100 do\n        if not is_prime(k) then goto continue3 end\n        if i*j*k == a then return true end\n        ::continue3::\n      end\n      ::continue2::\n    end\n    ::continue1::\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_multiply_prime` that takes an integer `a` as input and returns a boolean indicating whether `a` is the product of three prime numbers.\n\nThe first line of the code imports the math library.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_multiply_prime a)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (maximum arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)\n    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)\n    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)\n    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)\n    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)\n    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)\n    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)\n    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)\n    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)\n    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)\n    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function maximum(arr, k)\n    if k == 0 then\n        return {}\n    end\n    table.sort(arr)\n    local ans = {}\n    for i=#arr-k+1, #arr do\n        table.insert(ans, arr[i])\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function that returns the k largest numbers in an array. Here is a line-by-line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (maximum arr k)\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (separate_paren_groups paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate separate_paren_groups))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list \"(()())\" \"((()))\" \"()\" \"((())()())\") 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list \"()\" \"(())\" \"((()))\" \"(((())))\") 0.001)\n    (check-within (candidate \"(()(())((())))\") (list \"(()(())((())))\") 0.001)\n    (check-within (candidate \"( ) (( )) (( )( ))\") (list \"()\" \"(())\" \"(()())\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `separate_paren_groups` which takes a string of parentheses and returns a list of strings where each string is a group of parentheses. The function is implemented in Lua.\n\nThe first line of the code imports the `math` module.\n\n\n### Racket version\n\n#lang racket\n\n(define (separate_paren_groups paren_string)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_integers values)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9) 0.001)\n    (check-within (candidate (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_integers(values)\n  local result = {}\n  for _, x in ipairs(values) do\n    if type(x) == 'number' and math.floor(x) == x then\n      table.insert(result, x)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `filter_integers` that takes a list of values and returns a list of only the integer values. \n\n\n### Racket version\n\n#lang racket\n\n(define (filter_integers values)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (skjkasdkd lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)\n    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)\n    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)\n    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)\n    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)\n    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)\n    (check-within (candidate (list 8191)) 19 0.001)\n    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)\n    (check-within (candidate (list 127 97 8192)) 10 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function skjkasdkd(lst)\n  local function isPrime(n)\n    for i = 2, math.floor(n^0.5) do\n      if n % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local maxx = 0\n  local i = 1\n  while i <= #lst do\n    if lst[i] > maxx and isPrime(lst[i]) then\n      maxx = lst[i]\n    end\n    i = i + 1\n  end\n  local result = 0\n  for digit in tostring(maxx):gmatch('%d') do\n    result = result + tonumber(digit)\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `skjkasdkd` that takes a list of integers and returns the sum of the digits of the largest prime number in the list. \n\nThe function starts by importing the `math` module, which provides mathematical functions. \n\n\n### Racket version\n\n#lang racket\n\n(define (skjkasdkd lst)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (total_match lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate total_match))\n    (check-within (candidate (list ) (list )) (list ) 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\")) (list \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\" \"admin\" \"project\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list \"4\") (list \"1\" \"2\" \"3\" \"4\" \"5\")) (list \"4\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"Hi\")) (list \"hI\" \"Hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hi\")) (list \"hI\" \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hii\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list ) (list \"this\")) (list ) 0.001)\n    (check-within (candidate (list \"this\") (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function total_match(lst1, lst2)\n    local l1 = 0\n    for i = 1, #lst1 do\n        l1 = l1 + #lst1[i]\n    end\n\n    local l2 = 0\n    for i = 1, #lst2 do\n        l2 = l2 + #lst2[i]\n    end\n\n    if l1 <= l2 then\n        return lst1\n    else\n        return lst2\n    end\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (car_race_collision n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate car_race_collision))\n    (check-within (candidate 2) 4 0.001)\n    (check-within (candidate 3) 9 0.001)\n    (check-within (candidate 4) 16 0.001)\n    (check-within (candidate 8) 64 0.001)\n    (check-within (candidate 10) 100 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function car_race_collision(n)\n    return n^2\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_simple_power x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n    (check-within (candidate 16 2) #t 0.001)\n    (check-within (candidate 143214 16) #f 0.001)\n    (check-within (candidate 4 2) #t 0.001)\n    (check-within (candidate 9 3) #t 0.001)\n    (check-within (candidate 16 4) #t 0.001)\n    (check-within (candidate 24 2) #f 0.001)\n    (check-within (candidate 128 4) #f 0.001)\n    (check-within (candidate 12 6) #f 0.001)\n    (check-within (candidate 1 1) #t 0.001)\n    (check-within (candidate 1 12) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_simple_power(x, n)\n    if n == 1 then\n        return x == 1\n    end\n    local power = 1\n    while power < x do\n        power = power * n\n    end\n    return power == x\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_simple_power` that checks if a number `x` is a power of another number `n`. The function returns a boolean value.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_simple_power x n)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encode message)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n    (check-within (candidate \"TEST\") \"tgst\" 0.001)\n    (check-within (candidate \"Mudasir\") \"mWDCSKR\" 0.001)\n    (check-within (candidate \"YES\") \"ygs\" 0.001)\n    (check-within (candidate \"This is a message\") \"tHKS KS C MGSSCGG\" 0.001)\n    (check-within (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function encode(message)\n  local vowels = \"aeiouAEIOU\"\n  local vowels_replace = {}\n  for i = 1, #vowels do\n    vowels_replace[vowels:sub(i, i)] = string.char(string.byte(vowels:sub(i, i)) + 2)\n  end\n  message = message:gsub(\"%a\", function(c)\n    return c == c:upper() and c:lower() or c:upper()\n  end)\n  return message:gsub(\".\", function(c)\n    return vowels_replace[c] or c\n  end)\nend\n\n### Explanation\n\nThe code is an implementation of a message encoder. The encoder takes a message as input and returns a new message where all vowels have been replaced by the character two characters after them in the ASCII table. The encoder also swaps the case of all letters in the message.\n\nThe first line of the program imports the math library.\n\n\n### Racket version\n\n#lang racket\n\n(define (encode message)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (incr_list l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate incr_list))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)\n    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function incr_list(l)\n  local res = {}\n  for i = 1, #l do\n    res[i] = l[i] + 1\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns a new list with each element incremented by one.\n\n\n### Racket version\n\n#lang racket\n\n(define (incr_list l)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (flip_case string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hello!\") \"hELLO!\" 0.001)\n    (check-within (candidate \"These violent delights have violent ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function flip_case(string)\n    return string:gsub(\"%a\", function(c) return c:match(\"%l\") and c:upper() or c:lower() end)\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a string and returns the same string with the case of each letter flipped. The function is defined as `flip_case` and takes a single argument, `string`. \n\nThe first line of the code imports the `math` module. This is not used in the function and can be removed.\n\nThe second line defines the `flip_case` function using the `local` keyword. This means that the function is only accessible within the scope of the current block of code. The function takes a single argument, `string`.\n\nThe third line is the implementation of the `flip_case` function. It uses the `gsub` function of the `string` module to replace each letter in the string with its flipped case. The `gsub` function takes two arguments: a pattern to match and a function to apply to each match. In this case, the pattern is `\"%a\"`, which matches any alphabetic character. The function passed to `gsub` takes a single argument, `c`, which is the matched character. The function checks if the character is lowercase using the `match` function and the pattern `\"%l\"`. If the character is lowercase, it is converted to uppercase using the `upper` function. If the character is uppercase, it is converted to lowercase using the `lower` function. The flipped character is then returned by the function and used to replace the original character in the string.\n\n\n### Racket version\n\n#lang racket\n\n(define (flip_case string)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (vowels_count s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate vowels_count))\n    (check-within (candidate \"abcde\") 2 0.001)\n    (check-within (candidate \"Alone\") 3 0.001)\n    (check-within (candidate \"key\") 2 0.001)\n    (check-within (candidate \"bye\") 1 0.001)\n    (check-within (candidate \"keY\") 2 0.001)\n    (check-within (candidate \"bYe\") 1 0.001)\n    (check-within (candidate \"ACEDY\") 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function vowels_count(s)\n  local vowels = \"aeiouAEIOU\"\n  local n_vowels = 0\n  for i = 1, #s do\n    if string.find(vowels, s:sub(i, i), 1, true) then\n      n_vowels = n_vowels + 1\n    end\n  end\n  if s:sub(-1) == 'y' or s:sub(-1) == 'Y' then\n    n_vowels = n_vowels + 1\n  end\n  return n_vowels\nend\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of vowels in a string. \n\nThe first line imports the math library.\n\nThe second line defines a function called `vowels_count` that takes a string `s` as input.\n\nThe third line defines a string variable `vowels` that contains all the vowels in the English language.\n\nThe fourth line initializes a variable `n_vowels` to 0.\n\nThe fifth line starts a for loop that iterates over each character in the input string `s`. The loop runs from 1 to the length of the string `#s`.\n\nThe sixth line checks if the current character is a vowel by using the `string.find` function. If the character is a vowel, the `n_vowels` variable is incremented by 1.\n\nThe seventh and eighth lines check if the last character in the string is 'y' or 'Y'. If it is, then the `n_vowels` variable is incremented by 1.\n\nThe ninth line returns the final count of vowels in the string.\n\n\n### Racket version\n\n#lang racket\n\n(define (vowels_count s)\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (words_string s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_string))\n    (check-within (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\" \"is\" \"John\") 0.001)\n    (check-within (candidate \"One, two, three, four, five, six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\") 0.001)\n    (check-within (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function words_string(s)\n    if not s then\n        return {}\n    end\n\n    local s_list = {}\n\n    for i=1, #s do\n        local letter = s:sub(i, i)\n        if letter == ',' then\n            table.insert(s_list, ' ')\n        else\n            table.insert(s_list, letter)\n        end\n    end\n\n    s_list = table.concat(s_list)\n    local words = {}\n    for word in s_list:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n    return words\nend\n\n### Explanation\n\nThe code is an implementation of a function called `words_string` that takes a string as input and returns a list of words. The function first checks if the input string is nil, and if so, returns an empty list. Otherwise, it creates an empty list called `s_list`.\n\nThe function then iterates through each character in the input string, adding each character to `s_list` if it is not a comma, or adding a space character if it is a comma. After the iteration, `s_list` is concatenated into a single string, and the `gmatch` function is used to extract all non-space sequences of characters from the string. These sequences are then added to the `words` list, which is returned at the end of the function.\n\nTo rewrite this program in Racket, we can use the `string-split` function to split the input string into a list of words, using a comma as the delimiter. Here is the equivalent Racket code:\n\n\n### Racket version\n\n#lang racket\n\n(define (words_string s)\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (even_odd_palindrome n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_palindrome))\n    (check-within (candidate 123) (list 8 13) 0.001)\n    (check-within (candidate 12) (list 4 6) 0.001)\n    (check-within (candidate 3) (list 1 2) 0.001)\n    (check-within (candidate 63) (list 6 8) 0.001)\n    (check-within (candidate 25) (list 5 6) 0.001)\n    (check-within (candidate 19) (list 4 6) 0.001)\n    (check-within (candidate 9) (list 4 5) 0.001)\n    (check-within (candidate 1) (list 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of a function `even_odd_palindrome` that takes an integer `n` as input and returns a table with two integers: the number of even palindromes and the number of odd palindromes between 1 and `n` inclusive.\n\nThe function first imports the `math` module. This module provides a set of mathematical functions, such as `math.sqrt` and `math.random`.\n\n\n### Racket version\n\n#lang racket\n\n(define (even_odd_palindrome n)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 3 4 5) 6.0 0.001)\n    (check-within (candidate 1 2 10) -1 0.001)\n    (check-within (candidate 4 8 5) 8.18 0.001)\n    (check-within (candidate 2 2 2) 1.73 0.001)\n    (check-within (candidate 1 2 3) -1 0.001)\n    (check-within (candidate 10 5 7) 16.25 0.001)\n    (check-within (candidate 2 6 3) -1 0.001)\n    (check-within (candidate 1 1 1) 0.43 0.001)\n    (check-within (candidate 2 2 10) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, b, c)\n    if a + b <= c or a + c <= b or b + c <= a then\n        return -1 \n    end\n    s = (a + b + c)/2    \n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = math.floor(area * 100 + 0.5) / 100\n    return area\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates the area of a triangle given its three sides. \n\nThe first line of the code imports the math library, which provides a set of mathematical functions. \n\nThe second line defines a function called `triangle_area` that takes three arguments, `a`, `b`, and `c`. \n\nThe third line checks if the three sides form a valid triangle. If the sum of any two sides is less than or equal to the third side, then the sides do not form a valid triangle, and the function returns -1. \n\nThe fourth line calculates the semi-perimeter of the triangle, which is half the sum of the three sides. \n\nThe fifth line calculates the area of the triangle using Heron's formula, which is a formula for finding the area of a triangle given its three sides. \n\nThe sixth line rounds the area to two decimal places using the `math.floor` function and returns the result. \n\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a b c)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_dict_case dict)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f 0.001)\n    (check-within (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f 0.001)\n    (check-within (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t 0.001)\n    (check-within (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t 0.001)\n    (check-within (candidate #hash()) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function check_dict_case(dict)\n    if next(dict) == nil then\n        return false\n    else\n        local state = \"start\"\n        for key, value in pairs(dict) do\n            if type(key) ~= \"string\" then\n                state = \"mixed\"\n                break\n            end\n            if state == \"start\" then\n                if key:upper() == key then\n                    state = \"upper\"\n                elseif key:lower() == key then\n                    state = \"lower\"\n                else\n                    break\n                end\n            elseif (state == \"upper\" and key:upper() ~= key) or (state == \"lower\" and key:lower() ~= key) then\n                state = \"mixed\"\n                break\n            end\n        end\n        return state == \"upper\" or state == \"lower\"\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `check_dict_case` which takes a dictionary as an argument and returns a boolean value indicating whether all keys in the dictionary are either all uppercase or all lowercase.\n\nThe first line of the code imports the `math` module.\n\nThe second line defines a local function `check_dict_case` which takes a dictionary as an argument.\n\nThe third line checks if the dictionary is empty. If it is, the function returns `false`.\n\nIf the dictionary is not empty, the function initializes a variable `state` to \"start\".\n\nThe function then iterates over each key-value pair in the dictionary using the `pairs` function.\n\nFor each key-value pair, the function checks if the key is a string. If it is not, the function sets `state` to \"mixed\" and breaks out of the loop.\n\nIf the key is a string, the function checks if the current `state` is \"start\". If it is, the function checks if the key is all uppercase or all lowercase. If it is all uppercase, the function sets `state` to \"upper\". If it is all lowercase, the function sets `state` to \"lower\". If the key is neither all uppercase nor all lowercase, the function breaks out of the loop.\n\nIf the current `state` is not \"start\", the function checks if the key is consistent with the current `state`. If it is not, the function sets `state` to \"mixed\" and breaks out of the loop.\n\nAfter iterating over all key-value pairs, the function returns `true` if `state` is \"upper\" or \"lower\", and `false` otherwise.\n\n\n### Racket version\n\n#lang racket\n\n(define (check_dict_case dict)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (median l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n    (check-within (candidate (list 3 1 2 4 5)) 3 0.001)\n    (check-within (candidate (list -10 4 6 1000 10 20)) 8.0 0.001)\n    (check-within (candidate (list 5)) 5 0.001)\n    (check-within (candidate (list 6 5)) 5.5 0.001)\n    (check-within (candidate (list 8 1 3 9 9 2 7)) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function median(l)\n  table.sort(l)\n  if #l % 2 == 1 then\n    return l[math.floor(#l / 2) + 1]\n  else\n    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n  end\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates the median of a list of numbers. Here is a line-by-line explanation:\n\n\n### Racket version\n\n#lang racket\n\n(define (median l)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (change_base x base)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n    (check-within (candidate 8 3) \"22\" 0.001)\n    (check-within (candidate 9 3) \"100\" 0.001)\n    (check-within (candidate 234 2) \"11101010\" 0.001)\n    (check-within (candidate 16 2) \"10000\" 0.001)\n    (check-within (candidate 8 2) \"1000\" 0.001)\n    (check-within (candidate 7 2) \"111\" 0.001)\n    (check-within (candidate 2 3) \"2\" 0.001)\n    (check-within (candidate 3 4) \"3\" 0.001)\n    (check-within (candidate 4 5) \"4\" 0.001)\n    (check-within (candidate 5 6) \"5\" 0.001)\n    (check-within (candidate 6 7) \"6\" 0.001)\n    (check-within (candidate 7 8) \"7\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function change_base(x, base)\n  local ret = \"\"\n  while x > 0 do\n    ret = tostring(x % base) .. ret\n    x = math.floor(x / base)\n  end\n  return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function `change_base` that takes two arguments, `x` and `base`. The function returns a string representation of `x` in the given `base`.\n\nThe first line of the code imports the `math` module.\n\nThe second line defines a function `change_base` that takes two arguments, `x` and `base`. The function returns a string representation of `x` in the given `base`.\n\nThe third line defines a local variable `ret` and initializes it to an empty string.\n\nThe fourth line starts a while loop that runs as long as `x` is greater than zero.\n\nThe fifth line appends the remainder of `x` divided by `base` to the beginning of the `ret` string. The `tostring` function is used to convert the remainder to a string.\n\nThe sixth line updates `x` to be the result of `x` divided by `base`, rounded down to the nearest integer using the `math.floor` function.\n\nThe seventh line ends the while loop.\n\nThe eighth line returns the `ret` string, which contains the string representation of `x` in the given `base`.\n\n\n### Racket version\n\n#lang racket\n\n(define (change_base x base)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (longest strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"x\" 0.001)\n    (check-within (candidate (list \"x\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\")) \"zzzz\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function longest(strings)\n    if not strings then\n        return nil\n    end\n\n    local maxlen = 0\n    for _, s in ipairs(strings) do\n        maxlen = math.max(maxlen, #s)\n    end\n\n    for _, s in ipairs(strings) do\n        if #s == maxlen then\n            return s\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an array of strings and returns the longest string in the array. Here is a line by line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (longest strings)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (common l1 l2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n    (check-within (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653) 0.001)\n    (check-within (candidate (list 5 3 2 8) (list 3 2)) (list 2 3) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function common(l1, l2)\n    local ret = {}\n    local set_l2 = {}\n    for i=1, #l2 do\n        set_l2[l2[i]] = true\n    end\n    for i=1, #l1 do\n        if set_l2[l1[i]] then\n            table.insert(ret, l1[i])\n        end\n    end\n    table.sort(ret)\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function named `common` that takes two lists as input and returns a sorted list of the common elements between the two input lists. \n\n\n### Racket version\n\n#lang racket\n\n(define (common l1 l2)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (cycpattern_check a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n    (check-within (candidate \"xyzw\" \"xyw\") #f 0.001)\n    (check-within (candidate \"yello\" \"ell\") #t 0.001)\n    (check-within (candidate \"whattup\" \"ptut\") #f 0.001)\n    (check-within (candidate \"efef\" \"fee\") #t 0.001)\n    (check-within (candidate \"abab\" \"aabb\") #f 0.001)\n    (check-within (candidate \"winemtt\" \"tinem\") #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function cycpattern_check(a, b)\n  local l = #b\n  local pat = b .. b\n  for i = 1, #a - l + 1 do\n    for j = 1, l + 1 do\n      if a:sub(i, i + l - 1) == pat:sub(j, j + l - 1) then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `cycpattern_check` that checks if a string `a` contains a cyclic pattern of another string `b`. A cyclic pattern is a pattern that can be obtained by shifting the characters of a string by a certain number of positions, wrapping around when the end of the string is reached. For example, the string \"abcabc\" is a cyclic pattern of \"abc\".\n\nThe function first imports the `math` module, which provides mathematical functions.\n\n\n### Racket version\n\n#lang racket\n\n(define (cycpattern_check a b)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minSubArraySum nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSubArraySum))\n    (check-within (candidate (list 2 3 4 1 2 4)) 1 0.001)\n    (check-within (candidate (list -1 -2 -3)) -6 0.001)\n    (check-within (candidate (list -1 -2 -3 2 -10)) -14 0.001)\n    (check-within (candidate (list -9999999999999999)) -9999999999999999 0.001)\n    (check-within (candidate (list 0 10 20 1000000)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 100 -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 10 11 13 8 3 4)) 3 0.001)\n    (check-within (candidate (list 100 -33 32 -1 0 -2)) -33 0.001)\n    (check-within (candidate (list -10)) -10 0.001)\n    (check-within (candidate (list 7)) 7 0.001)\n    (check-within (candidate (list 1 -1)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function minSubArraySum(nums)\n    local max_sum = 0\n    local s = 0\n    for i=1, #nums do\n        s = s - nums[i]\n        if s < 0 then\n            s = 0\n        end\n        max_sum = math.max(s, max_sum)\n    end\n    if max_sum == 0 then\n        max_sum = -math.huge\n        for i=1, #nums do\n            max_sum = math.max(max_sum, -nums[i])\n        end\n    end\n    local min_sum = -max_sum\n    return min_sum\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_array array)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5)) (list 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3 4 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0) 0.001)\n    (check-within (candidate (list 2 1)) (list 1 2) 0.001)\n    (check-within (candidate (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87) 0.001)\n    (check-within (candidate (list 21 14 23 11)) (list 23 21 14 11) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function that sorts an array of integers. Here is a line-by-line explanation:\n\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (histogram test)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate histogram))\n    (check-within (candidate \"a b b a\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c a b\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c d g\") #hash((\"a\" .  1) (\"b\" .  1) (\"c\" .  1) (\"d\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"b b b b a\") #hash((\"b\" .  4)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"\") #hash() 0.001)\n    (check-within (candidate \"a\") #hash((\"a\" .  1)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function histogram(test)\n    local dict1 = {}\n    local list1 = {}\n    for word in test:gmatch(\"%w+\") do\n        table.insert(list1, word)\n    end\n    local t = 0\n    for i=1, #list1 do\n        if list1[i] ~= '' and list1[i] ~= nil then\n            if list1.count == nil then\n                list1.count = function(list, value)\n                    local count = 0\n                    for i=1, #list do\n                        if list[i] == value then\n                            count = count + 1\n                        end\n                    end\n                    return count\n                end\n            end\n            if list1:count(list1[i]) > t then\n                t = list1:count(list1[i])\n            end\n        end\n    end\n    if t > 0 then\n        for i=1, #list1 do\n            if list1[i] ~= '' and list1[i] ~= nil then\n                if list1:count(list1[i]) == t then\n                    dict1[list1[i]] = t\n                end\n            end\n        end\n    end\n    return dict1\nend\n\n### Explanation\n\nThe code is an implementation of a histogram function that takes a string as input and returns a dictionary with the most common word(s) and their frequency. The function works as follows:\n\n1. The first line imports the math library, which is not used in the function.\n2. The second line defines a local function called histogram that takes a string as input.\n3. The third line creates an empty dictionary called dict1.\n4. The fourth line creates an empty list called list1.\n5. The fifth line loops through each word in the input string using the gmatch function, which matches all alphanumeric characters in the string. Each word is then appended to list1 using the table.insert function.\n6. The sixth line initializes a variable t to 0.\n7. The seventh line loops through each element in list1.\n8. The eighth line checks if the current element is not an empty string or nil.\n9. The ninth line checks if the count function is defined on list1. If not, it defines the count function, which takes a list and a value as input and returns the number of times the value appears in the list.\n10. The tenth line checks if the count of the current element in list1 is greater than t. If so, it updates t to the count of the current element.\n11. The eleventh line checks if t is greater than 0.\n12. The twelfth line loops through each element in list1.\n13. The thirteenth line checks if the current element is not an empty string or nil.\n14. The fourteenth line checks if the count of the current element in list1 is equal to t. If so, it adds the current element and its count to dict1.\n15. The fifteenth line returns dict1.\n\nHere's the equivalent Racket code:\n\n(define (histogram test)\n  (define dict1 (make-hash))\n  (define list1 (regexp-match* #px\"\\\\w+\" test))\n  (define t 0)\n  (for ([i (in-range (length list1))])\n    (define word (list-ref list1 i))\n    (when (and (not (equal? word \"\")) (not (null? word)))\n      (define (list-count list value)\n        (define count 0)\n        (for ([i (in-range (length list))])\n          (when (equal? (list-ref list i) value)\n            (set! count (+ count 1))))\n        count)\n      (when (> (list-count list1 word) t)\n        (set! t (list-count list1 word)))))\n  (when (> t 0)\n    (for ([i (in-range (length list1))])\n      (define word (list-ref list1 i))\n      (when (and (not (equal? word \"\")) (not (null? word)))\n        (when (= (list-count list1 word) t)\n          (hash-set! dict1 word t)))))\n  dict1)\n\nThe Racket code uses a hash table instead of a dictionary, and replaces Lua's gmatch function with a regular expression match. It also uses a for loop instead of a while loop, and replaces Lua's table.insert function with Racket's list-ref function. The count function is defined inside the for loop to avoid redefining it multiple times. Finally, the hash-set! function is used to add elements to the hash table.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (histogram test)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_odd_collatz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_odd_collatz))\n    (check-within (candidate 14) (list 1 5 7 11 13 17) 0.001)\n    (check-within (candidate 5) (list 1 5) 0.001)\n    (check-within (candidate 12) (list 1 3 5) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_odd_collatz(n)\n    local odd_collatz = (n%2==0) and {} or {n}\n    while n > 1 do\n        if n % 2 == 0 then\n            n = n/2\n        else\n            n = n*3 + 1\n        end\n        if n%2 == 1 then\n            table.insert(odd_collatz, math.floor(n))\n        end\n    end\n    table.sort(odd_collatz)\n    return odd_collatz\nend\n\n### Explanation\n\nThe code is an implementation of the Collatz conjecture. The conjecture states that if you take any positive integer n, and you repeatedly apply the following function:\n\n- If n is even, divide it by 2.\n- If n is odd, multiply it by 3 and add 1.\n\nEventually, no matter what number you start with, you will always reach 1.\n\nThe code defines a function called `get_odd_collatz` that takes a single argument `n`. The function returns an array of all the odd numbers in the Collatz sequence starting from `n`.\n\nThe first line of the function imports the `math` module, which provides mathematical functions.\n\nThe second line of the function creates a local variable called `odd_collatz`. If `n` is even, `odd_collatz` is initialized as an empty array. If `n` is odd, `odd_collatz` is initialized with `n` as its only element.\n\nThe next block of code is a while loop that continues until `n` is equal to 1. Inside the loop, if `n` is even, it is divided by 2. If `n` is odd, it is multiplied by 3 and 1 is added to the result. If the resulting number is odd, it is added to the `odd_collatz` array.\n\nAfter the loop finishes, the `odd_collatz` array is sorted and returned. \n\n\n### Racket version\n\n#lang racket\n\n(define (get_odd_collatz n)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (derivative xs)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate derivative))\n    (check-within (candidate (list 3 1 2 4 5)) (list 1 4 12 20) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 6) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 2 2) 0.001)\n    (check-within (candidate (list 3 2 1 0 4)) (list 2 2 0 16) 0.001)\n    (check-within (candidate (list 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function derivative(xs)\n    local result = {}\n    for i=1, #xs-1 do\n        result[i] = i * xs[i+1]\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that computes the derivative of a polynomial. \n\nThe first line imports the math module.\n\nThe second line defines a function called `derivative` that takes a list of numbers `xs` as input. \n\nThe third line creates an empty list called `result`.\n\nThe fourth line loops over the indices of the list `xs` from 1 to the second to last index. For each index `i`, it computes the product of `i` and the value of `xs` at the next index `i+1`, and stores the result in the `i`-th position of the `result` list.\n\nThe fifth line returns the `result` list.\n\n\n### Racket version\n\n#lang racket\n\n(define (derivative xs)\n"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fibfib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 1) 0 0.001)\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 24 0.001)\n    (check-within (candidate 10) 81 0.001)\n    (check-within (candidate 12) 274 0.001)\n    (check-within (candidate 14) 927 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fibfib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    end\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\nend\n\n### Explanation\n\nThe code is an implementation of the Fibonacci-Fibonacci sequence. The sequence is defined as follows:\n\n\n### Racket version\n\n#lang racket\n\n(define (fibfib n)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (truncate_number number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n    (check-within (candidate 3.5) 0.5 0.001)\n    (check-within (candidate 1.25) 0.25 0.001)\n    (check-within (candidate 123.0) 0.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function truncate_number(number)\n    return number % 1\nend\n\n### Explanation\n\nThe code is an implementation of a function that truncates a number to its fractional part. \n\nThe first line imports the math library.\n\nThe second line defines a function called `truncate_number` that takes a single argument called `number`. \n\nThe third line returns the remainder of `number` divided by 1. This is equivalent to the fractional part of the number. \n\n\n### Racket version\n\n#lang racket\n\n(define (truncate_number number)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_element l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_element))\n    (check-within (candidate (list 1 2 3)) 3 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function max_element(l)\n    local m = l[1]\n    for i=2, #l do\n        if l[i] > m then\n            m = l[i]\n        end\n    end\n    return m\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns the maximum element in the list. Here is a line by line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (max_element l)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (closest_integer value)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-within (candidate \"10\") 10 0.001)\n    (check-within (candidate \"14.5\") 15 0.001)\n    (check-within (candidate \"-15.5\") -16 0.001)\n    (check-within (candidate \"15.3\") 15 0.001)\n    (check-within (candidate \"0\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if value:find('%.5$') then\n        if num > 0 then\n            return math.ceil(num)\n        else\n            return math.floor(num)\n        end\n    elseif #value > 0 then\n        return math.floor(num + 0.5)\n    else\n        return 0\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `closest_integer` that takes a string argument `value` and returns the closest integer to the value. \n\nThe first line imports the `math` module which provides mathematical functions.\n\nThe second line defines a function `closest_integer` that takes a string argument `value`. \n\nThe third line converts the string `value` to a number using `tonumber` and assigns it to a variable `num`. \n\nThe fourth line checks if the string `value` ends with `.5`. If it does, it checks if the number is positive or negative. If it is positive, it returns the smallest integer greater than or equal to `num` using `math.ceil`. If it is negative, it returns the largest integer less than or equal to `num` using `math.floor`. \n\nThe fifth line checks if the length of the string `value` is greater than 0. If it is, it returns the closest integer to `num` using `math.floor(num + 0.5)`. \n\nThe sixth line returns 0 if the length of the string `value` is 0. \n\n\n### Racket version\n\n#lang racket\n\n(define (closest_integer value)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 3) 5 0.001)\n    (check-within (candidate 4) 13 0.001)\n    (check-within (candidate 5) 89 0.001)\n    (check-within (candidate 6) 233 0.001)\n    (check-within (candidate 7) 1597 0.001)\n    (check-within (candidate 8) 28657 0.001)\n    (check-within (candidate 9) 514229 0.001)\n    (check-within (candidate 10) 433494437 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function prime_fib(n)\n  local function is_prime(p)\n    if p < 2 then\n      return false\n    end\n    for k = 2, math.min(math.sqrt(p) + 1, p - 1) do\n      if p % k == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local f = {0, 1}\n  while true do\n    table.insert(f, f[#f] + f[#f - 1])\n    if is_prime(f[#f]) then\n      n = n - 1\n    end\n    if n == 0 then\n      return f[#f]\n    end\n  end\nend\n\n### Explanation\n\nThe code is an implementation of a function `prime_fib` that returns the nth prime Fibonacci number. \n\n\n### Racket version\n\n#lang racket\n\n(define (prime_fib n)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_product numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n    (check-within (candidate (list )) (list 0 1) 0.001)\n    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)\n    (check-within (candidate (list 100 0)) (list 100 0) 0.001)\n    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)\n    (check-within (candidate (list 10)) (list 10 10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_product(numbers)\n    local sum_value = 0\n    local prod_value = 1\n\n    for _, n in ipairs(numbers) do\n        sum_value = sum_value + n\n        prod_value = prod_value * n\n    end\n    return {sum_value, prod_value}\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns a list with two values: the sum of the numbers in the input list and the product of the numbers in the input list.\n\nThe first line imports the math library.\n\nThe second line defines a function called `sum_product` that takes a list of numbers as input.\n\nThe third line initializes two variables, `sum_value` and `prod_value`, to 0 and 1, respectively.\n\nThe fourth line starts a loop that iterates over each element in the input list. The loop variable `_` is used to ignore the index of the current element, and `n` is used to store the value of the current element.\n\nThe fifth line updates the value of `sum_value` by adding the current element `n`.\n\nThe sixth line updates the value of `prod_value` by multiplying it with the current element `n`.\n\nThe loop continues until all elements in the input list have been processed.\n\nThe seventh line returns a list containing the values of `sum_value` and `prod_value`.\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_product numbers)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (select_words s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n    (check-within (candidate \"Mary had a little lamb\" 4) (list \"little\") 0.001)\n    (check-within (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\") 0.001)\n    (check-within (candidate \"simple white space\" 2) (list ) 0.001)\n    (check-within (candidate \"Hello world\" 4) (list \"world\") 0.001)\n    (check-within (candidate \"Uncle sam\" 3) (list \"Uncle\") 0.001)\n    (check-within (candidate \"\" 4) (list ) 0.001)\n    (check-within (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"f\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function select_words(s, n)\n  local result = {}\n  for word in s:gmatch(\"%S+\") do\n    local n_consonants = 0\n    for i = 1, #word do\n      if not word:sub(i,i):lower():find(\"[aeiou]\") then\n        n_consonants = n_consonants + 1\n      end\n    end\n    if n_consonants == n then\n      table.insert(result, word)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function named `select_words` that takes two arguments, a string `s` and an integer `n`. The function returns a table of all the words in the string that have exactly `n` consonants. \n\nThe first line of the code imports the `math` module. \n\nThe second line defines the function `select_words` and takes two arguments, a string `s` and an integer `n`. \n\nThe third line initializes an empty table named `result`. \n\nThe fourth line starts a loop that iterates over each word in the string `s`. The loop uses the `gmatch` method of the string object to match all non-space characters in the string. \n\nThe fifth line initializes a variable named `n_consonants` to zero. \n\nThe sixth line starts a nested loop that iterates over each character in the current word. \n\nThe seventh line checks if the current character is a consonant by checking if it is not a vowel. If the character is a consonant, the `n_consonants` variable is incremented by one. \n\nThe eighth line checks if the number of consonants in the current word is equal to the integer `n`. If the number of consonants is equal to `n`, the current word is added to the `result` table using the `table.insert` method. \n\nThe ninth line ends the nested loop. \n\nThe tenth line ends the outer loop. \n\nThe eleventh line returns the `result` table. \n\n\n### Racket version\n\n#lang racket\n\n(define (select_words s n)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add_elements arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)\n    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)\n    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)\n    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)\n    (check-within (candidate (list 1) 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function add_elements(arr, k)\n  local sum = 0\n  for i = 1, k do\n    if #tostring(arr[i]) <= 2 then\n      sum = sum + arr[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an array and a number `k` as input, and returns the sum of the elements of the array that have two or fewer digits. Here is a line-by-line explanation:\n\n\n### Racket version\n\n#lang racket\n\n(define (add_elements arr k)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (eat number need remaining)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate eat))\n    (check-within (candidate 5 6 10) (list 11 4) 0.001)\n    (check-within (candidate 4 8 9) (list 12 1) 0.001)\n    (check-within (candidate 1 10 10) (list 11 0) 0.001)\n    (check-within (candidate 2 11 5) (list 7 0) 0.001)\n    (check-within (candidate 4 5 7) (list 9 2) 0.001)\n    (check-within (candidate 4 5 1) (list 5 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function eat(number, need, remaining)\n    if need <= remaining then\n        return {number + need, remaining - need}\n    else\n        return {number + remaining, 0}\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `eat` that takes three arguments: `number`, `need`, and `remaining`. The function returns a table with two values: the first value is the sum of `number` and `need` if `need` is less than or equal to `remaining`, otherwise it is the sum of `number` and `remaining`. The second value is `remaining` minus `need` if `need` is less than or equal to `remaining`, otherwise it is 0.\n\nHere is a line-by-line explanation:\n\n1. `math = require('math')`: This line loads the Lua math library, which provides mathematical functions and constants.\n2. `local function eat(number, need, remaining)`: This line defines a local function called `eat` that takes three arguments: `number`, `need`, and `remaining`.\n3. `if need <= remaining then`: This line starts an if statement that checks if `need` is less than or equal to `remaining`.\n4. `return {number + need, remaining - need}`: This line returns a table with two values: the first value is the sum of `number` and `need`, and the second value is `remaining` minus `need`.\n5. `else`: This line starts the else block of the if statement.\n6. `return {number + remaining, 0}`: This line returns a table with two values: the first value is the sum of `number` and `remaining`, and the second value is 0.\n\n\n### Racket version\n\n#lang racket\n\n(define (eat number need remaining)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (odd_count lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate odd_count))\n    (check-within (candidate (list \"1234567\")) (list \"the number of odd elements 4n the str4ng 4 of the 4nput.\") 0.001)\n    (check-within (candidate (list \"3\" \"11111111\")) (list \"the number of odd elements 1n the str1ng 1 of the 1nput.\" \"the number of odd elements 8n the str8ng 8 of the 8nput.\") 0.001)\n    (check-within (candidate (list \"271\" \"137\" \"314\")) (list \"the number of odd elements 2n the str2ng 2 of the 2nput.\" \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \"the number of odd elements 2n the str2ng 2 of the 2nput.\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function odd_count(lst)\n  local res = {}\n  for _, arr in ipairs(lst) do\n    local n = 0\n    for d in arr:gmatch('%d') do\n      if math.fmod(tonumber(d), 2) == 1 then\n        n = n + 1\n      end\n    end\n    table.insert(res, \"the number of odd elements \" .. n .. \"n the str\" .. n .. \"ng \" .. n .. \" of the \" .. n .. \"nput.\")\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function `odd_count` that takes a list of strings as input and returns a list of strings that describes the number of odd digits in each string. Here is a line by line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (odd_count lst)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (next_smallest lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)\n    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list -35 34 12 -45)) -35 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function next_smallest(lst)\n    table.sort(lst)\n    for i = 2, #lst do\n        if lst[i] > lst[1] then\n            return lst[i]\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `next_smallest` that takes a list of numbers as input and returns the smallest number in the list that is greater than the first element of the list. If there is no such number, the function returns `nil`.\n\nThe function first imports the `math` module, which provides a number of mathematical functions. The `require` function is used to load the module.\n\n\n### Racket version\n\n#lang racket\n\n(define (next_smallest lst)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_prefix strings prefix)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_prefix(strings, prefix)\n    local res = {}\n    for _, x in ipairs(strings) do\n        if string.sub(x, 1, #prefix) == prefix then\n            table.insert(res, x)\n        end\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a function called `filter_by_prefix` that takes two arguments: a list of strings and a prefix. The function returns a new list of strings that start with the given prefix.\n\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_prefix strings prefix)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (choose_num x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n    (check-within (candidate 12 15) 14 0.001)\n    (check-within (candidate 13 12) -1 0.001)\n    (check-within (candidate 33 12354) 12354 0.001)\n    (check-within (candidate 5234 5233) -1 0.001)\n    (check-within (candidate 6 29) 28 0.001)\n    (check-within (candidate 27 10) -1 0.001)\n    (check-within (candidate 7 7) -1 0.001)\n    (check-within (candidate 546 546) 546 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function choose_num(x, y)\n    if x > y then\n        return -1\n    end\n    if y % 2 == 0 then\n        return y\n    end\n    if x == y then\n        return -1\n    end\n    return y - 1\nend\n\n### Explanation\n\nThe code is an implementation of the `choose_num` function in Lua. The function takes two arguments, `x` and `y`, and returns a number based on the values of `x` and `y`. \n\nThe first line of the code imports the `math` module, which provides access to mathematical functions in Lua.\n\nThe second line defines the `choose_num` function with two parameters, `x` and `y`. \n\nThe first `if` statement checks if `x` is greater than `y`. If it is, the function returns `-1`.\n\nThe second `if` statement checks if `y` is even. If it is, the function returns `y`.\n\nThe third `if` statement checks if `x` is equal to `y`. If it is, the function returns `-1`.\n\nIf none of the above conditions are met, the function returns `y - 1`.\n\n\n### Racket version\n\n#lang racket\n\n(define (choose_num x y)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_length string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n    (check-within (candidate \"Hello\") #t 0.001)\n    (check-within (candidate \"abcdcba\") #t 0.001)\n    (check-within (candidate \"kittens\") #t 0.001)\n    (check-within (candidate \"orange\") #f 0.001)\n    (check-within (candidate \"wow\") #t 0.001)\n    (check-within (candidate \"world\") #t 0.001)\n    (check-within (candidate \"MadaM\") #t 0.001)\n    (check-within (candidate \"Wow\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"HI\") #t 0.001)\n    (check-within (candidate \"go\") #t 0.001)\n    (check-within (candidate \"gogo\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaa\") #f 0.001)\n    (check-within (candidate \"Madam\") #t 0.001)\n    (check-within (candidate \"M\") #f 0.001)\n    (check-within (candidate \"0\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function prime_length(string)\n  local l = #string\n  if l == 0 or l == 1 then\n    return false\n  end\n  for i = 2, l - 1 do\n    if l % i == 0 then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `prime_length` that takes a string as an argument and returns `true` if the length of the string is a prime number, and `false` otherwise.\n\n\n### Racket version\n\n#lang racket\n\n(define (prime_length string)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_to_n n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_to_n))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 6) 21 0.001)\n    (check-within (candidate 11) 66 0.001)\n    (check-within (candidate 30) 465 0.001)\n    (check-within (candidate 100) 5050 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_to_n(n)\n  return (n * (n + 1)) / 2\nend\n\n### Explanation\n\nThe code is an implementation of a function that sums all numbers from 1 to n. \n\nThe first line imports the math library. \n\nThe second line defines a function called `sum_to_n` that takes a single argument `n`. \n\nThe function returns the sum of all numbers from 1 to `n`. The formula used to calculate the sum is `(n * (n + 1)) / 2`. \n\nThe function is defined as a local function, which means that it is only accessible within the scope of the file or block in which it is defined. \n\nTo translate this program to Racket, you would need to import the math library, define a function called `sum-to-n` that takes a single argument `n`, and return the sum of all numbers from 1 to `n` using the formula `(n * (n + 1)) / 2`. The Racket code would look something like this:\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_to_n n)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fix_spaces text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fix_spaces))\n    (check-within (candidate \"Example\") \"Example\" 0.001)\n    (check-within (candidate \"Mudasir Hanif \") \"Mudasir_Hanif_\" 0.001)\n    (check-within (candidate \"Yellow Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\" 0.001)\n    (check-within (candidate \"Exa   mple\") \"Exa-mple\" 0.001)\n    (check-within (candidate \"   Exa 1 2 2 mple\") \"-Exa_1_2_2_mple\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fix_spaces(text)\n    local new_text = \"\"\n    local i = 1\n    local start, _end = 1, 1\n    while i <= #text do\n        local c = text:sub(i, i)\n        if c == \" \" then\n            _end = _end + 1\n        else\n            if _end - start > 2 then\n                new_text = new_text .. \"-\" .. c\n            elseif _end - start > 0 then\n                new_text = new_text .. (\"_\"):rep(_end - start) .. c\n            else\n                new_text = new_text .. c\n            end\n            start, _end = i+1, i+1\n        end\n        i = i + 1\n    end\n    if _end - start > 2 then\n        new_text = new_text .. \"-\"\n    elseif _end - start > 0 then\n        new_text = new_text .. \"_\"\n    end\n    return new_text\nend\n\n### Explanation\n\nThe code is an implementation of a function `fix_spaces` that takes a string as input and returns a new string with spaces replaced by underscores or hyphens, depending on the number of spaces in a row. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the file or block in which it is defined.\n\nThe first line of the function imports the `math` module, which provides mathematical functions and constants. This is not actually used in the function, so it could be removed.\n\nThe function then defines a few local variables: `new_text` is an empty string that will be used to build the new string, `i` is an index variable that will be used to iterate over the characters in the input string, and `start` and `_end` are variables that will be used to keep track of the start and end indices of a sequence of spaces.\n\nThe function then enters a `while` loop that will iterate over each character in the input string. The loop condition is `i <= #text`, which means that the loop will continue until `i` is greater than the length of the input string.\n\nWithin the loop, the function first extracts the character at index `i` using the `sub` method of the input string. It then checks whether the character is a space. If it is, it increments the `_end` variable, which keeps track of the end index of the current sequence of spaces. If the character is not a space, the function checks whether there was a sequence of spaces before it. If there was, it determines whether the sequence was long enough to be replaced by a hyphen. If it was, it appends a hyphen followed by the current character to the `new_text` string. If the sequence was not long enough to be replaced by a hyphen but was still non-empty, it appends a number of underscores equal to the length of the sequence, followed by the current character. If there was no sequence of spaces before the current character, it simply appends the character to the `new_text` string. Finally, it updates the `start` and `_end` variables to reflect the current character.\n\nAfter the loop, the function checks whether there was a sequence of spaces at the end of the input string. If there was, it appends a hyphen if the sequence was long enough to be replaced by one, or an underscore if it was not.\n\nThe function then returns the `new_text` string.\n\n\n### Racket version\n\n#lang racket\n\n(define (fix_spaces text)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rolling_max numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)\n    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function rolling_max(numbers)\n    local running_max = nil\n    local result = {}\n\n    for _, n in ipairs(numbers) do\n        if running_max == nil then\n            running_max = n\n        else\n            running_max = math.max(running_max, n)\n        end\n\n        table.insert(result, running_max)\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a rolling maximum function. Given a list of numbers, it returns a new list where each element is the maximum of all the elements up to and including the corresponding element in the input list.\n\n\n### Racket version\n\n#lang racket\n\n(define (rolling_max numbers)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (words_in_sentence sentence)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_in_sentence))\n    (check-within (candidate \"This is a test\") \"is\" 0.001)\n    (check-within (candidate \"lets go for swimming\") \"go for\" 0.001)\n    (check-within (candidate \"there is no place available here\") \"there is no place\" 0.001)\n    (check-within (candidate \"Hi I am Hussein\") \"Hi am Hussein\" 0.001)\n    (check-within (candidate \"go for it\") \"go for it\" 0.001)\n    (check-within (candidate \"here\") \"\" 0.001)\n    (check-within (candidate \"here is\") \"is\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function words_in_sentence(sentence)\n    local new_lst = {}\n    for word in sentence:gmatch(\"%S+\") do\n        local flg = 0\n        if #word == 1 then\n            flg = 1\n        end\n        for i=2, #word-1 do\n            if #word%i == 0 then\n                flg = 1\n            end\n        end\n        if flg == 0 or #word == 2 then\n            table.insert(new_lst, word)\n        end\n    end\n    return table.concat(new_lst, \" \")\nend\n\n### Explanation\n\nThe code is an implementation of a function `words_in_sentence` that takes a string argument `sentence` and returns a string. The function removes all words in the sentence that are either one letter long or have a length that is divisible by any number other than 1 and the word's length. \n\nThe first line of the code imports the `math` module.\n\nThe second line of the code defines a function `words_in_sentence` that takes a string argument `sentence`. \n\nThe third line of the code creates a new empty table `new_lst`.\n\nThe fourth line of the code starts a loop that iterates over each word in the sentence. The loop uses the `gmatch` function to match all non-space characters in the sentence and returns an iterator that iterates over each match. \n\nThe fifth line of the code initializes a flag variable `flg` to 0.\n\nThe sixth line of the code checks if the length of the current word is 1. If it is, the flag variable `flg` is set to 1.\n\nThe seventh line of the code starts a loop that iterates over each number from 2 to the length of the current word minus 1.\n\nThe eighth line of the code checks if the length of the current word is divisible by the current number. If it is, the flag variable `flg` is set to 1.\n\nThe ninth line of the code checks if the flag variable `flg` is 0 or if the length of the current word is 2. If either of these conditions is true, the current word is added to the `new_lst` table using the `table.insert` function.\n\nThe tenth line of the code ends the loop.\n\nThe eleventh line of the code returns the concatenated string of all the words in the `new_lst` table separated by a space.\n\n\n### Racket version\n\n#lang racket\n\n(define (words_in_sentence sentence)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_closest_vowel word)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-within (candidate \"yogurt\") \"u\" 0.001)\n    (check-within (candidate \"full\") \"u\" 0.001)\n    (check-within (candidate \"easy\") \"\" 0.001)\n    (check-within (candidate \"eAsy\") \"\" 0.001)\n    (check-within (candidate \"ali\") \"\" 0.001)\n    (check-within (candidate \"bad\") \"a\" 0.001)\n    (check-within (candidate \"most\") \"o\" 0.001)\n    (check-within (candidate \"ab\") \"\" 0.001)\n    (check-within (candidate \"ba\") \"\" 0.001)\n    (check-within (candidate \"quick\") \"\" 0.001)\n    (check-within (candidate \"anime\") \"i\" 0.001)\n    (check-within (candidate \"Asia\") \"\" 0.001)\n    (check-within (candidate \"Above\") \"o\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_closest_vowel(word)\n    if #word < 3 then\n        return \"\"\n    end\n\n    local vowels = {a=true, e=true, i=true, o=true, u=true, A=true, E=true, I=true, O=true, U=true}\n    for i=#word-1, 2, -1 do\n        if vowels[word:sub(i, i)] then\n            if not (vowels[word:sub(i-1, i-1)] or vowels[word:sub(i+1, i+1)]) then\n                return word:sub(i, i)\n            end\n        end\n    end\n    return \"\"\nend\n\n### Explanation\n\nThe code is an implementation of a function `get_closest_vowel` that takes a string `word` and returns the closest vowel to the end of the string that is not surrounded by other vowels. If there is no such vowel, the function returns an empty string.\n\nThe function first imports the `math` module, which is not used in the function.\n\n\n### Racket version\n\n#lang racket\n\n(define (get_closest_vowel word)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare game guess)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)\n    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function compare(game, guess)\n  local result = {}\n  for i = 1, #game do\n    result[i] = math.abs(game[i] - guess[i])\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `compare` that takes two arrays `game` and `guess` of equal length and returns an array of the absolute differences between the elements of the two arrays.\n\n\n### Racket version\n\n#lang racket\n\n(define (compare game guess)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (remove_duplicates numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_duplicates))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function remove_duplicates(numbers)\n  local c = {}\n  for _, n in ipairs(numbers) do\n    c[n] = (c[n] or 0) + 1\n  end\n  local result = {}\n  for _, n in ipairs(numbers) do\n    if c[n] <= 1 then\n      table.insert(result, n)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that removes duplicates from an array of numbers.\n\n\n### Racket version\n\n#lang racket\n\n(define (remove_duplicates numbers)\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (same_chars s0 s1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabc\") #t 0.001)\n    (check-within (candidate \"dddddddabc\" \"abcd\") #t 0.001)\n    (check-within (candidate \"eabcd\" \"dddddddabc\") #f 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabcf\") #f 0.001)\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f 0.001)\n    (check-within (candidate \"aabb\" \"aaccc\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function same_chars(s0, s1)\n    local set0, set1 = {}, {}\n    for i=1, #s0 do set0[s0:sub(i,i)] = true end\n    for i=1, #s1 do set1[s1:sub(i,i)] = true end\n    for k in pairs(set0) do if not set1[k] then return false end end\n    for k in pairs(set1) do if not set0[k] then return false end end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `same_chars` that takes two strings `s0` and `s1` and returns `true` if they have the same characters, and `false` otherwise.\n\n\n### Racket version\n\n#lang racket\n\n(define (same_chars s0 s1)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_nested_parens paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3) 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4) 0.001)\n    (check-within (candidate \"(()(())((())))\") (list 4) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function parse_nested_parens(paren_string)\n    local function parse_paren_group(s)\n        local depth = 0\n        local max_depth = 0\n        for c in s:gmatch('.') do\n            if c == '(' then\n                depth = depth + 1\n                max_depth = math.max(depth, max_depth)\n            else\n                depth = depth - 1\n            end\n        end\n        return max_depth\n    end\n    local res = {}\n    for x in paren_string:gmatch('%S+') do\n        table.insert(res, parse_paren_group(x))\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a function called `parse_nested_parens` that takes a string of nested parentheses and returns a list of integers that represent the maximum depth of each group of parentheses. \n\n\n### Racket version\n\n#lang racket\n\n(define (parse_nested_parens paren_string)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (even_odd_count num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n    (check-within (candidate 7) (list 0 1) 0.001)\n    (check-within (candidate -78) (list 1 1) 0.001)\n    (check-within (candidate 3452) (list 2 2) 0.001)\n    (check-within (candidate 346211) (list 3 3) 0.001)\n    (check-within (candidate -345821) (list 3 3) 0.001)\n    (check-within (candidate -2) (list 1 0) 0.001)\n    (check-within (candidate -45347) (list 2 3) 0.001)\n    (check-within (candidate 0) (list 1 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_count(num)\n    local even_count = 0\n    local odd_count = 0\n    for i in tostring(math.abs(num)):gmatch(\".\") do\n        if tonumber(i)%2==0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n    end\n    return {even_count, odd_count}\nend\n\n### Explanation\n\nThe code is an implementation of a function `even_odd_count` that takes a number as an argument and returns a list of two numbers: the first number is the count of even digits in the number, and the second number is the count of odd digits in the number.\n\n\n### Racket version\n\n#lang racket\n\n(define (even_odd_count num)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fruit_distribution s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fruit_distribution))\n    (check-within (candidate \"5 apples and 6 oranges\" 19) 8 0.001)\n    (check-within (candidate \"5 apples and 6 oranges\" 21) 10 0.001)\n    (check-within (candidate \"0 apples and 1 oranges\" 3) 2 0.001)\n    (check-within (candidate \"1 apples and 0 oranges\" 3) 2 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 100) 95 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 5) 0 0.001)\n    (check-within (candidate \"1 apples and 100 oranges\" 120) 19 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fruit_distribution(s, n)\n    local sum = 0\n    for i in string.gmatch(s, \"%d+\") do\n        sum = sum + tonumber(i)\n    end\n    return n - sum\nend\n\n### Explanation\n\nThe code is an implementation of a function called `fruit_distribution` that takes two arguments: a string `s` and a number `n`. The function returns the difference between `n` and the sum of all the numbers in the string `s`.\n\nThe first line of the code imports the `math` module.\n\nThe second line of the code defines the `fruit_distribution` function. The function takes two arguments: a string `s` and a number `n`. The function returns the difference between `n` and the sum of all the numbers in the string `s`.\n\nThe third line of the code initializes a variable `sum` to 0.\n\nThe fourth line of the code starts a loop that iterates over all the numbers in the string `s`. The `string.gmatch` function is used to find all the numbers in the string `s`. The `%d+` pattern matches one or more digits. The `tonumber` function is used to convert each matched string to a number. The loop adds each number to the `sum` variable.\n\nThe fifth line of the code returns the difference between `n` and the `sum` variable.\n\n\n### Racket version\n\n#lang racket\n\n(define (fruit_distribution s n)\n"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_xor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n    (check-within (candidate \"111000\" \"101010\") \"010010\" 0.001)\n    (check-within (candidate \"1\" \"1\") \"0\" 0.001)\n    (check-within (candidate \"0101\" \"0000\") \"0101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function string_xor(a, b)\n    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result = result .. '0'\n        else\n            result = result .. '1'\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of the XOR operation between two strings. The function `string_xor` takes two strings `a` and `b` as input and returns a string `result` that is the result of the XOR operation between `a` and `b`. \n\nThe XOR operation is a bitwise operation that returns a 1 in each bit position where the corresponding bits of either but not both operands are 1s. In other words, it returns a 1 if the bits being compared are different, and a 0 if they are the same.\n\nThe function `string_xor` iterates over each character in the input strings `a` and `b` using a for loop. For each character, it compares the corresponding characters in `a` and `b` using the `sub` method of the string object. If the characters are the same, it appends a '0' to the `result` string, otherwise it appends a '1'. Finally, the function returns the `result` string.\n\nThe first line of the code imports the `math` module, which provides a set of mathematical functions and constants.\n\nThe second line of the code defines a local function `string_xor` that takes two string arguments `a` and `b`.\n\nThe `local` keyword is used to define a local variable that is only accessible within the scope of the function. This is a common practice in Lua to avoid polluting the global namespace with unnecessary variables.\n\nThe `function` keyword is used to define a function in Lua. The function name `string_xor` is followed by the argument list `(a, b)` enclosed in parentheses.\n\nThe body of the function is enclosed in a `do`...`end` block. The `for` loop iterates over each character in the input strings `a` and `b` using the `#` operator to get the length of the string. The `sub` method is used to get the character at the current index `i` in both strings.\n\nThe `if` statement compares the characters at the current index. If they are the same, it appends a '0' to the `result` string using the `..` operator. Otherwise, it appends a '1'.\n\nFinally, the `return` statement returns the `result` string. \n\n\n### Racket version\n\n#lang racket\n\n(define (string_xor a b)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strlen string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strlen))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"x\") 1 0.001)\n    (check-within (candidate \"asdasnakj\") 9 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function strlen(string)\n    return #string\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates the length of a string. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the current block. The function takes a single argument, `string`, which is the string whose length is to be calculated.\n\nThe function returns the length of the string using the `#` operator. The `#` operator is a shortcut for the `string.len` function, which returns the length of a string.\n\nThe `math` module is loaded using the `require` function. This module provides a number of mathematical functions that can be used in Lua programs. However, it is not used in this program.\n\n\n### Racket version\n\n#lang racket\n\n(define (strlen string)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_sequence n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n    (check-within (candidate 0) \"0\" 0.001)\n    (check-within (candidate 3) \"0 1 2 3\" 0.001)\n    (check-within (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function string_sequence(n)\n    local t = {}\n    for i = 0, n do\n        t[#t + 1] = tostring(i)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of a function called `string_sequence` that takes an integer `n` and returns a string of space-separated integers from 0 to `n`. \n\n\n### Racket version\n\n#lang racket\n\n(define (string_sequence n)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (can_arrange arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate can_arrange))\n    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)\n    (check-within (candidate (list 1 2 4 5)) -1 0.001)\n    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)\n    (check-within (candidate (list )) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function can_arrange(arr)\n    local ind=-1\n    local i=1\n    while i<#arr do\n      if arr[i]>arr[i+1] then\n        ind=i\n      end\n      i=i+1\n    end\n    return ind\nend\n\n### Explanation\n\nThe code is an implementation of a function called `can_arrange`. The function takes an array of numbers as input and returns an integer. The function checks if the array can be sorted in non-decreasing order by swapping at most one pair of elements. If the array can be sorted in non-decreasing order by swapping at most one pair of elements, the function returns the index of the element that needs to be swapped. If the array cannot be sorted in non-decreasing order by swapping at most one pair of elements, the function returns -1.\n\nThe first line of the code imports the math library.\n\n\n### Racket version\n\n#lang racket\n\n(define (can_arrange arr)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate (list 4 88)) 88 0.001)\n    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)\n    (check-within (candidate (list 4 0 6 7)) 0 0.001)\n    (check-within (candidate (list 4 4 6 8)) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function add(lst)\n  local sum = 0\n  for i = 2, #lst, 2 do\n    if lst[i]%2 == 0 then\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns the sum of all even numbers at even indices. \n\n\n### Racket version\n\n#lang racket\n\n(define (add lst)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersperse numbers delimeter)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersperse))\n    (check-within (candidate (list ) 7) (list ) 0.001)\n    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)\n    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function intersperse(numbers, delimeter)\n    if not numbers then\n        return {}\n    end\n\n    local result = {}\n\n    for i=1, #numbers-1 do\n        table.insert(result, numbers[i])\n        table.insert(result, delimeter)\n    end\n\n    table.insert(result, numbers[#numbers])\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `intersperse` that takes two arguments: `numbers` and `delimeter`. The function returns a new table that contains all the elements of `numbers` separated by `delimeter`. \n\nThe first line of the code imports the `math` library. This library provides a set of mathematical functions that can be used in Lua.\n\nThe second line of the code defines the `intersperse` function. The function takes two arguments: `numbers` and `delimeter`. \n\nThe third line of the code checks if `numbers` is nil. If `numbers` is nil, the function returns an empty table.\n\nThe fourth line of the code creates a new table called `result`.\n\nThe fifth line of the code starts a loop that iterates over the elements of `numbers`. The loop starts at index 1 and ends at the second to last index of `numbers`.\n\nThe sixth line of the code inserts the current element of `numbers` into the `result` table.\n\nThe seventh line of the code inserts the `delimeter` into the `result` table.\n\nThe eighth line of the code ends the loop.\n\nThe ninth line of the code inserts the last element of `numbers` into the `result` table.\n\nThe tenth line of the code returns the `result` table.\n\n\n### Racket version\n\n#lang racket\n\n(define (intersperse numbers delimeter)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (match_parens lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate match_parens))\n    (check-within (candidate (list \"()(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \")\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(())\" \"())())\")) \"No\" 0.001)\n    (check-within (candidate (list \")())\" \"(()()(\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"(())))\" \"(()())((\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"()\" \"())\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(\" \"()))()\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"((((\" \"((())\")) \"No\" 0.001)\n    (check-within (candidate (list \")(()\" \"(()(\")) \"No\" 0.001)\n    (check-within (candidate (list \")(\" \")(\")) \"No\" 0.001)\n    (check-within (candidate (list \"(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \"(\")) \"Yes\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function match_parens(lst)\n    local function check(s)\n        local val = 0\n        for i=1, #s do\n            if s:sub(i, i) == '(' then\n                val = val + 1\n            else\n                val = val - 1\n            end\n            if val < 0 then\n                return false\n            end\n        end\n        return val == 0\n    end\n\n    local S1 = lst[1]..lst[2]\n    local S2 = lst[2]..lst[1]\n    if check(S1) or check(S2) then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `match_parens` that takes a list of two strings and returns 'Yes' if the two strings can be concatenated in some order to form a string with balanced parentheses, and 'No' otherwise.\n\nThe function first defines an inner function `check` that takes a string and returns `true` if the string has balanced parentheses and `false` otherwise. The function works by iterating over the string and keeping track of the number of open parentheses encountered so far. If a closing parenthesis is encountered before an open one, or if the number of open parentheses becomes negative at any point, the function returns `false`. If the end of the string is reached and the number of open parentheses is zero, the function returns `true`.\n\nThe function then concatenates the two strings in both orders and checks if either of the resulting strings has balanced parentheses using the `check` function. If either string has balanced parentheses, the function returns 'Yes'. Otherwise, it returns 'No'.\n\n\n### Racket version\n\n#lang racket\n\n(define (match_parens lst)\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (any_int x y z)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate any_int))\n    (check-within (candidate 2 3 1) #t 0.001)\n    (check-within (candidate 2.5 2 3) #f 0.001)\n    (check-within (candidate 1.5 5 3.5) #f 0.001)\n    (check-within (candidate 2 6 2) #f 0.001)\n    (check-within (candidate 4 2 2) #t 0.001)\n    (check-within (candidate 2.2 2.2 2.2) #f 0.001)\n    (check-within (candidate -4 6 2) #t 0.001)\n    (check-within (candidate 2 1 1) #t 0.001)\n    (check-within (candidate 3 4 7) #t 0.001)\n    (check-within (candidate 3.0 4 7) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function any_int(x, y, z)\n    if math.type(x) == \"integer\" and math.type(y) == \"integer\" and math.type(z) == \"integer\" then\n        if (x+y==z) or (x+z==y) or (y+z==x) then\n            return true\n        end\n        return false\n    end\n    return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `any_int` that takes three arguments `x`, `y`, and `z`. The function returns `true` if any two of the arguments sum up to the third argument, and all three arguments are integers. Otherwise, it returns `false`.\n\nThe first line of the code imports the `math` module, which provides mathematical functions.\n\nThe second line of the code defines a function called `any_int` that takes three arguments `x`, `y`, and `z`.\n\nThe third line of the code checks if all three arguments are integers using the `math.type` function. If any of the arguments is not an integer, the function returns `false`.\n\nThe fourth line of the code checks if any two of the arguments sum up to the third argument. If this is true, the function returns `true`.\n\nThe fifth line of the code returns `false` if the previous condition is not met.\n\nThe sixth line of the code returns `false` if any of the arguments is not an integer. This is the case when the condition in the third line is not met.\n\n\n### Racket version\n\n#lang racket\n\n(define (any_int x y z)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_substring strings substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"grunt\" \"trumpet\" \"prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_substring(strings, substring)\n    local result = {}\n    for _, v in pairs(strings) do\n        if string.find(v, substring) then\n            table.insert(result, v)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `filter_by_substring` that takes two arguments, `strings` and `substring`, and returns a list of all the strings in `strings` that contain `substring`. \n\nThe first line imports the `math` module. This is not used in the function and can be removed.\n\nThe second line defines a function `filter_by_substring` that takes two arguments, `strings` and `substring`. \n\nThe third line creates an empty table called `result`.\n\nThe fourth line loops through each element in `strings`. The underscore is used as a placeholder for the index, which is not used in the loop. The variable `v` is assigned the value of the current element in `strings`.\n\nThe fifth line checks if `substring` is a substring of `v`. If it is, then the current element `v` is added to the `result` table using the `table.insert` function.\n\nThe sixth line returns the `result` table.\n\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_substring strings substring)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_max words)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n    (check-within (candidate (list \"name\" \"of\" \"string\")) \"string\" 0.001)\n    (check-within (candidate (list \"name\" \"enam\" \"game\")) \"enam\" 0.001)\n    (check-within (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\" 0.001)\n    (check-within (candidate (list \"abc\" \"cba\")) \"abc\" 0.001)\n    (check-within (candidate (list \"play\" \"this\" \"game\" \"of\" \"footbott\")) \"footbott\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\" 0.001)\n    (check-within (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\" 0.001)\n    (check-within (candidate (list \"b\")) \"b\" 0.001)\n    (check-within (candidate (list \"play\" \"play\" \"play\")) \"play\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function find_max(words)\n    table.sort(words, function(a, b)\n        if #a ~= #b then\n            return #a > #b\n        else\n            return a < b\n        end\n    end)\n\n    local max_word = words[1]\n    local max_count = 0\n\n    for i=1, #words do\n        local count = 0\n        local char_set = {}\n\n        for j=1, #words[i] do\n            if not char_set[words[i]:sub(j, j)] then\n                count = count + 1\n                char_set[words[i]:sub(j, j)] = true\n            end\n        end\n\n        if count > max_count then\n            max_count = count\n            max_word = words[i]\n        end\n    end\n\n    return max_word\nend\n\n### Explanation\n\nThe code is an implementation of a function `find_max` that takes a list of strings `words` and returns the string with the most unique characters. If there are multiple strings with the same number of unique characters, it returns the one with the smallest lexicographic order.\n\n\n### Racket version\n\n#lang racket\n\n(define (find_max words)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (generate_integers a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate generate_integers))\n    (check-within (candidate 2 10) (list 2 4 6 8) 0.001)\n    (check-within (candidate 10 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 132 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 17 89) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function generate_integers(a, b)\n    local lower = math.max(2, math.min(a, b))\n    local upper = math.min(8, math.max(a, b))\n\n    local result = {}\n    for i=lower, upper do\n        if i%2 == 0 then\n            table.insert(result, i)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that generates a list of even integers between two numbers, inclusive. \n\n\n### Racket version\n\n#lang racket\n\n(define (generate_integers a b)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (exchange lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate exchange))\n    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) \"YES\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 4)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 3)) \"NO\" 0.001)\n    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) \"NO\" 0.001)\n    (check-within (candidate (list 100 200) (list 200 200)) \"YES\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function exchange(lst1, lst2)\n    local odd = 0\n    local even = 0\n    for i=1, #lst1 do\n        if lst1[i]%2 == 1 then\n            odd = odd + 1\n        end\n    end\n    for i=1, #lst2 do\n        if lst2[i]%2 == 0 then\n            even = even + 1\n        end\n    end\n    if even >= odd then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThe code is an implementation of a function called `exchange` that takes two lists as input and returns a string \"YES\" or \"NO\". The function determines whether the number of even numbers in the second list is greater than or equal to the number of odd numbers in the first list.\n\nThe first line of the code imports the math library, which provides mathematical functions and constants.\n\nThe second line defines the `exchange` function and takes two arguments, `lst1` and `lst2`, which represent the two lists.\n\nThe next two lines define two variables, `odd` and `even`, and initialize them to zero.\n\nThe following two loops iterate over the elements of the two lists. The first loop checks if the current element of `lst1` is odd by checking if the remainder of the element divided by 2 is 1. If the element is odd, the `odd` variable is incremented. The second loop checks if the current element of `lst2` is even by checking if the remainder of the element divided by 2 is 0. If the element is even, the `even` variable is incremented.\n\nThe next line checks if the number of even elements in `lst2` is greater than or equal to the number of odd elements in `lst1`. If it is, the function returns \"YES\". Otherwise, it returns \"NO\". \n\n\n### Racket version\n\n#lang racket\n\n(define (exchange lst1 lst2)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (int_to_mini_roman number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n    (check-within (candidate 19) \"xix\" 0.001)\n    (check-within (candidate 152) \"clii\" 0.001)\n    (check-within (candidate 251) \"ccli\" 0.001)\n    (check-within (candidate 426) \"cdxxvi\" 0.001)\n    (check-within (candidate 500) \"d\" 0.001)\n    (check-within (candidate 1) \"i\" 0.001)\n    (check-within (candidate 4) \"iv\" 0.001)\n    (check-within (candidate 43) \"xliii\" 0.001)\n    (check-within (candidate 90) \"xc\" 0.001)\n    (check-within (candidate 94) \"xciv\" 0.001)\n    (check-within (candidate 532) \"dxxxii\" 0.001)\n    (check-within (candidate 900) \"cm\" 0.001)\n    (check-within (candidate 994) \"cmxciv\" 0.001)\n    (check-within (candidate 1000) \"m\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function int_to_mini_roman(number)\n    local num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}\n    local sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\n    local i = 13\n    local res = \"\"\n    while number > 0 do\n        local div = math.floor(number / num[i])\n        number = number % num[i]\n        while div > 0 do\n            res = res .. sym[i]\n            div = div - 1\n        end\n        i = i - 1\n    end\n    return string.lower(res)\nend\n\n### Explanation\n\nThe code is an implementation of a function that converts integers to mini roman numerals. The function is called `int_to_mini_roman` and takes a single argument `number`. \n\nThe first line of the code imports the `math` library. \n\nThe next two lines of the code define two tables `num` and `sym`. `num` contains the integer values of the mini roman numerals and `sym` contains the corresponding symbols. \n\nThe next line of the code initializes a variable `i` to 13 and a variable `res` to an empty string. \n\nThe code then enters a while loop that continues until `number` is less than or equal to 0. \n\nWithin the while loop, the code calculates the integer division of `number` by `num[i]` and stores the result in a variable `div`. It then calculates the remainder of `number` divided by `num[i]` and stores the result in `number`. \n\nThe code then enters another while loop that continues until `div` is less than or equal to 0. Within this loop, it appends the symbol corresponding to `num[i]` to `res` and decrements `div` by 1. \n\nFinally, the code decrements `i` by 1 and returns `res` in lowercase. \n\n\n### Racket version\n\n#lang racket\n\n(define (int_to_mini_roman number)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_equal_to_sum_even n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #t 0.001)\n    (check-within (candidate 11) #f 0.001)\n    (check-within (candidate 12) #t 0.001)\n    (check-within (candidate 13) #f 0.001)\n    (check-within (candidate 16) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_equal_to_sum_even(n)\n  return n%2 == 0 and n >= 8\nend\n\n### Explanation\n\nThe code is an implementation of a function that returns true if a number is even and greater than or equal to 8. \n\nThe first line imports the math module. \n\nThe second line defines a function called `is_equal_to_sum_even` that takes in a single argument `n`. \n\nThe third line returns a boolean value that is true if `n` is even and greater than or equal to 8. \n\nThe `n%2 == 0` checks if `n` is even. The `and` operator checks if the previous condition is true and if `n` is greater than or equal to 8. If both conditions are true, the function returns true. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_equal_to_sum_even n)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_third l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_third))\n    (check-within (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5) 0.001)\n    (check-within (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5) 0.001)\n    (check-within (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5) 0.001)\n    (check-within (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_third(l)\n    l = {table.unpack(l)}\n    for i = 3, #l, 3 do\n        local j = i\n        while j > 1 and l[j - 3 + 1] > l[j + 1] do\n            l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]\n            j = j - 3\n        end\n    end\n    return l\nend\n\n### Explanation\n\nThe code is an implementation of an insertion sort algorithm that sorts a list of numbers by their third element. \n\n`math = require('math')` imports the math library.\n\n`local function sort_third(l)` defines a function called `sort_third` that takes a list `l` as an argument.\n\n`l = {table.unpack(l)}` creates a copy of the list `l`.\n\n`for i = 3, #l, 3 do` iterates over every third element of the list `l`, starting from the third element.\n\n`local j = i` initializes a variable `j` to the current index `i`.\n\n`while j > 1 and l[j - 3 + 1] > l[j + 1] do` checks if the current element is greater than the previous element. If it is, then it swaps the two elements.\n\n`l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]` swaps the two elements.\n\n`j = j - 3` decrements the index `j` by 3.\n\n`return l` returns the sorted list. \n\n\n### Racket version\n\n#lang racket\n\n(define (sort_third l)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (simplify x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate simplify))\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/6\" \"2/1\") #f 0.001)\n    (check-within (candidate \"5/1\" \"3/1\") #t 0.001)\n    (check-within (candidate \"7/10\" \"10/2\") #f 0.001)\n    (check-within (candidate \"2/10\" \"50/10\") #t 0.001)\n    (check-within (candidate \"7/2\" \"4/2\") #t 0.001)\n    (check-within (candidate \"11/6\" \"6/1\") #t 0.001)\n    (check-within (candidate \"2/3\" \"5/2\") #f 0.001)\n    (check-within (candidate \"5/2\" \"3/5\") #f 0.001)\n    (check-within (candidate \"2/4\" \"8/4\") #t 0.001)\n    (check-within (candidate \"2/4\" \"4/2\") #t 0.001)\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/5\" \"1/5\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function simplify(x, n)\n  local a, b = x:match(\"([^/]+)/([^/]+)\")\n  local c, d = n:match(\"([^/]+)/([^/]+)\")\n  local numerator = tonumber(a) * tonumber(c)\n  local denom = tonumber(b) * tonumber(d)\n  if (numerator/denom == math.floor(numerator/denom)) then\n    return true\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `simplify` that takes two string arguments, `x` and `n`. The function returns a boolean value. \n\nThe first line of the code imports the `math` library. \n\nThe second line defines a function called `simplify` that takes two arguments, `x` and `n`. \n\nThe third line declares two variables, `a` and `b`, and assigns them the values of the numerator and denominator of the `x` argument, respectively. The `match` function is used to extract the numerator and denominator from the `x` argument. \n\nThe fourth line declares two variables, `c` and `d`, and assigns them the values of the numerator and denominator of the `n` argument, respectively. The `match` function is used to extract the numerator and denominator from the `n` argument. \n\nThe fifth line calculates the product of the numerators of `x` and `n` and assigns the result to the `numerator` variable. \n\nThe sixth line calculates the product of the denominators of `x` and `n` and assigns the result to the `denom` variable. \n\nThe seventh line checks if the quotient of the numerator and denominator is an integer. If it is, the function returns `true`. Otherwise, it returns `false`. \n\n\n### Racket version\n\n#lang racket\n\n(define (simplify x n)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solve s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate \"AsDf\") \"aSdF\" 0.001)\n    (check-within (candidate \"1234\") \"4321\" 0.001)\n    (check-within (candidate \"ab\") \"AB\" 0.001)\n    (check-within (candidate \"#a@C\") \"#A@c\" 0.001)\n    (check-within (candidate \"#AsdfW^45\") \"#aSDFw^45\" 0.001)\n    (check-within (candidate \"#6@2\") \"2@6#\" 0.001)\n    (check-within (candidate \"#$a^D\") \"#$A^d\" 0.001)\n    (check-within (candidate \"#ccc\") \"#CCC\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function solve(s)\n    local flg = 0\n    local idx = 1\n    local new_str = {}\n    for i=1, #s do\n        if string.match(s:sub(i,i), '%a') then\n            new_str[idx] = string.match(s:sub(i,i), '%a'):upper() == s:sub(i,i) and string.match(s:sub(i,i), '%a'):lower() or string.match(s:sub(i,i), '%a'):upper()\n            flg = 1\n        else\n            new_str[idx] = s:sub(i,i)\n        end\n        idx = idx + 1\n    end\n    s = table.concat(new_str)\n    if flg == 0 then\n        return s:reverse()\n    end\n    return s\nend\n\n### Explanation\n\nThe code is an implementation of a function called `solve` that takes a string `s` as input and returns a string as output. The function is defined using the `local` keyword, which means that it is only visible within the scope of the block in which it is defined.\n\nThe first line of the function imports the `math` module, which provides mathematical functions and constants.\n\nThe next three lines define three local variables: `flg`, `idx`, and `new_str`. `flg` is initialized to 0, `idx` is initialized to 1, and `new_str` is initialized to an empty table.\n\nThe function then enters a loop that iterates over each character in the input string `s`. The loop is defined using the `for` keyword, which specifies the loop variable (`i`), the start value (`1`), and the end value (`#s`, which is the length of the string `s`).\n\nWithin the loop, the function checks if the current character is a letter using the `string.match` function. If the character is a letter, the function converts it to uppercase or lowercase depending on its current case using the `string.upper` and `string.lower` functions. The converted letter is then added to the `new_str` table at the current index (`idx`), and the `flg` variable is set to 1 to indicate that at least one letter was found in the input string.\n\nIf the current character is not a letter, it is simply added to the `new_str` table at the current index.\n\nAfter the loop completes, the function concatenates the elements of the `new_str` table into a single string using the `table.concat` function and assigns the result to the `s` variable.\n\nIf no letters were found in the input string (`flg` is still 0), the function returns the reversed string `s`. Otherwise, it returns the modified string `s`.\n\n\n### Racket version\n\n#lang racket\n\n(define (solve s)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (right_angle_triangle a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n    (check-within (candidate 3 4 5) #t 0.001)\n    (check-within (candidate 1 2 3) #f 0.001)\n    (check-within (candidate 10 6 8) #t 0.001)\n    (check-within (candidate 2 2 2) #f 0.001)\n    (check-within (candidate 7 24 25) #t 0.001)\n    (check-within (candidate 10 5 7) #f 0.001)\n    (check-within (candidate 5 12 13) #t 0.001)\n    (check-within (candidate 15 8 17) #t 0.001)\n    (check-within (candidate 48 55 73) #t 0.001)\n    (check-within (candidate 1 1 1) #f 0.001)\n    (check-within (candidate 2 2 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function right_angle_triangle(a, b, c)\n  return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a triangle is a right angle triangle or not. The function takes three arguments, the length of each side of the triangle. The function returns true if the triangle is a right angle triangle, and false otherwise.\n\nThe first line of the code imports the math library. This library provides a number of mathematical functions that can be used in Lua programs.\n\nThe second line of the code defines a function called right_angle_triangle. This function takes three arguments, a, b, and c, which represent the length of each side of the triangle. The function returns true if the triangle is a right angle triangle, and false otherwise.\n\nThe function checks whether the triangle is a right angle triangle by using the Pythagorean theorem. The Pythagorean theorem states that in a right angle triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of the squares of the lengths of the other two sides. The function checks whether this is true for each of the three sides of the triangle.\n\nThe function returns true if any of the three sides satisfies the Pythagorean theorem, and false otherwise.\n\n\n### Racket version\n\n#lang racket\n\n(define (right_angle_triangle a b c)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (double_the_difference lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate double_the_difference))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 5.0 4.0)) 25 0.001)\n    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)\n    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)\n    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)\n    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)\n    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function double_the_difference(lst)\n    local sum = 0\n    for _, i in ipairs(lst) do\n        if i > 0 and i%2~=0 and math.floor(i) == i then\n            sum = sum + i^2\n        end\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `double_the_difference` that takes a list of numbers as input and returns the sum of the squares of all odd positive integers in the list.\n\n\n### Racket version\n\n#lang racket\n\n(define (double_the_difference lst)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare_one a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare_one))\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 2.5) 2.5 0.001)\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 5 6) 6 0.001)\n    (check-within (candidate 1 \"2,3\") \"2,3\" 0.001)\n    (check-within (candidate \"5,1\" \"6\") \"6\" 0.001)\n    (check-within (candidate \"1\" \"2\") \"2\" 0.001)\n    (check-within (candidate \"1\" 1) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function compare_one(a, b)\n  local temp_a, temp_b = a, b\n  if type(temp_a) == 'string' then temp_a = temp_a:gsub(',', '.') end\n  if type(temp_b) == 'string' then temp_b = temp_b:gsub(',', '.') end\n  if tonumber(temp_a) == tonumber(temp_b) then return nil end\n  return tonumber(temp_a) > tonumber(temp_b) and a or b\nend\n\n### Explanation\n\nThe code is an implementation of a function `compare_one` that takes two arguments `a` and `b`. The function returns `a` if `a` is greater than `b`, `b` if `b` is greater than `a`, and `nil` if `a` and `b` are equal. The function first checks if either `a` or `b` is a string, and if so, replaces any commas with periods. This is done to ensure that the string can be converted to a number. The function then compares the two numbers and returns the appropriate value. \n\nThe first line of the code imports the `math` module, which provides mathematical functions. The second line defines the `compare_one` function. The `local` keyword is used to define a local variable, which is only accessible within the function. \n\nThe `temp_a` and `temp_b` variables are assigned the values of `a` and `b`, respectively. This is done to avoid modifying the original values of `a` and `b`. \n\nThe `if` statements check if either `temp_a` or `temp_b` is a string. The `type` function is used to determine the type of the variable. If the variable is a string, the `gsub` function is used to replace any commas with periods. This is done because some locales use commas as decimal separators instead of periods. The `tonumber` function is then used to convert the string to a number. If either `temp_a` or `temp_b` cannot be converted to a number, the `tonumber` function returns `nil`. \n\nThe final `if` statement compares the two numbers using the greater than operator (`>`). If `temp_a` is greater than `temp_b`, `a` is returned. If `temp_b` is greater than `temp_a`, `b` is returned. If `temp_a` and `temp_b` are equal, `nil` is returned. \n\n\n### Racket version\n\n#lang racket\n\n(define (compare_one a b)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_zero operations)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_zero))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)\n    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)\n    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function below_zero(operations)\n    local balance = 0\n\n    for _, op in ipairs(operations) do\n        balance = balance + op\n        if balance < 0 then\n            return true\n        end\n    end\n\n    return false\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an array of numbers and returns true if the sum of the numbers in the array is ever negative. Otherwise, it returns false.\n\n`math = require('math')` - This line imports the math library.\n\n`local function below_zero(operations)` - This line defines a function called `below_zero` that takes an array of numbers called `operations`.\n\n`local balance = 0` - This line initializes a variable called `balance` to 0.\n\n`for _, op in ipairs(operations) do` - This line starts a loop that iterates over each element in the `operations` array. The `_` is a placeholder for the index of the current element, which is not used in the loop. The `op` variable is assigned to the current element.\n\n`balance = balance + op` - This line adds the value of `op` to the `balance` variable.\n\n`if balance < 0 then` - This line checks if the `balance` variable is less than 0.\n\n`return true` - This line returns true if the `balance` variable is less than 0.\n\n`end` - This line ends the if statement.\n\n`end` - This line ends the for loop.\n\n`return false` - This line returns false if the `balance` variable is not less than 0. \n\n\n### Racket version\n\n#lang racket\n\n(define (below_zero operations)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (greatest_common_divisor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n    (check-within (candidate 3 7) 1 0.001)\n    (check-within (candidate 10 15) 5 0.001)\n    (check-within (candidate 49 14) 7 0.001)\n    (check-within (candidate 144 60) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function greatest_common_divisor(a, b)\n    while b ~= 0 do\n        a, b = b, a % b\n    end\n    return a\nend\n\n### Explanation\n\nThe code is an implementation of the Euclidean algorithm for finding the greatest common divisor of two integers. \n\nThe first line of the program imports the math library. \n\nThe second line defines a function called `greatest_common_divisor` that takes two arguments, `a` and `b`. \n\nThe `while` loop in the function continues until `b` is equal to zero. In each iteration of the loop, `a` is assigned the value of `b`, and `b` is assigned the remainder of `a` divided by `b`. This process is repeated until `b` is equal to zero. \n\nFinally, the function returns the value of `a`, which is the greatest common divisor of the original values of `a` and `b`. \n\n\n### Racket version\n\n#lang racket\n\n(define (greatest_common_divisor a b)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (f n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate 5) (list 1 2 6 24 15) 0.001)\n    (check-within (candidate 7) (list 1 2 6 24 15 720 28) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n    (check-within (candidate 3) (list 1 2 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function f(n)\n    local ret = {}\n    for i=1,n do\n        if i%2 == 0 then\n            local x = 1\n            for j=1,i do x = x*j end\n            table.insert(ret, x)\n        else\n            local x = 0\n            for j=1,i do x = x+j end\n            table.insert(ret, x)\n        end\n    end\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function `f` that takes a single argument `n` and returns a list of `n` elements. The list contains alternating sums and factorials of integers from 1 to `n`. \n\nThe first line of the code imports the `math` module, which provides mathematical functions and constants. \n\nThe second line defines a local function `f` that takes a single argument `n`. The function returns a list of alternating sums and factorials of integers from 1 to `n`. \n\nThe third line defines a local variable `ret` and initializes it to an empty table. The table will be used to store the alternating sums and factorials. \n\nThe fourth line starts a loop that iterates from 1 to `n`. \n\nThe fifth line checks if the current iteration `i` is even by checking if `i%2 == 0`. If `i` is even, the code enters the `if` block. \n\nThe sixth line defines a local variable `x` and initializes it to 1. \n\nThe seventh line starts a loop that iterates from 1 to `i`. \n\nThe eighth line updates the value of `x` by multiplying it with the current iteration `j`. \n\nThe ninth line inserts the value of `x` into the `ret` table using the `table.insert` function. \n\nIf `i` is odd, the code enters the `else` block. \n\nThe eleventh line defines a local variable `x` and initializes it to 0. \n\nThe twelfth line starts a loop that iterates from 1 to `i`. \n\nThe thirteenth line updates the value of `x` by adding the current iteration `j`. \n\nThe fourteenth line inserts the value of `x` into the `ret` table using the `table.insert` function. \n\nThe loop ends and the fifteenth line returns the `ret` table. \n\n\n### Racket version\n\n#lang racket\n\n(define (f n)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (monotonic l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n    (check-within (candidate (list 1 2 4 10)) #t 0.001)\n    (check-within (candidate (list 1 2 4 20)) #t 0.001)\n    (check-within (candidate (list 1 20 4 10)) #f 0.001)\n    (check-within (candidate (list 4 1 0 -10)) #t 0.001)\n    (check-within (candidate (list 4 1 1 0)) #t 0.001)\n    (check-within (candidate (list 1 2 3 2 5 60)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 60)) #t 0.001)\n    (check-within (candidate (list 9 9 9 9)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function monotonic(l)\n    local is_increasing = true\n    local is_decreasing = true\n\n    for i=2, #l do\n        if l[i] > l[i-1] then\n            is_decreasing = false\n        elseif l[i] < l[i-1] then\n            is_increasing = false\n        end\n    end\n\n    return is_increasing or is_decreasing\nend\n\n### Explanation\n\nThe code is an implementation of a function called `monotonic` that takes a list of numbers as input and returns a boolean value indicating whether the list is monotonic or not. A list is monotonic if it is either entirely non-increasing or entirely non-decreasing.\n\nThe first line of the code imports the `math` module, which provides mathematical functions and constants.\n\nThe second line defines a local function called `monotonic` that takes a single argument `l`, which is expected to be a list of numbers.\n\nThe next two lines define two boolean variables `is_increasing` and `is_decreasing` and initialize them to `true`.\n\nThe `for` loop that follows iterates over the elements of the list `l` from the second element to the last element. For each pair of adjacent elements, the loop checks whether the second element is greater than the first element, in which case it sets `is_decreasing` to `false`. If the second element is less than the first element, it sets `is_increasing` to `false`. If neither of these conditions are met, the loop continues to the next pair of elements.\n\nFinally, the function returns `true` if either `is_increasing` or `is_decreasing` is `true`, indicating that the list is monotonic. Otherwise, it returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (monotonic l)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (by_length arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate by_length))\n    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\") 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -1 55)) (list \"One\") 0.001)\n    (check-within (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\") 0.001)\n    (check-within (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function by_length(arr)\n    local dic = {\n        [1] = \"One\",\n        [2] = \"Two\",\n        [3] = \"Three\",\n        [4] = \"Four\",\n        [5] = \"Five\",\n        [6] = \"Six\",\n        [7] = \"Seven\",\n        [8] = \"Eight\",\n        [9] = \"Nine\",\n    }\n    table.sort(arr, function(a, b) return a > b end)\n    local new_arr = {}\n    for i, var in ipairs(arr) do\n        if dic[var] then\n            table.insert(new_arr, dic[var])\n        end\n    end\n    return new_arr\nend\n\n### Explanation\n\nThe code is an implementation of a function called `by_length`. It takes an array of integers as an input and returns an array of strings. The strings are the English names of the integers in the input array, sorted in descending order by their length.\n\nThe first line of the code imports the `math` module.\n\nThe second line defines a local function called `by_length` that takes an array as an argument.\n\nThe third line creates a dictionary that maps integers to their English names.\n\nThe fourth line sorts the input array in descending order.\n\nThe fifth line creates a new empty array.\n\nThe sixth line iterates over the sorted input array and checks if the integer is in the dictionary. If it is, the corresponding English name is added to the new array.\n\nThe seventh line returns the new array.\n\n\n### Racket version\n\n#lang racket\n\n(define (by_length arr)\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (remove_vowels text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_vowels))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"abcdef\nghijklm\") \"bcdf\nghjklm\" 0.001)\n    (check-within (candidate \"fedcba\") \"fdcb\" 0.001)\n    (check-within (candidate \"eeeee\") \"\" 0.001)\n    (check-within (candidate \"acBAA\") \"cB\" 0.001)\n    (check-within (candidate \"EcBOO\") \"cB\" 0.001)\n    (check-within (candidate \"ybcd\") \"ybcd\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function remove_vowels(text)\n    return text:gsub(\"[aeiouAEIOU]\", \"\")\nend\n\n### Explanation\n\nThe code is an implementation of a function that removes all vowels from a given string. \n\nThe first line imports the math library. This is not used in the function, so it is not necessary.\n\nThe second line defines a function called `remove_vowels` that takes a string as input.\n\nThe third line returns the input string with all vowels removed. The `:gsub` method is called on the input string, which is a string method that replaces all occurrences of a pattern with a replacement string. In this case, the pattern is a regular expression that matches all vowels (both uppercase and lowercase), and the replacement string is an empty string. This effectively removes all vowels from the input string.\n\n\n### Racket version\n\n#lang racket\n\n(define (remove_vowels text)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n    (check-within (candidate \"apple\") #f 0.001)\n    (check-within (candidate \"apple pi e\") #t 0.001)\n    (check-within (candidate \"eeeee\") #f 0.001)\n    (check-within (candidate \"A\") #t 0.001)\n    (check-within (candidate \"Pumpkin pie \") #f 0.001)\n    (check-within (candidate \"Pumpkin pie 1\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"eeeee e \") #f 0.001)\n    (check-within (candidate \"apple pie\") #f 0.001)\n    (check-within (candidate \"apple pi e \") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function check_if_last_char_is_a_letter(txt)\n    local check = txt:match(\"%a%a*$\")\n    return check ~= nil and #check == 1\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if the last character of a string is a letter. \n\nThe first line imports the math library.\n\nThe second line defines a function called `check_if_last_char_is_a_letter` that takes a string as an argument. \n\nThe third line defines a local variable called `check` that is assigned the result of calling the `match` function on the string argument. The `match` function is called with a pattern argument of `%a%a*$`. This pattern matches a sequence of one or more letters at the end of the string. The `$` character matches the end of the string. The `*` character matches zero or more occurrences of the preceding pattern, which in this case is `%a%a`. The `%a` pattern matches any letter.\n\nThe fourth line returns a boolean value indicating whether `check` is not nil and has a length of 1. If `check` is nil, then the function returns false. If `check` has a length greater than 1, then the function returns false. Otherwise, the function returns true.\n\n\n### Racket version\n\n#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (iscube a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate iscube))\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate -1) #t 0.001)\n    (check-within (candidate 64) #t 0.001)\n    (check-within (candidate 180) #f 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 0) #t 0.001)\n    (check-within (candidate 1729) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function iscube(a)\n    a = math.abs(a)\n    return math.floor(a^(1/3) + 0.5)^3 == a\nend\n\n### Explanation\n\nThe code is an implementation of a function `iscube` that returns a boolean indicating whether its input is a perfect cube. The function takes a single argument `a`.\n\nThe first line imports the `math` module.\n\nThe second line defines a local function `iscube` that takes a single argument `a`. The `local` keyword means that the function is only visible within the scope of the current block.\n\nThe third line takes the absolute value of `a` using the `math.abs` function.\n\nThe fourth line calculates the cube root of `a` using the `^(1/3)` operator. The `math.floor` function is then used to round the result down to the nearest integer. The `+ 0.5` is added to ensure that the rounding is done correctly for negative numbers. Finally, the `^3` operator is used to cube the result.\n\nThe fifth line compares the result of the previous line to `a` using the `==` operator. If they are equal, the function returns `true`, indicating that `a` is a perfect cube. Otherwise, the function returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (iscube a)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (mean_absolute_deviation numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mean_absolute_deviation))\n    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function mean_absolute_deviation(numbers)\n    local mean = 0\n    for _, v in ipairs(numbers) do\n        mean = mean + v\n    end\n    mean = mean / #numbers\n    local sum = 0\n    for _, v in ipairs(numbers) do\n        sum = sum + math.abs(v - mean)\n    end\n    return sum / #numbers\nend\n\n### Explanation\n\nThe code is an implementation of a function called `mean_absolute_deviation` that takes a list of numbers and returns the mean absolute deviation of the list. Here is a line by line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (mean_absolute_deviation numbers)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"<>\") #t 0.001)\n    (check-within (candidate \"<<><>>\") #t 0.001)\n    (check-within (candidate \"<><><<><>><>\") #t 0.001)\n    (check-within (candidate \"<><><<<><><>><>><<><><<>>>\") #t 0.001)\n    (check-within (candidate \"<<<><>>>>\") #f 0.001)\n    (check-within (candidate \"><<>\") #f 0.001)\n    (check-within (candidate \"<\") #f 0.001)\n    (check-within (candidate \"<<<<\") #f 0.001)\n    (check-within (candidate \">\") #f 0.001)\n    (check-within (candidate \"<<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>><<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>>><>\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for b in brackets:gmatch(\".\") do\n        if b == \"<\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThe code is an implementation of a function called `correct_bracketing` that takes a string of brackets and returns true if the brackets are balanced, and false otherwise. \n\nThe function starts by importing the `math` module, which is not used in the rest of the code. \n\nThe function then defines a local function called `correct_bracketing` that takes a single argument called `brackets`. The function initializes a variable called `depth` to 0. \n\nThe function then iterates over each character in the `brackets` string using the `gmatch` method. For each character, the function checks if it is an opening bracket (`<`). If it is, the `depth` variable is incremented by 1. If it is a closing bracket (`>`), the `depth` variable is decremented by 1. \n\nIf the `depth` variable ever becomes negative, it means that there is a closing bracket without a corresponding opening bracket, so the function returns false. Otherwise, the function continues iterating over the string. \n\nAfter the loop, the function checks if the `depth` variable is equal to 0. If it is, it means that all opening brackets have a corresponding closing bracket, so the function returns true. Otherwise, it means that there are more opening brackets than closing brackets, so the function returns false.\n\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rescale_to_unit numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)\n    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)\n    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function rescale_to_unit(numbers)\n    local min_number = math.min(table.unpack(numbers))\n    local max_number = math.max(table.unpack(numbers))\n    local result = {}\n    for i, x in ipairs(numbers) do\n        result[i] = (x - min_number) / (max_number - min_number)\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that rescales a list of numbers to the unit interval [0, 1]. \n\nThe function takes a list of numbers as input. \n\nThe first line of the function imports the math library. \n\nThe second line of the function defines a local function called `rescale_to_unit` that takes a list of numbers as input. \n\nThe third line of the function defines a variable `min_number` that is assigned the minimum number in the input list using the `math.min` function. \n\nThe fourth line of the function defines a variable `max_number` that is assigned the maximum number in the input list using the `math.max` function. \n\nThe fifth line of the function defines an empty list called `result`. \n\nThe sixth line of the function starts a loop that iterates over the input list using the `ipairs` function. \n\nThe seventh line of the function rescales each number in the input list to the unit interval [0, 1] using the formula `(x - min_number) / (max_number - min_number)` and stores the result in the `result` list. \n\nThe eighth line of the function returns the `result` list. \n\n\n### Racket version\n\n#lang racket\n\n(define (rescale_to_unit numbers)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersection interval1 interval2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersection))\n    (check-within (candidate (list 1 2) (list 2 3)) \"NO\" 0.001)\n    (check-within (candidate (list -1 1) (list 0 4)) \"NO\" 0.001)\n    (check-within (candidate (list -3 -1) (list -5 5)) \"YES\" 0.001)\n    (check-within (candidate (list -2 2) (list -4 0)) \"YES\" 0.001)\n    (check-within (candidate (list -11 2) (list -1 -1)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 3 5)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 1 2)) \"NO\" 0.001)\n    (check-within (candidate (list -2 -2) (list -3 -2)) \"NO\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function intersection(interval1, interval2)\n    local function is_prime(num)\n        if num == 1 or num == 0 then\n            return false\n        end\n        if num == 2 then\n            return true\n        end\n        for i=2,num-1 do\n            if num%i == 0 then\n                return false\n            end\n        end\n        return true\n    end\n\n    local l = math.max(interval1[1], interval2[1])\n    local r = math.min(interval1[2], interval2[2])\n    local length = r - l\n    if length > 0 and is_prime(length) then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThe code is an implementation of a function called `intersection` that takes two intervals as input and returns \"YES\" if the length of the intersection between the two intervals is a prime number, and \"NO\" otherwise.\n\nThe first line of the code imports the `math` library, which provides mathematical functions.\n\nThe second line defines a local function called `intersection` that takes two intervals as input. The `local` keyword means that the function is only accessible within the scope of the block it is defined in.\n\nThe `is_prime` function is defined inside the `intersection` function. It takes a number as input and returns `true` if the number is prime, and `false` otherwise. The function first checks if the number is 1 or 0, in which case it returns `false`. It then checks if the number is 2, in which case it returns `true`. Finally, it checks if the number is divisible by any number between 2 and itself minus 1. If it is, it returns `false`. Otherwise, it returns `true`.\n\nThe next three lines of the `intersection` function calculate the left endpoint of the intersection, the right endpoint of the intersection, and the length of the intersection, respectively. The left endpoint is the maximum of the left endpoints of the two intervals, and the right endpoint is the minimum of the right endpoints of the two intervals. The length is simply the difference between the two endpoints.\n\nThe next line checks if the length of the intersection is greater than 0 and is a prime number. If it is, the function returns \"YES\". Otherwise, it returns \"NO\".<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (intersection interval1 interval2)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (hex_key num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n    (check-within (candidate \"AB\") 1 0.001)\n    (check-within (candidate \"1077E\") 2 0.001)\n    (check-within (candidate \"ABED1A33\") 4 0.001)\n    (check-within (candidate \"2020\") 2 0.001)\n    (check-within (candidate \"123456789ABCDEF0\") 6 0.001)\n    (check-within (candidate \"112233445566778899AABBCCDDEEFF00\") 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function hex_key(num)\n    local primes = {'2', '3', '5', '7', 'B', 'D'}\n    local total = 0\n    for i = 1, #num do\n        if table.concat(primes):find(num:sub(i, i)) then\n            total = total + 1\n        end\n    end\n    return total\nend\n\n### Explanation\n\nThe code is an implementation of a function `hex_key` that takes a string `num` and returns an integer. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the current block of code.\n\nThe first line of the function imports the `math` library, which provides a set of mathematical functions that can be used in the program.\n\nThe second line of the function defines a local variable `primes` as an array of strings containing the hexadecimal values of the prime numbers 2, 3, 5, 7, 11, and 13.\n\nThe third line of the function initializes a local variable `total` to 0.\n\nThe fourth line of the function starts a loop that iterates over the characters of the string `num`. The loop is defined using the `for` keyword, which takes three arguments: the loop variable `i`, the starting value of `i`, and the ending value of `i`. In this case, the loop variable `i` is initialized to 1, and the ending value of `i` is the length of the string `num`.\n\nThe fifth line of the function checks if the current character of `num` is one of the prime numbers in the `primes` array. This is done using the `find` method of the string returned by `table.concat(primes)`, which concatenates all the strings in the `primes` array into a single string. If the character is found, the `total` variable is incremented by 1.\n\nThe sixth line of the function returns the final value of `total`.\n\n\n### Racket version\n\n#lang racket\n\n(define (hex_key num)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strange_sort_list lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n    (check-within (candidate (list 1 2 3 4)) (list 1 4 2 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7) 0.001)\n    (check-within (candidate (list 5 5 5 5)) (list 5 5 5 5) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5) 0.001)\n    (check-within (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2) 0.001)\n    (check-within (candidate (list 111111)) (list 111111) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function strange_sort_list(lst)\n    local res, switch = {}, true\n    while #lst > 0 do\n        if switch then\n            table.insert(res, math.min(table.unpack(lst)))\n        else\n            table.insert(res, math.max(table.unpack(lst)))\n        end\n        local index = 0\n        for i, v in ipairs(lst) do\n            if v == res[#res] then\n                index = i\n                break\n            end\n        end\n        table.remove(lst, index)\n        switch = not switch\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a sorting algorithm that sorts a list of numbers in a strange way. The function `strange_sort_list` takes a list of numbers as input and returns a new list that is sorted in a strange way. \n\nThe first line of the code imports the `math` module, which provides mathematical functions for Lua.\n\nThe second line defines a function called `strange_sort_list` that takes a list of numbers as input. The function creates two empty tables, `res` and `switch`. The `res` table will hold the sorted list, and the `switch` table is used to alternate between finding the minimum and maximum values in the input list.\n\nThe `while` loop runs as long as there are still elements in the input list. The `if` statement checks the value of `switch`. If `switch` is true, the minimum value in the input list is found using the `math.min` function and added to the `res` table using `table.insert`. If `switch` is false, the maximum value in the input list is found using the `math.max` function and added to the `res` table using `table.insert`.\n\nThe `for` loop iterates over the input list and finds the index of the element that was just added to the `res` table. This is done so that the element can be removed from the input list using `table.remove`.\n\nFinally, the `switch` variable is toggled using the `not` operator, so that the next iteration of the loop will find the opposite extreme value (minimum or maximum).\n\nThe `res` table is returned at the end of the function, which contains the sorted list of numbers.\n\n\n### Racket version\n\n#lang racket\n\n(define (strange_sort_list lst)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (all_prefixes string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate all_prefixes))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"asdfgh\") (list \"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\") 0.001)\n    (check-within (candidate \"WWW\") (list \"W\" \"WW\" \"WWW\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function all_prefixes(string)\n    local result = {}\n\n    for i=1, #string do\n        table.insert(result, string:sub(1, i))\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function `all_prefixes` that takes a string as input and returns a list of all the prefixes of the string. A prefix is a substring that starts at the beginning of the string and includes all the characters up to a certain index. For example, the string \"hello\" has the following prefixes: \"h\", \"he\", \"hel\", \"hell\", and \"hello\".\n\nThe first line of the code imports the math library, which provides mathematical functions that can be used in the program.\n\nThe second line defines a function called `all_prefixes` that takes a single argument, `string`. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the current block of code.\n\nThe third line creates an empty table called `result`, which will be used to store the prefixes of the string.\n\nThe fourth line starts a loop that will iterate over the indices of the string from 1 to the length of the string. The `#` operator is used to get the length of the string.\n\nThe fifth line uses the `table.insert` function to add the prefix of the string up to the current index to the `result` table. The `string:sub` function is used to get the substring of the string from the beginning up to the current index.\n\nThe sixth line returns the `result` table, which contains all the prefixes of the string.\n\n\n### Racket version\n\n#lang racket\n\n(define (all_prefixes string)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (how_many_times string substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n    (check-within (candidate \"\" \"x\") 0 0.001)\n    (check-within (candidate \"xyxyxyx\" \"x\") 4 0.001)\n    (check-within (candidate \"cacacacac\" \"cac\") 4 0.001)\n    (check-within (candidate \"john doe\" \"john\") 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function how_many_times(string, substring)\n  local times = 0\n  for i = 1, #string - #substring + 1 do\n    if string:sub(i, i + #substring - 1) == substring then\n      times = times + 1\n    end\n  end\n  return times\nend\n\n### Explanation\n\nThe code is an implementation of a function `how_many_times` that takes two string arguments `string` and `substring` and returns the number of times `substring` appears in `string`.\n\n\n### Racket version\n\n#lang racket\n\n(define (how_many_times string substring)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solution lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solution))\n    (check-within (candidate (list 5 8 7 1)) 12 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 9 0.001)\n    (check-within (candidate (list 30 13 24 321)) 0 0.001)\n    (check-within (candidate (list 5 9)) 5 0.001)\n    (check-within (candidate (list 2 4 8)) 0 0.001)\n    (check-within (candidate (list 30 13 23 32)) 23 0.001)\n    (check-within (candidate (list 3 13 2 9)) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function solution(lst)\n  local sum = 0\n  for idx, x in ipairs(lst) do\n    if idx%2==1 and x%2==1 then\n      sum = sum + x\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of integers and returns the sum of all the odd integers at odd positions in the list. Here is a line-by-line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (solution lst)\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_sorted lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_sorted))\n    (check-within (candidate (list 5)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 7)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n    (check-within (candidate (list 1)) #t 0.001)\n    (check-within (candidate (list 3 2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 2 2 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 3 3 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 2 3 3 4)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if a list is sorted and has no more than two of the same element. The function is called `is_sorted` and takes a single argument `lst`.\n\nThe first line of the function imports the `math` module.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_sorted lst)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (search lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate search))\n    (check-within (candidate (list 5 5 5 5 1)) 1 0.001)\n    (check-within (candidate (list 4 1 4 1 4 4)) 4 0.001)\n    (check-within (candidate (list 3 3)) -1 0.001)\n    (check-within (candidate (list 8 8 8 8 8 8 8 8)) 8 0.001)\n    (check-within (candidate (list 2 3 3 2 2)) 2 0.001)\n    (check-within (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1 0.001)\n    (check-within (candidate (list 3 2 8 2)) 2 0.001)\n    (check-within (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1 0.001)\n    (check-within (candidate (list 8 8 3 6 5 6 4)) -1 0.001)\n    (check-within (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1 0.001)\n    (check-within (candidate (list 1 9 10 1 3)) 1 0.001)\n    (check-within (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n    (check-within (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4 0.001)\n    (check-within (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2 0.001)\n    (check-within (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1 0.001)\n    (check-within (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4 0.001)\n    (check-within (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4 0.001)\n    (check-within (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2 0.001)\n    (check-within (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1 0.001)\n    (check-within (candidate (list 10)) -1 0.001)\n    (check-within (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2 0.001)\n    (check-within (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1 0.001)\n    (check-within (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1 0.001)\n    (check-within (candidate (list 3 10 10 9 2)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function search(lst)\n    local frq = {}\n    for i=1, math.max(table.unpack(lst)) do\n        frq[i] = 0\n    end\n    for i=1, #lst do\n        frq[lst[i]] = frq[lst[i]] + 1\n    end\n\n    local ans = -1\n    for i=1, #frq do\n        if frq[i] >= i then\n            ans = i\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function `search` that takes a list of integers and returns the smallest integer that appears at least as many times as itself in the list. If no such integer exists, the function returns -1.\n\n\n### Racket version\n\n#lang racket\n\n(define (search lst)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pluck arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n    (check-within (candidate (list 4 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5 0 3 0 4 2)) (list 0 1) 0.001)\n    (check-within (candidate (list 1 2 3 0 5 3)) (list 0 3) 0.001)\n    (check-within (candidate (list 5 4 8 4 8)) (list 4 1) 0.001)\n    (check-within (candidate (list 7 6 7 1)) (list 6 1) 0.001)\n    (check-within (candidate (list 7 9 7 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function pluck(arr)\n    if(#arr == 0) then return {} end\n    local evens = {}\n    for _, v in ipairs(arr) do\n        if(v%2 == 0) then table.insert(evens, v) end\n    end\n    if(#evens == 0) then return {} end\n    local min_val = math.min(table.unpack(evens))\n    for i, v in ipairs(arr) do\n        if(v == min_val) then return {min_val, i-1} end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `pluck` that takes an array of integers and returns an array with the minimum even integer in the input array and its index. If there are no even integers in the input array, the function returns an empty array.\n\n\n### Racket version\n\n#lang racket\n\n(define (pluck arr)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pairs_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 30)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 31)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 30)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 31)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function pairs_sum_to_zero(l)\n  for i, l1 in ipairs(l) do\n    for j = i + 1, #l do\n      if l1 + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `pairs_sum_to_zero` that takes a list of numbers as input and returns a boolean indicating whether there are any two numbers in the list that sum to zero.\n\nThe first line of the code imports the `math` module, which provides a number of mathematical functions that can be used in the program.\n\nThe second line of the code defines a function called `pairs_sum_to_zero` that takes a single argument `l`, which is a list of numbers.\n\nThe function then iterates over the list using a nested loop. The outer loop iterates over the list using the `ipairs` function, which returns an iterator that iterates over the list in order. The inner loop iterates over the remaining elements of the list, starting from the element after the current element of the outer loop.\n\nFor each pair of elements, the function checks whether their sum is equal to zero. If it is, the function returns `true`. If no pair of elements sums to zero, the function returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (pairs_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_palindrome string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"xyz\") \"xyzyx\" 0.001)\n    (check-within (candidate \"xyx\") \"xyx\" 0.001)\n    (check-within (candidate \"jerry\") \"jerryrrej\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function make_palindrome(string)\n    if not string then\n        return ''\n    end\n\n    local beginning_of_suffix = 0\n\n    while string:sub(beginning_of_suffix+1) ~= string:sub(beginning_of_suffix+1):reverse() do\n        beginning_of_suffix = beginning_of_suffix + 1\n    end\n\n    return string .. string:sub(1, beginning_of_suffix):reverse()\nend\n\n### Explanation\n\nThe code is an implementation of a function called `make_palindrome` that takes a string as an argument and returns a palindrome. \n\nThe first line of the code imports the `math` module. \n\nThe second line defines a function called `make_palindrome` that takes a string as an argument. \n\nThe third line checks if the string is nil. If it is, the function returns an empty string. \n\nThe fourth line initializes a variable called `beginning_of_suffix` to 0. \n\nThe fifth line starts a while loop that continues until the substring of the string starting from `beginning_of_suffix+1` is equal to the reverse of the same substring. \n\nThe sixth line increments `beginning_of_suffix` by 1. \n\nThe seventh line concatenates the original string with a substring of the original string that starts from the beginning and ends at `beginning_of_suffix` (inclusive), and then reverses that substring. This creates a palindrome. \n\nThe function then returns the palindrome. \n\n\n### Racket version\n\n#lang racket\n\n(define (make_palindrome string)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (starts_one_ends n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 2) 18 0.001)\n    (check-within (candidate 3) 180 0.001)\n    (check-within (candidate 4) 1800 0.001)\n    (check-within (candidate 5) 18000 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function starts_one_ends(n)\n  if n == 1 then return 1 end\n  return 18 * (10 ^ (n - 2))\nend\n\n### Explanation\n\nThe code is an implementation of a function called `starts_one_ends` that takes an integer `n` and returns a number. The function is defined using the `local` keyword, which means that it is only available within the scope of the block it is defined in.\n\nThe first line of the function checks if the input `n` is equal to 1. If it is, the function returns 1. Otherwise, it proceeds to the next line.\n\nThe second line of the function calculates the value to return if `n` is not equal to 1. It does this by multiplying 18 by 10 raised to the power of `n - 2`. The `^` operator is used to raise a number to a power in Lua.\n\nThe `math` module is imported at the beginning of the program using the `require` function. This module provides a set of mathematical functions that can be used in Lua programs. However, it is not actually used in the `starts_one_ends` function.\n\n\n### Racket version\n\n#lang racket\n\n(define (starts_one_ends n)\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_positive l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)\n    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)\n    (check-within (candidate (list -1 -2)) (list ) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_positive(l)\n  local res = {}\n  for _, e in ipairs(l) do\n    if e > 0 then\n      table.insert(res, e)\n    end\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function called `get_positive` which takes a list of numbers and returns a new list containing only the positive numbers.\n\n\n### Racket version\n\n#lang racket\n\n(define (get_positive l)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (concatenate strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate concatenate))\n    (check-within (candidate (list )) \"\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"xyz\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\" \"w\" \"k\")) \"xyzwk\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function concatenate(strings)\n  return table.concat(strings)\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_nested string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n    (check-within (candidate \"[[]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]][[[[[]\") #f 0.001)\n    (check-within (candidate \"[][]\") #f 0.001)\n    (check-within (candidate \"[]\") #f 0.001)\n    (check-within (candidate \"[[[[]]]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]]]]]\") #f 0.001)\n    (check-within (candidate \"[][][[]]\") #t 0.001)\n    (check-within (candidate \"[[]\") #f 0.001)\n    (check-within (candidate \"[]]\") #f 0.001)\n    (check-within (candidate \"[[]][[\") #t 0.001)\n    (check-within (candidate \"[[][]]\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"[[[[[[[[\") #f 0.001)\n    (check-within (candidate \"]]]]]]]]\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_nested(string)\n    local opening_bracket_index = {}\n    local closing_bracket_index = {}\n    for i=1, #string do\n        if string:sub(i,i) == '[' then\n            table.insert(opening_bracket_index, i)\n        else\n            table.insert(closing_bracket_index, i)\n        end\n    end\n    table.sort(closing_bracket_index, function(a,b) return a>b end)\n    local cnt = 0\n    local i = 1\n    local l = #closing_bracket_index\n    for _, idx in ipairs(opening_bracket_index) do\n        if i <= l and idx < closing_bracket_index[i] then\n            cnt = cnt + 1\n            i = i + 1\n        end\n    end\n    return cnt >= 2\nend\n\n### Explanation\n\nThe code is an implementation of a function called `is_nested` which takes a string as input and returns a boolean value indicating whether the string contains at least two nested square brackets.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_nested string)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_palindrome text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n    (check-within (candidate \"\") #t 0.001)\n    (check-within (candidate \"aba\") #t 0.001)\n    (check-within (candidate \"aaaaa\") #t 0.001)\n    (check-within (candidate \"zbcd\") #f 0.001)\n    (check-within (candidate \"xywyx\") #t 0.001)\n    (check-within (candidate \"xywyz\") #f 0.001)\n    (check-within (candidate \"xywzx\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_palindrome(text)\n    for i=1, #text do\n        if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_palindrome` that checks if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\nThe function takes a single argument `text`, which is the string to check. It returns `true` if the string is a palindrome, and `false` otherwise.\n\nThe function works by iterating over the string, comparing the first and last characters, then the second and second-to-last characters, and so on. If any of these pairs of characters do not match, the function returns `false`. If all pairs of characters match, the function returns `true`.\n\nHere is a line-by-line breakdown of the code:\n\n1. `math = require('math')`: This line imports the `math` module, which provides mathematical functions and constants. However, this module is not used in the rest of the code, so this line is unnecessary.\n2. `local function is_palindrome(text)`: This line defines a local function named `is_palindrome`, which takes a single argument `text`.\n3. `for i=1, #text do`: This line starts a loop that iterates over the characters in the string `text`. The loop variable `i` starts at 1 and goes up to the length of the string `text`.\n4. `if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then`: This line checks if the `i`th character of `text` is not equal to the `i`th character from the end of the string. The `text:sub(i, i)` syntax is used to get the `i`th character of the string, and `text:sub(#text - i + 1, #text - i + 1)` is used to get the `i`th character from the end of the string. If these characters are not equal, the function returns `false`.\n5. `return true`: This line is reached if the loop completes without finding any non-matching characters. In this case, the function returns `true`.\n6. `end`: This line ends the loop.\n7. `return false`: This line is reached if the loop finds a non-matching pair of characters. In this case, the function returns `false`.\n\n\n### Racket version\n\n#lang racket\n\n(define (is_palindrome text)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (factorize n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate factorize))\n    (check-within (candidate 2) (list 2) 0.001)\n    (check-within (candidate 4) (list 2 2) 0.001)\n    (check-within (candidate 8) (list 2 2 2) 0.001)\n    (check-within (candidate 57) (list 3 19) 0.001)\n    (check-within (candidate 3249) (list 3 3 19 19) 0.001)\n    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)\n    (check-within (candidate 20577) (list 3 19 19 19) 0.001)\n    (check-within (candidate 18) (list 2 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function factorize(n)\n    local fact = {}\n    local i = 2\n    while i <= math.sqrt(n) + 1 do\n        if n % i == 0 then\n            table.insert(fact, i)\n            n = n / i\n        else\n            i = i + 1\n        end\n    end\n    if n > 1 then\n        table.insert(fact, n)\n    end\n    return fact\nend\n\n### Explanation\n\nThe code is an implementation of a prime factorization algorithm. Given a number `n`, it returns a list of all its prime factors.\n\n\n### Racket version\n\n#lang racket\n\n(define (factorize n)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_prime_factor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n    (check-within (candidate 15) 5 0.001)\n    (check-within (candidate 27) 3 0.001)\n    (check-within (candidate 63) 7 0.001)\n    (check-within (candidate 330) 11 0.001)\n    (check-within (candidate 13195) 29 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function largest_prime_factor(n)\n  local function is_prime(k)\n    if k < 2 then\n      return false\n    end\n    for i = 2, k - 1 do\n      if k % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local largest = 1\n  for j = 2, n + 1 do\n    if n % j == 0 and is_prime(j) then\n      largest = math.max(largest, j)\n    end\n  end\n  return largest\nend\n\n### Explanation\n\nThe code is an implementation of a function that finds the largest prime factor of a given number. Here is a line-by-line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (largest_prime_factor n)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_max_triples n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 10) 36 0.001)\n    (check-within (candidate 100) 53361 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_max_triples(n)\n  local A = {}\n  for i=1,n do\n    A[i] = i*i - i + 1\n  end\n  local ans = {}\n  for i=1,n do\n    for j=i+1,n do\n      for k=j+1,n do\n        if (A[i]+A[j]+A[k])%3 == 0 then\n          table.insert(ans, {A[i],A[j],A[k]})\n        end\n      end\n    end\n  end\n  return #ans\nend\n\n### Explanation\n\nThe code is an implementation of a function `get_max_triples(n)` that returns the number of triples of integers (a,b,c) such that a^2 - a + 1 + b^2 - b + 1 + c^2 - c + 1 is divisible by 3. The function takes an integer n as input and returns an integer.\n\n\n### Racket version\n\n#lang racket\n\n(define (get_max_triples n)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (anti_shuffle s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate anti_shuffle))\n    (check-within (candidate \"Hi\") \"Hi\" 0.001)\n    (check-within (candidate \"hello\") \"ehllo\" 0.001)\n    (check-within (candidate \"number\") \"bemnru\" 0.001)\n    (check-within (candidate \"abcd\") \"abcd\" 0.001)\n    (check-within (candidate \"Hello World!!!\") \"Hello !!!Wdlor\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst .Rboot How aer ?ouy\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function anti_shuffle(s)\n    local t = {}\n    for i in s:gmatch('%S+') do\n        local u = {}\n        for j = 1, #i do\n            u[j] = i:sub(j, j)\n        end\n        table.sort(u)\n        t[#t + 1] = table.concat(u)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of a function called `anti_shuffle` that takes a string `s` as input and returns a string. The function sorts the characters in each word of the input string in alphabetical order and returns the resulting string.\n\n\n### Racket version\n\n#lang racket\n\n(define (anti_shuffle s)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minPath grid k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minPath))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)\n    (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)\n    (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)\n    (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)\n    (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)\n    (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)\n    (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function minPath(grid, k)\n    local n = #grid\n    local val = n * n + 1\n    for i = 1, n do\n        for j = 1, n do\n            if grid[i][j] == 1 then\n                local temp = {}\n                if i ~= 1 then\n                    table.insert(temp, grid[i-1][j])\n                end\n\n                if j ~= 1 then\n                    table.insert(temp, grid[i][j-1])\n                end\n\n                if i ~= n then\n                    table.insert(temp, grid[i+1][j])\n                end\n\n                if j ~= n then\n                    table.insert(temp, grid[i][j+1])\n                end\n\n                val = math.min(table.unpack(temp))\n            end\n        end\n    end\n\n    local ans = {}\n    for i = 1, k do\n        if i % 2 == 1 then\n            table.insert(ans, 1)\n        else\n            table.insert(ans, val)\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function `minPath` that takes two arguments: a 2D grid of integers `grid` and an integer `k`. The function returns a list of `k` integers. The function finds the minimum path of the grid and returns a list of `k` integers where every odd index is 1 and every even index is the minimum path.\n\n\n### Racket version\n\n#lang racket\n\n(define (minPath grid k)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encrypt s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n    (check-within (candidate \"hi\") \"lm\" 0.001)\n    (check-within (candidate \"asdfghjkl\") \"ewhjklnop\" 0.001)\n    (check-within (candidate \"gf\") \"kj\" 0.001)\n    (check-within (candidate \"et\") \"ix\" 0.001)\n    (check-within (candidate \"faewfawefaewg\") \"jeiajeaijeiak\" 0.001)\n    (check-within (candidate \"hellomyfriend\") \"lippsqcjvmirh\" 0.001)\n    (check-within (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" 0.001)\n    (check-within (candidate \"a\") \"e\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function encrypt(s)\n    local d = 'abcdefghijklmnopqrstuvwxyz'\n    local out = ''\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if d:find(c) then\n            out = out .. d:sub((d:find(c) + 2*2 - 1) % 26 + 1, (d:find(c) + 2*2 - 1) % 26 + 1)\n        else\n            out = out .. c\n        end\n    end\n    return out\nend\n\n### Explanation\n\nThe code is an implementation of a simple encryption algorithm. The algorithm takes a string as input and returns a string as output. The encryption is done by shifting each letter in the input string two positions to the right in the alphabet. If a letter is shifted past the end of the alphabet, it wraps around to the beginning of the alphabet.\n\nThe first line of the code imports the math library.\n\nThe second line defines a function called `encrypt` that takes a string as input and returns a string as output.\n\nThe third line defines a string `d` that contains all the lowercase letters of the alphabet.\n\nThe fourth line defines an empty string `out` that will be used to store the encrypted output.\n\nThe fifth line starts a loop that iterates over each character in the input string.\n\nThe sixth line extracts the i-th character from the input string and stores it in the variable `c`.\n\nThe seventh line checks if the character `c` is a lowercase letter of the alphabet. If it is, the eighth line computes the index of the letter in the string `d` and applies the encryption by adding 2*2 to the index, wrapping around if necessary, and then extracting the corresponding letter from `d`. The result is appended to the output string `out`. If the character `c` is not a lowercase letter of the alphabet, the ninth line simply appends it to the output string `out`.\n\nThe tenth line returns the encrypted output string `out`.\n\n\n### Racket version\n\n#lang racket\n\n(define (encrypt s)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_a_pile n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_a_pile))\n    (check-within (candidate 3) (list 3 5 7) 0.001)\n    (check-within (candidate 4) (list 4 6 8 10) 0.001)\n    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)\n    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)\n    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function make_a_pile(n)\n  local pile = {}\n  for i = 0, n-1 do\n    pile[i+1] = n + 2*i\n  end\n  return pile\nend\n\n### Explanation\n\nThe code is an implementation of a function that creates a pile of stones for a game. The pile is created by taking a number `n` and generating `n` stones, with each stone being `n + 2i` where `i` is the index of the stone. \n\n\n### Racket version\n\n#lang racket\n\n(define (make_a_pile n)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_prime n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 101) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 13441) #t 0.001)\n    (check-within (candidate 61) #t 0.001)\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 1) #f 0.001)\n    (check-within (candidate 5) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 17) #t 0.001)\n    (check-within (candidate 85) #f 0.001)\n    (check-within (candidate 77) #f 0.001)\n    (check-within (candidate 255379) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_prime(n)\n    if n < 2 then\n        return false\n    end\n    for k=2, n-1 do\n        if n % k == 0 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a given number is prime or not. \n\nThe first line imports the math library. \n\nThe second line defines a function called `is_prime` that takes a single argument `n`. \n\nThe third line checks if `n` is less than 2. If it is, then the function returns `false` because 1 is not a prime number. \n\nThe fourth line starts a loop that iterates from 2 to `n-1`. \n\nThe fifth line checks if `n` is divisible by the current value of `k`. If it is, then the function returns `false` because `n` is not a prime number. \n\nThe sixth line returns `true` if the loop completes without finding a factor of `n`. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_prime n)\n"
  }
]