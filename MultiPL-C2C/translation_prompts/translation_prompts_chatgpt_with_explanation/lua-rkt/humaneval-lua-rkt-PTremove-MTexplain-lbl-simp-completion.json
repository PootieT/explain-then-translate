[
  {
    "name": "HumanEval_61_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_61_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"()\") #t 0.001)\n    (check-within (candidate \"(()())\") #t 0.001)\n    (check-within (candidate \"()()(()())()\") #t 0.001)\n    (check-within (candidate \"()()((()()())())(()()(()))\") #t 0.001)\n    (check-within (candidate \"((()())))\") #f 0.001)\n    (check-within (candidate \")(()\") #f 0.001)\n    (check-within (candidate \"(\") #f 0.001)\n    (check-within (candidate \"((((\") #f 0.001)\n    (check-within (candidate \")\") #f 0.001)\n    (check-within (candidate \"(()\") #f 0.001)\n    (check-within (candidate \"()()(()())())(()\") #f 0.001)\n    (check-within (candidate \"()()(()())()))()\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for i=1, #brackets do\n        if brackets:sub(i,i) == \"(\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThe code is an implementation of a function called `correct_bracketing` that takes a string of brackets and returns a boolean indicating whether the brackets are correctly balanced. \n\nThe first line of the code imports the math library. \n\nThe second line defines a function called `correct_bracketing` that takes a single argument called `brackets`. \n\nThe third line initializes a variable called `depth` to 0. \n\nThe fourth line starts a for loop that iterates over the indices of the string `brackets`. \n\nThe fifth line checks whether the character at the current index of `brackets` is an opening bracket (i.e., a left parenthesis). If it is, the `depth` variable is incremented by 1. \n\nThe sixth line checks whether the character at the current index of `brackets` is a closing bracket (i.e., a right parenthesis). If it is, the `depth` variable is decremented by 1. \n\nThe seventh line checks whether the `depth` variable is negative. If it is, the function returns `false`, indicating that the brackets are not correctly balanced. \n\nThe eighth line checks whether the `depth` variable is 0. If it is, the function returns `true`, indicating that the brackets are correctly balanced. \n\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_45_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a h)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_45_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 5 3) 7.5 0.001)\n    (check-within (candidate 2 2) 2.0 0.001)\n    (check-within (candidate 10 8) 40.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, h)\n    return a * h / 2\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates the area of a triangle given the base and height. \n\nThe first line of the code imports the math library, which provides a set of mathematical functions. \n\nThe second line of the code defines a function called `triangle_area` that takes two arguments, `a` and `h`. The function calculates the area of a triangle using the formula `a * h / 2` and returns the result. \n\nThe `local` keyword before the function definition limits the scope of the function to the current block of code. This means that the function can only be accessed within the current file or block of code. \n\nOverall, the code is a simple implementation of a mathematical formula in Lua. \n\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a h)\n"
  },
  {
    "name": "HumanEval_139_special_factorial",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (special_factorial n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_139_special_factorial.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate special_factorial))\n    (check-within (candidate 4) 288 0.001)\n    (check-within (candidate 5) 34560 0.001)\n    (check-within (candidate 7) 125411328000 0.001)\n    (check-within (candidate 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function special_factorial(n)\n  local fact_i = 1\n  local special_fact = 1\n  for i=1, n do\n    fact_i = fact_i * i\n    special_fact = special_fact * fact_i\n  end\n  return special_fact\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates a special factorial of a given number. The special factorial is defined as the product of factorials of all numbers from 1 to n. \n\n1. `math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions and constants. \n\n2. `local function special_factorial(n)` - This line declares a function called `special_factorial` that takes a single argument `n`. The `local` keyword means that the function is only accessible within the current scope. \n\n3. `local fact_i = 1` - This line declares a local variable `fact_i` and initializes it to 1. \n\n4. `local special_fact = 1` - This line declares a local variable `special_fact` and initializes it to 1. \n\n5. `for i=1, n do` - This line starts a loop that iterates from 1 to `n`. \n\n6. `fact_i = fact_i * i` - This line multiplies `fact_i` by `i` and assigns the result back to `fact_i`. \n\n7. `special_fact = special_fact * fact_i` - This line multiplies `special_fact` by `fact_i` and assigns the result back to `special_fact`. \n\n8. `end` - This line marks the end of the loop. \n\n9. `return special_fact` - This line returns the value of `special_fact` as the result of the function. \n\n\n### Racket version\n\n#lang racket\n\n(define (special_factorial n)\n"
  },
  {
    "name": "HumanEval_109_move_one_ball",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (move_one_ball arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_109_move_one_ball.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate move_one_ball))\n    (check-within (candidate (list 3 4 5 1 2)) #t 0.001)\n    (check-within (candidate (list 3 5 10 1 2)) #t 0.001)\n    (check-within (candidate (list 4 3 1 2)) #f 0.001)\n    (check-within (candidate (list 3 5 4 1 2)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function move_one_ball(arr)\n  if #arr==0 then\n    return true\n  end\n  local sorted_array = {}\n  for i=1,#arr do\n    sorted_array[i]=arr[i]\n  end\n  table.sort(sorted_array)\n  local my_arr = {}\n  local min_value = math.min(table.unpack(arr))\n  local min_index = 1\n  for i=1,#arr do\n    if arr[i]==min_value then\n      min_index = i\n      break\n    end\n  end\n  for i=min_index,#arr do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,min_index-1 do\n    my_arr[#my_arr+1]=arr[i]\n  end\n  for i=1,#arr do\n    if my_arr[i]~=sorted_array[i] then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `move_one_ball` that takes an array of integers as input and returns a boolean value. The function checks if it is possible to move one ball from one position in the array to another such that the resulting array is sorted in ascending order. \n\n\n### Racket version\n\n#lang racket\n\n(define (move_one_ball arr)\n"
  },
  {
    "name": "HumanEval_131_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digits n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_131_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 54) 5 0.001)\n    (check-within (candidate 120) 1 0.001)\n    (check-within (candidate 5014) 5 0.001)\n    (check-within (candidate 98765) 315 0.001)\n    (check-within (candidate 5576543) 2625 0.001)\n    (check-within (candidate 2468) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function digits(n)\n    local product = 1\n    local odd_count = 0\n    for digit in tostring(n):gmatch(\"%d\") do\n        local int_digit = tonumber(digit)\n        if int_digit%2 == 1 then\n            product= product*int_digit\n            odd_count=odd_count+1\n        end\n    end\n    if odd_count ==0 then\n        return 0\n    else\n        return product\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an integer as input and returns the product of all its odd digits. If there are no odd digits, it returns 0.\n\n- `math = require('math')`: This line imports the math module, which provides mathematical functions and constants. The module is assigned to the variable `math`.\n- `local function digits(n)`: This line defines a local function called `digits` that takes an integer `n` as input.\n- `local product = 1`: This line initializes a local variable `product` to 1. This variable will be used to accumulate the product of all odd digits.\n- `local odd_count = 0`: This line initializes a local variable `odd_count` to 0. This variable will be used to count the number of odd digits.\n- `for digit in tostring(n):gmatch(\"%d\") do`: This line starts a loop that iterates over each digit in the string representation of `n`. The `tostring` function converts `n` to a string, and the `gmatch` method returns an iterator that matches each digit in the string. The `for` loop assigns each digit to the variable `digit`.\n- `local int_digit = tonumber(digit)`: This line converts the string `digit` to an integer and assigns it to the variable `int_digit`.\n- `if int_digit%2 == 1 then`: This line checks if `int_digit` is odd by computing its remainder when divided by 2. If the remainder is 1, then `int_digit` is odd.\n- `product= product*int_digit`: This line multiplies `product` by `int_digit` if `int_digit` is odd.\n- `odd_count=odd_count+1`: This line increments `odd_count` by 1 if `int_digit` is odd.\n- `if odd_count ==0 then`: This line checks if there were no odd digits in `n`.\n- `return 0`: This line returns 0 if there were no odd digits in `n`.\n- `else`: This line starts the `else` block of the `if` statement.\n- `return product`: This line returns the product of all odd digits in `n`. If there were no odd digits, this line is not executed. \n\n\n### Racket version\n\n#lang racket\n\n(define (digits n)\n"
  },
  {
    "name": "HumanEval_46_fib4",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib4 n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_46_fib4.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib4))\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 28 0.001)\n    (check-within (candidate 10) 104 0.001)\n    (check-within (candidate 12) 386 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fib4(n)\n  local results = {0, 0, 2, 0}\n  if n < 4 then\n    return results[n]\n  end\n\n  for i = 4, n do\n    table.insert(results, results[#results] + results[#results - 1] + results[#results - 2] + results[#results - 3])\n    table.remove(results, 1)\n  end\n\n  return results[#results]\nend\n\n### Explanation\n\nThe code is an implementation of a Fibonacci sequence generator. The function `fib4` takes an integer `n` as input and returns the nth number in the Fibonacci sequence. \n\nThe first line imports the math library.\n\nThe second line defines a function `fib4` that takes an integer `n` as input.\n\nThe third line initializes a table `results` with the values 0, 0, 2, and 0.\n\nThe fourth line checks if `n` is less than 4. If it is, the function returns the value at index `n` in the `results` table.\n\nThe fifth line starts a for loop that iterates from 4 to `n`.\n\nThe sixth line inserts a new value into the `results` table. The value is the sum of the last four values in the table.\n\nThe seventh line removes the first value in the `results` table.\n\nThe eighth line returns the last value in the `results` table, which is the nth number in the Fibonacci sequence. \n\nTo rewrite this program in Racket, we would need to replace the Lua-specific syntax with Racket syntax. For example, we would need to replace `require('math')` with `(require math)`, and `table.insert(results, ...)` with `(set! results (append results (list ...)))`. We would also need to replace `table.remove(results, 1)` with `(set! results (cdr results))`. The resulting Racket code would look like this:\n\n\n### Racket version\n\n#lang racket\n\n(define (fib4 n)\n"
  },
  {
    "name": "HumanEval_37_sort_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_even l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_37_sort_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_even))\n    (check-within (candidate (list 1 2 3)) (list 1 2 3) 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123) 0.001)\n    (check-within (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_even(l)\n    local evens = {}\n    local odds = {}\n    for i = 1, #l, 2 do\n        table.insert(evens, l[i])\n    end\n    for i = 2, #l, 2 do\n        table.insert(odds, l[i])\n    end\n    table.sort(evens)\n    local ans = {}\n    for i = 1, math.min(#evens, #odds) do\n        table.insert(ans, evens[i])\n        table.insert(ans, odds[i])\n    end\n    if #evens > #odds then\n        table.insert(ans, evens[#evens])\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function called `sort_even` that takes a list of numbers and returns a new list with the even numbers sorted in ascending order, followed by the odd numbers in the order they appear in the input list. If there are more even numbers than odd numbers, the last even number is appended to the end of the output list.\n\n- `math = require('math')`: This line imports the `math` module, which provides mathematical functions and constants. The `require` function is used to load the module and assign it to the variable `math`.\n\n- `local function sort_even(l)`: This line defines a new function called `sort_even` that takes a single argument `l`, which is expected to be a list of numbers. The `local` keyword is used to make the function local to the current scope.\n\n- `local evens = {}`: This line initializes an empty list called `evens`, which will be used to store the even numbers in the input list.\n\n- `local odds = {}`: This line initializes an empty list called `odds`, which will be used to store the odd numbers in the input list.\n\n- `for i = 1, #l, 2 do`: This line starts a loop that iterates over the input list `l` with a step of 2. The loop variable `i` is initialized to 1 and incremented by 2 on each iteration until it reaches the length of `l`. This loop extracts the even numbers from the input list and appends them to the `evens` list.\n\n- `table.insert(evens, l[i])`: This line inserts the `i`-th element of `l` (which is an even number) into the `evens` list.\n\n- `for i = 2, #l, 2 do`: This line starts a loop that iterates over the input list `l` with a step of 2, starting from the second element. This loop extracts the odd numbers from the input list and appends them to the `odds` list.\n\n- `table.insert(odds, l[i])`: This line inserts the `i`-th element of `l` (which is an odd number) into the `odds` list.\n\n- `table.sort(evens)`: This line sorts the `evens` list in ascending order.\n\n- `local ans = {}`: This line initializes an empty list called `ans`, which will be used to store the sorted even and odd numbers.\n\n- `for i = 1, math.min(#evens, #odds) do`: This line starts a loop that iterates over the indices from 1 to the minimum of the lengths of the `evens` and `odds` lists. This loop pairs the sorted even and odd numbers and appends them to the `ans` list.\n\n- `table.insert(ans, evens[i])`: This line inserts the `i`-th element of the `evens` list into the `ans` list.\n\n- `table.insert(ans, odds[i])`: This line inserts the `i`-th element of the `odds` list into the `ans` list.\n\n- `if #evens > #odds then`: This line starts an `if` statement that checks if the `evens` list is longer than the `odds` list.\n\n- `table.insert(ans, evens[#evens])`: This line appends the last even number in the `evens` list to the `ans` list.\n\n- `return ans`: This line returns the `ans` list as the output of the `sort\n\n### Racket version\n\n#lang racket\n\n(define (sort_even l)\n"
  },
  {
    "name": "HumanEval_80_is_happy",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_happy s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_80_is_happy.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n    (check-within (candidate \"a\") #f 0.001)\n    (check-within (candidate \"aa\") #f 0.001)\n    (check-within (candidate \"abcd\") #t 0.001)\n    (check-within (candidate \"aabb\") #f 0.001)\n    (check-within (candidate \"adb\") #t 0.001)\n    (check-within (candidate \"xyy\") #f 0.001)\n    (check-within (candidate \"iopaxpoi\") #t 0.001)\n    (check-within (candidate \"iopaxioi\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_happy(s)\n  if #s < 3 then\n    return false\n  end\n\n  for i = 1, #s - 2 do\n    if s:sub(i,i) == s:sub(i+1,i+1) or s:sub(i+1,i+1) == s:sub(i+2,i+2) or s:sub(i,i) == s:sub(i+2,i+2) then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_happy` that takes a string `s` as input and returns a boolean value indicating whether the string is \"happy\" or not. A string is considered \"happy\" if it does not contain any consecutive identical characters, and it has at least 3 characters.\n\nThe first line of the code imports the `math` module.\n\nThe second line of the code defines a local function `is_happy` that takes a string `s` as input.\n\nThe third line of the code checks if the length of the string `s` is less than 3. If it is, the function returns `false`.\n\nThe fourth line of the code starts a loop that iterates over the indices of the string `s` from 1 to the second-to-last index.\n\nThe fifth line of the code checks if any of the three pairs of consecutive characters in the string `s` are equal. If any of them are, the function returns `false`.\n\nThe sixth line of the code returns `true` if the loop completes without returning `false`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (is_happy s)\n"
  },
  {
    "name": "HumanEval_65_circular_shift",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (circular_shift x shift)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_65_circular_shift.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n    (check-within (candidate 100 2) \"001\" 0.001)\n    (check-within (candidate 12 2) \"12\" 0.001)\n    (check-within (candidate 97 8) \"79\" 0.001)\n    (check-within (candidate 12 1) \"21\" 0.001)\n    (check-within (candidate 11 101) \"11\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function circular_shift(x, shift)\n    local s = tostring(x)\n    if shift > #s then\n        return s:reverse()\n    else\n        return s:sub(#s-shift+1) .. s:sub(1, #s-shift)\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `circular_shift` that takes two arguments `x` and `shift`. The function returns a string that is the result of circularly shifting the digits of `x` by `shift` positions to the left. \n\n1. `math = require('math')` - This line imports the built-in Lua math library. The `require` function is used to load a module. In this case, we are loading the math module. The `require` function returns the module table, which is assigned to the variable `math`.\n\n2. `local function circular_shift(x, shift)` - This line defines a local function called `circular_shift` that takes two arguments `x` and `shift`. The `local` keyword is used to define a local variable or function that is only accessible within the current block. In this case, the function is only accessible within the file or block of code that it is defined in.\n\n3. `local s = tostring(x)` - This line converts the `x` argument to a string and assigns it to a local variable `s`. The `tostring` function is a built-in Lua function that converts a value to a string.\n\n4. `if shift > #s then` - This line checks if the `shift` argument is greater than the length of the string `s`. The `#` operator is used to get the length of a string or the size of a table.\n\n5. `return s:reverse()` - This line returns the reversed string `s` if the `shift` argument is greater than the length of `s`. The `reverse` function is a built-in Lua function that returns a reversed copy of a string.\n\n6. `return s:sub(#s-shift+1) .. s:sub(1, #s-shift)` - This line returns the circularly shifted string if the `shift` argument is less than or equal to the length of `s`. The `sub` function is a built-in Lua function that returns a substring of a string. The first argument is the starting index and the second argument is the ending index. In this case, the first substring is from `#s-shift+1` to the end of the string `s`, and the second substring is from the beginning of the string `s` to `#s-shift`. The `..` operator is used to concatenate the two substrings. \n\nOverall, the `circular_shift` function takes a number `x` and a shift value `shift`, converts `x` to a string, and returns a new string that is the result of circularly shifting the digits of `x` by `shift` positions to the left. If `shift` is greater than the length of `x`, the function returns the reversed string `x`. If `shift` is less than or equal to the length of `x`, the function returns the circularly shifted string. The function makes use of built-in Lua functions such as `tostring`, `reverse`, and `sub`. \n\n\n### Racket version\n\n#lang racket\n\n(define (circular_shift x shift)\n"
  },
  {
    "name": "HumanEval_115_max_fill",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_fill grid capacity)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_115_max_fill.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_fill))\n    (check-within (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function max_fill(grid, capacity)\n  local sum = 0\n  for i=1, #grid do\n    local row_sum = 0\n    for j=1, #grid[i] do\n      row_sum = row_sum + grid[i][j]\n    end\n    sum = sum + math.ceil(row_sum/capacity)\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `max_fill` that takes in a 2D array `grid` and a number `capacity` and returns the maximum number of times the `grid` can be filled with `capacity` units of water. \n\n- `math = require('math')` imports the math library in Lua. This library provides basic mathematical functions like `ceil`, `floor`, `abs`, etc.\n\n- `local function max_fill(grid, capacity)` defines a local function `max_fill` that takes in two arguments `grid` and `capacity`. The `local` keyword means that the function is only accessible within the scope of the block it is defined in.\n\n- `local sum = 0` initializes a local variable `sum` to 0. This variable will be used to keep track of the total number of times the `grid` can be filled with `capacity` units of water.\n\n- `for i=1, #grid do` starts a loop that iterates over each row of the `grid`. The `#grid` operator returns the length of the `grid` array.\n\n- `local row_sum = 0` initializes a local variable `row_sum` to 0. This variable will be used to keep track of the total number of units of water in the current row.\n\n- `for j=1, #grid[i] do` starts a loop that iterates over each element in the current row of the `grid`.\n\n- `row_sum = row_sum + grid[i][j]` adds the current element to the `row_sum` variable.\n\n- `end` ends the inner loop.\n\n- `sum = sum + math.ceil(row_sum/capacity)` adds the number of times the current row can be filled with `capacity` units of water to the `sum` variable. The `math.ceil` function rounds up the result of `row_sum/capacity` to the nearest integer.\n\n- `end` ends the outer loop.\n\n- `return sum` returns the total number of times the `grid` can be filled with `capacity` units of water.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (max_fill grid capacity)\n"
  },
  {
    "name": "HumanEval_0_has_close_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (has_close_elements numbers threshold)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_0_has_close_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function has_close_elements(numbers, threshold)\n  for idx, elem in ipairs(numbers) do\n    for idx2, elem2 in ipairs(numbers) do\n      if idx ~= idx2 then\n        local distance = math.abs(elem - elem2)\n        if distance < threshold then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `has_close_elements` that takes two arguments, `numbers` and `threshold`. The function returns a boolean value, `true` or `false`. The function checks if there are any two elements in the `numbers` list that are closer than `threshold` to each other. \n\nThe first line of the code imports the `math` module. This module provides mathematical functions for Lua.\n\nThe second line of the code defines a function called `has_close_elements` that takes two arguments, `numbers` and `threshold`. The function is defined as a local function, which means that it is only accessible within the scope of the current block of code.\n\nThe third line of the code starts a `for` loop that iterates over the `numbers` list using the `ipairs` function. The `ipairs` function returns an iterator function that iterates over the elements of the `numbers` list.\n\nThe fourth line of the code starts another `for` loop that iterates over the `numbers` list using the `ipairs` function. The `idx` and `elem` variables are used to store the index and value of the current element being iterated over.\n\nThe fifth line of the code checks if the index of the current element being iterated over is not equal to the index of the second element being iterated over. This is to ensure that the function does not compare an element with itself.\n\nThe sixth line of the code calculates the absolute difference between the two elements being compared using the `math.abs` function. The `math.abs` function returns the absolute value of a number.\n\nThe seventh line of the code checks if the absolute difference between the two elements being compared is less than the `threshold` value. If it is, the function returns `true`.\n\nThe eighth line of the code ends the inner `for` loop.\n\nThe ninth line of the code ends the outer `for` loop.\n\nThe tenth line of the code returns `false` if no two elements in the `numbers` list are closer than `threshold` to each other. \n\n\n### Racket version\n\n#lang racket\n\n(define (has_close_elements numbers threshold)\n"
  },
  {
    "name": "HumanEval_81_numerical_letter_grade",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (numerical_letter_grade grades)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numerical_letter_grade))\n    (check-within (candidate (list 4.0 3 1.7 2 3.5)) (list \"A+\" \"B\" \"C-\" \"C\" \"A-\") 0.001)\n    (check-within (candidate (list 1.2)) (list \"D+\") 0.001)\n    (check-within (candidate (list 0.5)) (list \"D-\") 0.001)\n    (check-within (candidate (list 0.0)) (list \"E\") 0.001)\n    (check-within (candidate (list 1.0 0.3 1.5 2.8 3.3)) (list \"D\" \"D-\" \"C-\" \"B\" \"B+\") 0.001)\n    (check-within (candidate (list 0.0 0.7)) (list \"E\" \"D-\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function numerical_letter_grade(grades)\n    letter_grade = {}\n    for i, gpa in ipairs(grades) do\n        if gpa == 4.0 then\n            table.insert(letter_grade, \"A+\")\n        elseif gpa > 3.7 then\n            table.insert(letter_grade, \"A\")\n        elseif gpa > 3.3 then\n            table.insert(letter_grade, \"A-\")\n        elseif gpa > 3.0 then\n            table.insert(letter_grade, \"B+\")\n        elseif gpa > 2.7 then\n            table.insert(letter_grade, \"B\")\n        elseif gpa > 2.3 then\n            table.insert(letter_grade, \"B-\")\n        elseif gpa > 2.0 then\n            table.insert(letter_grade, \"C+\")\n        elseif gpa > 1.7 then\n            table.insert(letter_grade, \"C\")\n        elseif gpa > 1.3 then\n            table.insert(letter_grade, \"C-\")\n        elseif gpa > 1.0 then\n            table.insert(letter_grade, \"D+\")\n        elseif gpa > 0.7 then\n            table.insert(letter_grade, \"D\")\n        elseif gpa > 0.0 then\n            table.insert(letter_grade, \"D-\")\n        else\n            table.insert(letter_grade, \"E\")\n        end\n    end\n    return letter_grade\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of numerical grades and returns a list of letter grades. \n\nThe first line of the code imports the math module. \n\nThe second line of the code defines a function called numerical_letter_grade that takes in a list of numerical grades. \n\nThe third line of the code initializes an empty table called letter_grade. \n\nThe fourth line of the code starts a for loop that iterates through the list of numerical grades. \n\nThe fifth line of the code checks if the numerical grade is equal to 4.0. If it is, it inserts the string \"A+\" into the letter_grade table. \n\nThe sixth line of the code checks if the numerical grade is greater than 3.7. If it is, it inserts the string \"A\" into the letter_grade table. \n\nThe seventh line of the code checks if the numerical grade is greater than 3.3. If it is, it inserts the string \"A-\" into the letter_grade table. \n\nThe eighth line of the code checks if the numerical grade is greater than 3.0. If it is, it inserts the string \"B+\" into the letter_grade table. \n\nThe ninth line of the code checks if the numerical grade is greater than 2.7. If it is, it inserts the string \"B\" into the letter_grade table. \n\nThe tenth line of the code checks if the numerical grade is greater than 2.3. If it is, it inserts the string \"B-\" into the letter_grade table. \n\nThe eleventh line of the code checks if the numerical grade is greater than 2.0. If it is, it inserts the string \"C+\" into the letter_grade table. \n\nThe twelfth line of the code checks if the numerical grade is greater than 1.7. If it is, it inserts the string \"C\" into the letter_grade table. \n\nThe thirteenth line of the code checks if the numerical grade is greater than 1.3. If it is, it inserts the string \"C-\" into the letter_grade table. \n\nThe fourteenth line of the code checks if the numerical grade is greater than 1.0. If it is, it inserts the string \"D+\" into the letter_grade table. \n\nThe fifteenth line of the code checks if the numerical grade is greater than 0.7. If it is, it inserts the string \"D\" into the letter_grade table. \n\nThe sixteenth line of the code checks if the numerical grade is greater than 0.0. If it is, it inserts the string \"D-\" into the letter_grade table. \n\nThe seventeenth line of the code is an else statement that inserts the string \"E\" into the letter_grade table if none of the previous conditions are met. \n\nThe eighteenth line of the code ends the for loop. \n\nThe nineteenth line of the code returns the letter_grade table. \n\n\n### Racket version\n\n#lang racket\n\n(define (numerical_letter_grade grades)\n"
  },
  {
    "name": "HumanEval_150_x_or_y",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (x_or_y n x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_150_x_or_y.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate x_or_y))\n    (check-within (candidate 7 34 12) 34 0.001)\n    (check-within (candidate 15 8 5) 5 0.001)\n    (check-within (candidate 3 33 5212) 33 0.001)\n    (check-within (candidate 1259 3 52) 3 0.001)\n    (check-within (candidate 7919 -1 12) -1 0.001)\n    (check-within (candidate 3609 1245 583) 583 0.001)\n    (check-within (candidate 91 56 129) 129 0.001)\n    (check-within (candidate 6 34 1234) 1234 0.001)\n    (check-within (candidate 1 2 0) 0 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function x_or_y(n, x, y)\n    if n == 1 then\n        return y\n    end\n    for i=2, n-1 do\n        if n%i == 0 then\n            return y\n        end\n    end\n    return x\nend\n\n### Explanation\n\nThe code is an implementation of a function called `x_or_y` that takes three arguments, `n`, `x`, and `y`. It returns `y` if `n` is divisible by any number other than 1 and itself, otherwise it returns `x`.\n\nThe first line imports the `math` module.\n\nThe second line defines a function called `x_or_y` that takes three arguments, `n`, `x`, and `y`. The function is defined as a local function, which means it is only accessible within the scope of the file or block it is defined in.\n\nThe `if` statement checks if `n` is equal to 1. If it is, the function returns `y`.\n\nThe `for` loop iterates over the numbers from 2 to `n-1`. For each number `i`, the `if` statement checks if `n` is divisible by `i`. If it is, the function returns `y`.\n\nIf the `for` loop completes without returning, the function returns `x`. \n\n\n### Racket version\n\n#lang racket\n\n(define (x_or_y n x y)\n"
  },
  {
    "name": "HumanEval_146_specialFilter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (specialFilter nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_146_specialFilter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n    (check-within (candidate (list 5 -2 1 -5)) 0 0.001)\n    (check-within (candidate (list 15 -73 14 -15)) 1 0.001)\n    (check-within (candidate (list 33 -2 -3 45 21 109)) 2 0.001)\n    (check-within (candidate (list 43 -12 93 125 121 109)) 4 0.001)\n    (check-within (candidate (list 71 -2 -33 75 21 19)) 3 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function specialFilter(nums)\n    local count = 0\n    for _, num in ipairs(nums) do\n        if num > 10 then\n            local odd_digits = {1, 3, 5, 7, 9}\n            local number_as_string = tostring(num)\n            if math.floor(num / 10^(#number_as_string - 1)) % 2 == 1 and num % 10 % 2 == 1 then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of a function called `specialFilter` that takes a list of numbers as input and returns the count of numbers that are greater than 10 and have an odd first digit and an odd last digit. \n\n1. `math = require('math')` - this line imports the built-in math library in Lua. \n\n2. `local function specialFilter(nums)` - this line defines a function called `specialFilter` that takes a list of numbers as input. The `local` keyword means that the function is only accessible within the scope of the current block of code. \n\n3. `local count = 0` - this line initializes a variable called `count` to 0. This variable will be used to keep track of the count of numbers that meet the filter criteria. \n\n4. `for _, num in ipairs(nums) do` - this line starts a loop that iterates over each number in the input list. The `ipairs` function is used to iterate over the list in order. The `_` variable is used to ignore the index of each element in the list. \n\n5. `if num > 10 then` - this line checks if the current number is greater than 10. If it is not, the rest of the loop body is skipped. \n\n6. `local odd_digits = {1, 3, 5, 7, 9}` - this line initializes a list called `odd_digits` that contains the odd digits from 1 to 9. \n\n7. `local number_as_string = tostring(num)` - this line converts the current number to a string. \n\n8. `if math.floor(num / 10^(#number_as_string - 1)) % 2 == 1 and num % 10 % 2 == 1 then` - this line checks if the current number has an odd first digit and an odd last digit. \n\n    a. `math.floor(num / 10^(#number_as_string - 1))` - this expression extracts the first digit of the current number by dividing the number by 10 raised to the power of the length of the number minus 1, and then rounding down to the nearest integer. \n    \n    b. `% 2 == 1` - this expression checks if the first digit is odd. \n    \n    c. `num % 10 % 2 == 1` - this expression checks if the last digit is odd. \n    \n9. `count = count + 1` - this line increments the `count` variable if the current number meets the filter criteria. \n\n10. `end` - this line ends the `if` statement. \n\n11. `end` - this line ends the `for` loop. \n\n12. `return count` - this line returns the final count of numbers that meet the filter criteria. \n\n\n### Racket version\n\n#lang racket\n\n(define (specialFilter nums)\n"
  },
  {
    "name": "HumanEval_17_parse_music",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_music music_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_17_parse_music.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_music))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"o o o o\") (list 4 4 4 4) 0.001)\n    (check-within (candidate \".| .| .| .|\") (list 1 1 1 1) 0.001)\n    (check-within (candidate \"o| o| .| .| o o o o\") (list 2 2 1 1 4 4 4 4) 0.001)\n    (check-within (candidate \"o| .| o| .| o o| o o|\") (list 2 1 2 1 4 2 4 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function parse_music(music_string)\n    local note_map = {o=4, ['o|']=2, ['.|']=1}\n    local notes = {}\n    for x in music_string:gmatch(\"%S+\") do\n        table.insert(notes, note_map[x])\n    end\n    return notes\nend\n\n### Explanation\n\nThe code is an implementation of a function called `parse_music` that takes in a string called `music_string` and returns a list of integers called `notes`. \n\nThe first line of the code imports the math library.\n\nThe second line of the code defines a function called `parse_music` that takes in a string called `music_string`. \n\nThe third line of the code defines a table called `note_map` that maps certain strings to integers. The string \"o\" maps to 4, the string \"o|\" maps to 2, and the string \".|\" maps to 1.\n\nThe fourth line of the code defines an empty list called `notes`.\n\nThe fifth line of the code starts a for loop that iterates over each non-space substring in `music_string`. \n\nThe sixth line of the code inserts the integer value of the current substring into the `notes` list by looking up the substring in the `note_map` table.\n\nThe seventh line of the code returns the `notes` list. \n\n\n### Racket version\n\n#lang racket\n\n(define (parse_music music_string)\n"
  },
  {
    "name": "HumanEval_125_split_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (split_words txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_125_split_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n    (check-within (candidate \"Hello world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello,world!\") (list \"Hello\" \"world!\") 0.001)\n    (check-within (candidate \"Hello world,!\") (list \"Hello\" \"world,!\") 0.001)\n    (check-within (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\" \"!\") 0.001)\n    (check-within (candidate \"abcdef\") 3 0.001)\n    (check-within (candidate \"aaabb\") 2 0.001)\n    (check-within (candidate \"aaaBb\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function split_words(txt)\n    if string.find(txt, \" \") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt, \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    elseif string.find(txt, \",\") ~= nil then\n        local words = {}\n        for word in string.gmatch(txt:gsub(\",\", \" \"), \"%S+\") do\n            table.insert(words, word)\n        end\n        return words\n    else\n        local count = 0\n        for i = 1, #txt do\n            if string.match(txt:sub(i, i), \"%l\") and string.byte(txt:sub(i, i)) % 2 == 0 then\n                count = count + 1\n            end\n        end\n        return count\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `split_words` that takes a string as input and returns either a list of words or a count of lowercase letters that have an even ASCII value. The function is defined as a local function, which means that it is only visible within the scope of the file or block of code where it is defined.\n\nThe first line of the function imports the `math` library, which provides mathematical functions that can be used in the code.\n\nThe function then checks whether the input string contains spaces or commas. If it contains spaces, it splits the string into words and returns a list of the words. If it contains commas, it replaces the commas with spaces, splits the resulting string into words, and returns a list of the words. If it contains neither spaces nor commas, it counts the number of lowercase letters in the string that have an even ASCII value and returns the count.\n\nThe `string.find` function is used to check whether the input string contains spaces or commas. If it finds a space or comma, it returns the index of the first occurrence of the character in the string. If it does not find a space or comma, it returns `nil`.\n\nThe `string.gmatch` function is used to split the input string into words. It takes two arguments: the string to be split and a pattern that specifies how to split the string. The pattern `\"%S+\"` matches one or more non-space characters, so it splits the string into words based on spaces.\n\nThe `table.insert` function is used to add each word to the `words` table.\n\nThe `string.sub` function is used to get a substring of the input string. It takes three arguments: the string to be sliced, the starting index of the slice, and the ending index of the slice. In this case, it is used to get a single character from the input string.\n\nThe `string.match` function is used to check whether a character is a lowercase letter. It takes two arguments: the string to be matched and a pattern that specifies what to match. The pattern `\"%l\"` matches any lowercase letter.\n\nThe `string.byte` function is used to get the ASCII value of a character. It takes one argument: the character whose ASCII value is to be retrieved.\n\nThe `%` operator is used to get the remainder of a division operation. In this case, it is used to check whether the ASCII value of a character is even. If the remainder of the ASCII value divided by 2 is 0, then the ASCII value is even. If the remainder is 1, then the ASCII value is odd. \n\nThe `#` operator is used to get the length of a string or table. In this case, it is used to get the length of the input string.\n\nThe `return` statement is used to return the list of words or the count of lowercase letters with even ASCII values. If the input string contains spaces or commas, the list of words is returned. If it contains neither spaces nor commas, the count of lowercase letters with even ASCII values is returned. \n\n\n### Racket version\n\n#lang racket\n\n(define (split_words txt)\n"
  },
  {
    "name": "HumanEval_16_count_distinct_characters",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_distinct_characters string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_distinct_characters))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abcde\") 5 0.001)\n    (check-within (candidate \"abcdecadeCADE\") 5 0.001)\n    (check-within (candidate \"aaaaAAAAaaaa\") 1 0.001)\n    (check-within (candidate \"Jerry jERRY JeRRRY\") 5 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function count_distinct_characters(string)\n    local set = {}\n    for i=1, #string do\n        set[string:sub(i, i):lower()] = true\n    end\n    local count = 0\n    for k, v in pairs(set) do\n        count = count + 1\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of distinct characters in a string. \n\nThe first line imports the math library.\n\nThe second line defines a function called `count_distinct_characters` that takes a string as an argument.\n\nThe third line initializes an empty table called `set`.\n\nThe fourth line starts a loop that iterates over each character in the string. The loop variable `i` is initialized to 1 and incremented by 1 until it reaches the length of the string. \n\nThe fifth line adds a key-value pair to the `set` table. The key is the lowercase version of the current character in the string, obtained using the `string:sub(i, i):lower()` method chain. The value is `true`.\n\nThe sixth line initializes a variable called `count` to 0.\n\nThe seventh line starts a loop that iterates over each key-value pair in the `set` table.\n\nThe eighth line increments the `count` variable by 1.\n\nThe ninth line returns the `count` variable, which represents the number of distinct characters in the string. \n\n\n### Racket version\n\n#lang racket\n\n(define (count_distinct_characters string)\n"
  },
  {
    "name": "HumanEval_148_bf",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (bf planet1 planet2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_148_bf.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate bf))\n    (check-within (candidate \"Jupiter\" \"Neptune\") (list \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Mercury\") (list \"Venus\") 0.001)\n    (check-within (candidate \"Mercury\" \"Uranus\") (list \"Venus\" \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\") 0.001)\n    (check-within (candidate \"Neptune\" \"Venus\") (list \"Earth\" \"Mars\" \"Jupiter\" \"Saturn\" \"Uranus\") 0.001)\n    (check-within (candidate \"Earth\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Mars\" \"Earth\") (list ) 0.001)\n    (check-within (candidate \"Jupiter\" \"Makemake\") (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function bf(planet1, planet2)\n    local planet_names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    if not (table.concat(planet_names, ','):find(planet1) and table.concat(planet_names, ','):find(planet2)) or planet1 == planet2 then\n        return {}\n    end\n    local planet1_index = 0\n    local planet2_index = 0\n    for i, planet in ipairs(planet_names) do\n        if planet == planet1 then\n            planet1_index = i\n        elseif planet == planet2 then\n            planet2_index = i\n        end\n    end\n    if planet1_index < planet2_index then\n        return {table.unpack(planet_names, planet1_index + 1, planet2_index - 1)}\n    else\n        return {table.unpack(planet_names, planet2_index + 1, planet1_index - 1)}\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `bf` that takes two arguments `planet1` and `planet2` and returns a list of planets that are between `planet1` and `planet2` in the solar system. The function first imports the `math` module and then defines the `bf` function.\n\n\n### Racket version\n\n#lang racket\n\n(define (bf planet1 planet2)\n"
  },
  {
    "name": "HumanEval_66_digitSum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (digitSum s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_66_digitSum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digitSum))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"abAB\") 131 0.001)\n    (check-within (candidate \"abcCd\") 67 0.001)\n    (check-within (candidate \"helloE\") 69 0.001)\n    (check-within (candidate \"woArBld\") 131 0.001)\n    (check-within (candidate \"aAaaaXa\") 153 0.001)\n    (check-within (candidate \" How are yOu?\") 151 0.001)\n    (check-within (candidate \"You arE Very Smart\") 327 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function digitSum(s)\n    if s == \"\" then return 0 end\n    local sum = 0\n    for char in s:gmatch(\".\") do\n        sum = sum + (char:match(\"%u\") and string.byte(char) or 0)\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `digitSum` that takes a string as input and returns the sum of the ASCII values of all uppercase letters in the string. \n\n1. `math = require('math')` - This line imports the math library in Lua. The `require` function is used to load a module in Lua. In this case, the module being loaded is the `math` module.\n\n2. `local function digitSum(s)` - This line defines a local function called `digitSum` that takes a string `s` as input.\n\n3. `if s == \"\" then return 0 end` - This line checks if the input string `s` is an empty string. If it is, the function returns 0.\n\n4. `local sum = 0` - This line initializes a local variable `sum` to 0.\n\n5. `for char in s:gmatch(\".\") do` - This line starts a loop that iterates over each character in the input string `s`. The `gmatch` function is used to iterate over all characters in the string. The `.` pattern matches any character.\n\n6. `sum = sum + (char:match(\"%u\") and string.byte(char) or 0)` - This line adds the ASCII value of each uppercase letter in the string to the `sum` variable. The `match` function is used to check if the current character is an uppercase letter. The `%u` pattern matches any uppercase letter. If the current character is an uppercase letter, the `byte` function is used to get its ASCII value, which is added to the `sum` variable. If the current character is not an uppercase letter, 0 is added to the `sum` variable.\n\n7. `end` - This line marks the end of the loop.\n\n8. `return sum` - This line returns the final value of the `sum` variable, which is the sum of the ASCII values of all uppercase letters in the input string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (digitSum s)\n"
  },
  {
    "name": "HumanEval_142_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_142_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 1 4 9)) 14 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) 9 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1)) -3 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list -1 -5 2 -1 -5)) -126 0.001)\n    (check-within (candidate (list -56 -99 1 0 -2)) 3030 0.001)\n    (check-within (candidate (list -1 0 0 0 0 0 0 0 -1)) 0 0.001)\n    (check-within (candidate (list -16 -9 -2 36 36 26 -20 25 -40 20 -4 12 -26 35 37)) -14196 0.001)\n    (check-within (candidate (list -1 -3 17 -1 -15 13 -1 14 -14 -12 -5 14 -14 6 13 11 16 16 4 10)) -1448 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n    local result = {}\n    for i=1, #lst do\n        if i % 3 == 1 then\n            result[#result+1] = lst[i]^2\n        elseif i % 4 == 1 and i % 3 ~= 1 then\n            result[#result+1] = lst[i]^3\n        else\n            result[#result+1] = lst[i]\n        end\n    end\n    local sum = 0\n    for i=1, #result do\n        sum = sum + result[i]\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function called `sum_squares` that takes a list of numbers and returns the sum of the squares of some of the numbers in the list. \n\nThe first line of the code imports the `math` library, which provides mathematical functions in Lua. \n\nThe second line defines a function called `sum_squares` that takes a single argument `lst`. \n\nThe third line creates an empty table called `result` that will be used to store the results of the calculations. \n\nThe fourth line starts a loop that will iterate over each element in the list `lst`. The loop will run `#lst` times, where `#lst` is the length of the list. \n\nThe fifth line checks if the current index `i` is divisible by 3 with no remainder. If it is, then the square of the current element `lst[i]` is added to the `result` table. \n\nThe sixth line checks if the current index `i` is divisible by 4 with no remainder AND is not divisible by 3 with no remainder. If it is, then the cube of the current element `lst[i]` is added to the `result` table. \n\nThe seventh line is executed if neither of the previous conditions are met. In this case, the current element `lst[i]` is added to the `result` table. \n\nThe eighth line starts a new loop that will iterate over each element in the `result` table. The loop will run `#result` times, where `#result` is the length of the `result` table. \n\nThe ninth line adds the current element `result[i]` to the variable `sum`. \n\nThe tenth line returns the final value of `sum`. \n\nOverall, the function `sum_squares` takes a list of numbers, squares some of them, cubes others, and sums the results. The specific elements that are squared or cubed depend on their position in the list, as determined by the conditional statements in the loop. The final result is the sum of all the squared and cubed elements. \n\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_96_count_up_to",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_up_to n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_96_count_up_to.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_up_to))\n    (check-within (candidate 5) (list 2 3) 0.001)\n    (check-within (candidate 6) (list 2 3 5) 0.001)\n    (check-within (candidate 7) (list 2 3 5) 0.001)\n    (check-within (candidate 10) (list 2 3 5 7) 0.001)\n    (check-within (candidate 0) (list ) 0.001)\n    (check-within (candidate 22) (list 2 3 5 7 11 13 17 19) 0.001)\n    (check-within (candidate 1) (list ) 0.001)\n    (check-within (candidate 18) (list 2 3 5 7 11 13 17) 0.001)\n    (check-within (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43) 0.001)\n    (check-within (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function count_up_to(n)\n  local primes = {}\n  for i = 2, n - 1 do\n    local is_prime = true\n    for j = 2, i - 1 do\n      if i % j == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(primes, i)\n    end\n  end\n  return primes\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a number `n` and returns a list of all prime numbers up to `n`. \n\n1. `math = require('math')` - This line imports the `math` library. This library provides a set of mathematical functions that can be used in the program.\n\n2. `local function count_up_to(n)` - This line defines a function called `count_up_to` that takes a single argument `n`.\n\n3. `local primes = {}` - This line creates an empty table called `primes`. This table will be used to store the prime numbers found in the loop.\n\n4. `for i = 2, n - 1 do` - This line starts a loop that will iterate over all numbers from 2 to `n - 1`.\n\n5. `local is_prime = true` - This line creates a boolean variable called `is_prime` and sets it to `true`. This variable will be used to keep track of whether the current number is prime or not.\n\n6. `for j = 2, i - 1 do` - This line starts a nested loop that will iterate over all numbers from 2 to `i - 1`.\n\n7. `if i % j == 0 then` - This line checks if `i` is divisible by `j`.\n\n8. `is_prime = false` - This line sets `is_prime` to `false` if `i` is divisible by `j`.\n\n9. `break` - This line breaks out of the nested loop if `i` is not prime.\n\n10. `if is_prime then` - This line checks if `is_prime` is still `true`.\n\n11. `table.insert(primes, i)` - This line adds `i` to the `primes` table if it is prime.\n\n12. `end` - This line ends the nested loop.\n\n13. `end` - This line ends the outer loop.\n\n14. `return primes` - This line returns the `primes` table. This table contains all prime numbers up to `n`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (count_up_to n)\n"
  },
  {
    "name": "HumanEval_133_sum_squares",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_squares lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_133_sum_squares.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0)) 14 0.001)\n    (check-within (candidate (list 1.0 3.0 5.0 7.0)) 84 0.001)\n    (check-within (candidate (list 1.4 4.2 0.0)) 29 0.001)\n    (check-within (candidate (list -2.4 1.0 1.0)) 6 0.001)\n    (check-within (candidate (list 100.0 1.0 15.0 2.0)) 10230 0.001)\n    (check-within (candidate (list 10000.0 10000.0)) 200000000 0.001)\n    (check-within (candidate (list -1.4 4.6 6.3)) 75 0.001)\n    (check-within (candidate (list -1.4 17.9 18.9 19.9)) 1086 0.001)\n    (check-within (candidate (list 0.0)) 0 0.001)\n    (check-within (candidate (list -1.0)) 1 0.001)\n    (check-within (candidate (list -1.0 1.0 0.0)) 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_squares(lst)\n  local squared = 0\n  for _, i in ipairs(lst) do\n    squared = squared + math.ceil(i)^2\n  end\n  return squared\nend\n\n### Explanation\n\nThe code is an implementation of a function `sum_squares` that takes a list of numbers and returns the sum of their squares, rounded up to the nearest integer.\n\n\n### Racket version\n\n#lang racket\n\n(define (sum_squares lst)\n"
  },
  {
    "name": "HumanEval_34_unique",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_34_unique.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique))\n    (check-within (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function unique(l)\n  local s = {}\n  for _, v in ipairs(l) do\n    s[v] = true\n  end\n  local r = {}\n  for k, _ in pairs(s) do\n    table.insert(r, k)\n  end\n  table.sort(r)\n  return r\nend\n\n### Explanation\n\nThe code is an implementation of a function called `unique` that takes a list of values and returns a new list with all duplicates removed. Here's a line-by-line breakdown of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (unique l)\n"
  },
  {
    "name": "HumanEval_55_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_55_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n    (check-within (candidate 10) 55 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 8) 21 0.001)\n    (check-within (candidate 11) 89 0.001)\n    (check-within (candidate 12) 144 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nend\n\n### Explanation\n\nThe code is an implementation of the Fibonacci sequence in Lua. \n\n`math = require('math')` imports the math library.\n\n`local function fib(n)` defines a function `fib` that takes an integer `n` as input.\n\n`if n == 0 then` checks if `n` is equal to `0`.\n\n`return 0` returns `0` if `n` is equal to `0`.\n\n`elseif n == 1 then` checks if `n` is equal to `1`.\n\n`return 1` returns `1` if `n` is equal to `1`.\n\n`return fib(n - 1) + fib(n - 2)` returns the sum of the previous two numbers in the sequence if `n` is greater than `1`. This is achieved by recursively calling the `fib` function with `n - 1` and `n - 2` as arguments. \n\n\n### Racket version\n\n#lang racket\n\n(define (fib n)\n"
  },
  {
    "name": "HumanEval_36_fizz_buzz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fizz_buzz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_36_fizz_buzz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n    (check-within (candidate 50) 0 0.001)\n    (check-within (candidate 78) 2 0.001)\n    (check-within (candidate 79) 3 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 200) 6 0.001)\n    (check-within (candidate 4000) 192 0.001)\n    (check-within (candidate 10000) 639 0.001)\n    (check-within (candidate 100000) 8026 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fizz_buzz(n)\n  local ns = {}\n  for i = 0, n - 1 do\n    if i % 11 == 0 or i % 13 == 0 then\n      table.insert(ns, i)\n    end\n  end\n  local s = table.concat(ns)\n  local ans = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '7' then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThe code is an implementation of the FizzBuzz problem with a twist. The twist is that instead of printing out Fizz, Buzz, or FizzBuzz, the function counts the number of times the digit 7 appears in the numbers that are divisible by 11 or 13 up to n - 1. \n\nThe first line of the program imports the math library. \n\n\n### Racket version\n\n#lang racket\n\n(define (fizz_buzz n)\n"
  },
  {
    "name": "HumanEval_153_Strongest_Extension",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (Strongest_Extension class_name extensions)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n    (check-within (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\")) \"Watashi.eIGHt8OKe\" 0.001)\n    (check-within (candidate \"Boku123\" (list \"nani\" \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\" 0.001)\n    (check-within (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\" \"123NoooneB321\")) \"__YESIMHERE.NuLl__\" 0.001)\n    (check-within (candidate \"K\" (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\" 0.001)\n    (check-within (candidate \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\" 0.001)\n    (check-within (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"-_-\")) \"YameRore.okIWILL123\" 0.001)\n    (check-within (candidate \"finNNalLLly\" (list \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\" 0.001)\n    (check-within (candidate \"_\" (list \"Bb\" \"91245\")) \"_.Bb\" 0.001)\n    (check-within (candidate \"Sp\" (list \"671235\" \"Bb\")) \"Sp.671235\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function Strongest_Extension(class_name, extensions)\n    local strong = extensions[1]\n    local my_val = #extensions[1]:gsub('[^%a]', ''):gsub('[^%u]', '') - #extensions[1]:gsub('[^%a]', ''):gsub('[^%l]', '')\n    for i = 2, #extensions do\n        local s = extensions[i]\n        local val = #s:gsub('[^%a]', ''):gsub('[^%u]', '') - #s:gsub('[^%a]', ''):gsub('[^%l]', '')\n        if val > my_val then\n            strong = s\n            my_val = val\n        end\n    end\n    return class_name .. '.' .. strong\nend\n\n### Explanation\n\nThe code is an implementation of a function called `Strongest_Extension` that takes two arguments: `class_name` and `extensions`. The function returns a string that is the concatenation of `class_name`, a period, and the strongest extension in `extensions`. \n\nThe function first requires the `math` module. \n\nThe function then declares a local function called `Strongest_Extension`. \n\nThe function then declares a local variable called `strong` and initializes it to the first element in `extensions`. \n\nThe function then declares a local variable called `my_val` and initializes it to the difference between the length of the first element in `extensions` with all non-alphabetic characters removed and all non-upper-case alphabetic characters removed, and the length of the first element in `extensions` with all non-alphabetic characters removed and all non-lower-case alphabetic characters removed. \n\nThe function then enters a for loop that iterates from 2 to the length of `extensions`. \n\nWithin the for loop, the function declares a local variable called `s` and initializes it to the current element in `extensions`. \n\nThe function then declares a local variable called `val` and initializes it to the difference between the length of `s` with all non-alphabetic characters removed and all non-upper-case alphabetic characters removed, and the length of `s` with all non-alphabetic characters removed and all non-lower-case alphabetic characters removed. \n\nThe function then checks if `val` is greater than `my_val`. If it is, the function sets `strong` to `s` and sets `my_val` to `val`. \n\nAfter the for loop, the function returns the concatenation of `class_name`, a period, and `strong`. \n\n\n### Racket version\n\n#lang racket\n\n(define (Strongest_Extension class_name extensions)\n"
  },
  {
    "name": "HumanEval_20_find_closest_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_closest_elements numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_20_find_closest_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n    (check-within (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0) 0.001)\n    (check-within (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function find_closest_elements(numbers)\n    local closest_pair = nil\n    local distance = nil\n\n    for idx, elem in ipairs(numbers) do\n        for idx2, elem2 in ipairs(numbers) do\n            if idx ~= idx2 then\n                if distance == nil then\n                    distance = math.abs(elem - elem2)\n                    closest_pair = {elem, elem2}\n                else\n                    new_distance = math.abs(elem - elem2)\n                    if new_distance < distance then\n                        distance = new_distance\n                        closest_pair = {elem, elem2}\n                    end\n                end\n            end\n        end\n    end\n\n    table.sort(closest_pair)\n    return closest_pair\nend\n\n### Explanation\n\nThe code is an implementation of a function called `find_closest_elements` that takes a list of numbers as input and returns a list of two numbers that are closest to each other in the input list. \n\nThe first line of the code imports the `math` module, which provides mathematical functions and constants for Lua. \n\nThe second line defines a local function called `find_closest_elements` that takes a single argument `numbers`. \n\nThe next two lines initialize two variables, `closest_pair` and `distance`, to `nil`. These variables will be used to keep track of the closest pair of numbers and their distance from each other as the function iterates through the input list. \n\nThe next line starts a loop that iterates through each element in the input list. The `ipairs` function is used to iterate through the list by index and value. The `idx` variable holds the index of the current element, and the `elem` variable holds the value of the current element. \n\nThe next line starts another loop that iterates through each element in the input list. This loop is nested inside the first loop, so it will iterate through every possible pair of elements in the input list. The `idx2` variable holds the index of the current element, and the `elem2` variable holds the value of the current element. \n\nThe next line checks if the two elements being compared are not the same element. If they are the same element, then they are not a valid pair to consider. \n\nThe next line checks if the `distance` variable is `nil`. If it is `nil`, then this is the first pair of elements being compared, so the `distance` variable is set to the absolute difference between the two elements, and the `closest_pair` variable is set to a table containing the two elements being compared. \n\nIf the `distance` variable is not `nil`, then a new variable `new_distance` is initialized to the absolute difference between the two elements being compared. \n\nThe next line checks if the `new_distance` is less than the current `distance`. If it is, then the `distance` variable is updated to `new_distance`, and the `closest_pair` variable is updated to a table containing the two elements being compared. \n\nThe loop continues until all possible pairs of elements have been compared. \n\nThe next line sorts the `closest_pair` table in ascending order. \n\nThe final line of the function returns the `closest_pair` table. \n\n\n### Racket version\n\n#lang racket\n\n(define (find_closest_elements numbers)\n"
  },
  {
    "name": "HumanEval_124_valid_date",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (valid_date date)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_124_valid_date.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_date))\n    (check-within (candidate \"03-11-2000\") #t 0.001)\n    (check-within (candidate \"15-01-2012\") #f 0.001)\n    (check-within (candidate \"04-0-2040\") #f 0.001)\n    (check-within (candidate \"06-04-2020\") #t 0.001)\n    (check-within (candidate \"01-01-2007\") #t 0.001)\n    (check-within (candidate \"03-32-2011\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"04-31-3000\") #f 0.001)\n    (check-within (candidate \"06-06-2005\") #t 0.001)\n    (check-within (candidate \"21-31-2000\") #f 0.001)\n    (check-within (candidate \"04-12-2003\") #t 0.001)\n    (check-within (candidate \"04122003\") #f 0.001)\n    (check-within (candidate \"20030412\") #f 0.001)\n    (check-within (candidate \"2003-04\") #f 0.001)\n    (check-within (candidate \"2003-04-12\") #f 0.001)\n    (check-within (candidate \"04-2003\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function valid_date(date)\n    local month, day, year = date:match(\"(%d+)-(%d+)-(%d+)\")\n    if not month or not day or not year then\n        return false\n    end\n    month, day, year = tonumber(month), tonumber(day), tonumber(year)\n    if month < 1 or month > 12 then\n        return false\n    end\n    if month == 2 and (day < 1 or day > 29) then\n        return false\n    end\n    if month == 4 or month == 6 or month == 9 or month == 11 then\n        if day < 1 or day > 30 then\n            return false\n        end\n    else\n        if day < 1 or day > 31 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `valid_date` that takes a string `date` as input and returns a boolean indicating whether the date is valid or not. \n\nThe first line imports the `math` module. \n\nThe second line defines a local function `valid_date` that takes a string `date` as input. \n\nThe third line extracts the month, day, and year from the input string using a pattern match. The pattern match looks for three groups of digits separated by hyphens. \n\nThe fourth line checks if the month, day, and year were successfully extracted from the input string. If not, the function returns false. \n\nThe fifth line converts the month, day, and year from strings to numbers. \n\nThe sixth line checks if the month is between 1 and 12. If not, the function returns false. \n\nThe seventh line checks if the day is valid for February. If the month is February and the day is not between 1 and 29, the function returns false. \n\nThe eighth line checks if the day is valid for April, June, September, and November. If the month is one of these months and the day is not between 1 and 30, the function returns false. \n\nThe ninth line checks if the day is valid for all other months. If the month is not one of the previous months and the day is not between 1 and 31, the function returns false. \n\nThe last line returns true if none of the previous checks failed, indicating that the date is valid. \n\n\n### Racket version\n\n#lang racket\n\n(define (valid_date date)\n"
  },
  {
    "name": "HumanEval_53_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_53_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate 0 1) 1 0.001)\n    (check-within (candidate 1 0) 1 0.001)\n    (check-within (candidate 2 3) 5 0.001)\n    (check-within (candidate 5 7) 12 0.001)\n    (check-within (candidate 7 5) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function add(x, y)\n  return x + y\nend\n\n### Explanation\n\nThe code is an implementation of a function that adds two numbers together. \n\n- `math = require('math')` imports the math library. This library provides a set of mathematical functions. \n\n- `local function add(x, y)` defines a function called `add` that takes two arguments `x` and `y`. The `local` keyword means that the function is only accessible within the scope of the current block. \n\n- `return x + y` returns the sum of `x` and `y`. \n\nThe function can be called by passing two numbers as arguments, like so: `add(1, 2)`. This would return `3`. \n\n\n### Racket version\n\n#lang racket\n\n(define (add x y)\n"
  },
  {
    "name": "HumanEval_40_triples_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triples_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -1)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 1 2 5 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 9 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list 1 3 5 -100)) #f 0.001)\n    (check-within (candidate (list 100 3 5 -100)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function triples_sum_to_zero(l)\n  for i = 1, #l do\n    for j = i + 1, #l do\n      for k = j + 1, #l do\n        if l[i] + l[j] + l[k] == 0 then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `triples_sum_to_zero` which takes a list of numbers `l` as input and returns `true` if there are three numbers in the list that sum up to zero, and `false` otherwise.\n\n- `math = require('math')` imports the `math` library, which provides mathematical functions like `math.abs`, `math.floor`, `math.random`, etc.\n\n- `local function triples_sum_to_zero(l)` defines a local function called `triples_sum_to_zero` which takes a list of numbers `l` as input.\n\n- `for i = 1, #l do` starts a loop that iterates over the indices of the elements in the list `l`, from 1 to the length of the list.\n\n- `for j = i + 1, #l do` starts a nested loop that iterates over the indices of the elements in the list `l`, from the index of the current element `i` plus 1 to the length of the list.\n\n- `for k = j + 1, #l do` starts another nested loop that iterates over the indices of the elements in the list `l`, from the index of the current element `j` plus 1 to the length of the list.\n\n- `if l[i] + l[j] + l[k] == 0 then` checks if the sum of the three elements at indices `i`, `j`, and `k` in the list `l` is equal to zero.\n\n- `return true` returns `true` if the sum of the three elements is zero.\n\n- `end` ends the `if` statement.\n\n- `end` ends the innermost `for` loop.\n\n- `end` ends the middle `for` loop.\n\n- `end` ends the outermost `for` loop.\n\n- `return false` returns `false` if no three elements in the list `l` sum up to zero.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (triples_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_24_largest_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_divisor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_24_largest_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_divisor))\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 10) 5 0.001)\n    (check-within (candidate 100) 50 0.001)\n    (check-within (candidate 49) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function largest_divisor(n)\n    for i=n-1, 1, -1 do\n        if n % i == 0 then\n            return i\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `largest_divisor` that takes an integer `n` and returns the largest divisor of `n` that is less than `n`. \n\nThe first line imports the math library. \n\nThe second line defines a function `largest_divisor` that takes an integer `n` as an argument. \n\nThe `for` loop in the function starts at `n-1`, decrements by 1, and stops at 1. \n\nThe `if` statement inside the loop checks if `n` is divisible by `i` (the current value of the loop variable). \n\nIf `n` is divisible by `i`, then `i` is the largest divisor of `n` that is less than `n`, so the function returns `i`. \n\nIf the loop completes without finding a divisor, then the function returns `nil`. \n\n\n### Racket version\n\n#lang racket\n\n(define (largest_divisor n)\n"
  },
  {
    "name": "HumanEval_19_sort_numbers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_numbers numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_19_sort_numbers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"three\") \"three\" 0.001)\n    (check-within (candidate \"three five nine\") \"three five nine\" 0.001)\n    (check-within (candidate \"five zero four seven nine eight\") \"zero four five seven eight nine\" 0.001)\n    (check-within (candidate \"six five four three two one zero\") \"zero one two three four five six\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_numbers(numbers)\n    local value_map = {\n        zero = 0,\n        one = 1,\n        two = 2,\n        three = 3,\n        four = 4,\n        five = 5,\n        six = 6,\n        seven = 7,\n        eight = 8,\n        nine = 9\n    }\n    local words = {}\n    for word in numbers:gmatch(\"%w+\") do\n        table.insert(words, word)\n    end\n    table.sort(words, function(a, b) return value_map[a] < value_map[b] end)\n    return table.concat(words, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of a function called `sort_numbers` which takes a string of space-separated words as input and returns a string of the same words sorted by their numerical value. The function works by first defining a table called `value_map` which maps each word to its numerical value. The function then splits the input string into individual words using a for loop and the `gmatch` function. The words are stored in a table called `words`. The function then sorts the `words` table using the `table.sort` function and a custom comparison function which compares the numerical values of the words using the `value_map` table. Finally, the function returns the sorted words as a single string with spaces between them using the `table.concat` function. \n\nThe first line of the code imports the `math` library which provides mathematical functions. \n\nThe second line of the code defines a local function called `sort_numbers` which takes a single argument called `numbers`. The `local` keyword means that the function is only accessible within the scope of the current block of code. \n\nThe third line of the code defines a table called `value_map` which maps each word to its numerical value. The numerical values are integers ranging from 0 to 9. \n\nThe fourth line of the code defines an empty table called `words`. \n\nThe fifth line of the code uses a for loop and the `gmatch` function to split the input string into individual words. The `%w+` pattern matches one or more alphanumeric characters. The `:gmatch` method is called on the `numbers` string to iterate over all matches of the pattern. Each match is stored in the `word` variable and is inserted into the `words` table using the `table.insert` function. \n\nThe sixth line of the code sorts the `words` table using the `table.sort` function. The second argument to `table.sort` is a custom comparison function which compares the numerical values of the words using the `value_map` table. The function returns `true` if the numerical value of `a` is less than the numerical value of `b`. \n\nThe seventh line of the code returns the sorted words as a single string with spaces between them using the `table.concat` function. The first argument to `table.concat` is the table to concatenate, and the second argument is the separator to use between elements. In this case, the separator is a single space character. \n\nOverall, the `sort_numbers` function takes a string of space-separated words, sorts the words by their numerical value, and returns the sorted words as a single string with spaces between them. \n\n\n### Racket version\n\n#lang racket\n\n(define (sort_numbers numbers)\n"
  },
  {
    "name": "HumanEval_73_smallest_change",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (smallest_change arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_73_smallest_change.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallest_change))\n    (check-within (candidate (list 1 2 3 5 4 7 9 6)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 3 2 2)) 1 0.001)\n    (check-within (candidate (list 1 4 2)) 1 0.001)\n    (check-within (candidate (list 1 4 4 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 3 1 1 3)) 0 0.001)\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 0 1)) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function smallest_change(arr)\n  local ans = 0\n  for i = 1, math.floor(#arr / 2) do\n    if arr[i] ~= arr[#arr - i + 1] then\n      ans = ans + 1\n    end\n  end\n  return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function called `smallest_change` that takes an array as input and returns the number of elements that need to be changed so that the array becomes a palindrome. \n\n1. `math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions and constants. \n\n2. `local function smallest_change(arr)` - This line defines a function called `smallest_change` that takes an array as input. The `local` keyword is used to define a local variable that is only accessible within the scope of the function. \n\n3. `local ans = 0` - This line initializes a variable called `ans` to 0. This variable will be used to keep track of the number of changes required to make the array a palindrome. \n\n4. `for i = 1, math.floor(#arr / 2) do` - This line starts a loop that iterates over the first half of the array. The `#arr` operator returns the length of the array. The `math.floor` function is used to round down the length of the array divided by 2. \n\n5. `if arr[i] ~= arr[#arr - i + 1] then` - This line checks if the element at index `i` is not equal to the element at the corresponding index in the second half of the array. If they are not equal, it means that a change is required to make the array a palindrome. \n\n6. `ans = ans + 1` - This line increments the `ans` variable by 1 if a change is required. \n\n7. `end` - This line marks the end of the `if` statement. \n\n8. `end` - This line marks the end of the `for` loop. \n\n9. `return ans` - This line returns the value of the `ans` variable, which represents the number of changes required to make the array a palindrome. \n\n\n### Racket version\n\n#lang racket\n\n(define (smallest_change arr)\n"
  },
  {
    "name": "HumanEval_52_below_threshold",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_threshold l t)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_52_below_threshold.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_threshold))\n    (check-within (candidate (list 1 2 4 10) 100) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 5) #f 0.001)\n    (check-within (candidate (list 1 20 4 10) 21) #t 0.001)\n    (check-within (candidate (list 1 20 4 10) 22) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 11) #t 0.001)\n    (check-within (candidate (list 1 8 4 10) 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function below_threshold(l, t)\n  for _, e in ipairs(l) do\n    if e >= t then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function called `below_threshold` that takes two arguments, `l` and `t`. `l` is a list of numbers and `t` is a number. The function returns `true` if all the elements in `l` are less than `t`, otherwise it returns `false`.\n\n* `math = require('math')` - This line loads the `math` module. The `math` module provides a set of mathematical operations and functions.\n* `local function below_threshold(l, t)` - This line defines a local function called `below_threshold` that takes two arguments, `l` and `t`.\n* `for _, e in ipairs(l) do` - This line starts a loop that iterates over each element in the list `l`. The `_` is a placeholder for the index of the element, which is not used in the loop. `e` is the actual element being iterated over.\n* `if e >= t then` - This line checks if the current element `e` is greater than or equal to `t`.\n* `return false` - This line returns `false` if the current element `e` is greater than or equal to `t`.\n* `end` - This line ends the `if` statement.\n* `end` - This line ends the `for` loop.\n* `return true` - This line returns `true` if all the elements in `l` are less than `t`. If any element is greater than or equal to `t`, the function would have already returned `false` and this line would not be executed. \n\n\n### Racket version\n\n#lang racket\n\n(define (below_threshold l t)\n"
  },
  {
    "name": "HumanEval_128_prod_signs",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prod_signs arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_128_prod_signs.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-within (candidate (list 1 2 2 -4)) -9 0.001)\n    (check-within (candidate (list 0 1)) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 3 -1 1)) -10 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 2 4 1 2 -1 -1 9)) 20 0.001)\n    (check-within (candidate (list -1 1 -1 1)) 4 0.001)\n    (check-within (candidate (list -1 1 1 1)) -4 0.001)\n    (check-within (candidate (list -1 1 1 0)) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n    local prod = 0\n    local neg_count = 0\n    for i = 1, #arr do\n        if arr[i] == 0 then\n            return 0\n        end\n        if arr[i] < 0 then\n            neg_count = neg_count + 1\n        end\n    end\n    prod = math.pow(-1, neg_count)\n    local sum = 0\n    for i = 1, #arr do\n        sum = sum + math.abs(arr[i])\n    end\n    return prod * sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `prod_signs` that takes an array of numbers as input and returns the product of the signs of the numbers multiplied by the sum of the absolute values of the numbers. \n\n1. `math = require('math')` imports the math library which provides mathematical functions like `pow` (power) and `abs` (absolute value).\n2. `local function prod_signs(arr)` defines a local function `prod_signs` that takes an array `arr` as input.\n3. `if #arr == 0 then` checks if the length of the array is 0, meaning it is empty. If it is, the function returns `nil`.\n4. `local prod = 0` initializes a local variable `prod` to 0.\n5. `local neg_count = 0` initializes a local variable `neg_count` to 0.\n6. `for i = 1, #arr do` loops through each element of the array.\n7. `if arr[i] == 0 then` checks if the current element is 0. If it is, the function returns 0.\n8. `if arr[i] < 0 then` checks if the current element is negative. If it is, `neg_count` is incremented by 1.\n9. `prod = math.pow(-1, neg_count)` calculates the product of the signs of the numbers by raising -1 to the power of `neg_count`.\n10. `local sum = 0` initializes a local variable `sum` to 0.\n11. `for i = 1, #arr do` loops through each element of the array again.\n12. `sum = sum + math.abs(arr[i])` calculates the sum of the absolute values of the numbers.\n13. `return prod * sum` returns the product of the signs of the numbers multiplied by the sum of the absolute values of the numbers. \n\n\n### Racket version\n\n#lang racket\n\n(define (prod_signs arr)\n"
  },
  {
    "name": "HumanEval_49_modp",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (modp n p)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_49_modp.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n    (check-within (candidate 3 5) 3 0.001)\n    (check-within (candidate 1101 101) 2 0.001)\n    (check-within (candidate 0 101) 1 0.001)\n    (check-within (candidate 3 11) 8 0.001)\n    (check-within (candidate 100 101) 1 0.001)\n    (check-within (candidate 30 5) 4 0.001)\n    (check-within (candidate 31 5) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function modp(n, p)\n    local ret = 1\n    for i=1, n do\n        ret = (2 * ret) % p\n    end\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of modular exponentiation. It calculates (2^n) % p, where n and p are input parameters. \n\n1. `math = require('math')` - This line imports the Lua math library which provides mathematical functions. It is assigned to the variable `math`.\n\n2. `local function modp(n, p)` - This line defines a local function called `modp` which takes two parameters `n` and `p`.\n\n3. `local ret = 1` - This line initializes a local variable `ret` to 1.\n\n4. `for i=1, n do` - This line starts a for loop that iterates from 1 to `n`.\n\n5. `ret = (2 * ret) % p` - This line updates the value of `ret` by multiplying it by 2 and taking the modulus of `p`.\n\n6. `end` - This line marks the end of the for loop.\n\n7. `return ret` - This line returns the final value of `ret` after the for loop has completed. \n\n\n### Racket version\n\n#lang racket\n\n(define (modp n p)\n"
  },
  {
    "name": "HumanEval_98_count_upper",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (count_upper s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_98_count_upper.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n    (check-within (candidate \"aBCdEf\") 1 0.001)\n    (check-within (candidate \"abcdefg\") 0 0.001)\n    (check-within (candidate \"dBBE\") 0 0.001)\n    (check-within (candidate \"B\") 0 0.001)\n    (check-within (candidate \"U\") 1 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"EEEE\") 2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function count_upper(s)\n    local count = 0\n    for i = 1, #s, 2 do\n        if s:sub(i, i):match(\"[AEIOU]\") then\n            count = count + 1\n        end\n    end\n    return count\nend\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of uppercase vowels in a string. \n\n1. `math = require('math')` - This line imports the math library into the program. The math library provides a set of mathematical functions for the program to use.\n\n2. `local function count_upper(s)` - This line defines a function called `count_upper` that takes a string `s` as its argument. The `local` keyword means that the function is only accessible within the scope of the current block.\n\n3. `local count = 0` - This line initializes a variable called `count` to 0. This variable will be used to keep track of the number of uppercase vowels in the string.\n\n4. `for i = 1, #s, 2 do` - This line starts a loop that iterates over the characters in the string `s`. The loop starts at index 1 and goes up to the length of the string `s`, incrementing by 2 each time. This means that the loop only looks at every other character in the string.\n\n5. `if s:sub(i, i):match(\"[AEIOU]\") then` - This line checks if the current character in the loop is an uppercase vowel. The `s:sub(i, i)` function call returns the character at index `i` in the string `s`. The `:match(\"[AEIOU]\")` function call checks if the character matches any of the uppercase vowels in the string.\n\n6. `count = count + 1` - This line increments the `count` variable by 1 if the current character is an uppercase vowel.\n\n7. `end` - This line marks the end of the `if` statement.\n\n8. `end` - This line marks the end of the `for` loop.\n\n9. `return count` - This line returns the final count of uppercase vowels in the string. \n\n\n### Racket version\n\n#lang racket\n\n(define (count_upper s)\n"
  },
  {
    "name": "HumanEval_97_multiply",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (multiply a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_97_multiply.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate multiply))\n    (check-within (candidate 148 412) 16 0.001)\n    (check-within (candidate 19 28) 72 0.001)\n    (check-within (candidate 2020 1851) 0 0.001)\n    (check-within (candidate 14 -15) 20 0.001)\n    (check-within (candidate 76 67) 42 0.001)\n    (check-within (candidate 17 27) 49 0.001)\n    (check-within (candidate 0 1) 0 0.001)\n    (check-within (candidate 0 0) 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function multiply(a, b)\n  return math.abs(a % 10) * math.abs(b % 10)\nend\n\n### Explanation\n\nThe code is an implementation of a function that multiplies the last digit of two numbers and returns the result. \n\n- `math = require('math')` imports the math library.\n- `local function multiply(a, b)` defines a function called `multiply` that takes two arguments, `a` and `b`.\n- `return math.abs(a % 10) * math.abs(b % 10)` returns the absolute value of the remainder of `a` divided by 10, multiplied by the absolute value of the remainder of `b` divided by 10. \n\nThe `math.abs` function is used to ensure that the result is positive, and the `%` operator is used to get the remainder of the division. \n\nThe function is defined as a local function, which means that it is only accessible within the scope of the current block of code. To use it, it would need to be called from another function or from the main body of the program. \n\nTo translate this program to Racket, we can use the `remainder` function to get the remainder of the division, and the `abs` function to get the absolute value of the result. Here is the equivalent Racket code:\n\n\n### Racket version\n\n#lang racket\n\n(define (multiply a b)\n"
  },
  {
    "name": "HumanEval_104_unique_digits",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (unique_digits x)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_104_unique_digits.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_digits))\n    (check-within (candidate (list 15 33 1422 1)) (list 1 15 33) 0.001)\n    (check-within (candidate (list 152 323 1422 10)) (list ) 0.001)\n    (check-within (candidate (list 12345 2033 111 151)) (list 111 151) 0.001)\n    (check-within (candidate (list 135 103 31)) (list 31 135) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function unique_digits(x)\n    local odd_digit_elements = {}\n    for i=1, #x do\n        if string.match(tostring(x[i]), '^[13579]+$') then\n            table.insert(odd_digit_elements, x[i])\n        end\n    end\n    table.sort(odd_digit_elements)\n    return odd_digit_elements\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an array of integers and returns an array of integers that have unique odd digits in ascending order. \n\n1. `math = require('math')` - This line imports the math library into the program. The math library provides a set of mathematical functions that can be used in the program.\n\n2. `local function unique_digits(x)` - This line defines a function called `unique_digits` that takes an array of integers as an argument. The `local` keyword is used to define a local variable that is only accessible within the scope of the function.\n\n3. `local odd_digit_elements = {}` - This line creates an empty table called `odd_digit_elements` that will be used to store the odd digit elements of the input array.\n\n4. `for i=1, #x do` - This line starts a loop that iterates over each element of the input array. The `#x` operator returns the length of the array.\n\n5. `if string.match(tostring(x[i]), '^[13579]+$') then` - This line checks if the current element of the input array has only odd digits. The `tostring` function is used to convert the integer to a string, and the `string.match` function is used to check if the string matches the regular expression `'^[13579]+$'`. This regular expression matches strings that only contain odd digits.\n\n6. `table.insert(odd_digit_elements, x[i])` - This line adds the current element of the input array to the `odd_digit_elements` table if it has only odd digits.\n\n7. `table.sort(odd_digit_elements)` - This line sorts the `odd_digit_elements` table in ascending order.\n\n8. `return odd_digit_elements` - This line returns the `odd_digit_elements` table as the output of the `unique_digits` function. \n\n\n### Racket version\n\n#lang racket\n\n(define (unique_digits x)\n"
  },
  {
    "name": "HumanEval_75_is_multiply_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_multiply_prime a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_multiply_prime))\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #f 0.001)\n    (check-within (candidate 125) #t 0.001)\n    (check-within (candidate 105) #t 0.001)\n    (check-within (candidate 126) #f 0.001)\n    (check-within (candidate 729) #f 0.001)\n    (check-within (candidate 891) #f 0.001)\n    (check-within (candidate 1001) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_multiply_prime(a)\n  local function is_prime(n)\n    for j = 2, n-1 do\n      if n%j == 0 then\n        return false\n      end\n    end\n    return true\n  end\n\n  for i = 2, 100 do\n    if not is_prime(i) then goto continue1 end\n    for j = 2, 100 do\n      if not is_prime(j) then goto continue2 end\n      for k = 2, 100 do\n        if not is_prime(k) then goto continue3 end\n        if i*j*k == a then return true end\n        ::continue3::\n      end\n      ::continue2::\n    end\n    ::continue1::\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_multiply_prime` that takes an integer `a` as input and returns a boolean indicating whether or not `a` is the product of three prime numbers. \n\nThe first line imports the `math` module which provides mathematical functions.\n\nThe second line defines a function `is_multiply_prime` that takes an integer `a` as input. \n\nThe function `is_multiply_prime` defines a nested function `is_prime` that takes an integer `n` as input and returns a boolean indicating whether or not `n` is a prime number. \n\nThe `is_prime` function iterates over all integers `j` from 2 to `n-1` and checks if `n` is divisible by `j`. If `n` is divisible by any `j`, then `n` is not a prime number and the function returns `false`. If the loop completes without finding a divisor, then `n` is a prime number and the function returns `true`.\n\nThe `is_multiply_prime` function then iterates over all integers `i` from 2 to 100. For each `i`, it checks if `i` is prime. If `i` is not prime, then it skips to the next iteration using the `goto` statement. If `i` is prime, then it iterates over all integers `j` from 2 to 100. For each `j`, it checks if `j` is prime. If `j` is not prime, then it skips to the next iteration using the `goto` statement. If `j` is prime, then it iterates over all integers `k` from 2 to 100. For each `k`, it checks if `k` is prime. If `k` is not prime, then it skips to the next iteration using the `goto` statement. If `k` is prime, then it checks if the product of `i`, `j`, and `k` is equal to `a`. If the product is equal to `a`, then the function returns `true`. If the loop completes without finding a product equal to `a`, then the function continues to the next iteration of the `j` loop using the `goto` statement. If the `j` loop completes without finding a product equal to `a`, then the function continues to the next iteration of the `i` loop using the `goto` statement. If the `i` loop completes without finding a product equal to `a`, then the function returns `false`. \n\nThe function `is_multiply_prime` returns `false` if it completes all iterations without finding a product equal to `a`. \n\nNote: The use of `goto` statements is generally discouraged in modern programming languages because it can make code difficult to read and understand. In this case, the `goto` statements are used to simulate nested loops with early exits, which can be more difficult to implement with standard loop constructs. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_multiply_prime a)\n"
  },
  {
    "name": "HumanEval_120_maximum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (maximum arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_120_maximum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n    (check-within (candidate (list -3 -4 5) 3) (list -4 -3 5) 0.001)\n    (check-within (candidate (list 4 -4 4) 2) (list 4 4) 0.001)\n    (check-within (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2) 0.001)\n    (check-within (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123) 0.001)\n    (check-within (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20) 0.001)\n    (check-within (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15) 0.001)\n    (check-within (candidate (list -1 0 2 5 3 -10) 2) (list 3 5) 0.001)\n    (check-within (candidate (list 1 0 5 -7) 1) (list 5) 0.001)\n    (check-within (candidate (list 4 -4) 2) (list -4 4) 0.001)\n    (check-within (candidate (list -10 10) 2) (list -10 10) 0.001)\n    (check-within (candidate (list 1 2 3 -23 243 -400 0) 0) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function maximum(arr, k)\n    if k == 0 then\n        return {}\n    end\n    table.sort(arr)\n    local ans = {}\n    for i=#arr-k+1, #arr do\n        table.insert(ans, arr[i])\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function that returns the k largest elements in an array. Here is a line by line explanation:\n\n\n### Racket version\n\n#lang racket\n\n(define (maximum arr k)\n"
  },
  {
    "name": "HumanEval_1_separate_paren_groups",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (separate_paren_groups paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_1_separate_paren_groups.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate separate_paren_groups))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list \"(()())\" \"((()))\" \"()\" \"((())()())\") 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list \"()\" \"(())\" \"((()))\" \"(((())))\") 0.001)\n    (check-within (candidate \"(()(())((())))\") (list \"(()(())((())))\") 0.001)\n    (check-within (candidate \"( ) (( )) (( )( ))\") (list \"()\" \"(())\" \"(()())\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function separate_paren_groups(paren_string)\n    local result = {}\n    local current_string = {}\n    local current_depth = 0\n\n    for i=1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n            current_depth = current_depth + 1\n            table.insert(current_string, c)\n        elseif c == ')' then\n            current_depth = current_depth - 1\n            table.insert(current_string, c)\n\n            if current_depth == 0 then\n                table.insert(result, table.concat(current_string))\n                current_string = {}\n            end\n        end\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that separates a string of parentheses into groups. The function takes a string of parentheses as input and returns a table of strings, where each string is a group of parentheses.\n\nThe first line of the code imports the math library.\n\nThe second line of the code defines a local function called `separate_paren_groups` that takes a single argument called `paren_string`.\n\nThe third line of the code initializes an empty table called `result`.\n\nThe fourth line of the code initializes an empty table called `current_string`.\n\nThe fifth line of the code initializes a variable called `current_depth` to 0.\n\nThe sixth line of the code starts a for loop that iterates over each character in the `paren_string`.\n\nThe seventh line of the code gets the character at the current index of the `paren_string`.\n\nThe eighth line of the code checks if the character is an opening parenthesis.\n\nThe ninth line of the code increments the `current_depth` variable by 1.\n\nThe tenth line of the code adds the current character to the `current_string` table.\n\nThe eleventh line of the code checks if the character is a closing parenthesis.\n\nThe twelfth line of the code decrements the `current_depth` variable by 1.\n\nThe thirteenth line of the code adds the current character to the `current_string` table.\n\nThe fourteenth line of the code checks if the `current_depth` variable is 0.\n\nThe fifteenth line of the code adds the current `current_string` table to the `result` table as a concatenated string.\n\nThe sixteenth line of the code initializes the `current_string` table to an empty table.\n\nThe seventeenth line of the code ends the if statement.\n\nThe eighteenth line of the code ends the for loop.\n\nThe nineteenth line of the code returns the `result` table.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (separate_paren_groups paren_string)\n"
  },
  {
    "name": "HumanEval_22_filter_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_integers values)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_22_filter_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9) 0.001)\n    (check-within (candidate (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_integers(values)\n  local result = {}\n  for _, x in ipairs(values) do\n    if type(x) == 'number' and math.floor(x) == x then\n      table.insert(result, x)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that filters integers from a list of values. Here is a line-by-line explanation of the code:\n\n1. `math = require('math')` - This line imports the math module in Lua and assigns it to a variable called `math`. This module provides mathematical functions and constants.\n2. `local function filter_integers(values)` - This line defines a local function called `filter_integers` that takes a single parameter called `values`. The `local` keyword means that the function is only accessible within the scope of the current block of code.\n3. `local result = {}` - This line initializes an empty table called `result` that will be used to store the filtered integers.\n4. `for _, x in ipairs(values) do` - This line starts a loop that iterates over each value in the `values` list. The `_` is a placeholder variable that is used to ignore the index of the current value.\n5. `if type(x) == 'number' and math.floor(x) == x then` - This line checks if the current value `x` is a number and if its floor value is equal to itself. This is a way to check if `x` is an integer.\n6. `table.insert(result, x)` - This line adds the current value `x` to the `result` table if it is an integer.\n7. `end` - This line ends the `if` statement.\n8. `end` - This line ends the `for` loop.\n9. `return result` - This line returns the `result` table containing the filtered integers. \n\n\n### Racket version\n\n#lang racket\n\n(define (filter_integers values)\n"
  },
  {
    "name": "HumanEval_94_skjkasdkd",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (skjkasdkd lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_94_skjkasdkd.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate skjkasdkd))\n    (check-within (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10 0.001)\n    (check-within (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25 0.001)\n    (check-within (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13 0.001)\n    (check-within (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11 0.001)\n    (check-within (candidate (list 0 81 12 3 1 21)) 3 0.001)\n    (check-within (candidate (list 0 8 1 2 1 7)) 7 0.001)\n    (check-within (candidate (list 8191)) 19 0.001)\n    (check-within (candidate (list 8191 123456 127 7)) 19 0.001)\n    (check-within (candidate (list 127 97 8192)) 10 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function skjkasdkd(lst)\n  local function isPrime(n)\n    for i = 2, math.floor(n^0.5) do\n      if n % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local maxx = 0\n  local i = 1\n  while i <= #lst do\n    if lst[i] > maxx and isPrime(lst[i]) then\n      maxx = lst[i]\n    end\n    i = i + 1\n  end\n  local result = 0\n  for digit in tostring(maxx):gmatch('%d') do\n    result = result + tonumber(digit)\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `skjkasdkd` that takes a list of integers and returns the sum of the digits of the largest prime number in the list. \n\n\n### Racket version\n\n#lang racket\n\n(define (skjkasdkd lst)\n"
  },
  {
    "name": "HumanEval_74_total_match",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (total_match lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_74_total_match.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate total_match))\n    (check-within (candidate (list ) (list )) (list ) 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\")) (list \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hi\" \"hi\" \"admin\" \"project\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list \"4\") (list \"1\" \"2\" \"3\" \"4\" \"5\")) (list \"4\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"Hi\")) (list \"hI\" \"Hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hi\")) (list \"hI\" \"hi\" \"hi\") 0.001)\n    (check-within (candidate (list \"hi\" \"admin\") (list \"hI\" \"hi\" \"hii\")) (list \"hi\" \"admin\") 0.001)\n    (check-within (candidate (list ) (list \"this\")) (list ) 0.001)\n    (check-within (candidate (list \"this\") (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function total_match(lst1, lst2)\n    local l1 = 0\n    for i = 1, #lst1 do\n        l1 = l1 + #lst1[i]\n    end\n\n    local l2 = 0\n    for i = 1, #lst2 do\n        l2 = l2 + #lst2[i]\n    end\n\n    if l1 <= l2 then\n        return lst1\n    else\n        return lst2\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `total_match` that takes two lists as input and returns one of them based on the total length of the strings in each list. \n\nThe first line imports the math library.\n\nThe second line defines the function `total_match` which takes two lists as input.\n\nThe third line initializes a variable `l1` to 0.\n\nThe fourth line starts a loop that iterates over each element of `lst1` from 1 to the length of `lst1`. \n\nThe fifth line increments `l1` by the length of the current element of `lst1`.\n\nThe sixth line initializes a variable `l2` to 0.\n\nThe seventh line starts a loop that iterates over each element of `lst2` from 1 to the length of `lst2`.\n\nThe eighth line increments `l2` by the length of the current element of `lst2`.\n\nThe ninth line compares `l1` and `l2`. If `l1` is less than or equal to `l2`, the function returns `lst1`. Otherwise, it returns `lst2`. \n\nThe function is written in a way that is easy to understand and can be easily translated to other programming languages. \n\n\n### Racket version\n\n#lang racket\n\n(define (total_match lst1 lst2)\n"
  },
  {
    "name": "HumanEval_41_car_race_collision",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (car_race_collision n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_41_car_race_collision.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate car_race_collision))\n    (check-within (candidate 2) 4 0.001)\n    (check-within (candidate 3) 9 0.001)\n    (check-within (candidate 4) 16 0.001)\n    (check-within (candidate 8) 64 0.001)\n    (check-within (candidate 10) 100 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function car_race_collision(n)\n    return n^2\nend\n\n### Explanation\n\nThe code is an implementation of a function `car_race_collision` that takes a number `n` as input and returns `n^2`. The first line of the code imports the `math` module. The `math` module is a standard Lua library that provides mathematical functions and constants. The second line of the code defines a function `car_race_collision` that takes a single argument `n`. The function returns the square of the input `n`. The `^` operator in Lua is used to raise a number to a power. In this case, `n^2` is equivalent to `n * n`. The function is defined as a local function, which means that it is only accessible within the scope of the block of code in which it is defined. \n\n\n### Racket version\n\n#lang racket\n\n(define (car_race_collision n)\n"
  },
  {
    "name": "HumanEval_76_is_simple_power",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_simple_power x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_76_is_simple_power.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n    (check-within (candidate 16 2) #t 0.001)\n    (check-within (candidate 143214 16) #f 0.001)\n    (check-within (candidate 4 2) #t 0.001)\n    (check-within (candidate 9 3) #t 0.001)\n    (check-within (candidate 16 4) #t 0.001)\n    (check-within (candidate 24 2) #f 0.001)\n    (check-within (candidate 128 4) #f 0.001)\n    (check-within (candidate 12 6) #f 0.001)\n    (check-within (candidate 1 1) #t 0.001)\n    (check-within (candidate 1 12) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_simple_power(x, n)\n    if n == 1 then\n        return x == 1\n    end\n    local power = 1\n    while power < x do\n        power = power * n\n    end\n    return power == x\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if a given number `x` is a power of another number `n`. \n\n1. `math = require('math')` - This line imports the math library into the program. The math library provides a set of mathematical functions and constants. \n\n2. `local function is_simple_power(x, n)` - This line defines a function called `is_simple_power` that takes two arguments, `x` and `n`. The `local` keyword means that the function is only accessible within the scope of the current block.\n\n3. `if n == 1 then` - This line checks if `n` is equal to 1.\n\n4. `return x == 1` - This line returns `true` if `x` is equal to 1 and `false` otherwise.\n\n5. `local power = 1` - This line initializes a local variable called `power` to 1.\n\n6. `while power < x do` - This line starts a loop that continues as long as `power` is less than `x`.\n\n7. `power = power * n` - This line multiplies `power` by `n` in each iteration of the loop.\n\n8. `return power == x` - This line returns `true` if `power` is equal to `x` and `false` otherwise. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_simple_power x n)\n"
  },
  {
    "name": "HumanEval_93_encode",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encode message)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_93_encode.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n    (check-within (candidate \"TEST\") \"tgst\" 0.001)\n    (check-within (candidate \"Mudasir\") \"mWDCSKR\" 0.001)\n    (check-within (candidate \"YES\") \"ygs\" 0.001)\n    (check-within (candidate \"This is a message\") \"tHKS KS C MGSSCGG\" 0.001)\n    (check-within (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function encode(message)\n  local vowels = \"aeiouAEIOU\"\n  local vowels_replace = {}\n  for i = 1, #vowels do\n    vowels_replace[vowels:sub(i, i)] = string.char(string.byte(vowels:sub(i, i)) + 2)\n  end\n  message = message:gsub(\"%a\", function(c)\n    return c == c:upper() and c:lower() or c:upper()\n  end)\n  return message:gsub(\".\", function(c)\n    return vowels_replace[c] or c\n  end)\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a string as input and returns a modified version of the string. The function is called `encode` and is defined using the `local` keyword, which means that it is only visible within the scope of the current block.\n\nThe first line of the function imports the `math` module, which provides access to various mathematical functions.\n\nThe next few lines define a table called `vowels_replace`, which will be used to replace vowels in the input string. The table is populated by iterating over each character in the string `vowels`, which contains all the vowels in the English language (both upper and lower case). For each vowel, the corresponding ASCII code is incremented by 2 and converted back to a character using `string.char()`. The resulting character is then stored in the `vowels_replace` table with the vowel as the key.\n\nThe next line of the function uses the `gsub()` function to replace all alphabetic characters in the input string with their opposite case. This is done using a function that takes a single character as input and returns the opposite case of that character. If the character is uppercase, it is converted to lowercase, and vice versa.\n\nThe final line of the function uses `gsub()` again to replace each character in the input string with its corresponding value in the `vowels_replace` table, if it exists. If the character is not a vowel, it is left unchanged.\n\nOverall, the `encode()` function takes an input string, replaces all vowels with characters that are two ASCII codes higher, and swaps the case of all alphabetic characters. The resulting string is returned as output.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (encode message)\n"
  },
  {
    "name": "HumanEval_42_incr_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (incr_list l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_42_incr_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate incr_list))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 4 3 2) 0.001)\n    (check-within (candidate (list 5 2 5 2 3 3 9 0 123)) (list 6 3 6 3 4 4 10 1 124) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function incr_list(l)\n  local res = {}\n  for i = 1, #l do\n    res[i] = l[i] + 1\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function called `incr_list` that takes a list of numbers and returns a new list with each element incremented by 1. \n\n1. `math = require('math')` - This line imports the math library which provides mathematical functions and constants. The `require` function is used to load a module in Lua. In this case, it loads the math module and assigns it to the variable `math`.\n\n2. `local function incr_list(l)` - This line defines a local function called `incr_list` that takes a single argument `l`.\n\n3. `local res = {}` - This line creates a new empty table called `res` which will be used to store the incremented values.\n\n4. `for i = 1, #l do` - This line starts a loop that will iterate over the indices of the input list `l`. The `#` operator is used to get the length of the list.\n\n5. `res[i] = l[i] + 1` - This line sets the `i`th element of `res` to be the `i`th element of `l` incremented by 1.\n\n6. `end` - This line ends the loop.\n\n7. `return res` - This line returns the new list `res` with each element incremented by 1. \n\n\n### Racket version\n\n#lang racket\n\n(define (incr_list l)\n"
  },
  {
    "name": "HumanEval_27_flip_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (flip_case string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_27_flip_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hello!\") \"hELLO!\" 0.001)\n    (check-within (candidate \"These violent delights have violent ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function flip_case(string)\n    return string:gsub(\"%a\", function(c) return c:match(\"%l\") and c:upper() or c:lower() end)\nend\n\n### Explanation\n\nThe code is an implementation of a function called `flip_case` that takes a string as input and returns the string with the case of each letter flipped. \n\n1. `math = require('math')` - This line imports the `math` module. This module provides a set of mathematical functions that can be used in the program.\n2. `local function flip_case(string)` - This line defines a function called `flip_case` that takes a string as input. The `local` keyword means that the function is only accessible within the scope of the current block of code.\n3. `return string:gsub(\"%a\", function(c) return c:match(\"%l\") and c:upper() or c:lower() end)` - This line is the body of the `flip_case` function. It uses the `gsub` function to replace all alphabetical characters in the input string with their flipped case. \n    * `string:gsub(\"%a\", ...)` - This is a string method that replaces all occurrences of a pattern in the string with a replacement. `%a` is a pattern that matches any alphabetical character. \n    * `function(c) return c:match(\"%l\") and c:upper() or c:lower() end` - This is a function that takes a single character as input and returns the flipped case of that character. \n        * `c:match(\"%l\")` - This is a string method that returns true if the character is lowercase and false otherwise. \n        * `c:upper()` - This is a string method that returns the uppercase version of the character. \n        * `c:lower()` - This is a string method that returns the lowercase version of the character. \n    * The `and` and `or` operators are used to conditionally return the uppercase or lowercase version of the character based on whether it is originally lowercase or uppercase. \n\n\n### Racket version\n\n#lang racket\n\n(define (flip_case string)\n"
  },
  {
    "name": "HumanEval_64_vowels_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (vowels_count s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_64_vowels_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate vowels_count))\n    (check-within (candidate \"abcde\") 2 0.001)\n    (check-within (candidate \"Alone\") 3 0.001)\n    (check-within (candidate \"key\") 2 0.001)\n    (check-within (candidate \"bye\") 1 0.001)\n    (check-within (candidate \"keY\") 2 0.001)\n    (check-within (candidate \"bYe\") 1 0.001)\n    (check-within (candidate \"ACEDY\") 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function vowels_count(s)\n  local vowels = \"aeiouAEIOU\"\n  local n_vowels = 0\n  for i = 1, #s do\n    if string.find(vowels, s:sub(i, i), 1, true) then\n      n_vowels = n_vowels + 1\n    end\n  end\n  if s:sub(-1) == 'y' or s:sub(-1) == 'Y' then\n    n_vowels = n_vowels + 1\n  end\n  return n_vowels\nend\n\n### Explanation\n\nThe code is an implementation of a function that counts the number of vowels in a string. \n\nThe first line imports the math library.\n\nThe second line defines a function called `vowels_count` that takes a string `s` as input.\n\nThe third line defines a string variable `vowels` that contains all the vowels in the English alphabet, both uppercase and lowercase.\n\nThe fourth line defines an integer variable `n_vowels` and initializes it to 0.\n\nThe fifth line starts a loop that iterates over each character in the input string `s`. The loop is controlled by the `for` statement, which takes three arguments: the loop variable `i`, which starts at 1 and goes up to the length of the string `s`; the length of the string `s`, which is obtained using the `#` operator; and the step size, which is omitted and defaults to 1. \n\nThe sixth line checks if the current character is a vowel. It does this by calling the `string.find` function, which takes four arguments: the string to search in, the pattern to search for, the starting position, and a boolean flag that specifies whether to use plain text or pattern matching. In this case, the pattern is the `vowels` string, the starting position is the current index `i`, and the flag is `true`, which means to use plain text matching. If the function returns a non-nil value, then the current character is a vowel, so the `n_vowels` variable is incremented by 1.\n\nThe seventh line checks if the last character of the string is a 'y' or 'Y'. If it is, then it is counted as a vowel, so the `n_vowels` variable is incremented by 1.\n\nThe eighth line returns the final count of vowels in the string. \n\nTo rewrite this program in Racket, we can use the following code:\n\n\n### Racket version\n\n#lang racket\n\n(define (vowels_count s)\n"
  },
  {
    "name": "HumanEval_101_words_string",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (words_string s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_101_words_string.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_string))\n    (check-within (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\" \"is\" \"John\") 0.001)\n    (check-within (candidate \"One, two, three, four, five, six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\") 0.001)\n    (check-within (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\") 0.001)\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function words_string(s)\n    if not s then\n        return {}\n    end\n\n    local s_list = {}\n\n    for i=1, #s do\n        local letter = s:sub(i, i)\n        if letter == ',' then\n            table.insert(s_list, ' ')\n        else\n            table.insert(s_list, letter)\n        end\n    end\n\n    s_list = table.concat(s_list)\n    local words = {}\n    for word in s_list:gmatch(\"%S+\") do\n        table.insert(words, word)\n    end\n    return words\nend\n\n### Explanation\n\nThe code is an implementation of a function called `words_string` that takes a string as an argument and returns a list of words in the string. Here is a line-by-line explanation of the code:\n\n\n### Racket version\n\n#lang racket\n\n(define (words_string s)\n"
  },
  {
    "name": "HumanEval_107_even_odd_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (even_odd_palindrome n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_107_even_odd_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_palindrome))\n    (check-within (candidate 123) (list 8 13) 0.001)\n    (check-within (candidate 12) (list 4 6) 0.001)\n    (check-within (candidate 3) (list 1 2) 0.001)\n    (check-within (candidate 63) (list 6 8) 0.001)\n    (check-within (candidate 25) (list 5 6) 0.001)\n    (check-within (candidate 19) (list 4 6) 0.001)\n    (check-within (candidate 9) (list 4 5) 0.001)\n    (check-within (candidate 1) (list 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_palindrome(n)\n    local function is_palindrome(n)\n        return tostring(n) == string.reverse(tostring(n))\n    end\n\n    local even_palindrome_count = 0\n    local odd_palindrome_count = 0\n\n    for i=1, n do\n        if i%2 == 1 and is_palindrome(i) then\n            odd_palindrome_count = odd_palindrome_count + 1\n        elseif i%2 == 0 and is_palindrome(i) then\n            even_palindrome_count = even_palindrome_count + 1\n        end\n    end\n    return {even_palindrome_count, odd_palindrome_count}\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a number `n` and returns a list of two numbers: the number of even palindromes and the number of odd palindromes between 1 and `n` (inclusive). \n\n\n### Racket version\n\n#lang racket\n\n(define (even_odd_palindrome n)\n"
  },
  {
    "name": "HumanEval_71_triangle_area",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (triangle_area a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_71_triangle_area.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n    (check-within (candidate 3 4 5) 6.0 0.001)\n    (check-within (candidate 1 2 10) -1 0.001)\n    (check-within (candidate 4 8 5) 8.18 0.001)\n    (check-within (candidate 2 2 2) 1.73 0.001)\n    (check-within (candidate 1 2 3) -1 0.001)\n    (check-within (candidate 10 5 7) 16.25 0.001)\n    (check-within (candidate 2 6 3) -1 0.001)\n    (check-within (candidate 1 1 1) 0.43 0.001)\n    (check-within (candidate 2 2 10) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function triangle_area(a, b, c)\n    if a + b <= c or a + c <= b or b + c <= a then\n        return -1 \n    end\n    s = (a + b + c)/2    \n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    area = math.floor(area * 100 + 0.5) / 100\n    return area\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates the area of a triangle given the lengths of its sides. \n\n`math = require('math')` - This line imports the math library, which provides mathematical functions and constants. \n\n`local function triangle_area(a, b, c)` - This line defines a function called `triangle_area` that takes three arguments, `a`, `b`, and `c`. The `local` keyword means that the function is only accessible within the scope of the current block. \n\n`if a + b <= c or a + c <= b or b + c <= a then` - This line checks if the input values form a valid triangle. If the sum of any two sides is less than or equal to the third side, then the values do not form a valid triangle. \n\n`return -1` - If the input values do not form a valid triangle, the function returns -1. \n\n`s = (a + b + c)/2` - This line calculates the semiperimeter of the triangle, which is half the sum of its sides. \n\n`area = math.sqrt(s * (s - a) * (s - b) * (s - c))` - This line calculates the area of the triangle using Heron's formula, which is based on the semiperimeter and the lengths of the sides. \n\n`area = math.floor(area * 100 + 0.5) / 100` - This line rounds the area to two decimal places by multiplying it by 100, adding 0.5, flooring the result, and then dividing by 100. \n\n`return area` - This line returns the calculated area of the triangle. \n\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a b c)\n"
  },
  {
    "name": "HumanEval_95_check_dict_case",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_dict_case dict)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_95_check_dict_case.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f 0.001)\n    (check-within (candidate #hash((\"p\" .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f 0.001)\n    (check-within (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f 0.001)\n    (check-within (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t 0.001)\n    (check-within (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t 0.001)\n    (check-within (candidate #hash()) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function check_dict_case(dict)\n    if next(dict) == nil then\n        return false\n    else\n        local state = \"start\"\n        for key, value in pairs(dict) do\n            if type(key) ~= \"string\" then\n                state = \"mixed\"\n                break\n            end\n            if state == \"start\" then\n                if key:upper() == key then\n                    state = \"upper\"\n                elseif key:lower() == key then\n                    state = \"lower\"\n                else\n                    break\n                end\n            elseif (state == \"upper\" and key:upper() ~= key) or (state == \"lower\" and key:lower() ~= key) then\n                state = \"mixed\"\n                break\n            end\n        end\n        return state == \"upper\" or state == \"lower\"\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `check_dict_case` that takes a dictionary as an argument and returns a boolean indicating whether the keys of the dictionary are all in uppercase or all in lowercase. \n\n1. `math = require('math')`: This line loads the `math` library in Lua and assigns it to a variable `math`. The `math` library provides mathematical functions in Lua.\n\n2. `local function check_dict_case(dict)`: This line defines a local function `check_dict_case` that takes a dictionary as an argument. The `local` keyword makes the function only accessible within the scope of the file or block it is defined in.\n\n3. `if next(dict) == nil then`: This line checks if the dictionary is empty. The `next` function returns the next key-value pair in the dictionary, or `nil` if there are no more pairs. If `next(dict)` returns `nil`, then the dictionary is empty.\n\n4. `return false`: This line returns `false` if the dictionary is empty.\n\n5. `else`: This line is executed if the dictionary is not empty.\n\n6. `local state = \"start\"`: This line initializes a local variable `state` to `\"start\"`. The `state` variable is used to keep track of the case of the keys in the dictionary.\n\n7. `for key, value in pairs(dict) do`: This line starts a loop that iterates over the key-value pairs in the dictionary. The `pairs` function returns an iterator that iterates over the key-value pairs in the dictionary.\n\n8. `if type(key) ~= \"string\" then`: This line checks if the type of the key is not a string. The `type` function returns the type of a value.\n\n9. `state = \"mixed\"`: This line sets the `state` variable to `\"mixed\"` if the type of the key is not a string.\n\n10. `break`: This line breaks out of the loop if the type of the key is not a string.\n\n11. `if state == \"start\" then`: This line checks if the `state` variable is `\"start\"`. If it is, then this is the first key in the dictionary.\n\n12. `if key:upper() == key then`: This line checks if the key is all uppercase. The `:upper()` method returns a string with all characters in uppercase.\n\n13. `state = \"upper\"`: This line sets the `state` variable to `\"upper\"` if the key is all uppercase.\n\n14. `elseif key:lower() == key then`: This line checks if the key is all lowercase. The `:lower()` method returns a string with all characters in lowercase.\n\n15. `state = \"lower\"`: This line sets the `state` variable to `\"lower\"` if the key is all lowercase.\n\n16. `else`: This line is executed if the key is not all uppercase or all lowercase.\n\n17. `break`: This line breaks out of the loop if the key is not all uppercase or all lowercase.\n\n18. `elseif (state == \"upper\" and key:upper() ~= key) or (state == \"lower\" and key:lower() ~= key) then`: This line checks if the `state` variable is `\"upper\"` or `\"lower\"`, and if the key is not all uppercase or all lowercase.\n\n19. `state = \"mixed\"`: This line sets the `state` variable to `\"mixed\"` if the key is not all uppercase or all lowercase.\n\n20. `break`: This line breaks out of the loop if the key is not all uppercase or all lowercase.\n\n21. `return state == \"\n\n### Racket version\n\n#lang racket\n\n(define (check_dict_case dict)\n"
  },
  {
    "name": "HumanEval_47_median",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (median l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_47_median.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate median))\n    (check-within (candidate (list 3 1 2 4 5)) 3 0.001)\n    (check-within (candidate (list -10 4 6 1000 10 20)) 8.0 0.001)\n    (check-within (candidate (list 5)) 5 0.001)\n    (check-within (candidate (list 6 5)) 5.5 0.001)\n    (check-within (candidate (list 8 1 3 9 9 2 7)) 7 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function median(l)\n  table.sort(l)\n  if #l % 2 == 1 then\n    return l[math.floor(#l / 2) + 1]\n  else\n    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n  end\nend\n\n### Explanation\n\nThe code is an implementation of a function to calculate the median of a list of numbers.\n\n1. `math = require('math')` - This line imports the math module which provides mathematical functions and constants. It assigns the module to the variable `math`.\n\n2. `local function median(l)` - This line defines a function `median` that takes a list of numbers as an argument. The `local` keyword makes the function only accessible within the scope of the current block.\n\n3. `table.sort(l)` - This line sorts the list `l` in ascending order using the `sort` function provided by the `table` module.\n\n4. `if #l % 2 == 1 then` - This line checks if the length of the list `l` is odd. The `#` operator returns the length of a table. The `%` operator returns the remainder of a division.\n\n5. `return l[math.floor(#l / 2) + 1]` - This line returns the middle element of the sorted list if the length of the list is odd. The `math.floor` function rounds down to the nearest integer. The `+ 1` is necessary because Lua tables are 1-indexed.\n\n6. `return (l[#l / 2] + l[#l / 2 + 1]) / 2` - This line returns the average of the two middle elements of the sorted list if the length of the list is even. The `#` operator returns the length of a table. The `/` operator performs division. The `+` operator performs addition. Lua tables are 1-indexed, so we need to add 1 to the index of the second middle element. \n\nTo rewrite this program in Racket, we can use the `sort` function from the `racket/list` module and the `exact-integer?` function to check if the length of the list is odd.\n\n\n### Racket version\n\n#lang racket\n\n(define (median l)\n"
  },
  {
    "name": "HumanEval_44_change_base",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (change_base x base)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_44_change_base.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n    (check-within (candidate 8 3) \"22\" 0.001)\n    (check-within (candidate 9 3) \"100\" 0.001)\n    (check-within (candidate 234 2) \"11101010\" 0.001)\n    (check-within (candidate 16 2) \"10000\" 0.001)\n    (check-within (candidate 8 2) \"1000\" 0.001)\n    (check-within (candidate 7 2) \"111\" 0.001)\n    (check-within (candidate 2 3) \"2\" 0.001)\n    (check-within (candidate 3 4) \"3\" 0.001)\n    (check-within (candidate 4 5) \"4\" 0.001)\n    (check-within (candidate 5 6) \"5\" 0.001)\n    (check-within (candidate 6 7) \"6\" 0.001)\n    (check-within (candidate 7 8) \"7\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function change_base(x, base)\n  local ret = \"\"\n  while x > 0 do\n    ret = tostring(x % base) .. ret\n    x = math.floor(x / base)\n  end\n  return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function called `change_base` that takes two arguments, `x` and `base`, and returns a string representation of `x` in the given `base`.\n\nThe first line of the program imports the `math` module, which provides mathematical functions and constants.\n\nThe second line of the program defines a function called `change_base` that takes two arguments, `x` and `base`. The function is defined as a local function, which means that it is only accessible within the scope of the block of code in which it is defined.\n\nThe third line of the program initializes a local variable called `ret` to an empty string.\n\nThe fourth line of the program starts a while loop that continues as long as `x` is greater than 0. The body of the loop consists of two statements:\n\n1. The first statement appends the remainder of `x` divided by `base` to the beginning of the `ret` string. The `tostring` function is used to convert the remainder to a string before appending it to `ret`.\n\n2. The second statement updates the value of `x` to be the result of `x` divided by `base`, rounded down to the nearest integer using the `math.floor` function.\n\nThe fifth line of the program returns the final value of `ret`, which is the string representation of `x` in the given `base`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (change_base x base)\n"
  },
  {
    "name": "HumanEval_12_longest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (longest strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_12_longest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"x\" 0.001)\n    (check-within (candidate (list \"x\" \"yyy\" \"zzzz\" \"www\" \"kkkk\" \"abc\")) \"zzzz\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function longest(strings)\n    if not strings then\n        return nil\n    end\n\n    local maxlen = 0\n    for _, s in ipairs(strings) do\n        maxlen = math.max(maxlen, #s)\n    end\n\n    for _, s in ipairs(strings) do\n        if #s == maxlen then\n            return s\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `longest` that takes a list of strings and returns the longest string in the list. \n\nThe first line of the program imports the `math` module. This module provides a set of mathematical functions that can be used in Lua programs.\n\nThe second line of the program defines a local function called `longest` that takes a single argument called `strings`. The `local` keyword is used to define a function that is only accessible within the scope of the current block of code. \n\nThe third line of the program checks if the `strings` argument is `nil`. If it is, the function returns `nil`.\n\nThe fourth line of the program initializes a variable called `maxlen` to 0. This variable will be used to keep track of the length of the longest string in the list.\n\nThe fifth line of the program starts a loop that iterates over each string in the `strings` list. The `ipairs` function is used to iterate over the list. The `_` variable is used to ignore the index of each string in the list. The `s` variable is used to refer to each string in the list.\n\nThe sixth line of the program uses the `math.max` function to update the value of `maxlen` to be the maximum value between `maxlen` and the length of the current string `s`. The `#` operator is used to get the length of the string.\n\nThe seventh line of the program starts another loop that iterates over each string in the `strings` list.\n\nThe eighth line of the program checks if the length of the current string `s` is equal to `maxlen`. If it is, the function returns the current string `s`.\n\nIf none of the strings in the list have a length equal to `maxlen`, the function returns `nil`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (longest strings)\n"
  },
  {
    "name": "HumanEval_58_common",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (common l1 l2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_58_common.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n    (check-within (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653) 0.001)\n    (check-within (candidate (list 5 3 2 8) (list 3 2)) (list 2 3) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 8) (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function common(l1, l2)\n    local ret = {}\n    local set_l2 = {}\n    for i=1, #l2 do\n        set_l2[l2[i]] = true\n    end\n    for i=1, #l1 do\n        if set_l2[l1[i]] then\n            table.insert(ret, l1[i])\n        end\n    end\n    table.sort(ret)\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function `common` that takes two lists `l1` and `l2` as input and returns a sorted list of elements that are common to both lists. \n\n1. `math = require('math')` - This line imports the math library in Lua and assigns it to the variable `math`. The math library provides a set of mathematical functions and constants in Lua.\n\n2. `local function common(l1, l2)` - This line defines a local function `common` that takes two arguments `l1` and `l2`.\n\n3. `local ret = {}` - This line initializes an empty table `ret` that will be used to store the common elements.\n\n4. `local set_l2 = {}` - This line initializes an empty table `set_l2` that will be used to store the elements of `l2`.\n\n5. `for i=1, #l2 do` - This line starts a loop that iterates over the elements of `l2`.\n\n6. `set_l2[l2[i]] = true` - This line adds the element `l2[i]` to the `set_l2` table and sets its value to `true`. This creates a set of unique elements in `l2`.\n\n7. `for i=1, #l1 do` - This line starts a loop that iterates over the elements of `l1`.\n\n8. `if set_l2[l1[i]] then` - This line checks if the element `l1[i]` is present in the `set_l2` table.\n\n9. `table.insert(ret, l1[i])` - This line adds the element `l1[i]` to the `ret` table if it is present in both `l1` and `l2`.\n\n10. `table.sort(ret)` - This line sorts the `ret` table in ascending order.\n\n11. `return ret` - This line returns the sorted list of common elements. \n\n\n### Racket version\n\n#lang racket\n\n(define (common l1 l2)\n"
  },
  {
    "name": "HumanEval_154_cycpattern_check",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (cycpattern_check a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_154_cycpattern_check.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n    (check-within (candidate \"xyzw\" \"xyw\") #f 0.001)\n    (check-within (candidate \"yello\" \"ell\") #t 0.001)\n    (check-within (candidate \"whattup\" \"ptut\") #f 0.001)\n    (check-within (candidate \"efef\" \"fee\") #t 0.001)\n    (check-within (candidate \"abab\" \"aabb\") #f 0.001)\n    (check-within (candidate \"winemtt\" \"tinem\") #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function cycpattern_check(a, b)\n  local l = #b\n  local pat = b .. b\n  for i = 1, #a - l + 1 do\n    for j = 1, l + 1 do\n      if a:sub(i, i + l - 1) == pat:sub(j, j + l - 1) then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `cycpattern_check` that checks if a string `a` contains a cyclic pattern of another string `b`. \n\nThe first line imports the math library. \n\nThe second line defines a function called `cycpattern_check` that takes two arguments `a` and `b`. \n\nThe third line creates a local variable `l` that is equal to the length of string `b`. \n\nThe fourth line creates a local variable `pat` that is equal to the concatenation of string `b` with itself. \n\nThe fifth line starts a loop that iterates from `1` to the length of string `a` minus `l` plus `1`. \n\nThe sixth line starts a nested loop that iterates from `1` to `l` plus `1`. \n\nThe seventh line checks if a substring of `a` starting from index `i` and ending at index `i + l - 1` is equal to a substring of `pat` starting from index `j` and ending at index `j + l - 1`. \n\nThe eighth line returns `true` if the substrings are equal. \n\nThe ninth line returns `false` if the function has not yet returned `true`. \n\nOverall, the function checks if `a` contains a cyclic pattern of `b` by concatenating `b` with itself and checking if any substring of `a` matches a substring of the concatenated `b`. If a match is found, the function returns `true`. Otherwise, it returns `false`. \n\n\n### Racket version\n\n#lang racket\n\n(define (cycpattern_check a b)\n"
  },
  {
    "name": "HumanEval_114_minSubArraySum",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minSubArraySum nums)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_114_minSubArraySum.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSubArraySum))\n    (check-within (candidate (list 2 3 4 1 2 4)) 1 0.001)\n    (check-within (candidate (list -1 -2 -3)) -6 0.001)\n    (check-within (candidate (list -1 -2 -3 2 -10)) -14 0.001)\n    (check-within (candidate (list -9999999999999999)) -9999999999999999 0.001)\n    (check-within (candidate (list 0 10 20 1000000)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 100 -1 -2 -3 10 -5)) -6 0.001)\n    (check-within (candidate (list 10 11 13 8 3 4)) 3 0.001)\n    (check-within (candidate (list 100 -33 32 -1 0 -2)) -33 0.001)\n    (check-within (candidate (list -10)) -10 0.001)\n    (check-within (candidate (list 7)) 7 0.001)\n    (check-within (candidate (list 1 -1)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function minSubArraySum(nums)\n    local max_sum = 0\n    local s = 0\n    for i=1, #nums do\n        s = s - nums[i]\n        if s < 0 then\n            s = 0\n        end\n        max_sum = math.max(s, max_sum)\n    end\n    if max_sum == 0 then\n        max_sum = -math.huge\n        for i=1, #nums do\n            max_sum = math.max(max_sum, -nums[i])\n        end\n    end\n    local min_sum = -max_sum\n    return min_sum\nend\n\n### Explanation\n\nThe code is an implementation of the Kadane's algorithm for finding the minimum subarray sum of an array of integers. \n\n1. `math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions and constants. \n\n2. `local function minSubArraySum(nums)` - This line defines a function called `minSubArraySum` that takes an array of integers as an argument. The `local` keyword makes the function local to the current block. \n\n3. `local max_sum = 0` - This line initializes a variable `max_sum` to 0. This variable will store the maximum subarray sum. \n\n4. `local s = 0` - This line initializes a variable `s` to 0. This variable will store the current subarray sum. \n\n5. `for i=1, #nums do` - This line starts a loop that iterates over the array `nums`. The `#` operator returns the length of the array. \n\n6. `s = s - nums[i]` - This line subtracts the current element of the array from `s`. This updates the current subarray sum. \n\n7. `if s < 0 then s = 0 end` - This line checks if the current subarray sum is negative. If it is, then it sets `s` to 0. This is because a negative subarray sum cannot be the maximum subarray sum. \n\n8. `max_sum = math.max(s, max_sum)` - This line updates the maximum subarray sum. It takes the maximum of the current subarray sum `s` and the previous maximum subarray sum `max_sum`. \n\n9. `if max_sum == 0 then` - This line checks if the maximum subarray sum is 0. If it is, then it means that all elements in the array are negative. \n\n10. `max_sum = -math.huge` - This line sets the maximum subarray sum to negative infinity. This is because the minimum subarray sum of an array with all negative elements is the maximum element. \n\n11. `for i=1, #nums do` - This line starts another loop that iterates over the array `nums`. \n\n12. `max_sum = math.max(max_sum, -nums[i])` - This line updates the maximum subarray sum. It takes the maximum of the previous maximum subarray sum `max_sum` and the negative of the current element of the array `-nums[i]`. \n\n13. `end` - This line ends the loop. \n\n14. `local min_sum = -max_sum` - This line initializes a variable `min_sum` to the negative of the maximum subarray sum. This is because the minimum subarray sum is the negative of the maximum subarray sum. \n\n15. `return min_sum` - This line returns the minimum subarray sum. \n\n\n### Racket version\n\n#lang racket\n\n(define (minSubArraySum nums)\n"
  },
  {
    "name": "HumanEval_88_sort_array",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_array array)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_88_sort_array.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5)) (list 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3 4 5) 0.001)\n    (check-within (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0) 0.001)\n    (check-within (candidate (list 2 1)) (list 1 2) 0.001)\n    (check-within (candidate (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87) 0.001)\n    (check-within (candidate (list 21 14 23 11)) (list 23 21 14 11) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_array(array)\n    if #array == 0 then\n        return {}\n    else\n        if (array[1] + array[#array]) % 2 == 0 then\n            table.sort(array, function(a, b) return a > b end)\n        else\n            table.sort(array)\n        end\n        return array\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function that sorts an array of numbers in a specific way. Here is what each line does:\n\n1. `math = require('math')` - This line imports the math library, which provides a set of mathematical functions. The `require` function is used to load the library.\n\n2. `local function sort_array(array)` - This line defines a local function called `sort_array` that takes an array as an argument.\n\n3. `if #array == 0 then` - This line checks if the length of the array is 0. The `#` operator is used to get the length of the array.\n\n4. `return {}` - This line returns an empty array if the input array is empty.\n\n5. `else` - This line is the start of the else block.\n\n6. `if (array[1] + array[#array]) % 2 == 0 then` - This line checks if the sum of the first and last elements of the array is even. The `%` operator is used to get the remainder of the division by 2.\n\n7. `table.sort(array, function(a, b) return a > b end)` - This line sorts the array in descending order if the sum of the first and last elements is even. The `table.sort` function is used to sort the array, and a custom comparison function is provided as the second argument. The comparison function takes two arguments `a` and `b`, and returns `true` if `a` should come before `b` in the sorted array.\n\n8. `else` - This line is the start of the else block.\n\n9. `table.sort(array)` - This line sorts the array in ascending order if the sum of the first and last elements is odd. The `table.sort` function is used to sort the array.\n\n10. `return array` - This line returns the sorted array.\n\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n"
  },
  {
    "name": "HumanEval_111_histogram",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (histogram test)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_111_histogram.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate histogram))\n    (check-within (candidate \"a b b a\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c a b\") #hash((\"a\" .  2) (\"b\" .  2)) 0.001)\n    (check-within (candidate \"a b c d g\") #hash((\"a\" .  1) (\"b\" .  1) (\"c\" .  1) (\"d\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"b b b b a\") #hash((\"b\" .  4)) 0.001)\n    (check-within (candidate \"r t g\") #hash((\"r\" .  1) (\"t\" .  1) (\"g\" .  1)) 0.001)\n    (check-within (candidate \"\") #hash() 0.001)\n    (check-within (candidate \"a\") #hash((\"a\" .  1)) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function histogram(test)\n    local dict1 = {}\n    local list1 = {}\n    for word in test:gmatch(\"%w+\") do\n        table.insert(list1, word)\n    end\n    local t = 0\n    for i=1, #list1 do\n        if list1[i] ~= '' and list1[i] ~= nil then\n            if list1.count == nil then\n                list1.count = function(list, value)\n                    local count = 0\n                    for i=1, #list do\n                        if list[i] == value then\n                            count = count + 1\n                        end\n                    end\n                    return count\n                end\n            end\n            if list1:count(list1[i]) > t then\n                t = list1:count(list1[i])\n            end\n        end\n    end\n    if t > 0 then\n        for i=1, #list1 do\n            if list1[i] ~= '' and list1[i] ~= nil then\n                if list1:count(list1[i]) == t then\n                    dict1[list1[i]] = t\n                end\n            end\n        end\n    end\n    return dict1\nend\n\n### Explanation\n\nThe code is an implementation of a histogram function in Lua. The function takes a string as input and returns a dictionary (table) containing the frequency of each word in the string.\n\n- `math = require('math')`: This line imports the math library in Lua. The math library provides a set of mathematical functions and constants.\n- `local function histogram(test)`: This line defines a function called `histogram` that takes a string `test` as input. The `local` keyword is used to define a local variable that is only accessible within the function.\n- `local dict1 = {}`: This line creates an empty dictionary called `dict1`.\n- `local list1 = {}`: This line creates an empty list called `list1`.\n- `for word in test:gmatch(\"%w+\") do`: This line loops through each word in the string `test`. The `gmatch` function is used to match all occurrences of the pattern `%w+` (one or more alphanumeric characters) in the string `test`. The `for` loop iterates over each match and assigns it to the variable `word`.\n- `table.insert(list1, word)`: This line adds the word to the end of the list `list1`.\n- `local t = 0`: This line creates a local variable `t` and initializes it to 0.\n- `for i=1, #list1 do`: This line loops through each element in the list `list1`. The `#` operator is used to get the length of the list.\n- `if list1[i] ~= '' and list1[i] ~= nil then`: This line checks if the current element is not an empty string or `nil`.\n- `if list1.count == nil then`: This line checks if the `count` function is not defined for the list `list1`.\n- `list1.count = function(list, value)`: This line defines the `count` function for the list `list1`. The `function` keyword is used to define an anonymous function that takes two arguments `list` and `value`.\n- `local count = 0`: This line creates a local variable `count` and initializes it to 0.\n- `for i=1, #list do`: This line loops through each element in the list `list`.\n- `if list[i] == value then`: This line checks if the current element is equal to `value`.\n- `count = count + 1`: This line increments the `count` variable by 1.\n- `return count`: This line returns the `count` variable.\n- `end`: This line ends the `if` statement.\n- `end`: This line ends the `count` function definition.\n- `end`: This line ends the `if` statement.\n- `if list1:count(list1[i]) > t then`: This line checks if the frequency of the current word in the list `list1` is greater than the current maximum frequency `t`.\n- `t = list1:count(list1[i])`: This line updates the maximum frequency `t` to the frequency of the current word in the list `list1`.\n- `end`: This line ends the `if` statement.\n- `end`: This line ends the `for` loop.\n- `if t > 0 then`: This line checks if the maximum frequency `t` is greater than 0.\n- `for i=1, #list1 do`: This line loops through each element in the list `list1`.\n- `if list1[i] ~= '' and list1[i] ~= nil then`: This line checks if the current element is not\n\n### Racket version\n\n#lang racket\n\n(define (histogram test)\n"
  },
  {
    "name": "HumanEval_123_get_odd_collatz",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_odd_collatz n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_odd_collatz))\n    (check-within (candidate 14) (list 1 5 7 11 13 17) 0.001)\n    (check-within (candidate 5) (list 1 5) 0.001)\n    (check-within (candidate 12) (list 1 3 5) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_odd_collatz(n)\n    local odd_collatz = (n%2==0) and {} or {n}\n    while n > 1 do\n        if n % 2 == 0 then\n            n = n/2\n        else\n            n = n*3 + 1\n        end\n        if n%2 == 1 then\n            table.insert(odd_collatz, math.floor(n))\n        end\n    end\n    table.sort(odd_collatz)\n    return odd_collatz\nend\n\n### Explanation\n\nThe code is an implementation of the Collatz conjecture. The conjecture states that for any positive integer n, if n is even, divide it by 2, and if n is odd, multiply it by 3 and add 1. Repeat this process until n becomes 1. The conjecture also states that no matter what value of n, the sequence will always reach 1.\n\nThe program defines a function `get_odd_collatz` that takes an integer `n` as input and returns a sorted list of odd numbers in the Collatz sequence starting from `n`.\n\nThe first line of the program imports the `math` module, which provides mathematical functions.\n\nThe second line defines a local function `get_odd_collatz` that takes an integer `n` as input.\n\nThe third line initializes a local variable `odd_collatz` to an empty table if `n` is even, or a table containing `n` if `n` is odd.\n\nThe `while` loop starting on line 4 continues until `n` becomes 1. \n\nIf `n` is even, the program divides `n` by 2 and assigns the result to `n`. If `n` is odd, the program multiplies `n` by 3 and adds 1, and assigns the result to `n`.\n\nIf `n` is odd, the program appends `n` to the `odd_collatz` table.\n\nAfter the loop, the `odd_collatz` table is sorted in ascending order using the `table.sort` function.\n\nFinally, the `odd_collatz` table is returned. \n\n\n### Racket version\n\n#lang racket\n\n(define (get_odd_collatz n)\n"
  },
  {
    "name": "HumanEval_62_derivative",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (derivative xs)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_62_derivative.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate derivative))\n    (check-within (candidate (list 3 1 2 4 5)) (list 1 4 12 20) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 6) 0.001)\n    (check-within (candidate (list 3 2 1)) (list 2 2) 0.001)\n    (check-within (candidate (list 3 2 1 0 4)) (list 2 2 0 16) 0.001)\n    (check-within (candidate (list 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function derivative(xs)\n    local result = {}\n    for i=1, #xs-1 do\n        result[i] = i * xs[i+1]\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_63_fibfib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fibfib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_63_fibfib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 1) 0 0.001)\n    (check-within (candidate 5) 4 0.001)\n    (check-within (candidate 8) 24 0.001)\n    (check-within (candidate 10) 81 0.001)\n    (check-within (candidate 12) 274 0.001)\n    (check-within (candidate 14) 927 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fibfib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    end\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\nend\n\n### Explanation\n\nThe code is an implementation of the Fibonacci-Fibonacci sequence. \n\nThe first line imports the math library.\n\nThe second line defines a function called `fibfib` that takes in a number `n` as an argument.\n\nThe next three lines are conditional statements that check if `n` is equal to 0, 1, or 2. If `n` is equal to 0 or 1, the function returns 0. If `n` is equal to 2, the function returns 1.\n\nThe final line is a recursive call to the `fibfib` function with the argument `n - 1` added to `n - 2` added to `n - 3`. This is the recursive formula for the Fibonacci-Fibonacci sequence. \n\nIn Racket, the code would look like this:\n\n\n### Racket version\n\n#lang racket\n\n(define (fibfib n)\n"
  },
  {
    "name": "HumanEval_2_truncate_number",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (truncate_number number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_2_truncate_number.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n    (check-within (candidate 3.5) 0.5 0.001)\n    (check-within (candidate 1.25) 0.25 0.001)\n    (check-within (candidate 123.0) 0.0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function truncate_number(number)\n    return number % 1\nend\n\n### Explanation\n\nThe code is an implementation of a function that truncates a number to its fractional part. \n\n`math = require('math')` imports the Lua math library.\n\n`local function truncate_number(number)` defines a function named `truncate_number` that takes a single argument `number`.\n\n`return number % 1` returns the remainder of `number` divided by 1, which is the fractional part of `number`. \n\nThe function `truncate_number` is then called with a number as an argument, and returns the fractional part of that number. \n\n\n### Racket version\n\n#lang racket\n\n(define (truncate_number number)\n"
  },
  {
    "name": "HumanEval_35_max_element",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (max_element l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_35_max_element.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_element))\n    (check-within (candidate (list 1 2 3)) 3 0.001)\n    (check-within (candidate (list 5 3 -5 2 -3 3 9 0 124 1 -10)) 124 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function max_element(l)\n    local m = l[1]\n    for i=2, #l do\n        if l[i] > m then\n            m = l[i]\n        end\n    end\n    return m\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns the maximum value in the list.\n\n\n### Racket version\n\n#lang racket\n\n(define (max_element l)\n"
  },
  {
    "name": "HumanEval_99_closest_integer",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (closest_integer value)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_99_closest_integer.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-within (candidate \"10\") 10 0.001)\n    (check-within (candidate \"14.5\") 15 0.001)\n    (check-within (candidate \"-15.5\") -16 0.001)\n    (check-within (candidate \"15.3\") 15 0.001)\n    (check-within (candidate \"0\") 0 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if value:find('%.5$') then\n        if num > 0 then\n            return math.ceil(num)\n        else\n            return math.floor(num)\n        end\n    elseif #value > 0 then\n        return math.floor(num + 0.5)\n    else\n        return 0\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `closest_integer` that takes a number as input and returns the closest integer to that number. Here is what each line does:\n\n1. `math = require('math')` - This line loads the `math` module which provides mathematical functions in Lua.\n\n2. `local function closest_integer(value)` - This line defines a local function `closest_integer` that takes a single argument `value`.\n\n3. `local num = tonumber(value)` - This line converts the input `value` to a number and assigns it to a local variable `num`.\n\n4. `if value:find('%.5$') then` - This line checks if the input `value` ends with `.5`. The `%` character is an escape character that allows us to search for a literal `.` character. The `$` character matches the end of the string.\n\n5. `if num > 0 then` - This line checks if the number `num` is positive.\n\n6. `return math.ceil(num)` - This line returns the smallest integer greater than or equal to `num`.\n\n7. `else` - This line is executed if the condition in line 5 is false.\n\n8. `return math.floor(num)` - This line returns the largest integer less than or equal to `num`.\n\n9. `elseif #value > 0 then` - This line checks if the length of the input `value` is greater than 0.\n\n10. `return math.floor(num + 0.5)` - This line returns the closest integer to `num`. If `num` is exactly halfway between two integers, it rounds up to the nearest even integer.\n\n11. `else` - This line is executed if the condition in line 9 is false.\n\n12. `return 0` - This line returns 0 if the input `value` is empty or not a number. \n\n\n### Racket version\n\n#lang racket\n\n(define (closest_integer value)\n"
  },
  {
    "name": "HumanEval_39_prime_fib",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_fib n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_39_prime_fib.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 3) 5 0.001)\n    (check-within (candidate 4) 13 0.001)\n    (check-within (candidate 5) 89 0.001)\n    (check-within (candidate 6) 233 0.001)\n    (check-within (candidate 7) 1597 0.001)\n    (check-within (candidate 8) 28657 0.001)\n    (check-within (candidate 9) 514229 0.001)\n    (check-within (candidate 10) 433494437 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function prime_fib(n)\n  local function is_prime(p)\n    if p < 2 then\n      return false\n    end\n    for k = 2, math.min(math.sqrt(p) + 1, p - 1) do\n      if p % k == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local f = {0, 1}\n  while true do\n    table.insert(f, f[#f] + f[#f - 1])\n    if is_prime(f[#f]) then\n      n = n - 1\n    end\n    if n == 0 then\n      return f[#f]\n    end\n  end\nend\n\n### Explanation\n\nThe code is an implementation of a function `prime_fib` that returns the nth prime Fibonacci number. \n\n\n### Racket version\n\n#lang racket\n\n(define (prime_fib n)\n"
  },
  {
    "name": "HumanEval_8_sum_product",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_product numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_8_sum_product.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n    (check-within (candidate (list )) (list 0 1) 0.001)\n    (check-within (candidate (list 1 1 1)) (list 3 1) 0.001)\n    (check-within (candidate (list 100 0)) (list 100 0) 0.001)\n    (check-within (candidate (list 3 5 7)) (list 15 105) 0.001)\n    (check-within (candidate (list 10)) (list 10 10) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_product(numbers)\n    local sum_value = 0\n    local prod_value = 1\n\n    for _, n in ipairs(numbers) do\n        sum_value = sum_value + n\n        prod_value = prod_value * n\n    end\n    return {sum_value, prod_value}\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns a list containing the sum and product of the numbers in the input list. \n\n1. `math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions that can be used in Lua programs.\n\n2. `local function sum_product(numbers)` - This line defines a function called `sum_product` that takes a single argument called `numbers`. The `local` keyword means that the function is only accessible within the scope of the current block.\n\n3. `local sum_value = 0` - This line initializes a variable called `sum_value` to 0. This variable will be used to store the sum of the numbers in the input list.\n\n4. `local prod_value = 1` - This line initializes a variable called `prod_value` to 1. This variable will be used to store the product of the numbers in the input list.\n\n5. `for _, n in ipairs(numbers) do` - This line starts a loop that iterates over the `numbers` list. The `ipairs` function is used to iterate over the list in order. The loop variable `_` is used to ignore the index of the current element, and `n` is used to store the value of the current element.\n\n6. `sum_value = sum_value + n` - This line adds the value of `n` to `sum_value`.\n\n7. `prod_value = prod_value * n` - This line multiplies the value of `n` with `prod_value`.\n\n8. `end` - This line marks the end of the loop.\n\n9. `return {sum_value, prod_value}` - This line returns a list containing the sum and product of the numbers in the input list. The list is created using curly braces `{}` and the values are separated by commas. \n\n\n### Racket version\n\n#lang racket\n\n(define (sum_product numbers)\n"
  },
  {
    "name": "HumanEval_117_select_words",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (select_words s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_117_select_words.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n    (check-within (candidate \"Mary had a little lamb\" 4) (list \"little\") 0.001)\n    (check-within (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\") 0.001)\n    (check-within (candidate \"simple white space\" 2) (list ) 0.001)\n    (check-within (candidate \"Hello world\" 4) (list \"world\") 0.001)\n    (check-within (candidate \"Uncle sam\" 3) (list \"Uncle\") 0.001)\n    (check-within (candidate \"\" 4) (list ) 0.001)\n    (check-within (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"f\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function select_words(s, n)\n  local result = {}\n  for word in s:gmatch(\"%S+\") do\n    local n_consonants = 0\n    for i = 1, #word do\n      if not word:sub(i,i):lower():find(\"[aeiou]\") then\n        n_consonants = n_consonants + 1\n      end\n    end\n    if n_consonants == n then\n      table.insert(result, word)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `select_words` that takes two arguments: a string `s` and an integer `n`. The function returns a list of words in the string `s` that have exactly `n` consonants. \n\n- `math = require('math')`: This line imports the `math` module. This module provides a set of mathematical operations and functions. \n\n- `local function select_words(s, n)`: This line defines a local function called `select_words` that takes two arguments: a string `s` and an integer `n`. The `local` keyword means that the function is only accessible within the scope of the current block.\n\n- `local result = {}`: This line initializes an empty table called `result`. This table will store the words that have exactly `n` consonants.\n\n- `for word in s:gmatch(\"%S+\") do`: This line starts a loop that iterates over each word in the string `s`. The `gmatch` function is used to match all non-space characters in the string. `%S+` is a pattern that matches one or more non-space characters. The `for ... in ... do` loop is used to iterate over all matches of the pattern in the string.\n\n- `local n_consonants = 0`: This line initializes a variable called `n_consonants` to 0. This variable will store the number of consonants in the current word.\n\n- `for i = 1, #word do`: This line starts a loop that iterates over each character in the current word. `#word` returns the length of the current word.\n\n- `if not word:sub(i,i):lower():find(\"[aeiou]\") then`: This line checks if the current character is a consonant. `word:sub(i,i)` returns the substring of `word` that starts at index `i` and ends at index `i`. `:lower()` is used to convert the character to lowercase. `:find(\"[aeiou]\")` checks if the character is a vowel. The `not` keyword negates the result of the `:find` function, so the `if` statement is true if the character is not a vowel.\n\n- `n_consonants = n_consonants + 1`: This line increments the `n_consonants` variable if the current character is a consonant.\n\n- `if n_consonants == n then`: This line checks if the current word has exactly `n` consonants.\n\n- `table.insert(result, word)`: This line adds the current word to the `result` table if it has exactly `n` consonants.\n\n- `return result`: This line returns the `result` table, which contains all words in the string `s` that have exactly `n` consonants.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (select_words s n)\n"
  },
  {
    "name": "HumanEval_122_add_elements",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add_elements arr k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_122_add_elements.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add_elements))\n    (check-within (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4 0.001)\n    (check-within (candidate (list 111 121 3 4000 5 6) 2) 0 0.001)\n    (check-within (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125 0.001)\n    (check-within (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24 0.001)\n    (check-within (candidate (list 1) 1) 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function add_elements(arr, k)\n  local sum = 0\n  for i = 1, k do\n    if #tostring(arr[i]) <= 2 then\n      sum = sum + arr[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an array and a number `k` as input and returns the sum of the first `k` elements of the array that have a length of 2 or less. \n\n1. `math = require('math')` - This line imports the `math` module which provides a set of mathematical functions. \n\n2. `local function add_elements(arr, k)` - This line defines a function called `add_elements` that takes two parameters: an array `arr` and a number `k`. The `local` keyword makes the function local to the current block, meaning it can only be accessed within the current scope.\n\n3. `local sum = 0` - This line initializes a variable `sum` to 0.\n\n4. `for i = 1, k do` - This line starts a loop that iterates from 1 to `k`.\n\n5. `if #tostring(arr[i]) <= 2 then` - This line checks if the length of the string representation of the `i`th element of `arr` is less than or equal to 2. The `#` operator returns the length of a string, and `tostring` converts a value to a string.\n\n6. `sum = sum + arr[i]` - This line adds the `i`th element of `arr` to `sum`.\n\n7. `end` - This line ends the `if` statement.\n\n8. `end` - This line ends the `for` loop.\n\n9. `return sum` - This line returns the value of `sum`. \n\n\n### Racket version\n\n#lang racket\n\n(define (add_elements arr k)\n"
  },
  {
    "name": "HumanEval_159_eat",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (eat number need remaining)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_159_eat.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate eat))\n    (check-within (candidate 5 6 10) (list 11 4) 0.001)\n    (check-within (candidate 4 8 9) (list 12 1) 0.001)\n    (check-within (candidate 1 10 10) (list 11 0) 0.001)\n    (check-within (candidate 2 11 5) (list 7 0) 0.001)\n    (check-within (candidate 4 5 7) (list 9 2) 0.001)\n    (check-within (candidate 4 5 1) (list 5 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function eat(number, need, remaining)\n    if need <= remaining then\n        return {number + need, remaining - need}\n    else\n        return {number + remaining, 0}\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `eat` that takes three arguments: `number`, `need`, and `remaining`. The function returns a table with two values: the first value is the sum of `number` and `need` if `need` is less than or equal to `remaining`, otherwise it is the sum of `number` and `remaining`. The second value is `remaining` minus `need` if `need` is less than or equal to `remaining`, otherwise it is 0.\n\nThe first line of the code imports the `math` module.\n\nThe second line of the code defines a local function called `eat` that takes three arguments: `number`, `need`, and `remaining`.\n\nThe third line of the code is an `if` statement that checks if `need` is less than or equal to `remaining`. If it is, then the function returns a table with two values: the first value is the sum of `number` and `need`, and the second value is `remaining` minus `need`.\n\nThe fourth line of the code is an `else` statement that is executed if `need` is greater than `remaining`. In this case, the function returns a table with two values: the first value is the sum of `number` and `remaining`, and the second value is 0.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (eat number need remaining)\n"
  },
  {
    "name": "HumanEval_113_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (odd_count lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_113_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate odd_count))\n    (check-within (candidate (list \"1234567\")) (list \"the number of odd elements 4n the str4ng 4 of the 4nput.\") 0.001)\n    (check-within (candidate (list \"3\" \"11111111\")) (list \"the number of odd elements 1n the str1ng 1 of the 1nput.\" \"the number of odd elements 8n the str8ng 8 of the 8nput.\") 0.001)\n    (check-within (candidate (list \"271\" \"137\" \"314\")) (list \"the number of odd elements 2n the str2ng 2 of the 2nput.\" \"the number of odd elements 3n the str3ng 3 of the 3nput.\" \"the number of odd elements 2n the str2ng 2 of the 2nput.\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function odd_count(lst)\n  local res = {}\n  for _, arr in ipairs(lst) do\n    local n = 0\n    for d in arr:gmatch('%d') do\n      if math.fmod(tonumber(d), 2) == 1 then\n        n = n + 1\n      end\n    end\n    table.insert(res, \"the number of odd elements \" .. n .. \"n the str\" .. n .. \"ng \" .. n .. \" of the \" .. n .. \"nput.\")\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function called `odd_count` that takes a list of strings and returns a list of strings. The returned list contains a message that describes the number of odd digits in each string of the input list.\n\nThe first line of the code imports the math library.\n\n\n### Racket version\n\n#lang racket\n\n(define (odd_count lst)\n"
  },
  {
    "name": "HumanEval_90_next_smallest",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (next_smallest lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_90_next_smallest.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n    (check-within (candidate (list 1 2 3 4 5)) 2 0.001)\n    (check-within (candidate (list 5 1 4 3 2)) 2 0.001)\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 0)) 1 0.001)\n    (check-within (candidate (list 1 1)) #f 0.001)\n    (check-within (candidate (list -35 34 12 -45)) -35 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function next_smallest(lst)\n    table.sort(lst)\n    for i = 2, #lst do\n        if lst[i] > lst[1] then\n            return lst[i]\n        end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function called `next_smallest` that takes a list of numbers and returns the next smallest number in the list after the smallest number. \n\n1. `math = require('math')` - This line imports the math library which provides mathematical functions and constants in Lua. \n\n2. `local function next_smallest(lst)` - This line defines a function called `next_smallest` that takes a list of numbers as an argument. The `local` keyword indicates that the function is only accessible within the scope of the current block.\n\n3. `table.sort(lst)` - This line sorts the list of numbers in ascending order using the `sort` function provided by the `table` library in Lua.\n\n4. `for i = 2, #lst do` - This line starts a loop that iterates over the list of numbers starting from the second element (`i = 2`) up to the last element (`#lst`). The `#` operator returns the length of the list.\n\n5. `if lst[i] > lst[1] then` - This line checks if the current element (`lst[i]`) is greater than the first element (`lst[1]`) in the list.\n\n6. `return lst[i]` - This line returns the current element if it is greater than the first element.\n\n7. `end` - This line ends the `if` statement.\n\n8. `end` - This line ends the `for` loop.\n\nIf the function does not find a number greater than the smallest number in the list, it will return `nil`. \n\n\n### Racket version\n\n#lang racket\n\n(define (next_smallest lst)\n"
  },
  {
    "name": "HumanEval_29_filter_by_prefix",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_prefix strings prefix)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_prefix(strings, prefix)\n    local res = {}\n    for _, x in ipairs(strings) do\n        if string.sub(x, 1, #prefix) == prefix then\n            table.insert(res, x)\n        end\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a function called `filter_by_prefix` that takes in two arguments: `strings` and `prefix`. The function returns a new list of strings that start with the given `prefix`.\n\nThe first line of the code imports the `math` module.\n\nThe second line of the code defines a function called `filter_by_prefix` that takes in two arguments: `strings` and `prefix`.\n\nThe third line of the code initializes an empty list called `res`.\n\nThe fourth line of the code starts a loop that iterates over each element in the `strings` list.\n\nThe fifth line of the code checks if the current element starts with the given `prefix`. If it does, the current element is appended to the `res` list.\n\nThe sixth line of the code returns the `res` list.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_prefix strings prefix)\n"
  },
  {
    "name": "HumanEval_102_choose_num",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (choose_num x y)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_102_choose_num.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n    (check-within (candidate 12 15) 14 0.001)\n    (check-within (candidate 13 12) -1 0.001)\n    (check-within (candidate 33 12354) 12354 0.001)\n    (check-within (candidate 5234 5233) -1 0.001)\n    (check-within (candidate 6 29) 28 0.001)\n    (check-within (candidate 27 10) -1 0.001)\n    (check-within (candidate 7 7) -1 0.001)\n    (check-within (candidate 546 546) 546 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function choose_num(x, y)\n    if x > y then\n        return -1\n    end\n    if y % 2 == 0 then\n        return y\n    end\n    if x == y then\n        return -1\n    end\n    return y - 1\nend\n\n### Explanation\n\nThe code is an implementation of a function called `choose_num` that takes two arguments `x` and `y`. The function returns an integer value based on the values of `x` and `y`. \n\nThe first line of the code imports the `math` module which provides mathematical functions and constants. \n\nThe second line of the code defines a function called `choose_num` that takes two arguments `x` and `y`. The function is defined as a local function, which means it can only be accessed within the scope of the block it is defined in. \n\nThe third line of the code checks if `x` is greater than `y`. If `x` is greater than `y`, the function returns `-1`. \n\nThe fourth line of the code checks if `y` is an even number. If `y` is even, the function returns `y`. \n\nThe fifth line of the code checks if `x` is equal to `y`. If `x` is equal to `y`, the function returns `-1`. \n\nThe sixth line of the code returns `y - 1` if none of the previous conditions are met. \n\nIn summary, the `choose_num` function returns `-1` if `x` is greater than `y` or if `x` is equal to `y`. If `y` is even, the function returns `y`. Otherwise, the function returns `y - 1`. \n\n\n### Racket version\n\n#lang racket\n\n(define (choose_num x y)\n"
  },
  {
    "name": "HumanEval_82_prime_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (prime_length string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_82_prime_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n    (check-within (candidate \"Hello\") #t 0.001)\n    (check-within (candidate \"abcdcba\") #t 0.001)\n    (check-within (candidate \"kittens\") #t 0.001)\n    (check-within (candidate \"orange\") #f 0.001)\n    (check-within (candidate \"wow\") #t 0.001)\n    (check-within (candidate \"world\") #t 0.001)\n    (check-within (candidate \"MadaM\") #t 0.001)\n    (check-within (candidate \"Wow\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"HI\") #t 0.001)\n    (check-within (candidate \"go\") #t 0.001)\n    (check-within (candidate \"gogo\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaa\") #f 0.001)\n    (check-within (candidate \"Madam\") #t 0.001)\n    (check-within (candidate \"M\") #f 0.001)\n    (check-within (candidate \"0\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function prime_length(string)\n  local l = #string\n  if l == 0 or l == 1 then\n    return false\n  end\n  for i = 2, l - 1 do\n    if l % i == 0 then\n      return false\n    end\n  end\n  return true\nend\n\n### Explanation\n\nThe code is an implementation of a function called `prime_length` that takes a string as an argument and returns a boolean value indicating whether the length of the string is a prime number or not. \n\n1. `math = require('math')` - This line imports the math library in Lua, which provides a set of mathematical functions. The `require` function is used to load the library.\n\n2. `local function prime_length(string)` - This line defines a local function called `prime_length` that takes a single argument `string`.\n\n3. `local l = #string` - This line assigns the length of the `string` argument to a local variable `l`. The `#` operator is used to get the length of a string in Lua.\n\n4. `if l == 0 or l == 1 then` - This line checks if the length of the string is either 0 or 1. If it is, then the function returns `false`.\n\n5. `for i = 2, l - 1 do` - This line starts a loop that iterates from 2 to `l - 1`. The loop variable is `i`.\n\n6. `if l % i == 0 then` - This line checks if the length of the string is divisible by `i`. If it is, then the function returns `false`.\n\n7. `return true` - This line is executed if none of the previous conditions are met. It returns `true`, indicating that the length of the string is a prime number. \n\n\n### Racket version\n\n#lang racket\n\n(define (prime_length string)\n"
  },
  {
    "name": "HumanEval_60_sum_to_n",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sum_to_n n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_60_sum_to_n.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_to_n))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 6) 21 0.001)\n    (check-within (candidate 11) 66 0.001)\n    (check-within (candidate 30) 465 0.001)\n    (check-within (candidate 100) 5050 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sum_to_n(n)\n  return (n * (n + 1)) / 2\nend\n\n### Explanation\n\nThe code is an implementation of a function `sum_to_n` that calculates the sum of all integers from 1 to `n`. \n\n`math = require('math')` imports the `math` module, which provides mathematical functions and constants. \n\n`local function sum_to_n(n)` defines a local function `sum_to_n` that takes a single argument `n`. \n\n`return (n * (n + 1)) / 2` calculates the sum of all integers from 1 to `n` using the formula `(n * (n + 1)) / 2`. \n\nThe formula works by taking advantage of the fact that the sum of all integers from 1 to `n` is equal to the sum of the first and last integers (1 and `n`) plus the sum of the second and second-to-last integers (2 and `n-1`) plus the sum of the third and third-to-last integers (3 and `n-2`), and so on. \n\nThis can be expressed as `n/2` pairs of integers that sum to `n+1`, which simplifies to `(n * (n + 1)) / 2`. \n\nOverall, the function `sum_to_n` calculates the sum of all integers from 1 to `n` using a simple mathematical formula. \n\n\n### Racket version\n\n#lang racket\n\n(define (sum_to_n n)\n"
  },
  {
    "name": "HumanEval_140_fix_spaces",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fix_spaces text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_140_fix_spaces.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fix_spaces))\n    (check-within (candidate \"Example\") \"Example\" 0.001)\n    (check-within (candidate \"Mudasir Hanif \") \"Mudasir_Hanif_\" 0.001)\n    (check-within (candidate \"Yellow Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\" 0.001)\n    (check-within (candidate \"Exa   mple\") \"Exa-mple\" 0.001)\n    (check-within (candidate \"   Exa 1 2 2 mple\") \"-Exa_1_2_2_mple\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fix_spaces(text)\n    local new_text = \"\"\n    local i = 1\n    local start, _end = 1, 1\n    while i <= #text do\n        local c = text:sub(i, i)\n        if c == \" \" then\n            _end = _end + 1\n        else\n            if _end - start > 2 then\n                new_text = new_text .. \"-\" .. c\n            elseif _end - start > 0 then\n                new_text = new_text .. (\"_\"):rep(_end - start) .. c\n            else\n                new_text = new_text .. c\n            end\n            start, _end = i+1, i+1\n        end\n        i = i + 1\n    end\n    if _end - start > 2 then\n        new_text = new_text .. \"-\"\n    elseif _end - start > 0 then\n        new_text = new_text .. \"_\"\n    end\n    return new_text\nend\n\n### Explanation\n\nThe code is an implementation of a function that replaces spaces in a string with underscores and hyphens. \n\nThe first line imports the math library.\n\nThe second line defines a function called `fix_spaces` that takes a string as an argument.\n\nThe next three lines initialize some variables. `new_text` is an empty string that will be used to store the modified string. `i` is an integer that will be used to iterate through the string. `start` and `_end` are integers that will be used to keep track of the start and end indices of a sequence of spaces.\n\nThe next few lines define a while loop that will iterate through the string. \n\nThe first line inside the loop gets the character at the current index of the string.\n\nThe next few lines check if the character is a space. If it is, then the `_end` variable is incremented. If it isn't, then the code checks if there is a sequence of spaces that needs to be replaced. If there is, then the code replaces the sequence with a hyphen and the current character. If there isn't, then the code replaces the spaces with underscores. Finally, the `start` and `_end` variables are reset to the current index.\n\nThe last few lines of the loop increment the index variable.\n\nAfter the loop, the code checks if there is a sequence of spaces at the end of the string that needs to be replaced. If there is, then the code replaces the sequence with a hyphen. If there isn't, then the code replaces the spaces with underscores.\n\nFinally, the modified string is returned.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (fix_spaces text)\n"
  },
  {
    "name": "HumanEval_9_rolling_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rolling_max numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_9_rolling_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 4 3 2 1)) (list 4 4 4 4) 0.001)\n    (check-within (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function rolling_max(numbers)\n    local running_max = nil\n    local result = {}\n\n    for _, n in ipairs(numbers) do\n        if running_max == nil then\n            running_max = n\n        else\n            running_max = math.max(running_max, n)\n        end\n\n        table.insert(result, running_max)\n    end\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `rolling_max` that takes a list of numbers and returns a list of the maximum values seen so far. \n\n\n### Racket version\n\n#lang racket\n\n(define (rolling_max numbers)\n"
  },
  {
    "name": "HumanEval_143_words_in_sentence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (words_in_sentence sentence)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_143_words_in_sentence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_in_sentence))\n    (check-within (candidate \"This is a test\") \"is\" 0.001)\n    (check-within (candidate \"lets go for swimming\") \"go for\" 0.001)\n    (check-within (candidate \"there is no place available here\") \"there is no place\" 0.001)\n    (check-within (candidate \"Hi I am Hussein\") \"Hi am Hussein\" 0.001)\n    (check-within (candidate \"go for it\") \"go for it\" 0.001)\n    (check-within (candidate \"here\") \"\" 0.001)\n    (check-within (candidate \"here is\") \"is\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function words_in_sentence(sentence)\n    local new_lst = {}\n    for word in sentence:gmatch(\"%S+\") do\n        local flg = 0\n        if #word == 1 then\n            flg = 1\n        end\n        for i=2, #word-1 do\n            if #word%i == 0 then\n                flg = 1\n            end\n        end\n        if flg == 0 or #word == 2 then\n            table.insert(new_lst, word)\n        end\n    end\n    return table.concat(new_lst, \" \")\nend\n\n### Explanation\n\nThe code is an implementation of a function `words_in_sentence` that takes a string `sentence` and returns a string of words that satisfy a certain condition. \n\nThe first line of the code imports the `math` library. \n\nThe second line defines a function `words_in_sentence` that takes a string `sentence` as an argument. \n\nThe third line creates a new empty list `new_lst`. \n\nThe fourth line starts a loop that iterates over each word in the `sentence` string. \n\nThe fifth line uses the `gmatch` function to match all non-space characters in the `sentence` string and returns an iterator that can be used to iterate over each word in the string. \n\nThe sixth line creates a new variable `flg` and sets it to 0. \n\nThe seventh line checks if the length of the current `word` is equal to 1. If it is, `flg` is set to 1. \n\nThe eighth line starts another loop that iterates over each number `i` from 2 to the length of the `word` minus 1. \n\nThe ninth line checks if the length of the `word` is divisible by `i`. If it is, `flg` is set to 1. \n\nThe tenth line checks if `flg` is equal to 0 or if the length of the `word` is equal to 2. If either of these conditions is true, the current `word` is added to the `new_lst` list. \n\nThe eleventh line ends the loop that iterates over each word in the `sentence` string. \n\nThe twelfth line returns a string that is created by concatenating all the words in the `new_lst` list with a space character between each word. \n\n\n### Racket version\n\n#lang racket\n\n(define (words_in_sentence sentence)\n"
  },
  {
    "name": "HumanEval_118_get_closest_vowel",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_closest_vowel word)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-within (candidate \"yogurt\") \"u\" 0.001)\n    (check-within (candidate \"full\") \"u\" 0.001)\n    (check-within (candidate \"easy\") \"\" 0.001)\n    (check-within (candidate \"eAsy\") \"\" 0.001)\n    (check-within (candidate \"ali\") \"\" 0.001)\n    (check-within (candidate \"bad\") \"a\" 0.001)\n    (check-within (candidate \"most\") \"o\" 0.001)\n    (check-within (candidate \"ab\") \"\" 0.001)\n    (check-within (candidate \"ba\") \"\" 0.001)\n    (check-within (candidate \"quick\") \"\" 0.001)\n    (check-within (candidate \"anime\") \"i\" 0.001)\n    (check-within (candidate \"Asia\") \"\" 0.001)\n    (check-within (candidate \"Above\") \"o\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_closest_vowel(word)\n    if #word < 3 then\n        return \"\"\n    end\n\n    local vowels = {a=true, e=true, i=true, o=true, u=true, A=true, E=true, I=true, O=true, U=true}\n    for i=#word-1, 2, -1 do\n        if vowels[word:sub(i, i)] then\n            if not (vowels[word:sub(i-1, i-1)] or vowels[word:sub(i+1, i+1)]) then\n                return word:sub(i, i)\n            end\n        end\n    end\n    return \"\"\nend\n\n### Explanation\n\nThe code is an implementation of a function `get_closest_vowel(word)` that returns the closest vowel in a word. The function takes a string `word` as input and returns a string.\n\n1. `math = require('math')` - import the `math` module.\n2. `local function get_closest_vowel(word)` - define a function `get_closest_vowel` that takes a string `word` as input.\n3. `if #word < 3 then` - if the length of `word` is less than 3, return an empty string.\n4. `return \"\"` - return an empty string.\n5. `local vowels = {a=true, e=true, i=true, o=true, u=true, A=true, E=true, I=true, O=true, U=true}` - define a table `vowels` that contains all the vowels in both upper and lower case.\n6. `for i=#word-1, 2, -1 do` - loop through the characters in `word` from the second to the second last character in reverse order.\n7. `if vowels[word:sub(i, i)] then` - if the current character is a vowel,\n8. `if not (vowels[word:sub(i-1, i-1)] or vowels[word:sub(i+1, i+1)]) then` - if the previous and next characters are not vowels,\n9. `return word:sub(i, i)` - return the current character.\n10. `return \"\"` - if no such character is found, return an empty string.\n\n\n### Racket version\n\n#lang racket\n\n(define (get_closest_vowel word)\n"
  },
  {
    "name": "HumanEval_152_compare",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare game guess)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_152_compare.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n    (check-within (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0 0 0 3 3) 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3) (list -1 -2 -3)) (list 2 4 6) 0.001)\n    (check-within (candidate (list 1 2 3 5) (list -1 2 3 4)) (list 2 0 0 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function compare(game, guess)\n  local result = {}\n  for i = 1, #game do\n    result[i] = math.abs(game[i] - guess[i])\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `compare` that takes two arrays `game` and `guess` as input and returns an array `result` as output. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the current block of code.\n\nThe first line of the function imports the `math` module, which provides a set of mathematical functions that can be used in the program.\n\nThe `for` loop iterates over the indices of the `game` array using the `#` operator, which returns the length of the array. The loop body calculates the absolute difference between the `i`th element of `game` and `guess` arrays using the `math.abs` function and stores the result in the `result` array at the same index.\n\nFinally, the `result` array is returned as the output of the function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (compare game guess)\n"
  },
  {
    "name": "HumanEval_26_remove_duplicates",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (remove_duplicates numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_26_remove_duplicates.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_duplicates))\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4)) (list 1 2 3 4) 0.001)\n    (check-within (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function remove_duplicates(numbers)\n  local c = {}\n  for _, n in ipairs(numbers) do\n    c[n] = (c[n] or 0) + 1\n  end\n  local result = {}\n  for _, n in ipairs(numbers) do\n    if c[n] <= 1 then\n      table.insert(result, n)\n    end\n  end\n  return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that removes duplicates from a list of numbers. It does so by creating a new table `c` that counts the number of times each number appears in the input list `numbers`. It then creates a new list `result` that only contains the numbers that appear once in the input list.\n\n* `math = require('math')` - This line imports the `math` module, which provides mathematical functions and constants. It assigns the module to the variable `math`.\n\n* `local function remove_duplicates(numbers)` - This line defines a new function called `remove_duplicates` that takes a single argument `numbers`. The `local` keyword makes the function local to the current scope.\n\n* `local c = {}` - This line creates a new empty table called `c`. This table will be used to count the number of times each number appears in the input list.\n\n* `for _, n in ipairs(numbers) do` - This line starts a loop that iterates over each number in the input list `numbers`. The `_` variable is used to ignore the index of each number.\n\n* `c[n] = (c[n] or 0) + 1` - This line increments the count of the current number in the `c` table. If the number has not been seen before, `c[n]` will be `nil`, so the `or 0` expression ensures that the count starts at 0.\n\n* `local result = {}` - This line creates a new empty list called `result`. This list will be used to store the numbers that appear only once in the input list.\n\n* `for _, n in ipairs(numbers) do` - This line starts a new loop that iterates over each number in the input list `numbers`. The `_` variable is used to ignore the index of each number.\n\n* `if c[n] <= 1 then` - This line checks if the count of the current number in the `c` table is less than or equal to 1. If so, the number appears only once in the input list.\n\n* `table.insert(result, n)` - This line adds the current number to the `result` list.\n\n* `end` - This line ends the `if` statement.\n\n* `end` - This line ends the second `for` loop.\n\n* `return result` - This line returns the `result` list containing the numbers that appear only once in the input list.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (remove_duplicates numbers)\n"
  },
  {
    "name": "HumanEval_54_same_chars",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (same_chars s0 s1)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_54_same_chars.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabc\") #t 0.001)\n    (check-within (candidate \"dddddddabc\" \"abcd\") #t 0.001)\n    (check-within (candidate \"eabcd\" \"dddddddabc\") #f 0.001)\n    (check-within (candidate \"abcd\" \"dddddddabcf\") #f 0.001)\n    (check-within (candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f 0.001)\n    (check-within (candidate \"aabb\" \"aaccc\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function same_chars(s0, s1)\n    local set0, set1 = {}, {}\n    for i=1, #s0 do set0[s0:sub(i,i)] = true end\n    for i=1, #s1 do set1[s1:sub(i,i)] = true end\n    for k in pairs(set0) do if not set1[k] then return false end end\n    for k in pairs(set1) do if not set0[k] then return false end end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function `same_chars` that takes two strings `s0` and `s1` as input and returns `true` if they have the same characters and `false` otherwise.\n\n1. `math = require('math')` - This line imports the `math` module into the program. The `math` module provides a set of mathematical functions and constants.\n2. `local function same_chars(s0, s1)` - This line defines a local function `same_chars` that takes two string arguments `s0` and `s1`.\n3. `local set0, set1 = {}, {}` - This line defines two empty tables `set0` and `set1`.\n4. `for i=1, #s0 do set0[s0:sub(i,i)] = true end` - This line loops through each character in the first string `s0` and adds it as a key to the `set0` table with a value of `true`.\n5. `for i=1, #s1 do set1[s1:sub(i,i)] = true end` - This line loops through each character in the second string `s1` and adds it as a key to the `set1` table with a value of `true`.\n6. `for k in pairs(set0) do if not set1[k] then return false end end` - This line loops through each key in the `set0` table and checks if it exists in the `set1` table. If it does not exist, the function returns `false`.\n7. `for k in pairs(set1) do if not set0[k] then return false end end` - This line loops through each key in the `set1` table and checks if it exists in the `set0` table. If it does not exist, the function returns `false`.\n8. `return true` - This line returns `true` if the function has not yet returned `false`. This means that both strings have the same characters. \n\n\n### Racket version\n\n#lang racket\n\n(define (same_chars s0 s1)\n"
  },
  {
    "name": "HumanEval_6_parse_nested_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (parse_nested_parens paren_string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-within (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3) 0.001)\n    (check-within (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4) 0.001)\n    (check-within (candidate \"(()(())((())))\") (list 4) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function parse_nested_parens(paren_string)\n    local function parse_paren_group(s)\n        local depth = 0\n        local max_depth = 0\n        for c in s:gmatch('.') do\n            if c == '(' then\n                depth = depth + 1\n                max_depth = math.max(depth, max_depth)\n            else\n                depth = depth - 1\n            end\n        end\n        return max_depth\n    end\n    local res = {}\n    for x in paren_string:gmatch('%S+') do\n        table.insert(res, parse_paren_group(x))\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a function `parse_nested_parens` that takes a string of nested parentheses and returns a list of integers representing the maximum depth of each group of parentheses in the string. \n\n\n### Racket version\n\n#lang racket\n\n(define (parse_nested_parens paren_string)\n"
  },
  {
    "name": "HumanEval_155_even_odd_count",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (even_odd_count num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_155_even_odd_count.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate even_odd_count))\n    (check-within (candidate 7) (list 0 1) 0.001)\n    (check-within (candidate -78) (list 1 1) 0.001)\n    (check-within (candidate 3452) (list 2 2) 0.001)\n    (check-within (candidate 346211) (list 3 3) 0.001)\n    (check-within (candidate -345821) (list 3 3) 0.001)\n    (check-within (candidate -2) (list 1 0) 0.001)\n    (check-within (candidate -45347) (list 2 3) 0.001)\n    (check-within (candidate 0) (list 1 0) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function even_odd_count(num)\n    local even_count = 0\n    local odd_count = 0\n    for i in tostring(math.abs(num)):gmatch(\".\") do\n        if tonumber(i)%2==0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n    end\n    return {even_count, odd_count}\nend\n\n### Explanation\n\nThe code is an implementation of a function called `even_odd_count` that takes an integer `num` as input and returns a table with two elements: the first element is the count of even digits in `num` and the second element is the count of odd digits in `num`.\n\nThe first line of the code imports the `math` module, which provides mathematical functions and constants.\n\nThe second line of the code defines a local function called `even_odd_count` that takes an integer `num` as input.\n\nThe third and fourth lines of the code define two local variables called `even_count` and `odd_count` and initialize them to zero.\n\nThe fifth line of the code starts a `for` loop that iterates over each character in the string representation of the absolute value of `num`. The `tostring` function converts `num` to a string, and the `math.abs` function returns the absolute value of `num`.\n\nThe sixth line of the code uses the `gmatch` function to match each character in the string representation of `num`. The `.` pattern matches any character, and the `gmatch` function returns an iterator that produces all matches.\n\nThe seventh line of the code starts an `if` statement that checks if the current character is even. The `tonumber` function converts the current character to a number, and the `%` operator computes the remainder of the division of the number by 2. If the remainder is 0, then the number is even, and the `even_count` variable is incremented by 1. Otherwise, the number is odd, and the `odd_count` variable is incremented by 1.\n\nThe eighth line of the code ends the `if` statement.\n\nThe ninth line of the code ends the `for` loop.\n\nThe tenth line of the code returns a table with two elements: the first element is the value of `even_count`, and the second element is the value of `odd_count`. \n\n\n### Racket version\n\n#lang racket\n\n(define (even_odd_count num)\n"
  },
  {
    "name": "HumanEval_67_fruit_distribution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (fruit_distribution s n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_67_fruit_distribution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fruit_distribution))\n    (check-within (candidate \"5 apples and 6 oranges\" 19) 8 0.001)\n    (check-within (candidate \"5 apples and 6 oranges\" 21) 10 0.001)\n    (check-within (candidate \"0 apples and 1 oranges\" 3) 2 0.001)\n    (check-within (candidate \"1 apples and 0 oranges\" 3) 2 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 100) 95 0.001)\n    (check-within (candidate \"2 apples and 3 oranges\" 5) 0 0.001)\n    (check-within (candidate \"1 apples and 100 oranges\" 120) 19 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function fruit_distribution(s, n)\n    local sum = 0\n    for i in string.gmatch(s, \"%d+\") do\n        sum = sum + tonumber(i)\n    end\n    return n - sum\nend\n\n### Explanation\n\nThe code is an implementation of"
  },
  {
    "name": "HumanEval_11_string_xor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_xor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_11_string_xor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n    (check-within (candidate \"111000\" \"101010\") \"010010\" 0.001)\n    (check-within (candidate \"1\" \"1\") \"0\" 0.001)\n    (check-within (candidate \"0101\" \"0000\") \"0101\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function string_xor(a, b)\n    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result = result .. '0'\n        else\n            result = result .. '1'\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a string XOR function. \n\n1. `math = require('math')` - This line imports the math library. \n2. `local function string_xor(a, b)` - This line defines a function called `string_xor` that takes two arguments `a` and `b`. \n3. `local result = ''` - This line initializes an empty string called `result`. \n4. `for i = 1, #a do` - This line starts a loop that iterates from 1 to the length of the string `a`. \n5. `if a:sub(i, i) == b:sub(i, i) then` - This line checks if the i-th character of `a` is equal to the i-th character of `b`. \n6. `result = result .. '0'` - This line appends a '0' to `result` if the characters are equal. \n7. `else` - This line is the else clause for the if statement. \n8. `result = result .. '1'` - This line appends a '1' to `result` if the characters are not equal. \n9. `end` - This line ends the if statement. \n10. `end` - This line ends the for loop. \n11. `return result` - This line returns the final value of `result`. \n\nThe `string_xor` function takes two strings as input and returns a new string that is the result of XORing the two input strings. The function iterates over the characters of the input strings and compares them one by one. If the characters are equal, it appends a '0' to the result string, otherwise it appends a '1'. The resulting string is the XOR of the two input strings. \n\nTo rewrite this program in Racket, we can use the following code:\n\n\n### Racket version\n\n#lang racket\n\n(define (string_xor a b)\n"
  },
  {
    "name": "HumanEval_23_strlen",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strlen string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_23_strlen.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strlen))\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"x\") 1 0.001)\n    (check-within (candidate \"asdasnakj\") 9 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function strlen(string)\n    return #string\nend\n\n### Explanation\n\nThe code is an implementation of a function that returns the length of a string. \n\n`math = require('math')` - This line imports the math module into the program. The math module provides mathematical functions and constants. \n\n`local function strlen(string)` - This line defines a function called `strlen` that takes a string as an argument. The `local` keyword means that the function is only accessible within the scope of the current block. \n\n`return #string` - This line returns the length of the string passed as an argument. The `#` operator is used to get the length of the string. \n\nOverall, the program imports the math module and defines a function that returns the length of a string. \n\n\n### Racket version\n\n#lang racket\n\n(define (strlen string)\n"
  },
  {
    "name": "HumanEval_15_string_sequence",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (string_sequence n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_15_string_sequence.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n    (check-within (candidate 0) \"0\" 0.001)\n    (check-within (candidate 3) \"0 1 2 3\" 0.001)\n    (check-within (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function string_sequence(n)\n    local t = {}\n    for i = 0, n do\n        t[#t + 1] = tostring(i)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of a function `string_sequence` that takes an integer `n` and returns a string of space-separated numbers from 0 to `n`. \n\n1. `math = require('math')` - This line imports the Lua math library and assigns it to the variable `math`.\n2. `local function string_sequence(n)` - This line defines a local function `string_sequence` that takes an integer argument `n`.\n3. `local t = {}` - This line creates an empty table `t` to store the sequence of numbers.\n4. `for i = 0, n do` - This line starts a loop that iterates from 0 to `n`.\n5. `t[#t + 1] = tostring(i)` - This line appends the string representation of `i` to the end of the `t` table.\n6. `end` - This line ends the loop.\n7. `return table.concat(t, ' ')` - This line returns a string that is the concatenation of all elements in the `t` table, separated by a space. \n\n\n### Racket version\n\n#lang racket\n\n(define (string_sequence n)\n"
  },
  {
    "name": "HumanEval_135_can_arrange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (can_arrange arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_135_can_arrange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate can_arrange))\n    (check-within (candidate (list 1 2 4 3 5)) 3 0.001)\n    (check-within (candidate (list 1 2 4 5)) -1 0.001)\n    (check-within (candidate (list 1 4 2 5 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 4 8 5 7 3)) 4 0.001)\n    (check-within (candidate (list )) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function can_arrange(arr)\n    local ind=-1\n    local i=1\n    while i<#arr do\n      if arr[i]>arr[i+1] then\n        ind=i\n      end\n      i=i+1\n    end\n    return ind\nend\n\n### Explanation\n\nThe code is an implementation of a function `can_arrange` that takes an array as input and returns the index of the first element in the array that is greater than the element that follows it. If no such element exists, the function returns -1.\n\n- `math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions and constants. In this code, the math library is not used.\n\n- `local function can_arrange(arr)` - This line defines a local function named `can_arrange` that takes an array as input.\n\n- `local ind=-1` - This line initializes a local variable named `ind` to -1. This variable will be used to store the index of the first element in the array that is greater than the element that follows it.\n\n- `local i=1` - This line initializes a local variable named `i` to 1. This variable will be used to iterate over the array.\n\n- `while i<#arr do` - This line starts a while loop that will iterate over the array as long as the index `i` is less than the length of the array.\n\n- `if arr[i]>arr[i+1] then` - This line checks if the current element in the array is greater than the element that follows it.\n\n- `ind=i` - This line sets the value of `ind` to the current index `i` if the current element is greater than the element that follows it.\n\n- `i=i+1` - This line increments the value of `i` by 1.\n\n- `end` - This line ends the if statement.\n\n- `end` - This line ends the while loop.\n\n- `return ind` - This line returns the value of `ind`. If no element in the array is greater than the element that follows it, the value of `ind` will still be -1. Otherwise, it will be the index of the first such element.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (can_arrange arr)\n"
  },
  {
    "name": "HumanEval_85_add",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (add lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_85_add.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n    (check-within (candidate (list 4 88)) 88 0.001)\n    (check-within (candidate (list 4 5 6 7 2 122)) 122 0.001)\n    (check-within (candidate (list 4 0 6 7)) 0 0.001)\n    (check-within (candidate (list 4 4 6 8)) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function add(lst)\n  local sum = 0\n  for i = 2, #lst, 2 do\n    if lst[i]%2 == 0 then\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function `add` that takes a list as an argument and returns the sum of all even numbers in the list. \n\n1. `math = require('math')` - This line imports the math module which provides a set of mathematical functions. The `require` function is used to load a module in Lua.\n\n2. `local function add(lst)` - This line defines a local function `add` that takes a list `lst` as an argument.\n\n3. `local sum = 0` - This line initializes a local variable `sum` to 0.\n\n4. `for i = 2, #lst, 2 do` - This line starts a for loop that iterates over every other element of the list `lst` starting from the second element. The `#` operator is used to get the length of the list.\n\n5. `if lst[i]%2 == 0 then` - This line checks if the current element of the list is even. The `%` operator is used to get the remainder of a division operation.\n\n6. `sum = sum + lst[i]` - This line adds the current element of the list to the sum variable.\n\n7. `end` - This line ends the if statement.\n\n8. `end` - This line ends the for loop.\n\n9. `return sum` - This line returns the final value of the sum variable. \n\n\n### Racket version\n\n#lang racket\n\n(define (add lst)\n"
  },
  {
    "name": "HumanEval_5_intersperse",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersperse numbers delimeter)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_5_intersperse.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersperse))\n    (check-within (candidate (list ) 7) (list ) 0.001)\n    (check-within (candidate (list 5 6 3 2) 8) (list 5 8 6 8 3 8 2) 0.001)\n    (check-within (candidate (list 2 2 2) 2) (list 2 2 2 2 2) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function intersperse(numbers, delimeter)\n    if not numbers then\n        return {}\n    end\n\n    local result = {}\n\n    for i=1, #numbers-1 do\n        table.insert(result, numbers[i])\n        table.insert(result, delimeter)\n    end\n\n    table.insert(result, numbers[#numbers])\n\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `intersperse` that takes two arguments: `numbers` and `delimeter`. The function returns a new table that contains the elements of `numbers` separated by `delimeter`. \n\nThe first line of the code imports the `math` module. \n\nThe second line defines a local function called `intersperse` that takes two arguments: `numbers` and `delimeter`. \n\nThe third line checks if `numbers` is `nil`. If it is, then the function returns an empty table. \n\nThe fourth line creates a new table called `result`. \n\nThe fifth line starts a loop that iterates from 1 to the second-to-last element of `numbers`. \n\nThe sixth line inserts the `i`th element of `numbers` into `result`. \n\nThe seventh line inserts `delimeter` into `result`. \n\nThe eighth line ends the loop. \n\nThe ninth line inserts the last element of `numbers` into `result`. \n\nThe tenth line returns `result`. \n\n\n### Racket version\n\n#lang racket\n\n(define (intersperse numbers delimeter)\n"
  },
  {
    "name": "HumanEval_119_match_parens",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (match_parens lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_119_match_parens.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate match_parens))\n    (check-within (candidate (list \"()(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \")\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(())\" \"())())\")) \"No\" 0.001)\n    (check-within (candidate (list \")())\" \"(()()(\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"(())))\" \"(()())((\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"()\" \"())\")) \"No\" 0.001)\n    (check-within (candidate (list \"(()(\" \"()))()\")) \"Yes\" 0.001)\n    (check-within (candidate (list \"((((\" \"((())\")) \"No\" 0.001)\n    (check-within (candidate (list \")(()\" \"(()(\")) \"No\" 0.001)\n    (check-within (candidate (list \")(\" \")(\")) \"No\" 0.001)\n    (check-within (candidate (list \"(\" \")\")) \"Yes\" 0.001)\n    (check-within (candidate (list \")\" \"(\")) \"Yes\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function match_parens(lst)\n    local function check(s)\n        local val = 0\n        for i=1, #s do\n            if s:sub(i, i) == '(' then\n                val = val + 1\n            else\n                val = val - 1\n            end\n            if val < 0 then\n                return false\n            end\n        end\n        return val == 0\n    end\n\n    local S1 = lst[1]..lst[2]\n    local S2 = lst[2]..lst[1]\n    if check(S1) or check(S2) then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function `match_parens` that takes a list of two strings and returns either 'Yes' or 'No' depending on whether the two strings can be combined to form a string with balanced parentheses. \n\n\n### Racket version\n\n#lang racket\n\n(define (match_parens lst)\n"
  },
  {
    "name": "HumanEval_92_any_int",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (any_int x y z)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_92_any_int.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate any_int))\n    (check-within (candidate 2 3 1) #t 0.001)\n    (check-within (candidate 2.5 2 3) #f 0.001)\n    (check-within (candidate 1.5 5 3.5) #f 0.001)\n    (check-within (candidate 2 6 2) #f 0.001)\n    (check-within (candidate 4 2 2) #t 0.001)\n    (check-within (candidate 2.2 2.2 2.2) #f 0.001)\n    (check-within (candidate -4 6 2) #t 0.001)\n    (check-within (candidate 2 1 1) #t 0.001)\n    (check-within (candidate 3 4 7) #t 0.001)\n    (check-within (candidate 3.0 4 7) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function any_int(x, y, z)\n    if math.type(x) == \"integer\" and math.type(y) == \"integer\" and math.type(z) == \"integer\" then\n        if (x+y==z) or (x+z==y) or (y+z==x) then\n            return true\n        end\n        return false\n    end\n    return false\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes three arguments `x`, `y`, and `z` and returns `true` if any two of them add up to the third, and `false` otherwise. \n\n- `math = require('math')`: This line imports the built-in `math` module, which provides mathematical functions and constants. The `require` function is used to load modules in Lua.\n\n- `local function any_int(x, y, z)`: This line defines a local function `any_int` that takes three arguments `x`, `y`, and `z`. The `local` keyword is used to define a local variable or function, which is only accessible within the scope where it is defined.\n\n- `if math.type(x) == \"integer\" and math.type(y) == \"integer\" and math.type(z) == \"integer\" then`: This line checks if all three arguments are integers using the `math.type` function, which returns the type of a given value. If all three arguments are integers, the code inside the `if` block is executed.\n\n- `if (x+y==z) or (x+z==y) or (y+z==x) then`: This line checks if any two of the arguments add up to the third. If any of the conditions are true, the code inside the `if` block is executed.\n\n- `return true`: This line returns `true` if any two of the arguments add up to the third.\n\n- `return false`: This line returns `false` if none of the conditions in the `if` statement are true.\n\n- `end`: This line ends the `if` block.\n\n- `end`: This line ends the `any_int` function.\n\n\n### Racket version\n\n#lang racket\n\n(define (any_int x y z)\n"
  },
  {
    "name": "HumanEval_7_filter_by_substring",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (filter_by_substring strings substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_7_filter_by_substring.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n    (check-within (candidate (list ) \"john\") (list ) 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list \"xxx\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"xxx\" \"asd\" \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"xxxAAA\" \"xxx\") 0.001)\n    (check-within (candidate (list \"grunt\" \"trumpet\" \"prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function filter_by_substring(strings, substring)\n    local result = {}\n    for _, v in pairs(strings) do\n        if string.find(v, substring) then\n            table.insert(result, v)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `filter_by_substring` that takes in two arguments: a table of strings called `strings` and a string called `substring`. The function returns a new table that contains only the strings from the original table that contain the `substring`.\n\nThe first line of the code imports the `math` module.\n\nThe second line of the code defines a local function called `filter_by_substring` that takes in two arguments: `strings` and `substring`.\n\nThe third line of the code initializes an empty table called `result`.\n\nThe fourth line of the code starts a loop that iterates over each key-value pair in the `strings` table. The underscore `_` is used as a placeholder for the key, since it is not used in the loop. The variable `v` is used to represent the value of the current key-value pair.\n\nThe fifth line of the code checks if the `substring` is found in the current string `v` using the `string.find` function. If the `substring` is found, the current string `v` is added to the `result` table using the `table.insert` function.\n\nThe sixth line of the code ends the loop.\n\nThe seventh line of the code returns the `result` table.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_substring strings substring)\n"
  },
  {
    "name": "HumanEval_158_find_max",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (find_max words)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_158_find_max.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n    (check-within (candidate (list \"name\" \"of\" \"string\")) \"string\" 0.001)\n    (check-within (candidate (list \"name\" \"enam\" \"game\")) \"enam\" 0.001)\n    (check-within (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\" 0.001)\n    (check-within (candidate (list \"abc\" \"cba\")) \"abc\" 0.001)\n    (check-within (candidate (list \"play\" \"this\" \"game\" \"of\" \"footbott\")) \"footbott\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\" 0.001)\n    (check-within (candidate (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\" 0.001)\n    (check-within (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\" 0.001)\n    (check-within (candidate (list \"b\")) \"b\" 0.001)\n    (check-within (candidate (list \"play\" \"play\" \"play\")) \"play\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function find_max(words)\n    table.sort(words, function(a, b)\n        if #a ~= #b then\n            return #a > #b\n        else\n            return a < b\n        end\n    end)\n\n    local max_word = words[1]\n    local max_count = 0\n\n    for i=1, #words do\n        local count = 0\n        local char_set = {}\n\n        for j=1, #words[i] do\n            if not char_set[words[i]:sub(j, j)] then\n                count = count + 1\n                char_set[words[i]:sub(j, j)] = true\n            end\n        end\n\n        if count > max_count then\n            max_count = count\n            max_word = words[i]\n        end\n    end\n\n    return max_word\nend\n\n### Explanation\n\nThe code is an implementation of a function called `find_max` that takes a list of words and returns the word with the most unique characters. \n\nThe first line of the code imports the built-in `math` library. \n\nThe second line defines a local function called `find_max` that takes a single argument called `words`. \n\nThe third line sorts the `words` list in descending order of length and ascending order of lexicographic order. The `table.sort` function takes two arguments: the first is the list to be sorted, and the second is a comparison function that takes two elements of the list and returns `true` if the first element should come before the second element in the sorted list. In this case, the comparison function first checks if the lengths of the two words are different. If they are, it returns `true` if the length of the first word is greater than the length of the second word. If the lengths are the same, it returns `true` if the first word is lexicographically less than the second word. \n\nThe fourth line initializes two local variables called `max_word` and `max_count` to the first word in the sorted list and 0, respectively. \n\nThe fifth line starts a `for` loop that iterates over the indices of the `words` list from 1 to the length of the list. \n\nThe sixth line initializes two local variables called `count` and `char_set` to 0 and an empty table, respectively. \n\nThe seventh line starts another `for` loop that iterates over the indices of the current word in the `words` list from 1 to the length of the word. \n\nThe eighth line checks if the current character of the current word is already in the `char_set` table. If it is not, it increments the `count` variable and sets the value of the current character in the `char_set` table to `true`. \n\nThe ninth line checks if the `count` variable is greater than the `max_count` variable. If it is, it updates the values of `max_count` and `max_word` to the current `count` and the current word, respectively. \n\nThe tenth line returns the `max_word` variable. \n\n\n### Racket version\n\n#lang racket\n\n(define (find_max words)\n"
  },
  {
    "name": "HumanEval_163_generate_integers",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (generate_integers a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_163_generate_integers.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate generate_integers))\n    (check-within (candidate 2 10) (list 2 4 6 8) 0.001)\n    (check-within (candidate 10 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 132 2) (list 2 4 6 8) 0.001)\n    (check-within (candidate 17 89) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function generate_integers(a, b)\n    local lower = math.max(2, math.min(a, b))\n    local upper = math.min(8, math.max(a, b))\n\n    local result = {}\n    for i=lower, upper do\n        if i%2 == 0 then\n            table.insert(result, i)\n        end\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that generates a list of even integers between two given integers. \n\n1. `math = require('math')` - This line imports the math library into the program. The math library provides a set of mathematical functions that can be used in the program.\n\n2. `local function generate_integers(a, b)` - This line defines a function called `generate_integers` that takes two arguments `a` and `b`.\n\n3. `local lower = math.max(2, math.min(a, b))` - This line sets the variable `lower` to the maximum of 2 and the minimum of `a` and `b`. This ensures that `lower` is at least 2 and is not greater than either `a` or `b`.\n\n4. `local upper = math.min(8, math.max(a, b))` - This line sets the variable `upper` to the minimum of 8 and the maximum of `a` and `b`. This ensures that `upper` is at most 8 and is not less than either `a` or `b`.\n\n5. `local result = {}` - This line initializes an empty table called `result`.\n\n6. `for i=lower, upper do` - This line starts a loop that iterates over the range of integers from `lower` to `upper`.\n\n7. `if i%2 == 0 then` - This line checks if the current integer `i` is even.\n\n8. `table.insert(result, i)` - This line adds the current integer `i` to the `result` table.\n\n9. `end` - This line ends the `if` statement.\n\n10. `end` - This line ends the `for` loop.\n\n11. `return result` - This line returns the `result` table containing the even integers between `a` and `b`. \n\n\n### Racket version\n\n#lang racket\n\n(define (generate_integers a b)\n"
  },
  {
    "name": "HumanEval_110_exchange",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (exchange lst1 lst2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_110_exchange.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate exchange))\n    (check-within (candidate (list 1 2 3 4) (list 1 2 3 4)) \"YES\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 1 5 3 4)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2 3 4) (list 2 1 4 3)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 4)) \"YES\" 0.001)\n    (check-within (candidate (list 5 7 3) (list 2 6 3)) \"NO\" 0.001)\n    (check-within (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) \"NO\" 0.001)\n    (check-within (candidate (list 100 200) (list 200 200)) \"YES\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function exchange(lst1, lst2)\n    local odd = 0\n    local even = 0\n    for i=1, #lst1 do\n        if lst1[i]%2 == 1 then\n            odd = odd + 1\n        end\n    end\n    for i=1, #lst2 do\n        if lst2[i]%2 == 0 then\n            even = even + 1\n        end\n    end\n    if even >= odd then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes two lists of integers as input and returns \"YES\" if the number of even integers in the second list is greater than or equal to the number of odd integers in the first list, and \"NO\" otherwise.\n\n- `math = require('math')` - This line imports the math library, which provides mathematical functions and constants.\n- `local function exchange(lst1, lst2)` - This line defines a local function called `exchange` that takes two parameters, `lst1` and `lst2`, which are lists of integers.\n- `local odd = 0` - This line initializes a local variable `odd` to 0.\n- `local even = 0` - This line initializes a local variable `even` to 0.\n- `for i=1, #lst1 do` - This line starts a loop that iterates over the indices of the first list `lst1`, from 1 to the length of the list `#lst1`.\n- `if lst1[i]%2 == 1 then` - This line checks if the element at index `i` in `lst1` is odd, by checking if the remainder of the division of the element by 2 is equal to 1.\n- `odd = odd + 1` - This line increments the `odd` variable by 1 if the element at index `i` in `lst1` is odd.\n- `for i=1, #lst2 do` - This line starts a loop that iterates over the indices of the second list `lst2`, from 1 to the length of the list `#lst2`.\n- `if lst2[i]%2 == 0 then` - This line checks if the element at index `i` in `lst2` is even, by checking if the remainder of the division of the element by 2 is equal to 0.\n- `even = even + 1` - This line increments the `even` variable by 1 if the element at index `i` in `lst2` is even.\n- `if even >= odd then` - This line checks if the number of even integers in `lst2` is greater than or equal to the number of odd integers in `lst1`.\n- `return \"YES\"` - This line returns the string \"YES\" if the condition is true.\n- `return \"NO\"` - This line returns the string \"NO\" if the condition is false.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (exchange lst1 lst2)\n"
  },
  {
    "name": "HumanEval_156_int_to_mini_roman",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (int_to_mini_roman number)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_156_int_to_mini_roman.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n    (check-within (candidate 19) \"xix\" 0.001)\n    (check-within (candidate 152) \"clii\" 0.001)\n    (check-within (candidate 251) \"ccli\" 0.001)\n    (check-within (candidate 426) \"cdxxvi\" 0.001)\n    (check-within (candidate 500) \"d\" 0.001)\n    (check-within (candidate 1) \"i\" 0.001)\n    (check-within (candidate 4) \"iv\" 0.001)\n    (check-within (candidate 43) \"xliii\" 0.001)\n    (check-within (candidate 90) \"xc\" 0.001)\n    (check-within (candidate 94) \"xciv\" 0.001)\n    (check-within (candidate 532) \"dxxxii\" 0.001)\n    (check-within (candidate 900) \"cm\" 0.001)\n    (check-within (candidate 994) \"cmxciv\" 0.001)\n    (check-within (candidate 1000) \"m\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function int_to_mini_roman(number)\n    local num = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}\n    local sym = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"}\n    local i = 13\n    local res = \"\"\n    while number > 0 do\n        local div = math.floor(number / num[i])\n        number = number % num[i]\n        while div > 0 do\n            res = res .. sym[i]\n            div = div - 1\n        end\n        i = i - 1\n    end\n    return string.lower(res)\nend\n\n### Explanation\n\nThe code is an implementation of a function that converts integers to mini roman numerals. \n\nThe first line of the code imports the math library. \n\nThe second line of the code defines a function called `int_to_mini_roman` that takes an integer as an argument. \n\nThe third line of the code defines a table called `num` that contains the values of the roman numerals. \n\nThe fourth line of the code defines a table called `sym` that contains the symbols of the roman numerals. \n\nThe fifth line of the code initializes a variable called `i` to 13. \n\nThe sixth line of the code initializes a variable called `res` to an empty string. \n\nThe seventh line of the code starts a while loop that runs while the input number is greater than 0. \n\nThe eighth line of the code calculates the integer division of the input number by the value of the roman numeral at index `i` in the `num` table. \n\nThe ninth line of the code calculates the remainder of the input number divided by the value of the roman numeral at index `i` in the `num` table. \n\nThe tenth line of the code starts a nested while loop that runs while the value of `div` is greater than 0. \n\nThe eleventh line of the code appends the symbol of the roman numeral at index `i` in the `sym` table to the `res` variable. \n\nThe twelfth line of the code decrements the value of `div` by 1. \n\nThe thirteenth line of the code decrements the value of `i` by 1. \n\nThe fourteenth line of the code returns the `res` variable in lowercase. \n\n\n### Racket version\n\n#lang racket\n\n(define (int_to_mini_roman number)\n"
  },
  {
    "name": "HumanEval_138_is_equal_to_sum_even",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_equal_to_sum_even n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 10) #t 0.001)\n    (check-within (candidate 11) #f 0.001)\n    (check-within (candidate 12) #t 0.001)\n    (check-within (candidate 13) #f 0.001)\n    (check-within (candidate 16) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_equal_to_sum_even(n)\n  return n%2 == 0 and n >= 8\nend\n\n### Explanation\n\nThe code is an implementation of a function `is_equal_to_sum_even` that takes an integer `n` as input and returns `true` if `n` is even and greater than or equal to 8, and `false` otherwise.\n\n* `math = require('math')` - This line imports the `math` module, which provides a set of mathematical functions. The `require` function is used to load a module in Lua.\n\n* `local function is_equal_to_sum_even(n)` - This line defines a local function called `is_equal_to_sum_even` that takes an integer `n` as input.\n\n* `return n%2 == 0 and n >= 8` - This line returns `true` if `n` is even and greater than or equal to 8, and `false` otherwise. The `%` operator is used to calculate the remainder of `n` divided by 2. If the remainder is 0, then `n` is even. The `and` operator is used to combine two conditions, so that both must be true for the overall condition to be true. The `>=` operator is used to check if `n` is greater than or equal to 8. If both conditions are true, then the function returns `true`. Otherwise, it returns `false`. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_equal_to_sum_even n)\n"
  },
  {
    "name": "HumanEval_33_sort_third",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (sort_third l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_33_sort_third.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_third))\n    (check-within (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5) 0.001)\n    (check-within (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5) 0.001)\n    (check-within (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5) 0.001)\n    (check-within (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function sort_third(l)\n    l = {table.unpack(l)}\n    for i = 3, #l, 3 do\n        local j = i\n        while j > 1 and l[j - 3 + 1] > l[j + 1] do\n            l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]\n            j = j - 3\n        end\n    end\n    return l\nend\n\n### Explanation\n\nThe code is an implementation of an insertion sort algorithm that sorts a list of numbers based on the third element of each group of three numbers. \n\n1. `math = require('math')` - This line imports the math library which provides mathematical functions for the program to use.\n\n2. `local function sort_third(l)` - This line declares a local function called `sort_third` that takes a list `l` as an argument.\n\n3. `l = {table.unpack(l)}` - This line creates a copy of the list `l` using the `table.unpack` function and assigns it to the variable `l`. \n\n4. `for i = 3, #l, 3 do` - This line starts a loop that iterates over every third element of the list `l`, starting from the third element.\n\n5. `local j = i` - This line declares a local variable `j` and assigns it the value of `i`.\n\n6. `while j > 1 and l[j - 3 + 1] > l[j + 1] do` - This line starts a loop that continues as long as `j` is greater than 1 and the third element of the group of three numbers at index `j - 3 + 1` is greater than the third element of the group of three numbers at index `j + 1`.\n\n7. `l[j - 3 + 1], l[j + 1] = l[j + 1], l[j - 3 + 1]` - This line swaps the positions of the group of three numbers at index `j - 3 + 1` with the group of three numbers at index `j + 1`.\n\n8. `j = j - 3` - This line decrements the value of `j` by 3.\n\n9. `return l` - This line returns the sorted list `l`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (sort_third l)\n"
  },
  {
    "name": "HumanEval_144_simplify",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (simplify x n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_144_simplify.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate simplify))\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/6\" \"2/1\") #f 0.001)\n    (check-within (candidate \"5/1\" \"3/1\") #t 0.001)\n    (check-within (candidate \"7/10\" \"10/2\") #f 0.001)\n    (check-within (candidate \"2/10\" \"50/10\") #t 0.001)\n    (check-within (candidate \"7/2\" \"4/2\") #t 0.001)\n    (check-within (candidate \"11/6\" \"6/1\") #t 0.001)\n    (check-within (candidate \"2/3\" \"5/2\") #f 0.001)\n    (check-within (candidate \"5/2\" \"3/5\") #f 0.001)\n    (check-within (candidate \"2/4\" \"8/4\") #t 0.001)\n    (check-within (candidate \"2/4\" \"4/2\") #t 0.001)\n    (check-within (candidate \"1/5\" \"5/1\") #t 0.001)\n    (check-within (candidate \"1/5\" \"1/5\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function simplify(x, n)\n  local a, b = x:match(\"([^/]+)/([^/]+)\")\n  local c, d = n:match(\"([^/]+)/([^/]+)\")\n  local numerator = tonumber(a) * tonumber(c)\n  local denom = tonumber(b) * tonumber(d)\n  if (numerator/denom == math.floor(numerator/denom)) then\n    return true\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function that simplifies fractions. The function takes two arguments, `x` and `n`, which are strings representing fractions. The function returns a boolean value indicating whether the fraction `x` can be simplified to `n`.\n\n1. `math = require('math')` - Import the math library.\n2. `local function simplify(x, n)` - Define a function `simplify` that takes two arguments, `x` and `n`.\n3. `local a, b = x:match(\"([^/]+)/([^/]+)\")` - Extract the numerator and denominator of `x` and store them in variables `a` and `b`, respectively. The `match` function is used to extract the numerator and denominator from the string `x`. The pattern `\"([^/]+)/([^/]+)\"` matches a string that has a slash `/` in the middle, and captures the characters before and after the slash as separate groups.\n4. `local c, d = n:match(\"([^/]+)/([^/]+)\")` - Extract the numerator and denominator of `n` and store them in variables `c` and `d`, respectively. This line is similar to line 3, but extracts the numerator and denominator from the string `n`.\n5. `local numerator = tonumber(a) * tonumber(c)` - Convert the strings `a` and `c` to numbers and multiply them together to get the numerator of the simplified fraction.\n6. `local denom = tonumber(b) * tonumber(d)` - Convert the strings `b` and `d` to numbers and multiply them together to get the denominator of the simplified fraction.\n7. `if (numerator/denom == math.floor(numerator/denom)) then` - Check if the simplified fraction is an integer. If the numerator divided by the denominator is equal to the floor of the numerator divided by the denominator, then the simplified fraction is an integer.\n8. `return true` - If the simplified fraction is an integer, return `true`.\n9. `return false` - If the simplified fraction is not an integer, return `false`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (simplify x n)\n"
  },
  {
    "name": "HumanEval_161_solve",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solve s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_161_solve.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-within (candidate \"AsDf\") \"aSdF\" 0.001)\n    (check-within (candidate \"1234\") \"4321\" 0.001)\n    (check-within (candidate \"ab\") \"AB\" 0.001)\n    (check-within (candidate \"#a@C\") \"#A@c\" 0.001)\n    (check-within (candidate \"#AsdfW^45\") \"#aSDFw^45\" 0.001)\n    (check-within (candidate \"#6@2\") \"2@6#\" 0.001)\n    (check-within (candidate \"#$a^D\") \"#$A^d\" 0.001)\n    (check-within (candidate \"#ccc\") \"#CCC\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function solve(s)\n    local flg = 0\n    local idx = 1\n    local new_str = {}\n    for i=1, #s do\n        if string.match(s:sub(i,i), '%a') then\n            new_str[idx] = string.match(s:sub(i,i), '%a'):upper() == s:sub(i,i) and string.match(s:sub(i,i), '%a'):lower() or string.match(s:sub(i,i), '%a'):upper()\n            flg = 1\n        else\n            new_str[idx] = s:sub(i,i)\n        end\n        idx = idx + 1\n    end\n    s = table.concat(new_str)\n    if flg == 0 then\n        return s:reverse()\n    end\n    return s\nend\n\n### Explanation\n\nThe code is an implementation of a function called `solve` that takes a string `s` as input and returns a string as output. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the block in which it is defined.\n\nThe first line of the function imports the `math` module, which provides access to mathematical functions and constants.\n\nThe next three lines of the function define three local variables: `flg`, `idx`, and `new_str`. `flg` is initialized to 0, `idx` is initialized to 1, and `new_str` is initialized to an empty table.\n\nThe function then enters a `for` loop that iterates over the characters in the input string `s`. The loop is controlled by the `for` statement, which specifies the loop variable `i`, the start value `1`, and the end value `#s` (which is the length of the string `s`). The loop body contains an `if` statement that checks if the current character is a letter (i.e., an alphabetic character). If it is, the `if` statement extracts the letter using the `string.sub` function, and then checks if it is uppercase or lowercase using the `string.match` function and a regular expression pattern (`'%a'`). If it is uppercase, the `if` statement converts it to lowercase using the `string.lower` function, and if it is lowercase, the `if` statement converts it to uppercase using the `string.upper` function. The converted letter is then added to the `new_str` table at the current index `idx`, and the `flg` variable is set to 1 to indicate that at least one letter was converted. If the current character is not a letter, it is simply added to the `new_str` table at the current index `idx`. Finally, the `idx` variable is incremented by 1 to prepare for the next iteration of the loop.\n\nAfter the loop finishes, the function concatenates the elements of the `new_str` table into a single string using the `table.concat` function, and assigns the result back to the `s` variable. If no letters were converted during the loop (i.e., `flg` is still 0), the function returns the reversed string `s`. Otherwise, the function returns the original string `s`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (solve s)\n"
  },
  {
    "name": "HumanEval_157_right_angle_triangle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (right_angle_triangle a b c)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n    (check-within (candidate 3 4 5) #t 0.001)\n    (check-within (candidate 1 2 3) #f 0.001)\n    (check-within (candidate 10 6 8) #t 0.001)\n    (check-within (candidate 2 2 2) #f 0.001)\n    (check-within (candidate 7 24 25) #t 0.001)\n    (check-within (candidate 10 5 7) #f 0.001)\n    (check-within (candidate 5 12 13) #t 0.001)\n    (check-within (candidate 15 8 17) #t 0.001)\n    (check-within (candidate 48 55 73) #t 0.001)\n    (check-within (candidate 1 1 1) #f 0.001)\n    (check-within (candidate 2 2 10) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function right_angle_triangle(a, b, c)\n  return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if a triangle is a right angle triangle. \n\nThe first line of the code imports the math library. \n\nThe second line of the code defines a function called `right_angle_triangle` that takes three arguments `a`, `b`, and `c`. \n\nThe third line of the code returns a boolean value that is `true` if the triangle is a right angle triangle and `false` otherwise. \n\nThe function checks if the square of one of the sides of the triangle is equal to the sum of the squares of the other two sides. If this is true for any of the three sides, then the triangle is a right angle triangle. \n\nThe function uses the logical `or` operator to check if any of the three conditions are true. \n\nThe `a*a == b*b + c*c` condition checks if the square of side `a` is equal to the sum of the squares of sides `b` and `c`. \n\nThe `b*b == a*a + c*c` condition checks if the square of side `b` is equal to the sum of the squares of sides `a` and `c`. \n\nThe `c*c == a*a + b*b` condition checks if the square of side `c` is equal to the sum of the squares of sides `a` and `b`. \n\nThe `local` keyword before the function definition limits the scope of the function to the current block of code. \n\n\n### Racket version\n\n#lang racket\n\n(define (right_angle_triangle a b c)\n"
  },
  {
    "name": "HumanEval_151_double_the_difference",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (double_the_difference lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_151_double_the_difference.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate double_the_difference))\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 5.0 4.0)) 25 0.001)\n    (check-within (candidate (list 0.1 0.2 0.3)) 0 0.001)\n    (check-within (candidate (list -10.0 -20.0 -30.0)) 0 0.001)\n    (check-within (candidate (list -1.0 -2.0 8.0)) 0 0.001)\n    (check-within (candidate (list 0.2 3.0 5.0)) 34 0.001)\n    (check-within (candidate (list -9.0 -7.0 -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0)) 165 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function double_the_difference(lst)\n    local sum = 0\n    for _, i in ipairs(lst) do\n        if i > 0 and i%2~=0 and math.floor(i) == i then\n            sum = sum + i^2\n        end\n    end\n    return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function called `double_the_difference` that takes a list of numbers as input and returns the sum of the squares of all odd positive integers in the list. \n\n- `math = require('math')` imports the math library into the program, which provides mathematical functions and constants.\n- `local function double_the_difference(lst)` defines a local function called `double_the_difference` that takes a list of numbers as input.\n- `local sum = 0` initializes a local variable called `sum` to 0.\n- `for _, i in ipairs(lst) do` starts a loop that iterates over each element of the input list `lst`. The `_` is a placeholder for the index of the current element, which is not needed in this case.\n- `if i > 0 and i%2~=0 and math.floor(i) == i then` checks if the current element `i` is a positive odd integer. The condition is true if `i` is greater than 0, not divisible by 2, and is equal to its floor value (i.e., it is an integer).\n- `sum = sum + i^2` adds the square of the current element `i` to the `sum` variable.\n- `end` ends the `if` statement.\n- `end` ends the `for` loop.\n- `return sum` returns the final value of the `sum` variable as the output of the function. \n\nTo rewrite this program in Racket, you could define a function called `double-the-difference` that takes a list of numbers as input and uses the `for` loop construct to iterate over each element of the list. You could use the `cond` construct to check if each element is a positive odd integer, and if so, add its square to a running total. Finally, you could return the total as the output of the function. Here's an example implementation:\n\n\n### Racket version\n\n#lang racket\n\n(define (double_the_difference lst)\n"
  },
  {
    "name": "HumanEval_137_compare_one",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (compare_one a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_137_compare_one.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare_one))\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 2.5) 2.5 0.001)\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 5 6) 6 0.001)\n    (check-within (candidate 1 \"2,3\") \"2,3\" 0.001)\n    (check-within (candidate \"5,1\" \"6\") \"6\" 0.001)\n    (check-within (candidate \"1\" \"2\") \"2\" 0.001)\n    (check-within (candidate \"1\" 1) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function compare_one(a, b)\n  local temp_a, temp_b = a, b\n  if type(temp_a) == 'string' then temp_a = temp_a:gsub(',', '.') end\n  if type(temp_b) == 'string' then temp_b = temp_b:gsub(',', '.') end\n  if tonumber(temp_a) == tonumber(temp_b) then return nil end\n  return tonumber(temp_a) > tonumber(temp_b) and a or b\nend\n\n### Explanation\n\nThe code is an implementation of a function that compares two values. The function is called `compare_one` and takes two arguments, `a` and `b`. \n\nThe first line of the code imports the `math` module. This module provides mathematical functions that can be used in the code.\n\nThe second line of the code defines the `compare_one` function. The function takes two arguments, `a` and `b`. \n\nThe third and fourth lines of the code create two local variables, `temp_a` and `temp_b`, and assign them the values of `a` and `b`, respectively. \n\nThe fifth and sixth lines of the code check if `temp_a` and `temp_b` are strings. If they are, the commas in the strings are replaced with periods. This is done to ensure that the strings can be converted to numbers later on.\n\nThe seventh line of the code checks if `temp_a` and `temp_b` are equal. If they are, the function returns `nil`.\n\nThe eighth line of the code checks if `temp_a` is greater than `temp_b`. If it is, the function returns `a`. If it is not, the function returns `b`. \n\nIn summary, the `compare_one` function takes two arguments, `a` and `b`, and compares them. If they are equal, the function returns `nil`. If `a` is greater than `b`, the function returns `a`. If `b` is greater than `a`, the function returns `b`. Before the comparison is made, the function checks if `a` and `b` are strings and replaces commas with periods if necessary. The `math` module is imported but not used in the function. \n\n\n### Racket version\n\n#lang racket\n\n(define (compare_one a b)\n"
  },
  {
    "name": "HumanEval_3_below_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (below_zero operations)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_3_below_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_zero))\n    (check-within (candidate (list )) #f 0.001)\n    (check-within (candidate (list 1 2 -3 1 2 -3)) #f 0.001)\n    (check-within (candidate (list 1 2 -4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f 0.001)\n    (check-within (candidate (list 1 -1 2 -2 5 -5 4 -5)) #t 0.001)\n    (check-within (candidate (list 1 -2 2 -2 5 -5 4 -4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function below_zero(operations)\n    local balance = 0\n\n    for _, op in ipairs(operations) do\n        balance = balance + op\n        if balance < 0 then\n            return true\n        end\n    end\n\n    return false\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes in a list of numbers and returns true if the sum of the numbers in the list is negative at any point. Otherwise, it returns false.\n\n`math = require('math')` - This line imports the math library in Lua. This library provides mathematical functions that can be used in Lua programs.\n\n`local function below_zero(operations)` - This line defines a function called `below_zero` that takes in a list of numbers called `operations`.\n\n`local balance = 0` - This line initializes a variable called `balance` to 0. This variable will be used to keep track of the sum of the numbers in the list.\n\n`for _, op in ipairs(operations) do` - This line starts a loop that iterates over each number in the `operations` list. The `_` is used to ignore the index of the current number.\n\n`balance = balance + op` - This line adds the current number to the `balance` variable.\n\n`if balance < 0 then` - This line checks if the `balance` variable is negative.\n\n`return true` - This line returns `true` if the `balance` variable is negative.\n\n`end` - This line ends the `if` statement.\n\n`end` - This line ends the `for` loop.\n\n`return false` - This line returns `false` if the `balance` variable is never negative. This means that the sum of the numbers in the list is always non-negative.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (below_zero operations)\n"
  },
  {
    "name": "HumanEval_13_greatest_common_divisor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (greatest_common_divisor a b)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n    (check-within (candidate 3 7) 1 0.001)\n    (check-within (candidate 10 15) 5 0.001)\n    (check-within (candidate 49 14) 7 0.001)\n    (check-within (candidate 144 60) 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function greatest_common_divisor(a, b)\n    while b ~= 0 do\n        a, b = b, a % b\n    end\n    return a\nend\n\n### Explanation\n\nThe code is an implementation of the Euclidean algorithm to find the greatest common divisor of two numbers. \n\nThe first line imports the math library.\n\nThe second line defines a function called `greatest_common_divisor` that takes two arguments `a` and `b`.\n\nThe third line starts a while loop that continues until `b` is equal to 0.\n\nThe fourth line sets `a` to `b` and `b` to the remainder of `a` divided by `b`.\n\nThe fifth line returns the value of `a`.\n\n\n### Racket version\n\n#lang racket\n\n(define (greatest_common_divisor a b)\n"
  },
  {
    "name": "HumanEval_106_f",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (f n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_106_f.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate f))\n    (check-within (candidate 5) (list 1 2 6 24 15) 0.001)\n    (check-within (candidate 7) (list 1 2 6 24 15 720 28) 0.001)\n    (check-within (candidate 1) (list 1) 0.001)\n    (check-within (candidate 3) (list 1 2 6) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function f(n)\n    local ret = {}\n    for i=1,n do\n        if i%2 == 0 then\n            local x = 1\n            for j=1,i do x = x*j end\n            table.insert(ret, x)\n        else\n            local x = 0\n            for j=1,i do x = x+j end\n            table.insert(ret, x)\n        end\n    end\n    return ret\nend\n\n### Explanation\n\nThe code is an implementation of a function `f` that takes a single argument `n` and returns a table of length `n`. The table contains the values of `x` computed in the loop. The value of `x` is computed differently depending on whether `i` is even or odd. If `i` is even, `x` is the product of the first `i` integers. If `i` is odd, `x` is the sum of the first `i` integers.\n\n- `math = require('math')`: This line imports the `math` module, which provides mathematical functions and constants. The `require` function is used to load a module by name. The `math` module is a built-in module in Lua, so it should always be available.\n- `local function f(n)`: This line defines a local function `f` that takes a single argument `n`. The `local` keyword is used to declare a local variable or function. Local variables and functions are only visible in the block where they are defined (in this case, the body of the function `f`). The `function` keyword is used to define a function.\n- `local ret = {}`: This line declares a local variable `ret` and initializes it to an empty table. The table will be used to store the values of `x` computed in the loop.\n- `for i=1,n do`: This line starts a loop that iterates from `1` to `n`, inclusive. The loop variable is `i`.\n- `if i%2 == 0 then`: This line starts an `if` statement that checks whether `i` is even. The `%` operator is the modulus operator, which returns the remainder of the division of `i` by `2`. If the remainder is `0`, then `i` is even.\n- `local x = 1`: This line declares a local variable `x` and initializes it to `1`. This variable will be used to compute the value of `x` for even values of `i`.\n- `for j=1,i do x = x*j end`: This line starts a loop that iterates from `1` to `i`, inclusive. The loop variable is `j`. In each iteration, `x` is multiplied by `j`. After the loop, `x` will be the product of the first `i` integers.\n- `table.insert(ret, x)`: This line inserts the value of `x` into the table `ret`.\n- `else`: This line starts the `else` block of the `if` statement. If `i` is odd, this block will be executed.\n- `local x = 0`: This line declares a local variable `x` and initializes it to `0`. This variable will be used to compute the value of `x` for odd values of `i`.\n- `for j=1,i do x = x+j end`: This line starts a loop that iterates from `1` to `i`, inclusive. The loop variable is `j`. In each iteration, `x` is incremented by `j`. After the loop, `x` will be the sum of the first `i` integers.\n- `table.insert(ret, x)`: This line inserts the value of `x` into the table `ret`.\n- `end`: This line ends the `if` statement.\n- `end`: This line ends the `for` loop.\n- `return ret`: This line returns the table `ret` containing the values of `x` computed in the loop.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (f n)\n"
  },
  {
    "name": "HumanEval_57_monotonic",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (monotonic l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_57_monotonic.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n    (check-within (candidate (list 1 2 4 10)) #t 0.001)\n    (check-within (candidate (list 1 2 4 20)) #t 0.001)\n    (check-within (candidate (list 1 20 4 10)) #f 0.001)\n    (check-within (candidate (list 4 1 0 -10)) #t 0.001)\n    (check-within (candidate (list 4 1 1 0)) #t 0.001)\n    (check-within (candidate (list 1 2 3 2 5 60)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 60)) #t 0.001)\n    (check-within (candidate (list 9 9 9 9)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function monotonic(l)\n    local is_increasing = true\n    local is_decreasing = true\n\n    for i=2, #l do\n        if l[i] > l[i-1] then\n            is_decreasing = false\n        elseif l[i] < l[i-1] then\n            is_increasing = false\n        end\n    end\n\n    return is_increasing or is_decreasing\nend\n\n### Explanation\n\nThe code is an implementation of a function called `monotonic` that takes a list of numbers `l` and returns a boolean indicating whether the list is monotonic. A list is monotonic if it is either entirely non-increasing or entirely non-decreasing.\n\nThe first line imports the `math` module.\n\nThe second line defines a local function called `monotonic` that takes a single argument `l`.\n\nThe next two lines define two local variables `is_increasing` and `is_decreasing` and set them both to `true`.\n\nThe `for` loop iterates over the list `l` starting from the second element (since we need to compare each element to the previous one). For each pair of elements, if the second element is greater than the first, then `is_decreasing` is set to `false`. If the second element is less than the first, then `is_increasing` is set to `false`.\n\nFinally, the function returns `true` if either `is_increasing` or `is_decreasing` is still `true`, indicating that the list is monotonic. Otherwise, it returns `false`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (monotonic l)\n"
  },
  {
    "name": "HumanEval_105_by_length",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (by_length arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_105_by_length.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate by_length))\n    (check-within (candidate (list 2 1 1 4 5 8 2 3)) (list \"Eight\" \"Five\" \"Four\" \"Three\" \"Two\" \"Two\" \"One\" \"One\") 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 -1 55)) (list \"One\") 0.001)\n    (check-within (candidate (list 1 -1 3 2)) (list \"Three\" \"Two\" \"One\") 0.001)\n    (check-within (candidate (list 9 4 8)) (list \"Nine\" \"Eight\" \"Four\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function by_length(arr)\n    local dic = {\n        [1] = \"One\",\n        [2] = \"Two\",\n        [3] = \"Three\",\n        [4] = \"Four\",\n        [5] = \"Five\",\n        [6] = \"Six\",\n        [7] = \"Seven\",\n        [8] = \"Eight\",\n        [9] = \"Nine\",\n    }\n    table.sort(arr, function(a, b) return a > b end)\n    local new_arr = {}\n    for i, var in ipairs(arr) do\n        if dic[var] then\n            table.insert(new_arr, dic[var])\n        end\n    end\n    return new_arr\nend\n\n### Explanation\n\nThe code is an implementation of a function called `by_length` that takes an array of integers and returns a new array of strings. The strings in the new array are the English words for the integers in the original array, sorted in descending order by the length of the word.\n\nThe first line of the function imports the Lua math library.\n\n\n### Racket version\n\n#lang racket\n\n(define (by_length arr)\n"
  },
  {
    "name": "HumanEval_51_remove_vowels",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (remove_vowels text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_51_remove_vowels.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_vowels))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"abcdef\nghijklm\") \"bcdf\nghjklm\" 0.001)\n    (check-within (candidate \"fedcba\") \"fdcb\" 0.001)\n    (check-within (candidate \"eeeee\") \"\" 0.001)\n    (check-within (candidate \"acBAA\") \"cB\" 0.001)\n    (check-within (candidate \"EcBOO\") \"cB\" 0.001)\n    (check-within (candidate \"ybcd\") \"ybcd\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function remove_vowels(text)\n    return text:gsub(\"[aeiouAEIOU]\", \"\")\nend\n\n### Explanation\n\nThe code is an implementation of a function that removes vowels from a given string. \n\n1. `math = require('math')` - This line imports the math module. The math module provides a set of mathematical functions. In this code, it is not used.\n\n2. `local function remove_vowels(text)` - This line defines a function `remove_vowels` that takes a string argument `text`. The `local` keyword makes the function local to the current block, which means it can only be accessed within the current file or scope.\n\n3. `return text:gsub(\"[aeiouAEIOU]\", \"\")` - This line returns the result of calling the `gsub` method on the `text` string. The `gsub` method is used to replace all occurrences of a pattern in a string. In this case, the pattern is a regular expression that matches all vowels (both uppercase and lowercase). The second argument to `gsub` is an empty string, which means all vowels will be replaced with nothing (i.e., removed). The `return` keyword is used to return the modified string from the function. \n\n\n### Racket version\n\n#lang racket\n\n(define (remove_vowels text)\n"
  },
  {
    "name": "HumanEval_134_check_if_last_char_is_a_letter",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n    (check-within (candidate \"apple\") #f 0.001)\n    (check-within (candidate \"apple pi e\") #t 0.001)\n    (check-within (candidate \"eeeee\") #f 0.001)\n    (check-within (candidate \"A\") #t 0.001)\n    (check-within (candidate \"Pumpkin pie \") #f 0.001)\n    (check-within (candidate \"Pumpkin pie 1\") #f 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"eeeee e \") #f 0.001)\n    (check-within (candidate \"apple pie\") #f 0.001)\n    (check-within (candidate \"apple pi e \") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function check_if_last_char_is_a_letter(txt)\n    local check = txt:match(\"%a%a*$\")\n    return check ~= nil and #check == 1\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if the last character of a string is a letter. The function takes in a string as an argument and returns a boolean value. \n\n1. `math = require('math')` - This line imports the math library into the program. The math library provides a set of mathematical functions that can be used in the program.\n\n2. `local function check_if_last_char_is_a_letter(txt)` - This line defines a function called `check_if_last_char_is_a_letter` that takes in a string argument called `txt`. The `local` keyword is used to define a local variable that is only accessible within the scope of the function.\n\n3. `local check = txt:match(\"%a%a*$\")` - This line defines a local variable called `check` and assigns it the value of the result of the `match` function applied to the `txt` argument. The `match` function is a string function that searches for a pattern in a string. In this case, the pattern is `%a%a*$`. The `%a` pattern matches any letter, and the `$` pattern matches the end of the string. The `%a%a*$` pattern matches one or more letters at the end of the string. The `:` operator is used to call the `match` function on the `txt` argument.\n\n4. `return check ~= nil and #check == 1` - This line returns a boolean value based on the result of the previous line. The `~=` operator checks if `check` is not equal to `nil`. The `#` operator returns the length of the `check` string. The `==` operator checks if the length of `check` is equal to 1. The `and` operator combines the two conditions and returns `true` if both conditions are `true`. The line returns `true` if the last character of the `txt` argument is a letter and there is only one letter at the end of the string. Otherwise, it returns `false`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (check_if_last_char_is_a_letter txt)\n"
  },
  {
    "name": "HumanEval_77_iscube",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (iscube a)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_77_iscube.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate iscube))\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate -1) #t 0.001)\n    (check-within (candidate 64) #t 0.001)\n    (check-within (candidate 180) #f 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 0) #t 0.001)\n    (check-within (candidate 1729) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function iscube(a)\n    a = math.abs(a)\n    return math.floor(a^(1/3) + 0.5)^3 == a\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a number is a perfect cube. \n\n1. `math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions and constants. \n\n2. `local function iscube(a)` - This line defines a function called `iscube` that takes a single argument `a`. The `local` keyword makes the function local to the current scope.\n\n3. `a = math.abs(a)` - This line assigns the absolute value of `a` to `a`. The `math.abs()` function returns the absolute value of a number.\n\n4. `return math.floor(a^(1/3) + 0.5)^3 == a` - This line returns a boolean value indicating whether `a` is a perfect cube. \n\n    a. `math.floor(a^(1/3) + 0.5)` - This part of the line calculates the cube root of `a` and rounds it to the nearest integer. \n    \n    b. `^3` - This part of the line raises the rounded cube root to the power of 3. \n    \n    c. `== a` - This part of the line checks whether the result of the previous calculation is equal to `a`. If it is, then `a` is a perfect cube and the function returns `true`. Otherwise, it returns `false`. \n\nOverall, the function takes a number `a`, calculates its cube root, rounds it to the nearest integer, raises it to the power of 3, and checks whether the result is equal to `a`. If it is, then `a` is a perfect cube and the function returns `true`. Otherwise, it returns `false`. \n\n\n### Racket version\n\n#lang racket\n\n(define (iscube a)\n"
  },
  {
    "name": "HumanEval_4_mean_absolute_deviation",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (mean_absolute_deviation numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mean_absolute_deviation))\n    (check-within (candidate (list 1.0 2.0)) 0.5 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0)) 1.0 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function mean_absolute_deviation(numbers)\n    local mean = 0\n    for _, v in ipairs(numbers) do\n        mean = mean + v\n    end\n    mean = mean / #numbers\n    local sum = 0\n    for _, v in ipairs(numbers) do\n        sum = sum + math.abs(v - mean)\n    end\n    return sum / #numbers\nend\n\n### Explanation\n\nThe code is an implementation of a function that calculates the mean absolute deviation of a list of numbers. \n\n\n### Racket version\n\n#lang racket\n\n(define (mean_absolute_deviation numbers)\n"
  },
  {
    "name": "HumanEval_56_correct_bracketing",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (correct_bracketing brackets)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_56_correct_bracketing.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n    (check-within (candidate \"<>\") #t 0.001)\n    (check-within (candidate \"<<><>>\") #t 0.001)\n    (check-within (candidate \"<><><<><>><>\") #t 0.001)\n    (check-within (candidate \"<><><<<><><>><>><<><><<>>>\") #t 0.001)\n    (check-within (candidate \"<<<><>>>>\") #f 0.001)\n    (check-within (candidate \"><<>\") #f 0.001)\n    (check-within (candidate \"<\") #f 0.001)\n    (check-within (candidate \"<<<<\") #f 0.001)\n    (check-within (candidate \">\") #f 0.001)\n    (check-within (candidate \"<<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>><<>\") #f 0.001)\n    (check-within (candidate \"<><><<><>><>>><>\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function correct_bracketing(brackets)\n    local depth = 0\n    for b in brackets:gmatch(\".\") do\n        if b == \"<\" then\n            depth = depth + 1\n        else\n            depth = depth - 1\n        end\n        if depth < 0 then\n            return false\n        end\n    end\n    return depth == 0\nend\n\n### Explanation\n\nThe code is an implementation of a function `correct_bracketing` that takes a string of brackets and returns true if the brackets are correctly balanced and false otherwise. \n\n1. `math = require('math')` - This line imports the math library in Lua. This library provides a set of mathematical functions that can be used in Lua programs. \n\n2. `local function correct_bracketing(brackets)` - This line defines a local function called `correct_bracketing` that takes a string parameter called `brackets`. \n\n3. `local depth = 0` - This line initializes a local variable called `depth` to 0. This variable will be used to keep track of the depth of the bracketing.\n\n4. `for b in brackets:gmatch(\".\") do` - This line starts a loop that iterates over each character in the `brackets` string. The `gmatch` function is used to iterate over each character in the string. The `.` pattern matches any character.\n\n5. `if b == \"<\" then` - This line checks if the current character is an opening bracket. If it is, the depth is incremented by 1.\n\n6. `depth = depth - 1` - This line checks if the current character is a closing bracket. If it is, the depth is decremented by 1.\n\n7. `if depth < 0 then` - This line checks if the depth is less than 0. If it is, it means that there is a closing bracket without a corresponding opening bracket, so the function returns false.\n\n8. `return depth == 0` - This line checks if the depth is equal to 0. If it is, it means that all opening brackets have a corresponding closing bracket, so the function returns true. If it is not, it means that there are more opening brackets than closing brackets, so the function returns false. \n\n\n### Racket version\n\n#lang racket\n\n(define (correct_bracketing brackets)\n"
  },
  {
    "name": "HumanEval_21_rescale_to_unit",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (rescale_to_unit numbers)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n    (check-within (candidate (list 2.0 49.9)) (list 0.0 1.0) 0.001)\n    (check-within (candidate (list 100.0 49.9)) (list 1.0 0.0) 0.001)\n    (check-within (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0) 0.001)\n    (check-within (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n    (check-within (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function rescale_to_unit(numbers)\n    local min_number = math.min(table.unpack(numbers))\n    local max_number = math.max(table.unpack(numbers))\n    local result = {}\n    for i, x in ipairs(numbers) do\n        result[i] = (x - min_number) / (max_number - min_number)\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function that rescales a list of numbers to the unit interval [0, 1]. The function takes a list of numbers as input and returns a new list of the same length with each element rescaled to the unit interval.\n\n- `math = require('math')`: This line loads the built-in math library, which provides mathematical functions and constants.\n- `local function rescale_to_unit(numbers)`: This line defines a new function called `rescale_to_unit` that takes a list of numbers as input.\n- `local min_number = math.min(table.unpack(numbers))`: This line finds the minimum value in the input list by unpacking the list using the `table.unpack` function and passing the resulting values to the `math.min` function. The result is stored in a local variable called `min_number`.\n- `local max_number = math.max(table.unpack(numbers))`: This line finds the maximum value in the input list in a similar way to the previous line. The result is stored in a local variable called `max_number`.\n- `local result = {}`: This line creates an empty table called `result` that will be used to store the rescaled values.\n- `for i, x in ipairs(numbers) do`: This line starts a loop that iterates over each element in the input list. The `ipairs` function is used to iterate over the list in order.\n- `result[i] = (x - min_number) / (max_number - min_number)`: This line calculates the rescaled value for the current element by subtracting the minimum value from the element, dividing the result by the range of the input values, and storing the result in the `result` table at the same index as the current element.\n- `end`: This line ends the loop.\n- `return result`: This line returns the `result` table containing the rescaled values.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (rescale_to_unit numbers)\n"
  },
  {
    "name": "HumanEval_127_intersection",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (intersection interval1 interval2)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_127_intersection.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate intersection))\n    (check-within (candidate (list 1 2) (list 2 3)) \"NO\" 0.001)\n    (check-within (candidate (list -1 1) (list 0 4)) \"NO\" 0.001)\n    (check-within (candidate (list -3 -1) (list -5 5)) \"YES\" 0.001)\n    (check-within (candidate (list -2 2) (list -4 0)) \"YES\" 0.001)\n    (check-within (candidate (list -11 2) (list -1 -1)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 3 5)) \"NO\" 0.001)\n    (check-within (candidate (list 1 2) (list 1 2)) \"NO\" 0.001)\n    (check-within (candidate (list -2 -2) (list -3 -2)) \"NO\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function intersection(interval1, interval2)\n    local function is_prime(num)\n        if num == 1 or num == 0 then\n            return false\n        end\n        if num == 2 then\n            return true\n        end\n        for i=2,num-1 do\n            if num%i == 0 then\n                return false\n            end\n        end\n        return true\n    end\n\n    local l = math.max(interval1[1], interval2[1])\n    local r = math.min(interval1[2], interval2[2])\n    local length = r - l\n    if length > 0 and is_prime(length) then\n        return \"YES\"\n    end\n    return \"NO\"\nend\n\n### Explanation\n\nThe code is an implementation of an `intersection` function that takes two intervals as input and returns \"YES\" if the length of the intersection of the two intervals is a prime number, and \"NO\" otherwise.\n\n1. `math = require('math')` - This line imports the `math` module, which provides mathematical functions and constants in Lua.\n\n2. `local function intersection(interval1, interval2)` - This line defines a local function called `intersection` that takes two intervals as input.\n\n3. `local function is_prime(num)` - This line defines a local function called `is_prime` that takes a number as input and returns `true` if the number is prime, and `false` otherwise.\n\n4. `if num == 1 or num == 0 then return false end` - This line checks if the input number is 1 or 0, and returns `false` if it is.\n\n5. `if num == 2 then return true end` - This line checks if the input number is 2, and returns `true` if it is.\n\n6. `for i=2,num-1 do if num%i == 0 then return false end end` - This line loops through all numbers from 2 to `num-1`, and checks if `num` is divisible by any of them. If it is, the function returns `false`.\n\n7. `return true` - This line is reached if the input number is not 1, 0, 2, or divisible by any number from 2 to `num-1`. In this case, the function returns `true`.\n\n8. `local l = math.max(interval1[1], interval2[1])` - This line sets `l` to the maximum of the first element of `interval1` and the first element of `interval2`.\n\n9. `local r = math.min(interval1[2], interval2[2])` - This line sets `r` to the minimum of the second element of `interval1` and the second element of `interval2`.\n\n10. `local length = r - l` - This line sets `length` to the difference between `r` and `l`.\n\n11. `if length > 0 and is_prime(length) then return \"YES\" end` - This line checks if `length` is greater than 0 and is a prime number. If it is, the function returns \"YES\".\n\n12. `return \"NO\"` - This line is reached if `length` is not greater than 0 or is not a prime number. In this case, the function returns \"NO\".<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (intersection interval1 interval2)\n"
  },
  {
    "name": "HumanEval_78_hex_key",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (hex_key num)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_78_hex_key.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n    (check-within (candidate \"AB\") 1 0.001)\n    (check-within (candidate \"1077E\") 2 0.001)\n    (check-within (candidate \"ABED1A33\") 4 0.001)\n    (check-within (candidate \"2020\") 2 0.001)\n    (check-within (candidate \"123456789ABCDEF0\") 6 0.001)\n    (check-within (candidate \"112233445566778899AABBCCDDEEFF00\") 12 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function hex_key(num)\n    local primes = {'2', '3', '5', '7', 'B', 'D'}\n    local total = 0\n    for i = 1, #num do\n        if table.concat(primes):find(num:sub(i, i)) then\n            total = total + 1\n        end\n    end\n    return total\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a string of hexadecimal digits and returns the number of times a digit in the string is a prime number in hexadecimal. \n\n1. `math = require('math')` - This line imports the math library in Lua. This library provides a set of mathematical functions that can be used in Lua programs.\n\n2. `local function hex_key(num)` - This line defines a function called `hex_key` that takes a single argument `num`. The `local` keyword is used to define a local variable that is only accessible within the scope of the function.\n\n3. `local primes = {'2', '3', '5', '7', 'B', 'D'}` - This line defines a local variable called `primes` that is an array of hexadecimal digits that represent prime numbers.\n\n4. `local total = 0` - This line defines a local variable called `total` and initializes it to 0.\n\n5. `for i = 1, #num do` - This line starts a loop that iterates over each character in the `num` string. The `#` operator is used to get the length of the string.\n\n6. `if table.concat(primes):find(num:sub(i, i)) then` - This line checks if the current character in the `num` string is a prime number in hexadecimal. The `table.concat` function is used to concatenate all elements in the `primes` array into a single string. The `find` function is then called on this concatenated string with the current character in the `num` string as an argument. The `sub` function is used to get a substring of the `num` string that contains only the current character.\n\n7. `total = total + 1` - This line increments the `total` variable by 1 if the current character in the `num` string is a prime number in hexadecimal.\n\n8. `end` - This line marks the end of the loop.\n\n9. `return total` - This line returns the final value of the `total` variable, which represents the number of times a digit in the `num` string is a prime number in hexadecimal.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (hex_key num)\n"
  },
  {
    "name": "HumanEval_70_strange_sort_list",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (strange_sort_list lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_70_strange_sort_list.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate strange_sort_list))\n    (check-within (candidate (list 1 2 3 4)) (list 1 4 2 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3) 0.001)\n    (check-within (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7) 0.001)\n    (check-within (candidate (list 5 5 5 5)) (list 5 5 5 5) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5) 0.001)\n    (check-within (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2) 0.001)\n    (check-within (candidate (list 111111)) (list 111111) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function strange_sort_list(lst)\n    local res, switch = {}, true\n    while #lst > 0 do\n        if switch then\n            table.insert(res, math.min(table.unpack(lst)))\n        else\n            table.insert(res, math.max(table.unpack(lst)))\n        end\n        local index = 0\n        for i, v in ipairs(lst) do\n            if v == res[#res] then\n                index = i\n                break\n            end\n        end\n        table.remove(lst, index)\n        switch = not switch\n    end\n    return res\nend\n\n### Explanation\n\nThe code is an implementation of a sorting algorithm that sorts a list of numbers in a strange way. The function takes a list of numbers as an input and returns a new list that is sorted in a strange way. The function works as follows:\n\n1. `math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions that can be used in Lua programs.\n\n2. `local function strange_sort_list(lst)` - This line defines a new function called `strange_sort_list` that takes a list of numbers as an input.\n\n3. `local res, switch = {}, true` - This line initializes two variables, `res` and `switch`. `res` is an empty list that will be used to store the sorted numbers, and `switch` is a boolean variable that will be used to alternate between sorting the list in ascending and descending order.\n\n4. `while #lst > 0 do` - This line starts a loop that will continue until the input list is empty.\n\n5. `if switch then` - This line checks the value of the `switch` variable. If it is `true`, then the list will be sorted in ascending order.\n\n6. `table.insert(res, math.min(table.unpack(lst)))` - This line finds the minimum value in the input list using the `math.min` function and inserts it into the `res` list using the `table.insert` function.\n\n7. `else` - This line is executed if the `switch` variable is `false`. In this case, the list will be sorted in descending order.\n\n8. `table.insert(res, math.max(table.unpack(lst)))` - This line finds the maximum value in the input list using the `math.max` function and inserts it into the `res` list using the `table.insert` function.\n\n9. `local index = 0` - This line initializes a variable called `index` to 0. This variable will be used to keep track of the index of the number that was just added to the `res` list.\n\n10. `for i, v in ipairs(lst) do` - This line starts a loop that iterates over the input list and assigns each value to the variable `v` and its index to the variable `i`.\n\n11. `if v == res[#res] then` - This line checks if the current value in the input list is equal to the last value that was added to the `res` list.\n\n12. `index = i` - This line sets the value of the `index` variable to the index of the current value in the input list if it is equal to the last value that was added to the `res` list.\n\n13. `break` - This line breaks out of the loop as soon as the index of the current value in the input list is found.\n\n14. `table.remove(lst, index)` - This line removes the value at the index found in step 12 from the input list using the `table.remove` function.\n\n15. `switch = not switch` - This line toggles the value of the `switch` variable so that the next iteration of the loop will sort the list in the opposite order.\n\n16. `end` - This line marks the end of the loop.\n\n17. `return res` - This line returns the sorted list.\n\n\n### Racket version\n\n#lang racket\n\n(define (strange_sort_list lst)\n"
  },
  {
    "name": "HumanEval_14_all_prefixes",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (all_prefixes string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_14_all_prefixes.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate all_prefixes))\n    (check-within (candidate \"\") (list ) 0.001)\n    (check-within (candidate \"asdfgh\") (list \"a\" \"as\" \"asd\" \"asdf\" \"asdfg\" \"asdfgh\") 0.001)\n    (check-within (candidate \"WWW\") (list \"W\" \"WW\" \"WWW\") 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function all_prefixes(string)\n    local result = {}\n\n    for i=1, #string do\n        table.insert(result, string:sub(1, i))\n    end\n    return result\nend\n\n### Explanation\n\nThe code is an implementation of a function called `all_prefixes` that takes a string as input and returns a list of all its prefixes. \n\n1. `math = require('math')` - This line imports the math library in Lua. This library provides a set of mathematical functions that can be used in Lua programs. \n\n2. `local function all_prefixes(string)` - This line defines a function called `all_prefixes` that takes a string as input. The `local` keyword is used to define a local variable that is only accessible within the scope of the function. \n\n3. `local result = {}` - This line creates an empty table called `result` that will be used to store the prefixes of the input string. \n\n4. `for i=1, #string do` - This line starts a loop that will iterate from 1 to the length of the input string. The `#` operator is used to get the length of the string. \n\n5. `table.insert(result, string:sub(1, i))` - This line inserts a new element into the `result` table. The element is a substring of the input string that starts at the first character and ends at the `i`th character. The `table.insert` function is used to add the new element to the table. \n\n6. `end` - This line marks the end of the loop. \n\n7. `return result` - This line returns the `result` table, which contains all the prefixes of the input string. \n\n\n### Racket version\n\n#lang racket\n\n(define (all_prefixes string)\n"
  },
  {
    "name": "HumanEval_18_how_many_times",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (how_many_times string substring)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_18_how_many_times.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n    (check-within (candidate \"\" \"x\") 0 0.001)\n    (check-within (candidate \"xyxyxyx\" \"x\") 4 0.001)\n    (check-within (candidate \"cacacacac\" \"cac\") 4 0.001)\n    (check-within (candidate \"john doe\" \"john\") 1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function how_many_times(string, substring)\n  local times = 0\n  for i = 1, #string - #substring + 1 do\n    if string:sub(i, i + #substring - 1) == substring then\n      times = times + 1\n    end\n  end\n  return times\nend\n\n### Explanation\n\nThe code is an implementation of a function that counts how many times a substring appears in a string. \n\nThe first line imports the math library.\n\nThe second line defines a function called `how_many_times` that takes two arguments, `string` and `substring`.\n\nThe third line initializes a variable called `times` to 0.\n\nThe fourth line starts a loop that will run from `i = 1` to `i = #string - #substring + 1`. The `#` operator returns the length of a string.\n\nThe fifth line checks if the substring starting at index `i` and ending at index `i + #substring - 1` is equal to the `substring`. If it is, then `times` is incremented by 1.\n\nThe sixth line returns the value of `times`. \n\nOverall, the function iterates through all possible substrings of `string` of length `substring`, and counts how many times the `substring` appears. \n\n\n### Racket version\n\n#lang racket\n\n(define (how_many_times string substring)\n"
  },
  {
    "name": "HumanEval_121_solution",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (solution lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_121_solution.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solution))\n    (check-within (candidate (list 5 8 7 1)) 12 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 9 0.001)\n    (check-within (candidate (list 30 13 24 321)) 0 0.001)\n    (check-within (candidate (list 5 9)) 5 0.001)\n    (check-within (candidate (list 2 4 8)) 0 0.001)\n    (check-within (candidate (list 30 13 23 32)) 23 0.001)\n    (check-within (candidate (list 3 13 2 9)) 3 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function solution(lst)\n  local sum = 0\n  for idx, x in ipairs(lst) do\n    if idx%2==1 and x%2==1 then\n      sum = sum + x\n    end\n  end\n  return sum\nend\n\n### Explanation\n\nThe code is an implementation of a function called `solution` that takes a list as an input and returns the sum of all odd numbers in the list that are in odd positions. \n\n`math = require('math')` imports the math library.\n\n`local function solution(lst)` defines a function called `solution` that takes a list as an argument.\n\n`local sum = 0` initializes a variable called `sum` to 0.\n\n`for idx, x in ipairs(lst) do` iterates over the elements of the input list `lst` and assigns the index of the element to `idx` and the element itself to `x`.\n\n`if idx%2==1 and x%2==1 then` checks if the index of the element is odd (`idx%2==1`) and if the element itself is odd (`x%2==1`).\n\n`sum = sum + x` adds the element `x` to the `sum` variable.\n\n`end` ends the `if` statement.\n\n`end` ends the `for` loop.\n\n`return sum` returns the final value of the `sum` variable. \n\n\n### Racket version\n\n#lang racket\n\n(define (solution lst)\n"
  },
  {
    "name": "HumanEval_126_is_sorted",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_sorted lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_126_is_sorted.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_sorted))\n    (check-within (candidate (list 5)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7)) #t 0.001)\n    (check-within (candidate (list 1 3 2 4 5 6 7)) #f 0.001)\n    (check-within (candidate (list )) #t 0.001)\n    (check-within (candidate (list 1)) #t 0.001)\n    (check-within (candidate (list 3 2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 2 2 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 3 3 3 4)) #f 0.001)\n    (check-within (candidate (list 1 2 2 3 3 4)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4)) #t 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_sorted(lst)\n    local count_digit = {}\n    for i=1, #lst do\n        count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1\n    end\n    for i=1, #lst do\n        if count_digit[lst[i]] > 2 then\n            return false\n        end\n    end\n    for i=2, #lst do\n        if lst[i-1] > lst[i] then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a list of numbers is sorted and has no more than two of the same number. \n\n1. `math = require('math')` - import the math library\n2. `local function is_sorted(lst)` - define a function called `is_sorted` that takes a list as an argument\n3. `local count_digit = {}` - create an empty table called `count_digit`\n4. `for i=1, #lst do` - loop through the list `lst` from index 1 to the length of the list\n5. `count_digit[lst[i]] = (count_digit[lst[i]] or 0) + 1` - increment the count of the current number in the `count_digit` table by 1. If the number is not in the table yet, set its count to 0 and then increment it by 1.\n6. `for i=1, #lst do` - loop through the list `lst` from index 1 to the length of the list\n7. `if count_digit[lst[i]] > 2 then` - if the count of the current number in the `count_digit` table is greater than 2, return `false`\n8. `for i=2, #lst do` - loop through the list `lst` from index 2 to the length of the list\n9. `if lst[i-1] > lst[i] then` - if the previous number in the list is greater than the current number, return `false`\n10. `return true` - if the list passes both checks, return `true` to indicate that it is sorted and has no more than two of the same number.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (is_sorted lst)\n"
  },
  {
    "name": "HumanEval_69_search",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (search lst)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_69_search.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate search))\n    (check-within (candidate (list 5 5 5 5 1)) 1 0.001)\n    (check-within (candidate (list 4 1 4 1 4 4)) 4 0.001)\n    (check-within (candidate (list 3 3)) -1 0.001)\n    (check-within (candidate (list 8 8 8 8 8 8 8 8)) 8 0.001)\n    (check-within (candidate (list 2 3 3 2 2)) 2 0.001)\n    (check-within (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1 0.001)\n    (check-within (candidate (list 3 2 8 2)) 2 0.001)\n    (check-within (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1 0.001)\n    (check-within (candidate (list 8 8 3 6 5 6 4)) -1 0.001)\n    (check-within (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1 0.001)\n    (check-within (candidate (list 1 9 10 1 3)) 1 0.001)\n    (check-within (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5 0.001)\n    (check-within (candidate (list 1)) 1 0.001)\n    (check-within (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4 0.001)\n    (check-within (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2 0.001)\n    (check-within (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1 0.001)\n    (check-within (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4 0.001)\n    (check-within (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4 0.001)\n    (check-within (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2 0.001)\n    (check-within (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1 0.001)\n    (check-within (candidate (list 10)) -1 0.001)\n    (check-within (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2 0.001)\n    (check-within (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1 0.001)\n    (check-within (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1 0.001)\n    (check-within (candidate (list 3 10 10 9 2)) -1 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function search(lst)\n    local frq = {}\n    for i=1, math.max(table.unpack(lst)) do\n        frq[i] = 0\n    end\n    for i=1, #lst do\n        frq[lst[i]] = frq[lst[i]] + 1\n    end\n\n    local ans = -1\n    for i=1, #frq do\n        if frq[i] >= i then\n            ans = i\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function `search` that takes a list of integers as input and returns an integer. The function returns the smallest integer `i` such that the frequency of `i` in the input list is greater than or equal to `i`. If no such integer exists, the function returns `-1`.\n\n* `math = require('math')` - This line imports the `math` module, which provides mathematical functions and constants. The `require` function is used to load modules in Lua.\n\n* `local function search(lst)` - This line defines a local function `search` that takes a single argument `lst`. The `local` keyword is used to declare that the function is only accessible within the current scope.\n\n* `local frq = {}` - This line declares a local variable `frq` and initializes it to an empty table. The table will be used to keep track of the frequency of each integer in the input list.\n\n* `for i=1, math.max(table.unpack(lst)) do` - This line starts a `for` loop that iterates over the integers from `1` to the maximum value in the input list. The `math.max` function is used to find the maximum value in the input list, and `table.unpack` is used to unpack the list into individual arguments for the `math.max` function.\n\n* `frq[i] = 0` - This line sets the value of the `i`th index of the `frq` table to `0`. This initializes the frequency count for each integer to `0`.\n\n* `for i=1, #lst do` - This line starts another `for` loop that iterates over the indices of the input list.\n\n* `frq[lst[i]] = frq[lst[i]] + 1` - This line increments the frequency count for the `i`th element of the input list. The `lst[i]` expression is used to access the `i`th element of the input list, and the `frq[lst[i]]` expression is used to access the frequency count for that element.\n\n* `local ans = -1` - This line declares a local variable `ans` and initializes it to `-1`. This variable will be used to store the result of the function.\n\n* `for i=1, #frq do` - This line starts another `for` loop that iterates over the indices of the `frq` table.\n\n* `if frq[i] >= i then` - This line checks if the frequency count for the `i`th element of the `frq` table is greater than or equal to `i`.\n\n* `ans = i` - This line sets the value of `ans` to `i` if the condition in the previous line is true. This means that `ans` will be set to the smallest integer `i` such that the frequency of `i` in the input list is greater than or equal to `i`.\n\n* `return ans` - This line returns the value of `ans` as the result of the function. If no such integer exists, the function returns `-1`.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (search lst)\n"
  },
  {
    "name": "HumanEval_68_pluck",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pluck arr)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_68_pluck.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n    (check-within (candidate (list 4 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list 1 2 3)) (list 2 1) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n    (check-within (candidate (list 5 0 3 0 4 2)) (list 0 1) 0.001)\n    (check-within (candidate (list 1 2 3 0 5 3)) (list 0 3) 0.001)\n    (check-within (candidate (list 5 4 8 4 8)) (list 4 1) 0.001)\n    (check-within (candidate (list 7 6 7 1)) (list 6 1) 0.001)\n    (check-within (candidate (list 7 9 7 1)) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function pluck(arr)\n    if(#arr == 0) then return {} end\n    local evens = {}\n    for _, v in ipairs(arr) do\n        if(v%2 == 0) then table.insert(evens, v) end\n    end\n    if(#evens == 0) then return {} end\n    local min_val = math.min(table.unpack(evens))\n    for i, v in ipairs(arr) do\n        if(v == min_val) then return {min_val, i-1} end\n    end\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes an array of numbers and returns the smallest even number in the array and its index. If there are no even numbers in the array, it returns an empty array.\n\n\n### Racket version\n\n#lang racket\n\n(define (pluck arr)\n"
  },
  {
    "name": "HumanEval_43_pairs_sum_to_zero",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (pairs_sum_to_zero l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n    (check-within (candidate (list 1 3 5 0)) #f 0.001)\n    (check-within (candidate (list 1 3 -2 1)) #f 0.001)\n    (check-within (candidate (list 1 2 3 7)) #f 0.001)\n    (check-within (candidate (list 2 4 -5 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 30)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 3 2 31)) #t 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 30)) #f 0.001)\n    (check-within (candidate (list -3 9 -1 4 2 31)) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function pairs_sum_to_zero(l)\n  for i, l1 in ipairs(l) do\n    for j = i + 1, #l do\n      if l1 + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\nend\n\n### Explanation\n\nThe code is an implementation of a function called `pairs_sum_to_zero` that takes a list of numbers as input and returns `true` if there are any pairs of numbers in the list that sum to zero, and `false` otherwise.\n\nThe function first imports the `math` module, which provides a set of mathematical functions and constants. \n\n\n### Racket version\n\n#lang racket\n\n(define (pairs_sum_to_zero l)\n"
  },
  {
    "name": "HumanEval_10_make_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_palindrome string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_10_make_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_palindrome))\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"xyz\") \"xyzyx\" 0.001)\n    (check-within (candidate \"xyx\") \"xyx\" 0.001)\n    (check-within (candidate \"jerry\") \"jerryrrej\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function make_palindrome(string)\n    if not string then\n        return ''\n    end\n\n    local beginning_of_suffix = 0\n\n    while string:sub(beginning_of_suffix+1) ~= string:sub(beginning_of_suffix+1):reverse() do\n        beginning_of_suffix = beginning_of_suffix + 1\n    end\n\n    return string .. string:sub(1, beginning_of_suffix):reverse()\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a string and returns a palindrome of that string.\n\n1. `math = require('math')` - import the math module.\n2. `local function make_palindrome(string)` - define a function called `make_palindrome` that takes a string as an argument.\n3. `if not string then return '' end` - if the string is empty, return an empty string.\n4. `local beginning_of_suffix = 0` - initialize a variable called `beginning_of_suffix` to 0.\n5. `while string:sub(beginning_of_suffix+1) ~= string:sub(beginning_of_suffix+1):reverse() do` - while the substring of the string starting from `beginning_of_suffix+1` to the end of the string is not equal to the reverse of the same substring, do the following:\n6. `beginning_of_suffix = beginning_of_suffix + 1` - increment `beginning_of_suffix` by 1.\n7. `end` - end the while loop.\n8. `return string .. string:sub(1, beginning_of_suffix):reverse()` - return the original string concatenated with the substring of the string from the beginning to `beginning_of_suffix` reversed. This creates a palindrome of the original string. \n\n\n### Racket version\n\n#lang racket\n\n(define (make_palindrome string)\n"
  },
  {
    "name": "HumanEval_83_starts_one_ends",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (starts_one_ends n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_83_starts_one_ends.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 2) 18 0.001)\n    (check-within (candidate 3) 180 0.001)\n    (check-within (candidate 4) 1800 0.001)\n    (check-within (candidate 5) 18000 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function starts_one_ends(n)\n  if n == 1 then return 1 end\n  return 18 * (10 ^ (n - 2))\nend\n\n### Explanation\n\nThe code is an implementation of a function called `starts_one_ends` that takes an integer `n` as input and returns an integer. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the current block of code.\n\nThe first line of the function checks if the input `n` is equal to 1. If it is, the function returns 1. Otherwise, the function returns the result of a mathematical expression.\n\nThe mathematical expression is `18 * (10 ^ (n - 2))`. The `^` symbol is the exponentiation operator in Lua, so `10 ^ (n - 2)` raises 10 to the power of `n - 2`. The result of this expression is then multiplied by 18.\n\nThe purpose of this function is not immediately clear from the code itself, but it appears to be related to generating numbers that start with 1 and end with 0. Specifically, the function returns the number of integers that start with 1 and end with `n` zeros. For example, `starts_one_ends(3)` returns 1800, which is the number of integers that start with 1 and end with 3 zeros (i.e. 1000, 1100, 1200, ..., 19800). \n\n\n### Racket version\n\n#lang racket\n\n(define (starts_one_ends n)\n"
  },
  {
    "name": "HumanEval_30_get_positive",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_positive l)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_30_get_positive.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n    (check-within (candidate (list -1 -2 4 5 6)) (list 4 5 6) 0.001)\n    (check-within (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1) 0.001)\n    (check-within (candidate (list -1 -2)) (list ) 0.001)\n    (check-within (candidate (list )) (list ) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_positive(l)\n  local res = {}\n  for _, e in ipairs(l) do\n    if e > 0 then\n      table.insert(res, e)\n    end\n  end\n  return res\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes a list of numbers and returns a list of only the positive numbers in the original list.\n\n1. `math = require('math')` - This line imports the math library, which is a standard Lua library that provides mathematical functions. In this case, it is not used in the function.\n\n2. `local function get_positive(l)` - This line defines a function called `get_positive` that takes a single argument `l`.\n\n3. `local res = {}` - This line initializes an empty table called `res`.\n\n4. `for _, e in ipairs(l) do` - This line starts a loop that iterates over each element `e` in the list `l`. The `_` is used to ignore the index of the element.\n\n5. `if e > 0 then` - This line checks if the current element `e` is greater than 0.\n\n6. `table.insert(res, e)` - This line inserts the current element `e` into the `res` table.\n\n7. `end` - This line ends the `if` statement.\n\n8. `end` - This line ends the `for` loop.\n\n9. `return res` - This line returns the `res` table, which contains only the positive elements from the original list. \n\n\n### Racket version\n\n#lang racket\n\n(define (get_positive l)\n"
  },
  {
    "name": "HumanEval_28_concatenate",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (concatenate strings)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_28_concatenate.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate concatenate))\n    (check-within (candidate (list )) \"\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) \"xyz\" 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\" \"w\" \"k\")) \"xyzwk\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function concatenate(strings)\n  return table.concat(strings)\nend\n\n### Explanation\n\nThe code is an implementation of a function that concatenates a list of strings. \n\n1. `math = require('math')` - This line imports the math library. The math library provides a set of mathematical functions that can be used in Lua programs. In this case, it is not used, but it is imported for future use.\n\n2. `local function concatenate(strings)` - This line defines a local function called `concatenate` that takes a single argument `strings`. The `local` keyword is used to define a function that is only accessible within the scope of the current block of code. \n\n3. `return table.concat(strings)` - This line returns the result of calling the `concat` method on the `table` object with the `strings` argument. The `table` object is a built-in Lua object that provides a set of functions for working with tables (i.e., arrays). The `concat` method concatenates all the elements of the table into a single string. \n\nOverall, the code defines a function called `concatenate` that takes a list of strings as an argument and returns a single string that is the concatenation of all the strings in the list. \n\n\n### Racket version\n\n#lang racket\n\n(define (concatenate strings)\n"
  },
  {
    "name": "HumanEval_132_is_nested",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_nested string)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_132_is_nested.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n    (check-within (candidate \"[[]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]][[[[[]\") #f 0.001)\n    (check-within (candidate \"[][]\") #f 0.001)\n    (check-within (candidate \"[]\") #f 0.001)\n    (check-within (candidate \"[[[[]]]]\") #t 0.001)\n    (check-within (candidate \"[]]]]]]]]]]\") #f 0.001)\n    (check-within (candidate \"[][][[]]\") #t 0.001)\n    (check-within (candidate \"[[]\") #f 0.001)\n    (check-within (candidate \"[]]\") #f 0.001)\n    (check-within (candidate \"[[]][[\") #t 0.001)\n    (check-within (candidate \"[[][]]\") #t 0.001)\n    (check-within (candidate \"\") #f 0.001)\n    (check-within (candidate \"[[[[[[[[\") #f 0.001)\n    (check-within (candidate \"]]]]]]]]\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_nested(string)\n    local opening_bracket_index = {}\n    local closing_bracket_index = {}\n    for i=1, #string do\n        if string:sub(i,i) == '[' then\n            table.insert(opening_bracket_index, i)\n        else\n            table.insert(closing_bracket_index, i)\n        end\n    end\n    table.sort(closing_bracket_index, function(a,b) return a>b end)\n    local cnt = 0\n    local i = 1\n    local l = #closing_bracket_index\n    for _, idx in ipairs(opening_bracket_index) do\n        if i <= l and idx < closing_bracket_index[i] then\n            cnt = cnt + 1\n            i = i + 1\n        end\n    end\n    return cnt >= 2\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if a string contains at least two nested square brackets. The function is named `is_nested` and takes a string as an argument.\n\nThe first line of the function imports the `math` module.\n\nThe second line of the function declares a local function named `is_nested` that takes a string as an argument.\n\nThe third line of the function declares two empty tables named `opening_bracket_index` and `closing_bracket_index`.\n\nThe fourth line of the function starts a for loop that iterates over each character in the input string. The loop checks if the current character is an opening square bracket (`[`), and if it is, it adds the index of the character to the `opening_bracket_index` table. If the current character is not an opening square bracket, it adds the index of the character to the `closing_bracket_index` table.\n\nThe fifth line of the function sorts the `closing_bracket_index` table in descending order.\n\nThe sixth line of the function declares two variables named `cnt` and `i`, both initialized to 0.\n\nThe seventh line of the function declares a variable named `l` and assigns it the length of the `closing_bracket_index` table.\n\nThe eighth line of the function starts a for loop that iterates over each index in the `opening_bracket_index` table. The loop checks if the current index is less than the index of the first closing square bracket that has not yet been used (`closing_bracket_index[i]`). If it is, it increments the `cnt` variable and moves to the next closing bracket index by incrementing `i`. If it is not, it moves to the next opening bracket index.\n\nThe ninth line of the function returns `true` if `cnt` is greater than or equal to 2, and `false` otherwise. This indicates whether the input string contains at least two nested square brackets.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (is_nested string)\n"
  },
  {
    "name": "HumanEval_48_is_palindrome",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_palindrome text)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_48_is_palindrome.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n    (check-within (candidate \"\") #t 0.001)\n    (check-within (candidate \"aba\") #t 0.001)\n    (check-within (candidate \"aaaaa\") #t 0.001)\n    (check-within (candidate \"zbcd\") #f 0.001)\n    (check-within (candidate \"xywyx\") #t 0.001)\n    (check-within (candidate \"xywyz\") #f 0.001)\n    (check-within (candidate \"xywzx\") #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_palindrome(text)\n    for i=1, #text do\n        if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). \n\nThe first line of the code imports the math library. This library provides a set of mathematical functions that can be used in the program.\n\nThe second line of the code defines a function called `is_palindrome` that takes a single argument `text`. \n\nThe `for` loop in the function iterates through each character of the string `text`. The loop starts at index 1 and ends at the length of the string `#text`. \n\nThe `if` statement inside the loop checks if the character at index `i` is equal to the character at index `#text - i + 1`. If these two characters are not equal, the function returns `false` indicating that the string is not a palindrome.\n\nIf the loop completes without returning `false`, the function returns `true` indicating that the string is a palindrome. \n\nOverall, the function checks if the string is the same when read forwards and backwards. It does this by comparing the first and last characters, then the second and second-to-last characters, and so on until it reaches the middle of the string. If any of these pairs of characters are not equal, the function returns `false`. Otherwise, it returns `true`. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_palindrome text)\n"
  },
  {
    "name": "HumanEval_25_factorize",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (factorize n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_25_factorize.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate factorize))\n    (check-within (candidate 2) (list 2) 0.001)\n    (check-within (candidate 4) (list 2 2) 0.001)\n    (check-within (candidate 8) (list 2 2 2) 0.001)\n    (check-within (candidate 57) (list 3 19) 0.001)\n    (check-within (candidate 3249) (list 3 3 19 19) 0.001)\n    (check-within (candidate 185193) (list 3 3 3 19 19 19) 0.001)\n    (check-within (candidate 20577) (list 3 19 19 19) 0.001)\n    (check-within (candidate 18) (list 2 3 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function factorize(n)\n    local fact = {}\n    local i = 2\n    while i <= math.sqrt(n) + 1 do\n        if n % i == 0 then\n            table.insert(fact, i)\n            n = n / i\n        else\n            i = i + 1\n        end\n    end\n    if n > 1 then\n        table.insert(fact, n)\n    end\n    return fact\nend\n\n### Explanation\n\nThe code is an implementation of a function `factorize` that takes an integer `n` and returns a list of its prime factors. Here is a line-by-line explanation:\n\n\n### Racket version\n\n#lang racket\n\n(define (factorize n)\n"
  },
  {
    "name": "HumanEval_59_largest_prime_factor",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (largest_prime_factor n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n    (check-within (candidate 15) 5 0.001)\n    (check-within (candidate 27) 3 0.001)\n    (check-within (candidate 63) 7 0.001)\n    (check-within (candidate 330) 11 0.001)\n    (check-within (candidate 13195) 29 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function largest_prime_factor(n)\n  local function is_prime(k)\n    if k < 2 then\n      return false\n    end\n    for i = 2, k - 1 do\n      if k % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  local largest = 1\n  for j = 2, n + 1 do\n    if n % j == 0 and is_prime(j) then\n      largest = math.max(largest, j)\n    end\n  end\n  return largest\nend\n\n### Explanation\n\nThe code is an implementation of a function that finds the largest prime factor of a given number. \n\nThe first line imports the math library. \n\nThe second line defines a function called `largest_prime_factor` that takes an integer `n` as input. \n\nThe third line defines a nested function called `is_prime` that takes an integer `k` as input. \n\nThe fourth line checks if `k` is less than 2, and if so, returns `false`. \n\nThe fifth line starts a loop that iterates from 2 to `k - 1`. \n\nThe sixth line checks if `k` is divisible by `i`, and if so, returns `false`. \n\nThe seventh line returns `true` if the loop completes without returning `false`. \n\nThe eighth line initializes a variable called `largest` to 1. \n\nThe ninth line starts a loop that iterates from 2 to `n + 1`. \n\nThe tenth line checks if `n` is divisible by `j` and if `j` is prime (using the `is_prime` function). \n\nThe eleventh line updates `largest` to be the maximum of its current value and `j`. \n\nThe twelfth line returns `largest`. \n\nTo rewrite this program in Racket, we would need to replace the `math` library with the appropriate Racket library, and adjust the syntax of the loops and conditionals to match Racket's syntax. For example, we might use the `for/list` construct to iterate over a range of values, and the `cond` construct to check multiple conditions. The `max` function can be used to find the maximum of two values. Here is an example implementation in Racket:\n\n\n### Racket version\n\n#lang racket\n\n(define (largest_prime_factor n)\n"
  },
  {
    "name": "HumanEval_147_get_max_triples",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (get_max_triples n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_147_get_max_triples.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 10) 36 0.001)\n    (check-within (candidate 100) 53361 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function get_max_triples(n)\n  local A = {}\n  for i=1,n do\n    A[i] = i*i - i + 1\n  end\n  local ans = {}\n  for i=1,n do\n    for j=i+1,n do\n      for k=j+1,n do\n        if (A[i]+A[j]+A[k])%3 == 0 then\n          table.insert(ans, {A[i],A[j],A[k]})\n        end\n      end\n    end\n  end\n  return #ans\nend\n\n### Explanation\n\nThe code is an implementation of a function that takes in a number `n` and returns the number of triples of integers `(i,j,k)` such that `1 <= i < j < k <= n` and `i^2 + j^2 + k^2` is divisible by 3.\n\n1. `math = require('math')` - This line imports the math library into the program. The math library provides a set of mathematical functions for Lua programs.\n\n2. `local function get_max_triples(n)` - This line defines a function called `get_max_triples` that takes in a parameter `n`.\n\n3. `local A = {}` - This line initializes an empty table called `A`.\n\n4. `for i=1,n do` - This line starts a loop that iterates from `1` to `n`, inclusive, with `i` as the loop variable.\n\n5. `A[i] = i*i - i + 1` - This line sets the `i`th element of `A` to `i^2 - i + 1`.\n\n6. `local ans = {}` - This line initializes an empty table called `ans`.\n\n7. `for i=1,n do` - This line starts a loop that iterates from `1` to `n`, inclusive, with `i` as the loop variable.\n\n8. `for j=i+1,n do` - This line starts a nested loop that iterates from `i+1` to `n`, inclusive, with `j` as the loop variable.\n\n9. `for k=j+1,n do` - This line starts a nested loop that iterates from `j+1` to `n`, inclusive, with `k` as the loop variable.\n\n10. `if (A[i]+A[j]+A[k])%3 == 0 then` - This line checks if the sum of the `i`th, `j`th, and `k`th elements of `A` is divisible by 3.\n\n11. `table.insert(ans, {A[i],A[j],A[k]})` - This line inserts a new table containing the `i`th, `j`th, and `k`th elements of `A` into the `ans` table.\n\n12. `return #ans` - This line returns the length of the `ans` table, which is the number of triples of integers `(i,j,k)` such that `1 <= i < j < k <= n` and `i^2 + j^2 + k^2` is divisible by 3.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (get_max_triples n)\n"
  },
  {
    "name": "HumanEval_86_anti_shuffle",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (anti_shuffle s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_86_anti_shuffle.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate anti_shuffle))\n    (check-within (candidate \"Hi\") \"Hi\" 0.001)\n    (check-within (candidate \"hello\") \"ehllo\" 0.001)\n    (check-within (candidate \"number\") \"bemnru\" 0.001)\n    (check-within (candidate \"abcd\") \"abcd\" 0.001)\n    (check-within (candidate \"Hello World!!!\") \"Hello !!!Wdlor\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst .Rboot How aer ?ouy\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function anti_shuffle(s)\n    local t = {}\n    for i in s:gmatch('%S+') do\n        local u = {}\n        for j = 1, #i do\n            u[j] = i:sub(j, j)\n        end\n        table.sort(u)\n        t[#t + 1] = table.concat(u)\n    end\n    return table.concat(t, ' ')\nend\n\n### Explanation\n\nThe code is an implementation of a function called `anti_shuffle` that takes a string `s` as input and returns a string as output. The function is defined using the `local` keyword, which means that it is only accessible within the scope of the current block of code.\n\nThe first line of the function imports the `math` module, which provides various mathematical functions that can be used in Lua.\n\nThe second line of the function creates an empty table called `t`.\n\nThe third line of the function uses a `for` loop to iterate over each word in the input string `s`. The `gmatch` function is used to match all non-space characters in the string, and the `%S+` pattern is used to match one or more non-space characters. The `for` loop creates a new table called `u` for each word in `s`.\n\nThe fourth line of the function uses another `for` loop to iterate over each character in the current word `i`. The `sub` function is used to extract a substring of `i` starting at position `j` and ending at position `j`. The resulting substring is then added to the `u` table.\n\nThe fifth line of the function sorts the `u` table in ascending order using the `table.sort` function.\n\nThe sixth line of the function concatenates the sorted `u` table into a single string using the `table.concat` function, and adds it to the `t` table.\n\nThe seventh line of the function concatenates all the strings in the `t` table into a single string separated by spaces using the `table.concat` function, and returns the resulting string.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (anti_shuffle s)\n"
  },
  {
    "name": "HumanEval_129_minPath",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (minPath grid k)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_129_minPath.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minPath))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1) 0.001)\n    (check-within (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1) 0.001)\n    (check-within (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1) 0.001)\n    (check-within (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1) 0.001)\n    (check-within (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6) 0.001)\n    (check-within (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3) 0.001)\n    (check-within (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function minPath(grid, k)\n    local n = #grid\n    local val = n * n + 1\n    for i = 1, n do\n        for j = 1, n do\n            if grid[i][j] == 1 then\n                local temp = {}\n                if i ~= 1 then\n                    table.insert(temp, grid[i-1][j])\n                end\n\n                if j ~= 1 then\n                    table.insert(temp, grid[i][j-1])\n                end\n\n                if i ~= n then\n                    table.insert(temp, grid[i+1][j])\n                end\n\n                if j ~= n then\n                    table.insert(temp, grid[i][j+1])\n                end\n\n                val = math.min(table.unpack(temp))\n            end\n        end\n    end\n\n    local ans = {}\n    for i = 1, k do\n        if i % 2 == 1 then\n            table.insert(ans, 1)\n        else\n            table.insert(ans, val)\n        end\n    end\n    return ans\nend\n\n### Explanation\n\nThe code is an implementation of a function called `minPath` that takes two arguments: `grid` and `k`. `grid` is a 2D array of integers, and `k` is an integer. The function returns an array of `k` integers.\n\nThe first line of the function imports the `math` library.\n\nThe second line of the function defines a local function called `minPath`. The function takes two arguments: `grid` and `k`.\n\nThe third line of the function gets the length of the `grid` array and assigns it to the variable `n`.\n\nThe fourth line of the function initializes the variable `val` to `n * n + 1`.\n\nThe fifth line of the function starts a nested loop that iterates over each element of the `grid` array. The outer loop iterates over the rows of the array, and the inner loop iterates over the columns of the array.\n\nThe sixth line of the function checks if the current element of the `grid` array is equal to `1`. If it is, the function proceeds to the next step. If it is not, the function skips to the next iteration of the inner loop.\n\nThe seventh line of the function initializes an empty table called `temp`.\n\nThe eighth line of the function checks if the current row is not the first row of the `grid` array. If it is not, the function inserts the element above the current element into the `temp` table.\n\nThe ninth line of the function checks if the current column is not the first column of the `grid` array. If it is not, the function inserts the element to the left of the current element into the `temp` table.\n\nThe tenth line of the function checks if the current row is not the last row of the `grid` array. If it is not, the function inserts the element below the current element into the `temp` table.\n\nThe eleventh line of the function checks if the current column is not the last column of the `grid` array. If it is not, the function inserts the element to the right of the current element into the `temp` table.\n\nThe twelfth line of the function finds the minimum value in the `temp` table using the `math.min` function and assigns it to the variable `val`.\n\nThe thirteenth line of the function initializes an empty table called `ans`.\n\nThe fourteenth line of the function starts a loop that iterates `k` times.\n\nThe fifteenth line of the function checks if the current iteration is odd. If it is, the function inserts `1` into the `ans` table. If it is not, the function inserts the value of `val` into the `ans` table.\n\nThe sixteenth line of the function returns the `ans` table.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (minPath grid k)\n"
  },
  {
    "name": "HumanEval_89_encrypt",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (encrypt s)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_89_encrypt.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n    (check-within (candidate \"hi\") \"lm\" 0.001)\n    (check-within (candidate \"asdfghjkl\") \"ewhjklnop\" 0.001)\n    (check-within (candidate \"gf\") \"kj\" 0.001)\n    (check-within (candidate \"et\") \"ix\" 0.001)\n    (check-within (candidate \"faewfawefaewg\") \"jeiajeaijeiak\" 0.001)\n    (check-within (candidate \"hellomyfriend\") \"lippsqcjvmirh\" 0.001)\n    (check-within (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" 0.001)\n    (check-within (candidate \"a\") \"e\" 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function encrypt(s)\n    local d = 'abcdefghijklmnopqrstuvwxyz'\n    local out = ''\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if d:find(c) then\n            out = out .. d:sub((d:find(c) + 2*2 - 1) % 26 + 1, (d:find(c) + 2*2 - 1) % 26 + 1)\n        else\n            out = out .. c\n        end\n    end\n    return out\nend\n\n### Explanation\n\nThe code is an implementation of a simple encryption algorithm that shifts each letter in the input string by 4 places to the right in the alphabet. \n\n`math = require('math')` - This line imports the math library in Lua. The math library provides a set of mathematical functions and constants.\n\n`local function encrypt(s)` - This line defines a local function called `encrypt` that takes a string `s` as input.\n\n`local d = 'abcdefghijklmnopqrstuvwxyz'` - This line defines a local variable `d` that contains the lowercase English alphabet.\n\n`local out = ''` - This line defines a local variable `out` that is initialized to an empty string.\n\n`for i = 1, #s do` - This line starts a loop that iterates over each character in the input string `s`.\n\n`local c = s:sub(i, i)` - This line extracts the i-th character of the input string `s` and assigns it to a local variable `c`.\n\n`if d:find(c) then` - This line checks if the character `c` is a lowercase letter in the English alphabet.\n\n`out = out .. d:sub((d:find(c) + 2*2 - 1) % 26 + 1, (d:find(c) + 2*2 - 1) % 26 + 1)` - This line appends the encrypted version of the character `c` to the output string `out`. The encrypted version is obtained by finding the position of the character `c` in the alphabet, adding 4 to it, and wrapping around to the beginning of the alphabet if necessary. The `..` operator concatenates two strings together.\n\n`else` - This line is executed if the character `c` is not a lowercase letter in the English alphabet.\n\n`out = out .. c` - This line appends the original character `c` to the output string `out`.\n\n`return out` - This line returns the encrypted string `out` as the output of the `encrypt` function.<|im_end|>\n\n### Racket version\n\n#lang racket\n\n(define (encrypt s)\n"
  },
  {
    "name": "HumanEval_100_make_a_pile",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (make_a_pile n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_100_make_a_pile.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_a_pile))\n    (check-within (candidate 3) (list 3 5 7) 0.001)\n    (check-within (candidate 4) (list 4 6 8 10) 0.001)\n    (check-within (candidate 5) (list 5 7 9 11 13) 0.001)\n    (check-within (candidate 6) (list 6 8 10 12 14 16) 0.001)\n    (check-within (candidate 8) (list 8 10 12 14 16 18 20 22) 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function make_a_pile(n)\n  local pile = {}\n  for i = 0, n-1 do\n    pile[i+1] = n + 2*i\n  end\n  return pile\nend\n\n### Explanation\n\nThe code is an implementation of a function that creates a pile of numbers. The pile is created by iterating over a range of numbers from 0 to n-1 and adding to the pile a number that is equal to n plus two times the current index. The function returns the pile.\n\n1. `math = require('math')` - This line imports the math library into the program. The math library provides a set of mathematical functions that can be used in the program.\n2. `local function make_a_pile(n)` - This line defines a function called `make_a_pile` that takes a single argument `n`.\n3. `local pile = {}` - This line creates an empty table called `pile`.\n4. `for i = 0, n-1 do` - This line starts a loop that iterates over a range of numbers from 0 to n-1.\n5. `pile[i+1] = n + 2*i` - This line adds a new element to the `pile` table. The element is equal to `n + 2*i`, where `i` is the current index of the loop. The `i+1` is used to adjust the index of the table to start at 1 instead of 0.\n6. `end` - This line ends the loop.\n7. `return pile` - This line returns the `pile` table. \n\n\n### Racket version\n\n#lang racket\n\n(define (make_a_pile n)\n"
  },
  {
    "name": "HumanEval_31_is_prime",
    "language": "rkt",
    "prompt": "#lang racket\n\n(define (is_prime n)\n",
    "doctests": "keep",
    "original": "../datasets/originals/HumanEval_31_is_prime.py",
    "prompt_terminology": "remove",
    "source_program": "keep",
    "target_signature": "keep",
    "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n    (check-within (candidate 6) #f 0.001)\n    (check-within (candidate 101) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 13441) #t 0.001)\n    (check-within (candidate 61) #t 0.001)\n    (check-within (candidate 4) #f 0.001)\n    (check-within (candidate 1) #f 0.001)\n    (check-within (candidate 5) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 17) #t 0.001)\n    (check-within (candidate 85) #f 0.001)\n    (check-within (candidate 77) #f 0.001)\n    (check-within (candidate 255379) #f 0.001)\n))\n\n(test-humaneval)",
    "stop_tokens": [
      "\n(define ",
      "\n#|",
      "\n;",
      "\n("
    ],
    "translation_prompt": "You are an helpful AI assistant who understands all programming languages and can translate between them at ease. Can you explain what this Lua program does line by line? If a line is too long or too complicated, simplify it and explain what individual parts of the line mean first before explaining the whole line. The goal with the explanation, is so that a reader can easily rewrite the program in Racket.\n\n### Lua version\n\nmath = require('math')\nlocal function is_prime(n)\n    if n < 2 then\n        return false\n    end\n    for k=2, n-1 do\n        if n % k == 0 then\n            return false\n        end\n    end\n    return true\nend\n\n### Explanation\n\nThe code is an implementation of a function that checks whether a number is prime or not. \n\n`math = require('math')` imports the math library. \n\n`local function is_prime(n)` declares a local function `is_prime` that takes an argument `n`. \n\n`if n < 2 then` checks if `n` is less than 2. If it is, the function returns `false`. \n\n`for k=2, n-1 do` sets up a loop that starts at 2 and goes up to `n-1`. \n\n`if n % k == 0 then` checks if `n` is divisible by `k`. If it is, the function returns `false`. \n\n`return true` returns `true` if the function has not yet returned `false`. \n\nIn summary, the function checks if a number is prime by checking if it is divisible by any number between 2 and `n-1`. If it is, the function returns `false`. If it is not divisible by any number between 2 and `n-1`, the function returns `true`. \n\n\n### Racket version\n\n#lang racket\n\n(define (is_prime n)\n"
  }
]