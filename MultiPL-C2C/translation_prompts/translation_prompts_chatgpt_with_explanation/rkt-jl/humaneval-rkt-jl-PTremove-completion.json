[{"name": "HumanEval_61_correct_bracketing", "language": "jl", "prompt": "function correct_bracketing(brackets::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_61_correct_bracketing.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = correct_bracketing;\n\t@test(candidate(\"()\") == true)\n\t@test(candidate(\"(()())\") == true)\n\t@test(candidate(\"()()(()())()\") == true)\n\t@test(candidate(\"()()((()()())())(()()(()))\") == true)\n\t@test(candidate(\"((()())))\") == false)\n\t@test(candidate(\")(()\") == false)\n\t@test(candidate(\"(\") == false)\n\t@test(candidate(\"((((\") == false)\n\t@test(candidate(\")\") == false)\n\t@test(candidate(\"(()\") == false)\n\t@test(candidate(\"()()(()())())(()\") == false)\n\t@test(candidate(\"()()(()())()))()\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (correct_bracketing brackets)\n  (let loop ((depth 0)\n             (bs (string->list brackets)))\n    (cond\n      [(null? bs) (= depth 0)]\n      [(char=? (car bs) #\\() (loop (add1 depth) (cdr bs))]\n      [(char=? (car bs) #\\)) (and (> depth 0) (loop (sub1 depth) (cdr bs)))]\n      [else (loop depth (cdr bs))])))\n\n### Julia version\n\nfunction correct_bracketing(brackets::String)::Bool\n"}, {"name": "HumanEval_45_triangle_area", "language": "jl", "prompt": "function triangle_area(a::Int64, h::Int64)::Float64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_45_triangle_area.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = triangle_area;\n\t@test(candidate(5, 3) == 7.5)\n\t@test(candidate(2, 2) == 2.0)\n\t@test(candidate(10, 8) == 40.0)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (triangle_area a h)\n  (/ (* a h) 2.0))\n\n### Julia version\n\nfunction triangle_area(a::Int64, h::Int64)::Float64\n"}, {"name": "HumanEval_139_special_factorial", "language": "jl", "prompt": "function special_factorial(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_139_special_factorial.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = special_factorial;\n\t@test(candidate(4) == 288)\n\t@test(candidate(5) == 34560)\n\t@test(candidate(7) == 125411328000)\n\t@test(candidate(1) == 1)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (special_factorial n)\n  (define (fact i)\n    (if (zero? i) 1 (* i (fact (- i 1)))))\n  (define (special_fact i)\n    (if (zero? i) 1 (* (fact i) (special_fact (- i 1)))))\n  (special_fact n))\n\n### Julia version\n\nfunction special_factorial(n::Int64)::Int64\n"}, {"name": "HumanEval_136_largest_smallest_integers", "language": "jl", "prompt": "function largest_smallest_integers(lst::Vector{Int64})::Tuple{Union{Int64, Nothing}, Union{Int64, Nothing}}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_136_largest_smallest_integers.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = largest_smallest_integers;\n\t@test(candidate([2, 4, 1, 3, 5, 7]) == (nothing, 1))\n\t@test(candidate([2, 4, 1, 3, 5, 7, 0]) == (nothing, 1))\n\t@test(candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1))\n\t@test(candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2))\n\t@test(candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))\n\t@test(candidate(Vector{Int64}([])) == (nothing, nothing))\n\t@test(candidate([0]) == (nothing, nothing))\n\t@test(candidate([-1, -3, -5, -6]) == (-1, nothing))\n\t@test(candidate([-1, -3, -5, -6, 0]) == (-1, nothing))\n\t@test(candidate([-6, -4, -4, -3, 1]) == (-3, 1))\n\t@test(candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_smallest_integers lst)\n  (define smallest (filter (lambda (x) (< x 0)) lst))\n  (define largest (filter (lambda (x) (> x 0)) lst))\n  (list (if (null? smallest) #f (apply max smallest))\n        (if (null? largest) #f (apply min largest))))\n\n### Julia version\n\nfunction largest_smallest_integers(lst::Vector{Int64})::Tuple{Union{Int64, Nothing}, Union{Int64, Nothing}}\n"}, {"name": "HumanEval_109_move_one_ball", "language": "jl", "prompt": "function move_one_ball(arr::Vector{Int64})::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_109_move_one_ball.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (move_one_ball arr)\n  (if (null? arr)\n      #t\n      (let ((sorted-array (sort arr <))\n            (my-arr '()))\n        (let ((min-value (apply min arr))\n              (min-index (index-of arr (apply min arr))))\n          (set! my-arr (append (drop arr min-index) (take arr min-index))))\n        (for/and ((i (in-range (length arr))))\n          (= (list-ref my-arr i) (list-ref sorted-array i))))))\n\n### Julia version\n\nfunction move_one_ball(arr::Vector{Int64})::Bool\n"}, {"name": "HumanEval_131_digits", "language": "jl", "prompt": "function digits(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_131_digits.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = digits;\n\t@test(candidate(5) == 5)\n\t@test(candidate(54) == 5)\n\t@test(candidate(120) == 1)\n\t@test(candidate(5014) == 5)\n\t@test(candidate(98765) == 315)\n\t@test(candidate(5576543) == 2625)\n\t@test(candidate(2468) == 0)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (digits n)\n  (define (odd? x) (= (modulo x 2) 1))\n  (define (product lst) (apply * lst))\n  (define digits (map (lambda (x) (string->number (string x))) (string->list (number->string n))))\n  (define odd-digits (filter odd? digits))\n  (if (null? odd-digits)\n      0\n      (product odd-digits)))\n\n### Julia version\n\nfunction digits(n::Int64)::Int64\n"}, {"name": "HumanEval_46_fib4", "language": "jl", "prompt": "function fib4(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_46_fib4.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = fib4;\n\t@test(candidate(5) == 4)\n\t@test(candidate(8) == 28)\n\t@test(candidate(10) == 104)\n\t@test(candidate(12) == 386)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fib4 n)\n  (define results (list 0 0 2 0))\n  (if (< n 4)\n      (list-ref results n)\n      (begin\n        (for ([i (in-range 4 (add1 n))])\n          (set! results (append results (list (+ (last results) (list-ref (reverse results) 1) (list-ref (reverse results) 2) (list-ref (reverse results) 3))))))\n        (car (reverse results)))))\n\n### Julia version\n\nfunction fib4(n::Int64)::Int64\n"}, {"name": "HumanEval_37_sort_even", "language": "jl", "prompt": "function sort_even(l::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_37_sort_even.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (sort_even l)\n  (define evens (for/list ([i (in-range 0 (length l) 2)]) (list-ref l i)))\n  (define odds (for/list ([i (in-range 1 (length l) 2)]) (list-ref l i)))\n  (set! evens (sort evens <))\n  (define ans '())\n  (for ([e evens] [o odds])\n    (set! ans (append ans (list e o))))\n  (when (> (length evens) (length odds))\n    (set! ans (append ans (list (last evens)))))\n  ans)\n\n### Julia version\n\nfunction sort_even(l::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_80_is_happy", "language": "jl", "prompt": "function is_happy(s::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_80_is_happy.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_happy;\n\t@test(candidate(\"a\") == false)\n\t@test(candidate(\"aa\") == false)\n\t@test(candidate(\"abcd\") == true)\n\t@test(candidate(\"aabb\") == false)\n\t@test(candidate(\"adb\") == true)\n\t@test(candidate(\"xyy\") == false)\n\t@test(candidate(\"iopaxpoi\") == true)\n\t@test(candidate(\"iopaxioi\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_happy s)\n  (if (< (string-length s) 3)\n      #f\n      (for/and ([i (in-range (- (string-length s) 2))])\n        (not (or (char=? (string-ref s i) (string-ref s (+ i 1)))\n                 (char=? (string-ref s (+ i 1)) (string-ref s (+ i 2)))\n                 (char=? (string-ref s i) (string-ref s (+ i 2))))))))\n\n### Julia version\n\nfunction is_happy(s::String)::Bool\n"}, {"name": "HumanEval_65_circular_shift", "language": "jl", "prompt": "function circular_shift(x::Int64, shift::Int64)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_65_circular_shift.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = circular_shift;\n\t@test(candidate(100, 2) == \"001\")\n\t@test(candidate(12, 2) == \"12\")\n\t@test(candidate(97, 8) == \"79\")\n\t@test(candidate(12, 1) == \"21\")\n\t@test(candidate(11, 101) == \"11\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (circular_shift x shift)\n  (define s (number->string x))\n  (if (> shift (string-length s))\n      (list->string (reverse (string->list s)))\n      (string-append (substring s (- (string-length s) shift)) (substring s 0 (- (string-length s) shift)))))\n\n### Julia version\n\nfunction circular_shift(x::Int64, shift::Int64)::String\n"}, {"name": "HumanEval_115_max_fill", "language": "jl", "prompt": "function max_fill(grid::Vector{Vector{Int64}}, capacity::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_115_max_fill.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = max_fill;\n\t@test(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) == 6)\n\t@test(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) == 5)\n\t@test(candidate([[0, 0, 0], [0, 0, 0]], 5) == 0)\n\t@test(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2) == 4)\n\t@test(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9) == 2)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (max_fill grid capacity)\n  (apply + (map (lambda (arr) (ceiling (/ (apply + arr) capacity))) grid)))\n\n### Julia version\n\nfunction max_fill(grid::Vector{Vector{Int64}}, capacity::Int64)::Int64\n"}, {"name": "HumanEval_0_has_close_elements", "language": "jl", "prompt": "function has_close_elements(numbers::Vector{Float64}, threshold::Float64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_0_has_close_elements.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = has_close_elements;\n\t@test(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\n\t@test(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\n\t@test(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\n\t@test(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\n\t@test(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\n\t@test(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\n\t@test(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (has_close_elements numbers threshold)\n  (define (helper i j)\n    (cond [(= i (length numbers)) #f]\n          [(= j (length numbers)) (helper (+ i 1) (+ i 2))]\n          [(< (abs (- (list-ref numbers i) (list-ref numbers j))) threshold) #t]\n          [else (helper i (+ j 1))]))\n  (helper 0 1))\n\n### Julia version\n\nfunction has_close_elements(numbers::Vector{Float64}, threshold::Float64)::Bool\n"}, {"name": "HumanEval_81_numerical_letter_grade", "language": "jl", "prompt": "function numerical_letter_grade(grades::Vector{Float64})::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_81_numerical_letter_grade.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = numerical_letter_grade;\n\t@test(candidate([4.0, 3, 1.7, 2, 3.5]) == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\n\t@test(candidate([1.2]) == [\"D+\"])\n\t@test(candidate([0.5]) == [\"D-\"])\n\t@test(candidate([0.0]) == [\"E\"])\n\t@test(candidate([1.0, 0.3, 1.5, 2.8, 3.3]) == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\n\t@test(candidate([0.0, 0.7]) == [\"E\", \"D-\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (numerical_letter_grade grades)\n  (define (grade gpa)\n    (cond [(= gpa 4.0) \"A+\"]\n          [(> gpa 3.7) \"A\"]\n          [(> gpa 3.3) \"A-\"]\n          [(> gpa 3.0) \"B+\"]\n          [(> gpa 2.7) \"B\"]\n          [(> gpa 2.3) \"B-\"]\n          [(> gpa 2.0) \"C+\"]\n          [(> gpa 1.7) \"C\"]\n          [(> gpa 1.3) \"C-\"]\n          [(> gpa 1.0) \"D+\"]\n          [(> gpa 0.7) \"D\"]\n          [(> gpa 0.0) \"D-\"]\n          [else \"E\"]))\n  (map grade grades))\n\n### Julia version\n\nfunction numerical_letter_grade(grades::Vector{Float64})::Vector{String}\n"}, {"name": "HumanEval_150_x_or_y", "language": "jl", "prompt": "function x_or_y(n::Int64, x::Int64, y::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_150_x_or_y.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = x_or_y;\n\t@test(candidate(7, 34, 12) == 34)\n\t@test(candidate(15, 8, 5) == 5)\n\t@test(candidate(3, 33, 5212) == 33)\n\t@test(candidate(1259, 3, 52) == 3)\n\t@test(candidate(7919, -1, 12) == -1)\n\t@test(candidate(3609, 1245, 583) == 583)\n\t@test(candidate(91, 56, 129) == 129)\n\t@test(candidate(6, 34, 1234) == 1234)\n\t@test(candidate(1, 2, 0) == 0)\n\t@test(candidate(2, 2, 0) == 2)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (x_or_y n x y)\n  (cond\n    [(= n 1) y]\n    [(for/or ([i (in-range 2 n)]) (= (modulo n i) 0)) y]\n    [else x]))\n\n### Julia version\n\nfunction x_or_y(n::Int64, x::Int64, y::Int64)::Int64\n"}, {"name": "HumanEval_146_specialFilter", "language": "jl", "prompt": "function specialFilter(nums::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_146_specialFilter.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = specialFilter;\n\t@test(candidate([5, -2, 1, -5]) == 0)\n\t@test(candidate([15, -73, 14, -15]) == 1)\n\t@test(candidate([33, -2, -3, 45, 21, 109]) == 2)\n\t@test(candidate([43, -12, 93, 125, 121, 109]) == 4)\n\t@test(candidate([71, -2, -33, 75, 21, 19]) == 3)\n\t@test(candidate([1]) == 0)\n\t@test(candidate(Vector{Int64}([])) == 0)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (specialFilter nums)\n  (define count 0)\n  (for ([num nums])\n    (when (> num 10)\n      (let ([number_as_string (number->string num)])\n        (when (and (odd? (string->number (substring number_as_string 0 1)))\n                   (odd? (string->number (substring number_as_string (- (string-length number_as_string) 1)))))\n          (set! count (add1 count))))))\n  count)\n\n### Julia version\n\nfunction specialFilter(nums::Vector{Int64})::Int64\n"}, {"name": "HumanEval_17_parse_music", "language": "jl", "prompt": "function parse_music(music_string::String)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_17_parse_music.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = parse_music;\n\t@test(candidate(\"\") == Vector{Int64}([]))\n\t@test(candidate(\"o o o o\") == [4, 4, 4, 4])\n\t@test(candidate(\".| .| .| .|\") == [1, 1, 1, 1])\n\t@test(candidate(\"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\n\t@test(candidate(\"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (parse_music music_string)\n  (define note-map (hash \"o\" 4 \"o|\" 2 \".|\" 1))\n  (define (note->int note)\n    (hash-ref note-map note))\n  (filter-map note->int (string-split music_string \" \")))\n\n### Julia version\n\nfunction parse_music(music_string::String)::Vector{Int64}\n"}, {"name": "HumanEval_125_split_words", "language": "jl", "prompt": "function split_words(txt::String)::Union{Vector{String}, Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_125_split_words.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = split_words;\n\t@test(candidate(\"Hello world!\") == [\"Hello\", \"world!\"])\n\t@test(candidate(\"Hello,world!\") == [\"Hello\", \"world!\"])\n\t@test(candidate(\"Hello world,!\") == [\"Hello\", \"world,!\"])\n\t@test(candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\", \"!\"])\n\t@test(candidate(\"abcdef\") == 3)\n\t@test(candidate(\"aaabb\") == 2)\n\t@test(candidate(\"aaaBb\") == 1)\n\t@test(candidate(\"\") == 0)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (split_words txt)\n  (cond\n    [(regexp-match? #rx\" \" txt) (string-split txt)]\n    [(regexp-match? #rx\",\" txt) (string-split (string-replace txt \",\" \" \"))]\n    [else (length (filter (lambda (i) (and (char-lower-case? i) (even? (char->integer i)))) (string->list txt)))]))\n\n### Julia version\n\nfunction split_words(txt::String)::Union{Vector{String}, Int64}\n"}, {"name": "HumanEval_16_count_distinct_characters", "language": "jl", "prompt": "function count_distinct_characters(string::String)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_16_count_distinct_characters.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = count_distinct_characters;\n\t@test(candidate(\"\") == 0)\n\t@test(candidate(\"abcde\") == 5)\n\t@test(candidate(\"abcdecadeCADE\") == 5)\n\t@test(candidate(\"aaaaAAAAaaaa\") == 1)\n\t@test(candidate(\"Jerry jERRY JeRRRY\") == 5)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (count_distinct_characters string)\n  (length (remove-duplicates (string->list (string-downcase string)))))\n\n### Julia version\n\nfunction count_distinct_characters(string::String)::Int64\n"}, {"name": "HumanEval_66_digitSum", "language": "jl", "prompt": "function digitSum(s::String)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_66_digitSum.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = digitSum;\n\t@test(candidate(\"\") == 0)\n\t@test(candidate(\"abAB\") == 131)\n\t@test(candidate(\"abcCd\") == 67)\n\t@test(candidate(\"helloE\") == 69)\n\t@test(candidate(\"woArBld\") == 131)\n\t@test(candidate(\"aAaaaXa\") == 153)\n\t@test(candidate(\" How are yOu?\") == 151)\n\t@test(candidate(\"You arE Very Smart\") == 327)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (digitSum s)\n  (if (string=? s \"\") 0\n      (for/sum ((char (in-string s)))\n        (if (char-upper-case? char) (char->integer char) 0))))\n\n### Julia version\n\nfunction digitSum(s::String)::Int64\n"}, {"name": "HumanEval_142_sum_squares", "language": "jl", "prompt": "function sum_squares(lst::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_142_sum_squares.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sum_squares;\n\t@test(candidate([1, 2, 3]) == 6)\n\t@test(candidate([1, 4, 9]) == 14)\n\t@test(candidate(Vector{Int64}([])) == 0)\n\t@test(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]) == 9)\n\t@test(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]) == -3)\n\t@test(candidate([0]) == 0)\n\t@test(candidate([-1, -5, 2, -1, -5]) == -126)\n\t@test(candidate([-56, -99, 1, 0, -2]) == 3030)\n\t@test(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]) == 0)\n\t@test(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196)\n\t@test(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_squares lst)\n  (define (f i)\n    (cond [(= (modulo i 3) 0) (expt (list-ref lst i) 2)]\n          [(and (= (modulo i 4) 0) (not (= (modulo i 3) 0))) (expt (list-ref lst i) 3)]\n          [else (list-ref lst i)]))\n  (apply + (map f (range (length lst)))))\n\n### Julia version\n\nfunction sum_squares(lst::Vector{Int64})::Int64\n"}, {"name": "HumanEval_96_count_up_to", "language": "jl", "prompt": "function count_up_to(n::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_96_count_up_to.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = count_up_to;\n\t@test(candidate(5) == [2, 3])\n\t@test(candidate(6) == [2, 3, 5])\n\t@test(candidate(7) == [2, 3, 5])\n\t@test(candidate(10) == [2, 3, 5, 7])\n\t@test(candidate(0) == Vector{Int64}([]))\n\t@test(candidate(22) == [2, 3, 5, 7, 11, 13, 17, 19])\n\t@test(candidate(1) == Vector{Int64}([]))\n\t@test(candidate(18) == [2, 3, 5, 7, 11, 13, 17])\n\t@test(candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n\t@test(candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_up_to n)\n  (define (is_prime x)\n    (and (> x 1) (not (ormap (lambda (i) (= (modulo x i) 0)) (range 2 x)))) )\n  (filter is_prime (range 2 n)))\n\n### Julia version\n\nfunction count_up_to(n::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_133_sum_squares", "language": "jl", "prompt": "function sum_squares(lst::Vector{Float64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_133_sum_squares.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sum_squares;\n\t@test(candidate([1.0, 2.0, 3.0]) == 14)\n\t@test(candidate([1.0, 2.0, 3.0]) == 14)\n\t@test(candidate([1.0, 3.0, 5.0, 7.0]) == 84)\n\t@test(candidate([1.4, 4.2, 0.0]) == 29)\n\t@test(candidate([-2.4, 1.0, 1.0]) == 6)\n\t@test(candidate([100.0, 1.0, 15.0, 2.0]) == 10230)\n\t@test(candidate([10000.0, 10000.0]) == 200000000)\n\t@test(candidate([-1.4, 4.6, 6.3]) == 75)\n\t@test(candidate([-1.4, 17.9, 18.9, 19.9]) == 1086)\n\t@test(candidate([0.0]) == 0)\n\t@test(candidate([-1.0]) == 1)\n\t@test(candidate([-1.0, 1.0, 0.0]) == 2)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_squares lst)\n  (define (square x) (* x x))\n  (apply + (map square (map (lambda (x) (ceiling x)) lst))))\n\n### Julia version\n\nfunction sum_squares(lst::Vector{Float64})::Int64\n"}, {"name": "HumanEval_34_unique", "language": "jl", "prompt": "function unique(l::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_34_unique.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = unique;\n\t@test(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (unique l)\n  (sort (remove-duplicates l) <))\n\n### Julia version\n\nfunction unique(l::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_55_fib", "language": "jl", "prompt": "function fib(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_55_fib.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = fib;\n\t@test(candidate(10) == 55)\n\t@test(candidate(1) == 1)\n\t@test(candidate(8) == 21)\n\t@test(candidate(11) == 89)\n\t@test(candidate(12) == 144)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fib n)\n  (if (or (= n 0) (= n 1))\n      n\n      (+ (fib (- n 1)) (fib (- n 2)))))\n\n### Julia version\n\nfunction fib(n::Int64)::Int64\n"}, {"name": "HumanEval_36_fizz_buzz", "language": "jl", "prompt": "function fizz_buzz(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_36_fizz_buzz.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = fizz_buzz;\n\t@test(candidate(50) == 0)\n\t@test(candidate(78) == 2)\n\t@test(candidate(79) == 3)\n\t@test(candidate(100) == 3)\n\t@test(candidate(200) == 6)\n\t@test(candidate(4000) == 192)\n\t@test(candidate(10000) == 639)\n\t@test(candidate(100000) == 8026)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (fizz_buzz n)\n  (define ns (filter (lambda (x) (or (= (modulo x 11) 0) (= (modulo x 13) 0))) (range n)))\n  (define s (string-join (map number->string ns) \"\"))\n  (define ans (count (lambda (c) (char=? c #\\7)) (string->list s)))\n  ans)\n\n### Julia version\n\nfunction fizz_buzz(n::Int64)::Int64\n"}, {"name": "HumanEval_153_Strongest_Extension", "language": "jl", "prompt": "function Strongest_Extension(class_name::String, extensions::Vector{String})::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_153_Strongest_Extension.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (Strongest_Extension class_name extensions)\n  (define strong (first extensions))\n  (define my-val (- (length (regexp-match* #rx\"[A-Z]\" strong)) (length (regexp-match* #rx\"[a-z]\" strong))))\n  (for-each (lambda (s)\n              (let ([val (- (length (regexp-match* #rx\"[A-Z]\" s)) (length (regexp-match* #rx\"[a-z]\" s)))])\n                (when (> val my-val)\n                  (set! strong s)\n                  (set! my-val val))))\n            (cdr extensions))\n  (string-append class_name \".\" strong))\n\n### Julia version\n\nfunction Strongest_Extension(class_name::String, extensions::Vector{String})::String\n"}, {"name": "HumanEval_20_find_closest_elements", "language": "jl", "prompt": "function find_closest_elements(numbers::Vector{Float64})::Tuple{Float64, Float64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_20_find_closest_elements.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = find_closest_elements;\n\t@test(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\n\t@test(candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\n\t@test(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\n\t@test(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\n\t@test(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (find_closest_elements numbers)\n  (define closest-pair #f)\n  (define distance #f)\n\n  (for ([i (in-range (length numbers))])\n    (for ([j (in-range (length numbers))])\n      (unless (= i j)\n        (let ([new-distance (abs (- (list-ref numbers i) (list-ref numbers j)))])\n          (when (or (not distance) (< new-distance distance))\n            (set! distance new-distance)\n            (set! closest-pair (sort (list (list-ref numbers i) (list-ref numbers j)) <)))))))\n\n  closest-pair)\n\n### Julia version\n\nfunction find_closest_elements(numbers::Vector{Float64})::Tuple{Float64, Float64}\n"}, {"name": "HumanEval_124_valid_date", "language": "jl", "prompt": "function valid_date(date::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_124_valid_date.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = valid_date;\n\t@test(candidate(\"03-11-2000\") == true)\n\t@test(candidate(\"15-01-2012\") == false)\n\t@test(candidate(\"04-0-2040\") == false)\n\t@test(candidate(\"06-04-2020\") == true)\n\t@test(candidate(\"01-01-2007\") == true)\n\t@test(candidate(\"03-32-2011\") == false)\n\t@test(candidate(\"\") == false)\n\t@test(candidate(\"04-31-3000\") == false)\n\t@test(candidate(\"06-06-2005\") == true)\n\t@test(candidate(\"21-31-2000\") == false)\n\t@test(candidate(\"04-12-2003\") == true)\n\t@test(candidate(\"04122003\") == false)\n\t@test(candidate(\"20030412\") == false)\n\t@test(candidate(\"2003-04\") == false)\n\t@test(candidate(\"2003-04-12\") == false)\n\t@test(candidate(\"04-2003\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (valid_date date)\n  (define (is-valid-date month day year)\n    (cond [(or (< month 1) (> month 12)) #f]\n          [(and (member month '(1 3 5 7 8 10 12)) (or (< day 1) (> day 31))) #f]\n          [(and (member month '(4 6 9 11)) (or (< day 1) (> day 30))) #f]\n          [(and (= month 2) (or (< day 1) (> day 29))) #f]\n          [else #t]))\n  (with-handlers ([exn:fail? (lambda (e) #f)])\n    (let ([date-list (map string->number (string-split date \"-\"))])\n      (apply is-valid-date date-list))))\n\n### Julia version\n\nfunction valid_date(date::String)::Bool\n"}, {"name": "HumanEval_53_add", "language": "jl", "prompt": "function add(x::Int64, y::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_53_add.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = add;\n\t@test(candidate(0, 1) == 1)\n\t@test(candidate(1, 0) == 1)\n\t@test(candidate(2, 3) == 5)\n\t@test(candidate(5, 7) == 12)\n\t@test(candidate(7, 5) == 12)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (add x y)\n  (+ x y))\n\n### Julia version\n\nfunction add(x::Int64, y::Int64)::Int64\n"}, {"name": "HumanEval_40_triples_sum_to_zero", "language": "jl", "prompt": "function triples_sum_to_zero(l::Vector{Int64})::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_40_triples_sum_to_zero.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = triples_sum_to_zero;\n\t@test(candidate([1, 3, 5, 0]) == false)\n\t@test(candidate([1, 3, 5, -1]) == false)\n\t@test(candidate([1, 3, -2, 1]) == true)\n\t@test(candidate([1, 2, 3, 7]) == false)\n\t@test(candidate([1, 2, 5, 7]) == false)\n\t@test(candidate([2, 4, -5, 3, 9, 7]) == true)\n\t@test(candidate([1]) == false)\n\t@test(candidate([1, 3, 5, -100]) == false)\n\t@test(candidate([100, 3, 5, -100]) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (triples_sum_to_zero l)\n  (for*/first ([i (in-range (length l))]\n               [j (in-range (add1 i) (length l))]\n               [k (in-range (add1 j) (length l))]\n               #:when (= 0 (+ (list-ref l i) (list-ref l j) (list-ref l k))))\n    #t))\n\n### Julia version\n\nfunction triples_sum_to_zero(l::Vector{Int64})::Bool\n"}, {"name": "HumanEval_24_largest_divisor", "language": "jl", "prompt": "function largest_divisor(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_24_largest_divisor.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = largest_divisor;\n\t@test(candidate(3) == 1)\n\t@test(candidate(7) == 1)\n\t@test(candidate(10) == 5)\n\t@test(candidate(100) == 50)\n\t@test(candidate(49) == 7)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (largest_divisor n)\n  (for/first ([i (reverse (range 1 n))] #:when (= (modulo n i) 0))\n    i))\n\n### Julia version\n\nfunction largest_divisor(n::Int64)::Int64\n"}, {"name": "HumanEval_19_sort_numbers", "language": "jl", "prompt": "function sort_numbers(numbers::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_19_sort_numbers.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sort_numbers;\n\t@test(candidate(\"\") == \"\")\n\t@test(candidate(\"three\") == \"three\")\n\t@test(candidate(\"three five nine\") == \"three five nine\")\n\t@test(candidate(\"five zero four seven nine eight\") == \"zero four five seven eight nine\")\n\t@test(candidate(\"six five four three two one zero\") == \"zero one two three four five six\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sort_numbers numbers)\n  (define value-map (hash \"zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"seven\" 7 \"eight\" 8 \"nine\" 9))\n  (string-join (sort (filter (lambda (x) (not (string=? x \"\"))) (string-split numbers \" \")) (lambda (a b) (< (hash-ref value-map a) (hash-ref value-map b)))) \" \"))\n\n### Julia version\n\nfunction sort_numbers(numbers::String)::String\n"}, {"name": "HumanEval_73_smallest_change", "language": "jl", "prompt": "function smallest_change(arr::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_73_smallest_change.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = smallest_change;\n\t@test(candidate([1, 2, 3, 5, 4, 7, 9, 6]) == 4)\n\t@test(candidate([1, 2, 3, 4, 3, 2, 2]) == 1)\n\t@test(candidate([1, 4, 2]) == 1)\n\t@test(candidate([1, 4, 4, 2]) == 1)\n\t@test(candidate([1, 2, 3, 2, 1]) == 0)\n\t@test(candidate([3, 1, 1, 3]) == 0)\n\t@test(candidate([1]) == 0)\n\t@test(candidate([0, 1]) == 1)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (smallest_change arr)\n  (define ans 0)\n  (for ([i (in-range (quotient (length arr) 2))])\n    (when (not (= (list-ref arr i) (list-ref arr (- (length arr) i 1))))\n      (set! ans (+ ans 1))))\n  ans)\n\n### Julia version\n\nfunction smallest_change(arr::Vector{Int64})::Int64\n"}, {"name": "HumanEval_52_below_threshold", "language": "jl", "prompt": "function below_threshold(l::Vector{Int64}, t::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_52_below_threshold.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = below_threshold;\n\t@test(candidate([1, 2, 4, 10], 100) == true)\n\t@test(candidate([1, 20, 4, 10], 5) == false)\n\t@test(candidate([1, 20, 4, 10], 21) == true)\n\t@test(candidate([1, 20, 4, 10], 22) == true)\n\t@test(candidate([1, 8, 4, 10], 11) == true)\n\t@test(candidate([1, 8, 4, 10], 10) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (below_threshold l t)\n  (for/and ([e l])\n    (< e t)))\n\n### Julia version\n\nfunction below_threshold(l::Vector{Int64}, t::Int64)::Bool\n"}, {"name": "HumanEval_128_prod_signs", "language": "jl", "prompt": "function prod_signs(arr::Vector{Int64})::Union{Int64, Nothing}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_128_prod_signs.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (prod_signs arr)\n  (if (null? arr) #f\n      (let ((prod (if (member 0 arr) 0 (expt -1 (length (filter (lambda (x) (< x 0)) arr))))))\n        (* prod (apply + (map abs arr))))))\n\n### Julia version\n\nfunction prod_signs(arr::Vector{Int64})::Union{Int64, Nothing}\n"}, {"name": "HumanEval_49_modp", "language": "jl", "prompt": "function modp(n::Int64, p::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_49_modp.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (modp n p)\n  (define ret 1)\n  (for ([i (in-range n)])\n    (set! ret (modulo (* 2 ret) p)))\n  ret)\n\n### Julia version\n\nfunction modp(n::Int64, p::Int64)::Int64\n"}, {"name": "HumanEval_98_count_upper", "language": "jl", "prompt": "function count_upper(s::String)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_98_count_upper.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = count_upper;\n\t@test(candidate(\"aBCdEf\") == 1)\n\t@test(candidate(\"abcdefg\") == 0)\n\t@test(candidate(\"dBBE\") == 0)\n\t@test(candidate(\"B\") == 0)\n\t@test(candidate(\"U\") == 1)\n\t@test(candidate(\"\") == 0)\n\t@test(candidate(\"EEEE\") == 2)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (count_upper s)\n  (define count 0)\n  (for ([i (in-range 0 (string-length s) 2)])\n    (when (member (string-ref s i) (string->list \"AEIOU\"))\n      (set! count (+ count 1))))\n  count)\n\n### Julia version\n\nfunction count_upper(s::String)::Int64\n"}, {"name": "HumanEval_97_multiply", "language": "jl", "prompt": "function multiply(a::Int64, b::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_97_multiply.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = multiply;\n\t@test(candidate(148, 412) == 16)\n\t@test(candidate(19, 28) == 72)\n\t@test(candidate(2020, 1851) == 0)\n\t@test(candidate(14, -15) == 20)\n\t@test(candidate(76, 67) == 42)\n\t@test(candidate(17, 27) == 49)\n\t@test(candidate(0, 1) == 0)\n\t@test(candidate(0, 0) == 0)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (multiply a b)\n  (abs (* (modulo a 10) (modulo b 10))))\n\n### Julia version\n\nfunction multiply(a::Int64, b::Int64)::Int64\n"}, {"name": "HumanEval_104_unique_digits", "language": "jl", "prompt": "function unique_digits(x::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_104_unique_digits.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = unique_digits;\n\t@test(candidate([15, 33, 1422, 1]) == [1, 15, 33])\n\t@test(candidate([152, 323, 1422, 10]) == Vector{Int64}([]))\n\t@test(candidate([12345, 2033, 111, 151]) == [111, 151])\n\t@test(candidate([135, 103, 31]) == [31, 135])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (unique_digits x)\n  (define (all-odd-digits? n)\n    (andmap odd? (map (lambda (c) (string->number (string c))) (string->list (number->string n)))))\n  (sort (filter all-odd-digits? x) <))\n\n### Julia version\n\nfunction unique_digits(x::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_72_will_it_fly", "language": "jl", "prompt": "function will_it_fly(q::Vector{Int64}, w::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_72_will_it_fly.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = will_it_fly;\n\t@test(candidate([3, 2, 3], 9) == true)\n\t@test(candidate([1, 2], 5) == false)\n\t@test(candidate([3], 5) == true)\n\t@test(candidate([3, 2, 3], 1) == false)\n\t@test(candidate([1, 2, 3], 6) == false)\n\t@test(candidate([5], 5) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (will_it_fly q w)\n  (cond [(> (apply + q) w) #f]\n        [(not (equal? q (reverse q))) #f]\n        [else #t]))\n\n### Julia version\n\nfunction will_it_fly(q::Vector{Int64}, w::Int64)::Bool\n"}, {"name": "HumanEval_75_is_multiply_prime", "language": "jl", "prompt": "function is_multiply_prime(a::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_75_is_multiply_prime.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_multiply_prime;\n\t@test(candidate(5) == false)\n\t@test(candidate(30) == true)\n\t@test(candidate(8) == true)\n\t@test(candidate(10) == false)\n\t@test(candidate(125) == true)\n\t@test(candidate(105) == true)\n\t@test(candidate(126) == false)\n\t@test(candidate(729) == false)\n\t@test(candidate(891) == false)\n\t@test(candidate(1001) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_multiply_prime a)\n  (define (is-prime n)\n    (for/and ([j (in-range 2 n)])\n      (not (= (modulo n j) 0))))\n  (for/or ([i (in-range 2 101)])\n    (for/or ([j (in-range 2 101)])\n      (for/or ([k (in-range 2 101)])\n        (and (is-prime i) (is-prime j) (is-prime k) (= (* i j k) a))))))\n\n### Julia version\n\nfunction is_multiply_prime(a::Int64)::Bool\n"}, {"name": "HumanEval_120_maximum", "language": "jl", "prompt": "function maximum(arr::Vector{Int64}, k::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_120_maximum.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = maximum;\n\t@test(candidate([-3, -4, 5], 3) == [-4, -3, 5])\n\t@test(candidate([4, -4, 4], 2) == [4, 4])\n\t@test(candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2])\n\t@test(candidate([123, -123, 20, 0, 1, 2, -3], 3) == [2, 20, 123])\n\t@test(candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2, 20])\n\t@test(candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15])\n\t@test(candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5])\n\t@test(candidate([1, 0, 5, -7], 1) == [5])\n\t@test(candidate([4, -4], 2) == [-4, 4])\n\t@test(candidate([-10, 10], 2) == [-10, 10])\n\t@test(candidate([1, 2, 3, -23, 243, -400, 0], 0) == Vector{Int64}([]))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (maximum arr k)\n  (if (= k 0)\n      '()\n      (list-tail (sort arr <) (- (length arr) k))))\n\n### Julia version\n\nfunction maximum(arr::Vector{Int64}, k::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_1_separate_paren_groups", "language": "jl", "prompt": "function separate_paren_groups(paren_string::String)::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_1_separate_paren_groups.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (separate_paren_groups paren_string)\n  (define result '())\n  (define current_string '())\n  (define current_depth 0)\n\n  (for ([c (string->list paren_string)])\n    (cond [(char=? c #\\() (set! current_depth (add1 current_depth))\n           (set! current_string (append current_string (list c)))]\n          [(char=? c #\\)) (set! current_depth (sub1 current_depth))\n           (set! current_string (append current_string (list c)))\n           (cond [(= current_depth 0) (set! result (append result (list (list->string current_string))))\n                  (set! current_string '())])]))\n  result)\n\n### Julia version\n\nfunction separate_paren_groups(paren_string::String)::Vector{String}\n"}, {"name": "HumanEval_22_filter_integers", "language": "jl", "prompt": "function filter_integers(values::Vector{Any})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_22_filter_integers.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = filter_integers;\n\t@test(candidate(Vector{Any}([])) == Vector{Int64}([]))\n\t@test(candidate([4, Dict(), [], 23.2, 9, \"adasd\"]) == [4, 9])\n\t@test(candidate([3, \"c\", 3, 3, \"a\", \"b\"]) == [3, 3, 3])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (filter_integers values)\n  (filter integer? values))\n\n### Julia version\n\nfunction filter_integers(values::Vector{Any})::Vector{Int64}\n"}, {"name": "HumanEval_94_skjkasdkd", "language": "jl", "prompt": "function skjkasdkd(lst::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_94_skjkasdkd.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = skjkasdkd;\n\t@test(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)\n\t@test(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)\n\t@test(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)\n\t@test(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)\n\t@test(candidate([0, 81, 12, 3, 1, 21]) == 3)\n\t@test(candidate([0, 8, 1, 2, 1, 7]) == 7)\n\t@test(candidate([8191]) == 19)\n\t@test(candidate([8191, 123456, 127, 7]) == 19)\n\t@test(candidate([127, 97, 8192]) == 10)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (skjkasdkd lst)\n  (define (isPrime n)\n    (define (iter i)\n      (cond [(> i (sqrt n)) #t]\n            [(= (modulo n i) 0) #f]\n            [else (iter (+ i 1))]))\n    (if (< n 2) #f (iter 2)))\n\n  (define maxx 0)\n  (for ([i lst])\n    (when (and (> i maxx) (isPrime i))\n      (set! maxx i)))\n  (define result (apply + (map (lambda (d) (string->number (string d))) (string->list (number->string maxx)))))\n  result)\n\n### Julia version\n\nfunction skjkasdkd(lst::Vector{Int64})::Int64\n"}, {"name": "HumanEval_74_total_match", "language": "jl", "prompt": "function total_match(lst1::Vector{String}, lst2::Vector{String})::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_74_total_match.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = total_match;\n\t@test(candidate(Vector{String}([]), Vector{String}([])) == Vector{String}([]))\n\t@test(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\n\t@test(candidate([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"])\n\t@test(candidate([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]) == [\"4\"])\n\t@test(candidate([\"hi\", \"admin\"], [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"])\n\t@test(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\n\t@test(candidate([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\n\t@test(candidate(Vector{String}([]), [\"this\"]) == Vector{String}([]))\n\t@test(candidate([\"this\"], Vector{String}([])) == Vector{String}([]))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (total_match lst1 lst2)\n  (define l1 (apply + (map string-length lst1)))\n  (define l2 (apply + (map string-length lst2)))\n  (if (<= l1 l2) lst1 lst2))\n\n### Julia version\n\nfunction total_match(lst1::Vector{String}, lst2::Vector{String})::Vector{String}\n"}, {"name": "HumanEval_41_car_race_collision", "language": "jl", "prompt": "function car_race_collision(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_41_car_race_collision.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = car_race_collision;\n\t@test(candidate(2) == 4)\n\t@test(candidate(3) == 9)\n\t@test(candidate(4) == 16)\n\t@test(candidate(8) == 64)\n\t@test(candidate(10) == 100)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (car_race_collision n)\n  (* n n))\n\n### Julia version\n\nfunction car_race_collision(n::Int64)::Int64\n"}, {"name": "HumanEval_76_is_simple_power", "language": "jl", "prompt": "function is_simple_power(x::Int64, n::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_76_is_simple_power.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_simple_power;\n\t@test(candidate(16, 2) == true)\n\t@test(candidate(143214, 16) == false)\n\t@test(candidate(4, 2) == true)\n\t@test(candidate(9, 3) == true)\n\t@test(candidate(16, 4) == true)\n\t@test(candidate(24, 2) == false)\n\t@test(candidate(128, 4) == false)\n\t@test(candidate(12, 6) == false)\n\t@test(candidate(1, 1) == true)\n\t@test(candidate(1, 12) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (is_simple_power x n)\n  (if (= n 1)\n      (= x 1)\n      (let loop ((power 1))\n        (if (< power x)\n            (loop (* power n))\n            (= power x)))))\n\n### Julia version\n\nfunction is_simple_power(x::Int64, n::Int64)::Bool\n"}, {"name": "HumanEval_93_encode", "language": "jl", "prompt": "function encode(message::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_93_encode.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = encode;\n\t@test(candidate(\"TEST\") == \"tgst\")\n\t@test(candidate(\"Mudasir\") == \"mWDCSKR\")\n\t@test(candidate(\"YES\") == \"ygs\")\n\t@test(candidate(\"This is a message\") == \"tHKS KS C MGSSCGG\")\n\t@test(candidate(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (encode message)\n  (define vowels \"aeiouAEIOU\")\n  (define vowels-replace (make-hash '((#\\a . #\\c) (#\\e . #\\g) (#\\i . #\\k) (#\\o . #\\q) (#\\u . #\\w) (#\\A . #\\C) (#\\E . #\\G) (#\\I . #\\K) (#\\O . #\\Q) (#\\U . #\\W))))\n\n  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\n  (define (replace-vowels c)\n    (hash-ref vowels-replace c c))\n\n  (list->string (map replace-vowels (map swap-case (string->list message)))))\n\n### Julia version\n\nfunction encode(message::String)::String\n"}, {"name": "HumanEval_42_incr_list", "language": "jl", "prompt": "function incr_list(l::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_42_incr_list.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = incr_list;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([3, 2, 1]) == [4, 3, 2])\n\t@test(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (incr_list l)\n  (map add1 l))\n\n### Julia version\n\nfunction incr_list(l::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_64_vowels_count", "language": "jl", "prompt": "function vowels_count(s::String)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_64_vowels_count.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = vowels_count;\n\t@test(candidate(\"abcde\") == 2)\n\t@test(candidate(\"Alone\") == 3)\n\t@test(candidate(\"key\") == 2)\n\t@test(candidate(\"bye\") == 1)\n\t@test(candidate(\"keY\") == 2)\n\t@test(candidate(\"bYe\") == 1)\n\t@test(candidate(\"ACEDY\") == 3)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (vowels_count s)\n  (define vowels \"aeiouAEIOU\")\n  (define n_vowels (count (lambda (c) (member c (string->list vowels))) (string->list s)))\n  (if (or (char=? (last (string->list s)) #\\y) (char=? (last (string->list s)) #\\Y))\n      (+ n_vowels 1)\n      n_vowels))\n\n### Julia version\n\nfunction vowels_count(s::String)::Int64\n"}, {"name": "HumanEval_149_sorted_list_sum", "language": "jl", "prompt": "function sorted_list_sum(lst::Vector{String})::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_149_sorted_list_sum.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sorted_list_sum;\n\t@test(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"])\n\t@test(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"])\n\t@test(candidate([\"d\", \"b\", \"c\", \"a\"]) == Vector{String}([]))\n\t@test(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\n\t@test(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\n\t@test(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == Vector{String}([]))\n\t@test(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (sorted_list_sum lst)\n  (define (even-length? str) (= (modulo (string-length str) 2) 0))\n  (define new-lst (filter even-length? (sort lst string<?)))\n  (sort new-lst (lambda (a b) (< (string-length a) (string-length b)))))\n\n### Julia version\n\nfunction sorted_list_sum(lst::Vector{String})::Vector{String}\n"}, {"name": "HumanEval_101_words_string", "language": "jl", "prompt": "function words_string(s::String)::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_101_words_string.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = words_string;\n\t@test(candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\n\t@test(candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\n\t@test(candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"])\n\t@test(candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\n\t@test(candidate(\"\") == Vector{String}([]))\n\t@test(candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (words_string s)\n  (if (not s)\n      '()\n      (string-split (string-replace s \",\" \" \"))))\n\n### Julia version\n\nfunction words_string(s::String)::Vector{String}\n"}, {"name": "HumanEval_107_even_odd_palindrome", "language": "jl", "prompt": "function even_odd_palindrome(n::Int64)::Tuple{Int64, Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_107_even_odd_palindrome.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = even_odd_palindrome;\n\t@test(candidate(123) == (8, 13))\n\t@test(candidate(12) == (4, 6))\n\t@test(candidate(3) == (1, 2))\n\t@test(candidate(63) == (6, 8))\n\t@test(candidate(25) == (5, 6))\n\t@test(candidate(19) == (4, 6))\n\t@test(candidate(9) == (4, 5))\n\t@test(candidate(1) == (0, 1))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;;\n(define (even_odd_palindrome n)\n  (define (is_palindrome n)\n    (equal? (number->string n) (list->string (reverse (string->list (number->string n))))))\n\n  (define even_palindrome_count 0)\n  (define odd_palindrome_count 0)\n  (for ([i (in-range 1 (add1 n))])\n    (cond [(and (odd? i) (is_palindrome i)) (set! odd_palindrome_count (add1 odd_palindrome_count))]\n          [(and (even? i) (is_palindrome i)) (set! even_palindrome_count (add1 even_palindrome_count))]))\n  (list even_palindrome_count odd_palindrome_count))\n\n### Julia version\n\nfunction even_odd_palindrome(n::Int64)::Tuple{Int64, Int64}\n"}, {"name": "HumanEval_95_check_dict_case", "language": "jl", "prompt": "function check_dict_case(dict::Dict{String, String}>)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_95_check_dict_case.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = check_dict_case;\n\t@test(candidate(Dict(\"p\" => \"pineapple\", \"b\" => \"banana\")) == true)\n\t@test(candidate(Dict(\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\")) == false)\n\t@test(candidate(Dict(\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\")) == false)\n\t@test(candidate(Dict(\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\")) == false)\n\t@test(candidate(Dict(\"STATE\" => \"NC\", \"ZIP\" => \"12345\")) == true)\n\t@test(candidate(Dict(\"fruit\" => \"Orange\", \"taste\" => \"Sweet\")) == true)\n\t@test(candidate(Dict()) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (check_dict_case dict)\n  (define (is-upper s) (string=? s (string-upcase s)))\n  (define (is-lower s) (string=? s (string-downcase s)))\n\n  (cond [(zero? (hash-count dict)) #f]\n        [else\n         (let loop ([state \"start\"] [keys (hash-keys dict)])\n           (cond [(null? keys) (or (string=? state \"upper\") (string=? state \"lower\"))]\n                 [(not (string? (car keys))) #f]\n                 [(string=? state \"start\")\n                  (if (is-upper (car keys))\n                      (loop \"upper\" (cdr keys))\n                      (if (is-lower (car keys))\n                          (loop \"lower\" (cdr keys))\n                          #f))]\n\n                 [(or (and (string=? state \"upper\") (not (is-upper (car keys))))\n                      (and (string=? state \"lower\") (not (is-lower (car keys)))))\n                  #f]\n\n                 [else (loop state (cdr keys))]))]))\n\n### Julia version\n\nfunction check_dict_case(dict::Dict{String, String}>)::Bool\n"}, {"name": "HumanEval_130_tri", "language": "jl", "prompt": "function tri(n::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_130_tri.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = tri;\n\t@test(candidate(3) == [1, 3, 2, 8])\n\t@test(candidate(4) == [1, 3, 2, 8, 3])\n\t@test(candidate(5) == [1, 3, 2, 8, 3, 15])\n\t@test(candidate(6) == [1, 3, 2, 8, 3, 15, 4])\n\t@test(candidate(7) == [1, 3, 2, 8, 3, 15, 4, 24])\n\t@test(candidate(8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\n\t@test(candidate(9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\n\t@test(candidate(20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\n\t@test(candidate(0) == [1])\n\t@test(candidate(1) == [1, 3])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (tri n)\n  (if (= n 0)\n      '(1)\n      (let ((my-tri '(1 3)))\n        (for ([i (in-range 2 (add1 n))])\n          (if (even? i)\n              (set! my-tri (append my-tri (list (/ (+ i 2) 2))))\n              (set! my-tri (append my-tri (list (+ (list-ref my-tri (- i 1)) (list-ref my-tri (- i 2)) (/ (+ i 3) 2)))))))\n        my-tri)))\n\n### Julia version\n\nfunction tri(n::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_47_median", "language": "jl", "prompt": "function median(l::Vector{Int64})::Float64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_47_median.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = median;\n\t@test(candidate([3, 1, 2, 4, 5]) == 3)\n\t@test(candidate([-10, 4, 6, 1000, 10, 20]) == 8.0)\n\t@test(candidate([5]) == 5)\n\t@test(candidate([6, 5]) == 5.5)\n\t@test(candidate([8, 1, 3, 9, 9, 2, 7]) == 7)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (median l)\n  (set! l (sort l <))\n  (if (odd? (length l))\n      (list-ref l (quotient (length l) 2))\n      (/ (+ (list-ref l (quotient (length l) 2))\n            (list-ref l (- (quotient (length l) 2) 1)))\n         2.0)))\n\n### Julia version\n\nfunction median(l::Vector{Int64})::Float64\n"}, {"name": "HumanEval_44_change_base", "language": "jl", "prompt": "function change_base(x::Int64, base::Int64)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_44_change_base.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = change_base;\n\t@test(candidate(8, 3) == \"22\")\n\t@test(candidate(9, 3) == \"100\")\n\t@test(candidate(234, 2) == \"11101010\")\n\t@test(candidate(16, 2) == \"10000\")\n\t@test(candidate(8, 2) == \"1000\")\n\t@test(candidate(7, 2) == \"111\")\n\t@test(candidate(2, 3) == \"2\")\n\t@test(candidate(3, 4) == \"3\")\n\t@test(candidate(4, 5) == \"4\")\n\t@test(candidate(5, 6) == \"5\")\n\t@test(candidate(6, 7) == \"6\")\n\t@test(candidate(7, 8) == \"7\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (change_base x base)\n  (let loop ((x x) (ret \"\"))\n    (if (> x 0)\n        (loop (quotient x base) (string-append (number->string (modulo x base)) ret))\n        ret)))\n\n### Julia version\n\nfunction change_base(x::Int64, base::Int64)::String\n"}, {"name": "HumanEval_12_longest", "language": "jl", "prompt": "function longest(strings::Vector{String})::Union{String, Nothing}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_12_longest.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = longest;\n\t@test(candidate(Vector{String}([])) == nothing)\n\t@test(candidate([\"x\", \"y\", \"z\"]) == \"x\")\n\t@test(candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (longest strings)\n  (if (null? strings)\n      #f\n      (let ((maxlen (apply max (map string-length strings))))\n        (findf (lambda (s) (= (string-length s) maxlen)) strings))))\n\n### Julia version\n\nfunction longest(strings::Vector{String})::Union{String, Nothing}\n"}, {"name": "HumanEval_58_common", "language": "jl", "prompt": "function common(l1::Vector{Int64}, l2::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_58_common.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (common l1 l2)\n  (define ret (make-hash))\n  (for ([e1 l1])\n    (for ([e2 l2])\n      (when (= e1 e2)\n        (hash-set! ret e1 #t))))\n  (sort (hash-keys ret) <))\n\n### Julia version\n\nfunction common(l1::Vector{Int64}, l2::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_114_minSubArraySum", "language": "jl", "prompt": "function minSubArraySum(nums::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_114_minSubArraySum.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = minSubArraySum;\n\t@test(candidate([2, 3, 4, 1, 2, 4]) == 1)\n\t@test(candidate([-1, -2, -3]) == -6)\n\t@test(candidate([-1, -2, -3, 2, -10]) == -14)\n\t@test(candidate([-9999999999999999]) == -9999999999999999)\n\t@test(candidate([0, 10, 20, 1000000]) == 0)\n\t@test(candidate([-1, -2, -3, 10, -5]) == -6)\n\t@test(candidate([100, -1, -2, -3, 10, -5]) == -6)\n\t@test(candidate([10, 11, 13, 8, 3, 4]) == 3)\n\t@test(candidate([100, -33, 32, -1, 0, -2]) == -33)\n\t@test(candidate([-10]) == -10)\n\t@test(candidate([7]) == 7)\n\t@test(candidate([1, -1]) == -1)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (minSubArraySum nums)\n  (define max-sum 0)\n  (define s 0)\n  (for ([num nums])\n    (set! s (+ s (- num)))\n    (when (< s 0)\n      (set! s 0))\n    (set! max-sum (max s max-sum)))\n  (when (= max-sum 0)\n    (set! max-sum (apply max (map - nums))))\n  (define min-sum (- max-sum))\n  min-sum)\n\n### Julia version\n\nfunction minSubArraySum(nums::Vector{Int64})::Int64\n"}, {"name": "HumanEval_88_sort_array", "language": "jl", "prompt": "function sort_array(array::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_88_sort_array.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (sort_array array)\n  (if (null? array)\n      '()\n      (sort array (if (even? (+ (first array) (last array))) > <))))\n\n### Julia version\n\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_123_get_odd_collatz", "language": "jl", "prompt": "function get_odd_collatz(n::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_123_get_odd_collatz.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_odd_collatz n)\n  (define (collatz-seq n)\n    (cond [(= n 1) (list 1)]\n          [(even? n) (cons n (collatz-seq (/ n 2)))]\n          [else (cons n (collatz-seq (+ (* n 3) 1)))]))\n  (let ([seq (collatz-seq n)])\n    (sort (filter odd? seq) <)))\n\n### Julia version\n\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_62_derivative", "language": "jl", "prompt": "function derivative(xs::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_62_derivative.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = derivative;\n\t@test(candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20])\n\t@test(candidate([1, 2, 3]) == [2, 6])\n\t@test(candidate([3, 2, 1]) == [2, 2])\n\t@test(candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16])\n\t@test(candidate([1]) == Vector{Int64}([]))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (derivative xs)\n  (cdr (map (lambda (x i) (* i x)) xs (range 0 (length xs)))))\n\n### Julia version\n\nfunction derivative(xs::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_63_fibfib", "language": "jl", "prompt": "function fibfib(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_63_fibfib.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = fibfib;\n\t@test(candidate(2) == 1)\n\t@test(candidate(1) == 0)\n\t@test(candidate(5) == 4)\n\t@test(candidate(8) == 24)\n\t@test(candidate(10) == 81)\n\t@test(candidate(12) == 274)\n\t@test(candidate(14) == 927)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (fibfib n)\n  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\n### Julia version\n\nfunction fibfib(n::Int64)::Int64\n"}, {"name": "HumanEval_35_max_element", "language": "jl", "prompt": "function max_element(l::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_35_max_element.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = max_element;\n\t@test(candidate([1, 2, 3]) == 3)\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (max_element l)\n  (apply max l))\n\n### Julia version\n\nfunction max_element(l::Vector{Int64})::Int64\n"}, {"name": "HumanEval_39_prime_fib", "language": "jl", "prompt": "function prime_fib(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_39_prime_fib.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = prime_fib;\n\t@test(candidate(1) == 2)\n\t@test(candidate(2) == 3)\n\t@test(candidate(3) == 5)\n\t@test(candidate(4) == 13)\n\t@test(candidate(5) == 89)\n\t@test(candidate(6) == 233)\n\t@test(candidate(7) == 1597)\n\t@test(candidate(8) == 28657)\n\t@test(candidate(9) == 514229)\n\t@test(candidate(10) == 433494437)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prime_fib n)\n  (define (is-prime? p)\n    (cond [(< p 2) #f]\n          [else (for/and ([k (in-range 2 (min (add1 (floor (sqrt p))) (sub1 p)))])\n                  (not (= 0 (modulo p k))))]))\n  (define f (list 0 1))\n  (let loop ([n n])\n    (cond [(= n 0) (car (reverse f))]\n          [else (begin\n                  (set! f (append f (list (+ (car (reverse f)) (cadr (reverse f))))))\n                  (if (is-prime? (car (reverse f)))\n                      (loop (sub1 n))\n                      (loop n)))])))\n\n### Julia version\n\nfunction prime_fib(n::Int64)::Int64\n"}, {"name": "HumanEval_8_sum_product", "language": "jl", "prompt": "function sum_product(numbers::Vector{Int64})::Tuple{Int64, Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_8_sum_product.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sum_product;\n\t@test(candidate(Vector{Int64}([])) == (0, 1))\n\t@test(candidate([1, 1, 1]) == (3, 1))\n\t@test(candidate([100, 0]) == (100, 0))\n\t@test(candidate([3, 5, 7]) == (15, 105))\n\t@test(candidate([10]) == (10, 10))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (sum_product numbers)\n  (define sum-value (apply + numbers))\n  (define prod-value (apply * numbers))\n  (list sum-value prod-value))\n\n### Julia version\n\nfunction sum_product(numbers::Vector{Int64})::Tuple{Int64, Int64}\n"}, {"name": "HumanEval_117_select_words", "language": "jl", "prompt": "function select_words(s::String, n::Int64)::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_117_select_words.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = select_words;\n\t@test(candidate(\"Mary had a little lamb\", 4) == [\"little\"])\n\t@test(candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"])\n\t@test(candidate(\"simple white space\", 2) == Vector{String}([]))\n\t@test(candidate(\"Hello world\", 4) == [\"world\"])\n\t@test(candidate(\"Uncle sam\", 3) == [\"Uncle\"])\n\t@test(candidate(\"\", 4) == Vector{String}([]))\n\t@test(candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (select_words s n)\n  (define (consonant? c)\n    (not (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u))))\n  (define (count-consonants word)\n    (count consonant? (string->list word)))\n  (filter (lambda (word) (= (count-consonants word) n))\n          (string-split s)))\n\n### Julia version\n\nfunction select_words(s::String, n::Int64)::Vector{String}\n"}, {"name": "HumanEval_122_add_elements", "language": "jl", "prompt": "function add_elements(arr::Vector{Int64}, k::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_122_add_elements.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = add_elements;\n\t@test(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) == -4)\n\t@test(candidate([111, 121, 3, 4000, 5, 6], 2) == 0)\n\t@test(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) == 125)\n\t@test(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) == 24)\n\t@test(candidate([1], 1) == 1)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (add_elements arr k)\n  (apply + (filter (lambda (x) (<= (string-length (number->string x)) 2)) (take arr k))))\n\n### Julia version\n\nfunction add_elements(arr::Vector{Int64}, k::Int64)::Int64\n"}, {"name": "HumanEval_159_eat", "language": "jl", "prompt": "function eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_159_eat.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (eat number need remaining)\n  (if (<= need remaining)\n      (list (+ number need) (- remaining need))\n      (list (+ number remaining) 0)))\n\n### Julia version\n\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_113_odd_count", "language": "jl", "prompt": "function odd_count(lst::Vector{String})::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_113_odd_count.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = odd_count;\n\t@test(candidate([\"1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\n\t@test(candidate([\"3\", \"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\n\t@test(candidate([\"271\", \"137\", \"314\"]) == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (odd_count lst)\n  (map (lambda (arr)\n         (let ([n (count (lambda (d) (odd? (string->number (string d)))) (string->list arr))])\n           (string-append \"the number of odd elements \" (number->string n) \"n the str\" (number->string n) \"ng \" (number->string n) \" of the \" (number->string n) \"nput.\")))\n       lst))\n\n### Julia version\n\nfunction odd_count(lst::Vector{String})::Vector{String}\n"}, {"name": "HumanEval_90_next_smallest", "language": "jl", "prompt": "function next_smallest(lst::Vector{Int64})::Union{Int64, Nothing}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_90_next_smallest.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = next_smallest;\n\t@test(candidate([1, 2, 3, 4, 5]) == 2)\n\t@test(candidate([5, 1, 4, 3, 2]) == 2)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([1, 1]) == nothing)\n\t@test(candidate([1, 1, 1, 1, 0]) == 1)\n\t@test(candidate([1, 1]) == nothing)\n\t@test(candidate([-35, 34, 12, -45]) == -35)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (next_smallest lst)\n  (set! lst (sort (remove-duplicates lst) <))\n  (if (< (length lst) 2)\n      #f\n      (list-ref lst 1)))\n\n### Julia version\n\nfunction next_smallest(lst::Vector{Int64})::Union{Int64, Nothing}\n"}, {"name": "HumanEval_87_get_row", "language": "jl", "prompt": "function get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64, Int64}}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_87_get_row.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_row lst x)\n  (define coords\n    (for*/list ([i (in-range (length lst))]\n                [j (in-range (length (list-ref lst i)))]\n                #:when (= (list-ref (list-ref lst i) j) x))\n      (list i j)))\n  (sort coords (lambda (a b) (or (< (first a) (first b))\n                                 (and (= (first a) (first b))\n                                      (> (second a) (second b)))))))\n\n### Julia version\n\nfunction get_row(lst::Vector{Vector{Int64}}, x::Int64)::Vector{Tuple{Int64, Int64}}\n"}, {"name": "HumanEval_29_filter_by_prefix", "language": "jl", "prompt": "function filter_by_prefix(strings::Vector{String}, prefix::String)::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_29_filter_by_prefix.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = filter_by_prefix;\n\t@test(candidate(Vector{String}([]), \"john\") == Vector{String}([]))\n\t@test(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (filter_by_prefix strings prefix)\n  (filter (lambda (x) (string-prefix? x prefix)) strings))\n\n### Julia version\n\nfunction filter_by_prefix(strings::Vector{String}, prefix::String)::Vector{String}\n"}, {"name": "HumanEval_102_choose_num", "language": "jl", "prompt": "function choose_num(x::Int64, y::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_102_choose_num.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = choose_num;\n\t@test(candidate(12, 15) == 14)\n\t@test(candidate(13, 12) == -1)\n\t@test(candidate(33, 12354) == 12354)\n\t@test(candidate(5234, 5233) == -1)\n\t@test(candidate(6, 29) == 28)\n\t@test(candidate(27, 10) == -1)\n\t@test(candidate(7, 7) == -1)\n\t@test(candidate(546, 546) == 546)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (choose_num x y)\n  (cond\n    [(> x y) -1]\n    [(even? y) y]\n    [(= x y) -1]\n    [else (- y 1)]))\n\n### Julia version\n\nfunction choose_num(x::Int64, y::Int64)::Int64\n"}, {"name": "HumanEval_82_prime_length", "language": "jl", "prompt": "function prime_length(string::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_82_prime_length.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = prime_length;\n\t@test(candidate(\"Hello\") == true)\n\t@test(candidate(\"abcdcba\") == true)\n\t@test(candidate(\"kittens\") == true)\n\t@test(candidate(\"orange\") == false)\n\t@test(candidate(\"wow\") == true)\n\t@test(candidate(\"world\") == true)\n\t@test(candidate(\"MadaM\") == true)\n\t@test(candidate(\"Wow\") == true)\n\t@test(candidate(\"\") == false)\n\t@test(candidate(\"HI\") == true)\n\t@test(candidate(\"go\") == true)\n\t@test(candidate(\"gogo\") == false)\n\t@test(candidate(\"aaaaaaaaaaaaaaa\") == false)\n\t@test(candidate(\"Madam\") == true)\n\t@test(candidate(\"M\") == false)\n\t@test(candidate(\"0\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (prime_length string)\n  (define l (string-length string))\n  (and (> l 1)\n       (not (ormap (lambda (i) (= (modulo l i) 0)) (range 2 l)))))\n\n### Julia version\n\nfunction prime_length(string::String)::Bool\n"}, {"name": "HumanEval_60_sum_to_n", "language": "jl", "prompt": "function sum_to_n(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_60_sum_to_n.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = sum_to_n;\n\t@test(candidate(1) == 1)\n\t@test(candidate(6) == 21)\n\t@test(candidate(11) == 66)\n\t@test(candidate(30) == 465)\n\t@test(candidate(100) == 5050)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (sum_to_n n)\n  (apply + (range 0 (add1 n))))\n\n### Julia version\n\nfunction sum_to_n(n::Int64)::Int64\n"}, {"name": "HumanEval_140_fix_spaces", "language": "jl", "prompt": "function fix_spaces(text::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_140_fix_spaces.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = fix_spaces;\n\t@test(candidate(\"Example\") == \"Example\")\n\t@test(candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\")\n\t@test(candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\")\n\t@test(candidate(\"Exa   mple\") == \"Exa-mple\")\n\t@test(candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fix_spaces text)\n  (define new_text \"\")\n  (define i 0)\n  (define start 0)\n  (define end 0)\n\n  (define (append_text! text)\n    (if (> (- end start) 2)\n        (set! new_text (string-append new_text \"-\" text))\n        (if (> (- end start) 0)\n            (set! new_text (string-append new_text (make-string (- end start) #\\_ ) text))\n            (set! new_text (string-append new_text text))))\n    (set! start (+ i 1))\n    (set! end (+ i 1)))\n\n  (for ([c (string->list text)])\n    (cond [(char=? c #\\space)\n           (set! end (+ end 1))]\n          [else\n           (append_text! (string c))]))\n\n  (if (> (- end start) 2)\n      (set! new_text (string-append new_text \"-\"))\n      (if (> (- end start) 0)\n          (set! new_text (string-append new_text (make-string (- end start) #\\_)))\n          (void)))\n  new_text)\n\n### Julia version\n\nfunction fix_spaces(text::String)::String\n"}, {"name": "HumanEval_9_rolling_max", "language": "jl", "prompt": "function rolling_max(numbers::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_9_rolling_max.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = rolling_max;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4]) == [1, 2, 3, 4])\n\t@test(candidate([4, 3, 2, 1]) == [4, 4, 4, 4])\n\t@test(candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (rolling_max numbers)\n  (define running-max #f)\n  (define result '())\n\n  (for ([n (in-list numbers)])\n    (set! running-max (if (not running-max) n (max running-max n)))\n    (set! result (append result (list running-max))))\n\n  result)\n\n### Julia version\n\nfunction rolling_max(numbers::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_143_words_in_sentence", "language": "jl", "prompt": "function words_in_sentence(sentence::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_143_words_in_sentence.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = words_in_sentence;\n\t@test(candidate(\"This is a test\") == \"is\")\n\t@test(candidate(\"lets go for swimming\") == \"go for\")\n\t@test(candidate(\"there is no place available here\") == \"there is no place\")\n\t@test(candidate(\"Hi I am Hussein\") == \"Hi am Hussein\")\n\t@test(candidate(\"go for it\") == \"go for it\")\n\t@test(candidate(\"here\") == \"\")\n\t@test(candidate(\"here is\") == \"is\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (words_in_sentence sentence)\n  (define (is-prime n)\n    (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))  \n    (if (< n 2) #f (iter 2)))\n  (define (prime-word? word)\n    (or (= (string-length word) 2) (is-prime (string-length word))))\n  (string-join (filter prime-word? (string-split sentence)) \" \"))\n\n### Julia version\n\nfunction words_in_sentence(sentence::String)::String\n"}, {"name": "HumanEval_118_get_closest_vowel", "language": "jl", "prompt": "function get_closest_vowel(word::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_118_get_closest_vowel.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_closest_vowel word)\n  (define vowels (list \"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"O\" \"U\" \"I\"))\n  (let loop ([i (- (string-length word) 2)])\n    (if (< i 1)\n        \"\"\n        (if (member (substring word i (+ i 1)) vowels)\n            (if (and (not (member (substring word (- i 1) i) vowels))\n                     (not (member (substring word (+ i 1) (+ i 2)) vowels)))\n                (substring word i (+ i 1))\n                (loop (- i 1)))\n            (loop (- i 1))))))\n\n### Julia version\n\nfunction get_closest_vowel(word::String)::String\n"}, {"name": "HumanEval_152_compare", "language": "jl", "prompt": "function compare(game::Vector{Int64}, guess::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_152_compare.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = compare;\n\t@test(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])\n\t@test(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])\n\t@test(candidate([1, 2, 3], [-1, -2, -3]) == [2, 4, 6])\n\t@test(candidate([1, 2, 3, 5], [-1, 2, 3, 4]) == [2, 0, 0, 1])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (compare game guess)\n  (map abs (map - game guess)))\n\n### Julia version\n\nfunction compare(game::Vector{Int64}, guess::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_26_remove_duplicates", "language": "jl", "prompt": "function remove_duplicates(numbers::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_26_remove_duplicates.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = remove_duplicates;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4]) == [1, 2, 3, 4])\n\t@test(candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (remove_duplicates numbers)\n  (define c (make-hash))\n  (for ([n numbers])\n    (hash-update! c n add1 0))\n  (filter (lambda (n) (<= (hash-ref c n 0) 1)) numbers))\n\n### Julia version\n\nfunction remove_duplicates(numbers::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_6_parse_nested_parens", "language": "jl", "prompt": "function parse_nested_parens(paren_string::String)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_6_parse_nested_parens.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (parse_nested_parens paren_string)\n  (define (parse_paren_group s)\n    (define depth 0)\n    (define max_depth 0)\n    (for ([c (string->list s)])\n      (if (equal? c #\\()\n          (set! depth (+ depth 1))\n          (set! depth (- depth 1)))\n      (set! max_depth (max depth max_depth)))\n    max_depth)\n  (filter (lambda (x) (not (equal? x \"\"))) (map parse_paren_group (string-split paren_string \" \"))))\n\n### Julia version\n\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\n"}, {"name": "HumanEval_155_even_odd_count", "language": "jl", "prompt": "function even_odd_count(num::Int64)::Tuple{Int64, Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_155_even_odd_count.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = even_odd_count;\n\t@test(candidate(7) == (0, 1))\n\t@test(candidate(-78) == (1, 1))\n\t@test(candidate(3452) == (2, 2))\n\t@test(candidate(346211) == (3, 3))\n\t@test(candidate(-345821) == (3, 3))\n\t@test(candidate(-2) == (1, 0))\n\t@test(candidate(-45347) == (2, 3))\n\t@test(candidate(0) == (1, 0))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (even_odd_count num)\n  (define even_count 0)\n  (define odd_count 0)\n  (for-each (lambda (i) (if (even? (string->number (string i))) (set! even_count (add1 even_count)) (set! odd_count (add1 odd_count)))) (string->list (number->string (abs num))))\n  (list even_count odd_count))\n\n### Julia version\n\nfunction even_odd_count(num::Int64)::Tuple{Int64, Int64}\n"}, {"name": "HumanEval_67_fruit_distribution", "language": "jl", "prompt": "function fruit_distribution(s::String, n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_67_fruit_distribution.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = fruit_distribution;\n\t@test(candidate(\"5 apples and 6 oranges\", 19) == 8)\n\t@test(candidate(\"5 apples and 6 oranges\", 21) == 10)\n\t@test(candidate(\"0 apples and 1 oranges\", 3) == 2)\n\t@test(candidate(\"1 apples and 0 oranges\", 3) == 2)\n\t@test(candidate(\"2 apples and 3 oranges\", 100) == 95)\n\t@test(candidate(\"2 apples and 3 oranges\", 5) == 0)\n\t@test(candidate(\"1 apples and 100 oranges\", 120) == 19)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (fruit_distribution s n)\n  (define (string->intlist s)\n    (map string->number (string-split s)))\n  (- n (apply + (filter integer? (string->intlist s)))))\n\n### Julia version\n\nfunction fruit_distribution(s::String, n::Int64)::Int64\n"}, {"name": "HumanEval_11_string_xor", "language": "jl", "prompt": "function string_xor(a::String, b::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_11_string_xor.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (string_xor a b)\n  (define (xor i j)\n    (if (char=? i j) #\\0 #\\1))\n  (list->string (map xor (string->list a) (string->list b))))\n\n### Julia version\n\nfunction string_xor(a::String, b::String)::String\n"}, {"name": "HumanEval_23_strlen", "language": "jl", "prompt": "function strlen(string::String)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_23_strlen.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = strlen;\n\t@test(candidate(\"\") == 0)\n\t@test(candidate(\"x\") == 1)\n\t@test(candidate(\"asdasnakj\") == 9)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (strlen string)\n  (string-length string))\n\n### Julia version\n\nfunction strlen(string::String)::Int64\n"}, {"name": "HumanEval_15_string_sequence", "language": "jl", "prompt": "function string_sequence(n::Int64)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_15_string_sequence.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = string_sequence;\n\t@test(candidate(0) == \"0\")\n\t@test(candidate(3) == \"0 1 2 3\")\n\t@test(candidate(10) == \"0 1 2 3 4 5 6 7 8 9 10\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (string_sequence n)\n  (string-join (map number->string (range (add1 n)))))\n\n### Julia version\n\nfunction string_sequence(n::Int64)::String\n"}, {"name": "HumanEval_141_file_name_check", "language": "jl", "prompt": "function file_name_check(file_name::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_141_file_name_check.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = file_name_check;\n\t@test(candidate(\"example.txt\") == \"Yes\")\n\t@test(candidate(\"1example.dll\") == \"No\")\n\t@test(candidate(\"s1sdf3.asd\") == \"No\")\n\t@test(candidate(\"K.dll\") == \"Yes\")\n\t@test(candidate(\"MY16FILE3.exe\") == \"Yes\")\n\t@test(candidate(\"His12FILE94.exe\") == \"No\")\n\t@test(candidate(\"_Y.txt\") == \"No\")\n\t@test(candidate(\"?aREYA.exe\") == \"No\")\n\t@test(candidate(\"/this_is_valid.dll\") == \"No\")\n\t@test(candidate(\"this_is_valid.wow\") == \"No\")\n\t@test(candidate(\"this_is_valid.txt\") == \"Yes\")\n\t@test(candidate(\"this_is_valid.txtexe\") == \"No\")\n\t@test(candidate(\"#this2_i4s_5valid.ten\") == \"No\")\n\t@test(candidate(\"@this1_is6_valid.exe\") == \"No\")\n\t@test(candidate(\"this_is_12valid.6exe4.txt\") == \"No\")\n\t@test(candidate(\"all.exe.txt\") == \"No\")\n\t@test(candidate(\"I563_No.exe\") == \"Yes\")\n\t@test(candidate(\"Is3youfault.txt\") == \"Yes\")\n\t@test(candidate(\"no_one#knows.dll\") == \"Yes\")\n\t@test(candidate(\"1I563_Yes3.exe\") == \"No\")\n\t@test(candidate(\"I563_Yes3.txtt\") == \"No\")\n\t@test(candidate(\"final..txt\") == \"No\")\n\t@test(candidate(\"final132\") == \"No\")\n\t@test(candidate(\"_f4indsartal132.\") == \"No\")\n\t@test(candidate(\".txt\") == \"No\")\n\t@test(candidate(\"s.\") == \"No\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (file_name_check file_name)\n  (define suf '(\"txt\" \"exe\" \"dll\"))\n  (define lst (string-split file_name \".\"))\n  (cond\n    [(not (= (length lst) 2)) \"No\"]\n    [(not (member (list-ref lst 1) suf)) \"No\"]\n    [(= (string-length (list-ref lst 0)) 0) \"No\"]\n    [(not (char-alphabetic? (string-ref (list-ref lst 0) 0))) \"No\"]\n    [(> (length (regexp-match* #rx\"[0-9]\" (list-ref lst 0))) 3) \"No\"]\n    [else \"Yes\"]))\n\n### Julia version\n\nfunction file_name_check(file_name::String)::String\n"}, {"name": "HumanEval_135_can_arrange", "language": "jl", "prompt": "function can_arrange(arr::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_135_can_arrange.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = can_arrange;\n\t@test(candidate([1, 2, 4, 3, 5]) == 3)\n\t@test(candidate([1, 2, 4, 5]) == -1)\n\t@test(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\n\t@test(candidate([4, 8, 5, 7, 3]) == 4)\n\t@test(candidate(Vector{Int64}([])) == -1)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (can_arrange arr)\n  (define ind -1)\n  (for ([i (in-range 1 (length arr))])\n    (when (< (list-ref arr i) (list-ref arr (- i 1)))\n      (set! ind i)))\n  ind)\n\n### Julia version\n\nfunction can_arrange(arr::Vector{Int64})::Int64\n"}, {"name": "HumanEval_85_add", "language": "jl", "prompt": "function add(lst::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_85_add.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = add;\n\t@test(candidate([4, 88]) == 88)\n\t@test(candidate([4, 5, 6, 7, 2, 122]) == 122)\n\t@test(candidate([4, 0, 6, 7]) == 0)\n\t@test(candidate([4, 4, 6, 8]) == 12)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (add lst)\n  (apply + (filter even? (map (lambda (i) (list-ref lst i)) (range 1 (length lst) 2)))))\n\n### Julia version\n\nfunction add(lst::Vector{Int64})::Int64\n"}, {"name": "HumanEval_5_intersperse", "language": "jl", "prompt": "function intersperse(numbers::Vector{Int64}, delimeter::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_5_intersperse.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (intersperse numbers delimeter)\n  (if (null? numbers)\n      '()\n      (let loop ((n (cdr numbers)) (result (list (car numbers))))\n        (if (null? n)\n            result\n            (loop (cdr n) (append result (list delimeter) (list (car n))))))))\n\n### Julia version\n\nfunction intersperse(numbers::Vector{Int64}, delimeter::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_119_match_parens", "language": "jl", "prompt": "function match_parens(lst::Vector{String})::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_119_match_parens.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (match_parens lst)\n  (define (check s)\n    (define (iter val s)\n      (cond\n        [(null? s) (if (= val 0) #t #f)]\n        [(eq? (car s) #\\() (iter (+ val 1) (cdr s))]\n        [(eq? (car s) #\\)) (if (< val 1) #f (iter (- val 1) (cdr s)))]\n        [else (iter val (cdr s))]))\n    (iter 0 (string->list s)))\n\n  (define S1 (string-append (list-ref lst 0) (list-ref lst 1)))\n  (define S2 (string-append (list-ref lst 1) (list-ref lst 0)))\n  (if (or (check S1) (check S2)) \"Yes\" \"No\"))\n\n### Julia version\n\nfunction match_parens(lst::Vector{String})::String\n"}, {"name": "HumanEval_7_filter_by_substring", "language": "jl", "prompt": "function filter_by_substring(strings::Vector{String}, substring::String)::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_7_filter_by_substring.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = filter_by_substring;\n\t@test(candidate(Vector{String}([]), \"john\") == Vector{String}([]))\n\t@test(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\n\t@test(candidate([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\n\t@test(candidate([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (filter_by_substring strings substring)\n  (filter (lambda (x) (string-contains? x substring)) strings))\n\n### Julia version\n\nfunction filter_by_substring(strings::Vector{String}, substring::String)::Vector{String}\n"}, {"name": "HumanEval_158_find_max", "language": "jl", "prompt": "function find_max(words::Vector{String})::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_158_find_max.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = find_max;\n\t@test(candidate([\"name\", \"of\", \"string\"]) == \"string\")\n\t@test(candidate([\"name\", \"enam\", \"game\"]) == \"enam\")\n\t@test(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\n\t@test(candidate([\"abc\", \"cba\"]) == \"abc\")\n\t@test(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\n\t@test(candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\n\t@test(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\n\t@test(candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\n\t@test(candidate([\"b\"]) == \"b\")\n\t@test(candidate([\"play\", \"play\", \"play\"]) == \"play\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (find_max words)\n  (car (sort words (lambda (a b)\n                      (or (> (length (remove-duplicates (string->list a))) (length (remove-duplicates (string->list b))))\n                          (and (= (length (remove-duplicates (string->list a))) (length (remove-duplicates (string->list b))))\n                               (string<? a b)))))))\n\n### Julia version\n\nfunction find_max(words::Vector{String})::String\n"}, {"name": "HumanEval_163_generate_integers", "language": "jl", "prompt": "function generate_integers(a::Int64, b::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_163_generate_integers.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = generate_integers;\n\t@test(candidate(2, 10) == [2, 4, 6, 8])\n\t@test(candidate(10, 2) == [2, 4, 6, 8])\n\t@test(candidate(132, 2) == [2, 4, 6, 8])\n\t@test(candidate(17, 89) == Vector{Int64}([]))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (generate_integers a b)\n  (define lower (max 2 (min a b)))\n  (define upper (min 8 (max a b)))\n  (filter even? (range lower (+ upper 1))))\n\n### Julia version\n\nfunction generate_integers(a::Int64, b::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_110_exchange", "language": "jl", "prompt": "function exchange(lst1::Vector{Int64}, lst2::Vector{Int64})::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_110_exchange.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = exchange;\n\t@test(candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\")\n\t@test(candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\")\n\t@test(candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 4]) == \"YES\")\n\t@test(candidate([5, 7, 3], [2, 6, 3]) == \"NO\")\n\t@test(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\")\n\t@test(candidate([100, 200], [200, 200]) == \"YES\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (exchange lst1 lst2)\n  (define odd (count odd? lst1))\n  (define even (count even? lst2))\n  (if (>= even odd)\n      \"YES\"\n      \"NO\"))\n\n### Julia version\n\nfunction exchange(lst1::Vector{Int64}, lst2::Vector{Int64})::String\n"}, {"name": "HumanEval_138_is_equal_to_sum_even", "language": "jl", "prompt": "function is_equal_to_sum_even(n::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_138_is_equal_to_sum_even.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_equal_to_sum_even;\n\t@test(candidate(4) == false)\n\t@test(candidate(6) == false)\n\t@test(candidate(8) == true)\n\t@test(candidate(10) == true)\n\t@test(candidate(11) == false)\n\t@test(candidate(12) == true)\n\t@test(candidate(13) == false)\n\t@test(candidate(16) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (is_equal_to_sum_even n)\n  (and (even? n) (>= n 8)))\n\n### Julia version\n\nfunction is_equal_to_sum_even(n::Int64)::Bool\n"}, {"name": "HumanEval_79_decimal_to_binary", "language": "jl", "prompt": "function decimal_to_binary(decimal::Int64)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_79_decimal_to_binary.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = decimal_to_binary;\n\t@test(candidate(0) == \"db0db\")\n\t@test(candidate(32) == \"db100000db\")\n\t@test(candidate(103) == \"db1100111db\")\n\t@test(candidate(15) == \"db1111db\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (decimal_to_binary decimal)\n  (string-append \"db\" (number->string decimal 2) \"db\"))\n\n### Julia version\n\nfunction decimal_to_binary(decimal::Int64)::String\n"}, {"name": "HumanEval_144_simplify", "language": "jl", "prompt": "function simplify(x::String, n::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_144_simplify.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = simplify;\n\t@test(candidate(\"1/5\", \"5/1\") == true)\n\t@test(candidate(\"1/6\", \"2/1\") == false)\n\t@test(candidate(\"5/1\", \"3/1\") == true)\n\t@test(candidate(\"7/10\", \"10/2\") == false)\n\t@test(candidate(\"2/10\", \"50/10\") == true)\n\t@test(candidate(\"7/2\", \"4/2\") == true)\n\t@test(candidate(\"11/6\", \"6/1\") == true)\n\t@test(candidate(\"2/3\", \"5/2\") == false)\n\t@test(candidate(\"5/2\", \"3/5\") == false)\n\t@test(candidate(\"2/4\", \"8/4\") == true)\n\t@test(candidate(\"2/4\", \"4/2\") == true)\n\t@test(candidate(\"1/5\", \"5/1\") == true)\n\t@test(candidate(\"1/5\", \"1/5\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (simplify x n)\n  (define a-b (string-split x \"/\"))\n  (define c-d (string-split n \"/\"))\n  (define numerator (* (string->number (first a-b)) (string->number (first c-d))))\n  (define denom (* (string->number (second a-b)) (string->number (second c-d))))\n  (= (/ numerator denom) (floor (/ numerator denom))))\n\n### Julia version\n\nfunction simplify(x::String, n::String)::Bool\n"}, {"name": "HumanEval_157_right_angle_triangle", "language": "jl", "prompt": "function right_angle_triangle(a::Int64, b::Int64, c::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_157_right_angle_triangle.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = right_angle_triangle;\n\t@test(candidate(3, 4, 5) == true)\n\t@test(candidate(1, 2, 3) == false)\n\t@test(candidate(10, 6, 8) == true)\n\t@test(candidate(2, 2, 2) == false)\n\t@test(candidate(7, 24, 25) == true)\n\t@test(candidate(10, 5, 7) == false)\n\t@test(candidate(5, 12, 13) == true)\n\t@test(candidate(15, 8, 17) == true)\n\t@test(candidate(48, 55, 73) == true)\n\t@test(candidate(1, 1, 1) == false)\n\t@test(candidate(2, 2, 10) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (right_angle_triangle a b c)\n  (or (= (* a a) (+ (* b b) (* c c)))\n      (= (* b b) (+ (* a a) (* c c)))\n      (= (* c c) (+ (* a a) (* b b)))))\n\n### Julia version\n\nfunction right_angle_triangle(a::Int64, b::Int64, c::Int64)::Bool\n"}, {"name": "HumanEval_151_double_the_difference", "language": "jl", "prompt": "function double_the_difference(lst::Vector{Float64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_151_double_the_difference.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = double_the_difference;\n\t@test(candidate(Vector{Float64}([])) == 0)\n\t@test(candidate([5.0, 4.0]) == 25)\n\t@test(candidate([0.1, 0.2, 0.3]) == 0)\n\t@test(candidate([-10.0, -20.0, -30.0]) == 0)\n\t@test(candidate([-1.0, -2.0, 8.0]) == 0)\n\t@test(candidate([0.2, 3.0, 5.0]) == 34)\n\t@test(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (double_the_difference lst)\n  (apply + (filter odd? (map (lambda (x) (* x x)) (filter (lambda (x) (and (> x 0) (integer? x))) lst)))))\n\n### Julia version\n\nfunction double_the_difference(lst::Vector{Float64})::Int64\n"}, {"name": "HumanEval_3_below_zero", "language": "jl", "prompt": "function below_zero(operations::Vector{Int64})::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_3_below_zero.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = below_zero;\n\t@test(candidate(Vector{Int64}([])) == false)\n\t@test(candidate([1, 2, -3, 1, 2, -3]) == false)\n\t@test(candidate([1, 2, -4, 5, 6]) == true)\n\t@test(candidate([1, -1, 2, -2, 5, -5, 4, -4]) == false)\n\t@test(candidate([1, -1, 2, -2, 5, -5, 4, -5]) == true)\n\t@test(candidate([1, -2, 2, -2, 5, -5, 4, -4]) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (below_zero operations)\n  (let loop ([balance 0] [ops operations])\n    (cond [(null? ops) #f]\n          [(< (+ balance (car ops)) 0) #t]\n          [else (loop (+ balance (car ops)) (cdr ops))])))\n\n### Julia version\n\nfunction below_zero(operations::Vector{Int64})::Bool\n"}, {"name": "HumanEval_13_greatest_common_divisor", "language": "jl", "prompt": "function greatest_common_divisor(a::Int64, b::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_13_greatest_common_divisor.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = greatest_common_divisor;\n\t@test(candidate(3, 7) == 1)\n\t@test(candidate(10, 15) == 5)\n\t@test(candidate(49, 14) == 7)\n\t@test(candidate(144, 60) == 12)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (greatest_common_divisor a b)\n  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n\n### Julia version\n\nfunction greatest_common_divisor(a::Int64, b::Int64)::Int64\n"}, {"name": "HumanEval_106_f", "language": "jl", "prompt": "function f(n::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_106_f.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = f;\n\t@test(candidate(5) == [1, 2, 6, 24, 15])\n\t@test(candidate(7) == [1, 2, 6, 24, 15, 720, 28])\n\t@test(candidate(1) == [1])\n\t@test(candidate(3) == [1, 2, 6])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (f n)\n  (define (factorial x)\n    (foldl * 1 (range 1 (+ x 1))))\n  (define (sum x)\n    (foldl + 0 (range 1 (+ x 1))))\n  (for/list ([i (range 1 (+ n 1))])\n    (if (even? i)\n        (factorial i)\n        (sum i))))\n\n### Julia version\n\nfunction f(n::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_57_monotonic", "language": "jl", "prompt": "function monotonic(l::Vector{Int64})::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_57_monotonic.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = monotonic;\n\t@test(candidate([1, 2, 4, 10]) == true)\n\t@test(candidate([1, 2, 4, 20]) == true)\n\t@test(candidate([1, 20, 4, 10]) == false)\n\t@test(candidate([4, 1, 0, -10]) == true)\n\t@test(candidate([4, 1, 1, 0]) == true)\n\t@test(candidate([1, 2, 3, 2, 5, 60]) == false)\n\t@test(candidate([1, 2, 3, 4, 5, 60]) == true)\n\t@test(candidate([9, 9, 9, 9]) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (monotonic l)\n  (or (equal? l (sort l <))\n      (equal? l (sort l >))))\n\n### Julia version\n\nfunction monotonic(l::Vector{Int64})::Bool\n"}, {"name": "HumanEval_105_by_length", "language": "jl", "prompt": "function by_length(arr::Vector{Int64})::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_105_by_length.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (by_length arr)\n  (define dic (hash 1 \"One\" 2 \"Two\" 3 \"Three\" 4 \"Four\" 5 \"Five\" 6 \"Six\" 7 \"Seven\" 8 \"Eight\" 9 \"Nine\"))\n  (define sorted-arr (sort arr >))\n  (define new-arr '())\n  (for ([var sorted-arr])\n    (when (hash-ref dic var #f)\n      (set! new-arr (append new-arr (list (hash-ref dic var))))))\n\n  new-arr)\n\n### Julia version\n\nfunction by_length(arr::Vector{Int64})::Vector{String}\n"}, {"name": "HumanEval_51_remove_vowels", "language": "jl", "prompt": "function remove_vowels(text::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_51_remove_vowels.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = remove_vowels;\n\t@test(candidate(\"\") == \"\")\n\t@test(candidate(\"abcdef\nghijklm\") == \"bcdf\nghjklm\")\n\t@test(candidate(\"fedcba\") == \"fdcb\")\n\t@test(candidate(\"eeeee\") == \"\")\n\t@test(candidate(\"acBAA\") == \"cB\")\n\t@test(candidate(\"EcBOO\") == \"cB\")\n\t@test(candidate(\"ybcd\") == \"ybcd\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (remove_vowels text)\n  (list->string (filter (lambda (s) (not (member s '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))) (string->list text))))\n\n### Julia version\n\nfunction remove_vowels(text::String)::String\n"}, {"name": "HumanEval_77_iscube", "language": "jl", "prompt": "function iscube(a::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_77_iscube.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = iscube;\n\t@test(candidate(1) == true)\n\t@test(candidate(2) == false)\n\t@test(candidate(-1) == true)\n\t@test(candidate(64) == true)\n\t@test(candidate(180) == false)\n\t@test(candidate(1000) == true)\n\t@test(candidate(0) == true)\n\t@test(candidate(1729) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (iscube a)\n  (= (expt (round (expt (abs a) (/ 1 3))) 3) (abs a)))\n\n### Julia version\n\nfunction iscube(a::Int64)::Bool\n"}, {"name": "HumanEval_112_reverse_delete", "language": "jl", "prompt": "function reverse_delete(s::String, c::String)::Tuple{String, Bool}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_112_reverse_delete.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = reverse_delete;\n\t@test(candidate(\"abcde\", \"ae\") == (\"bcd\", false))\n\t@test(candidate(\"abcdef\", \"b\") == (\"acdef\", false))\n\t@test(candidate(\"abcdedcba\", \"ab\") == (\"cdedc\", true))\n\t@test(candidate(\"dwik\", \"w\") == (\"dik\", false))\n\t@test(candidate(\"a\", \"a\") == (\"\", true))\n\t@test(candidate(\"abcdedcba\", \"\") == (\"abcdedcba\", true))\n\t@test(candidate(\"abcdedcba\", \"v\") == (\"abcdedcba\", true))\n\t@test(candidate(\"vabba\", \"v\") == (\"abba\", true))\n\t@test(candidate(\"mamma\", \"mia\") == (\"\", true))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (reverse_delete s c)\n  (define new-string (list->string (filter (lambda (char) (not (member char (string->list c)) )) (string->list s))))\n  (list new-string (equal? new-string (list->string (reverse (string->list new-string))))))\n\n### Julia version\n\nfunction reverse_delete(s::String, c::String)::Tuple{String, Bool}\n"}, {"name": "HumanEval_4_mean_absolute_deviation", "language": "jl", "prompt": "function mean_absolute_deviation(numbers::Vector{Float64})::Float64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_4_mean_absolute_deviation.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = mean_absolute_deviation;\n\t@test(candidate([1.0, 2.0]) == 0.5)\n\t@test(candidate([1.0, 2.0, 3.0, 4.0]) == 1.0)\n\t@test(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (mean_absolute_deviation numbers)\n  (define mean (/ (apply + numbers) (length numbers)))\n  (/ (apply + (map (lambda (x) (abs (- x mean))) numbers)) (length numbers)))\n\n### Julia version\n\nfunction mean_absolute_deviation(numbers::Vector{Float64})::Float64\n"}, {"name": "HumanEval_56_correct_bracketing", "language": "jl", "prompt": "function correct_bracketing(brackets::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_56_correct_bracketing.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = correct_bracketing;\n\t@test(candidate(\"<>\") == true)\n\t@test(candidate(\"<<><>>\") == true)\n\t@test(candidate(\"<><><<><>><>\") == true)\n\t@test(candidate(\"<><><<<><><>><>><<><><<>>>\") == true)\n\t@test(candidate(\"<<<><>>>>\") == false)\n\t@test(candidate(\"><<>\") == false)\n\t@test(candidate(\"<\") == false)\n\t@test(candidate(\"<<<<\") == false)\n\t@test(candidate(\">\") == false)\n\t@test(candidate(\"<<>\") == false)\n\t@test(candidate(\"<><><<><>><>><<>\") == false)\n\t@test(candidate(\"<><><<><>><>>><>\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (correct_bracketing brackets)\n  (let loop ([depth 0] [brackets (string->list brackets)])\n    (if (null? brackets)\n        (zero? depth)\n        (if (char=? (car brackets) #\\<)\n            (loop (+ depth 1) (cdr brackets))\n            (and (positive? depth) (loop (- depth 1) (cdr brackets)))))))\n\n### Julia version\n\nfunction correct_bracketing(brackets::String)::Bool\n"}, {"name": "HumanEval_21_rescale_to_unit", "language": "jl", "prompt": "function rescale_to_unit(numbers::Vector{Float64})::Vector{Float64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_21_rescale_to_unit.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = rescale_to_unit;\n\t@test(candidate([2.0, 49.9]) == [0.0, 1.0])\n\t@test(candidate([100.0, 49.9]) == [1.0, 0.0])\n\t@test(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\n\t@test(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\n\t@test(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (rescale_to_unit numbers)\n  (let ([min-number (apply min numbers)]\n        [max-number (apply max numbers)])\n    (map (\u03bb (x) (/ (- x min-number) (- max-number min-number))) numbers)))\n\n### Julia version\n\nfunction rescale_to_unit(numbers::Vector{Float64})::Vector{Float64}\n"}, {"name": "HumanEval_127_intersection", "language": "jl", "prompt": "function intersection(interval1::Tuple{Int64, Int64}, interval2::Tuple{Int64, Int64})::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_127_intersection.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = intersection;\n\t@test(candidate((1, 2), (2, 3)) == \"NO\")\n\t@test(candidate((-1, 1), (0, 4)) == \"NO\")\n\t@test(candidate((-3, -1), (-5, 5)) == \"YES\")\n\t@test(candidate((-2, 2), (-4, 0)) == \"YES\")\n\t@test(candidate((-11, 2), (-1, -1)) == \"NO\")\n\t@test(candidate((1, 2), (3, 5)) == \"NO\")\n\t@test(candidate((1, 2), (1, 2)) == \"NO\")\n\t@test(candidate((-2, -2), (-3, -2)) == \"NO\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (intersection interval1 interval2)\n  (define (is-prime num)\n    (cond [(or (= num 1) (= num 0)) #f]\n          [(= num 2) #t]\n          [else (for/and ([i (in-range 2 num)]) (not (= 0 (modulo num i))))]))\n\n  (define l (max (first interval1) (first interval2)))\n  (define r (min (second interval1) (second interval2)))\n  (define length (- r l))\n  (if (and (> length 0) (is-prime length))\n      \"YES\"\n      \"NO\"))\n\n### Julia version\n\nfunction intersection(interval1::Tuple{Int64, Int64}, interval2::Tuple{Int64, Int64})::String\n"}, {"name": "HumanEval_78_hex_key", "language": "jl", "prompt": "function hex_key(num::String)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_78_hex_key.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = hex_key;\n\t@test(candidate(\"AB\") == 1)\n\t@test(candidate(\"1077E\") == 2)\n\t@test(candidate(\"ABED1A33\") == 4)\n\t@test(candidate(\"2020\") == 2)\n\t@test(candidate(\"123456789ABCDEF0\") == 6)\n\t@test(candidate(\"112233445566778899AABBCCDDEEFF00\") == 12)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (hex_key num)\n  (define primes '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n  (define total 0)\n  (for ((i (in-string num)))\n    (when (member i primes)\n      (set! total (+ total 1))))\n  total)\n\n### Julia version\n\nfunction hex_key(num::String)::Int64\n"}, {"name": "HumanEval_70_strange_sort_list", "language": "jl", "prompt": "function strange_sort_list(lst::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_70_strange_sort_list.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (strange_sort_list lst)\n  (let loop ((lst lst) (res '()) (switch #t))\n    (if (null? lst)\n        res\n        (let ((x (if switch (apply min lst) (apply max lst))))\n          (loop (remove x lst) (append res (list x)) (not switch))))))\n\n### Julia version\n\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_14_all_prefixes", "language": "jl", "prompt": "function all_prefixes(string::String)::Vector{String}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_14_all_prefixes.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = all_prefixes;\n\t@test(candidate(\"\") == Vector{String}([]))\n\t@test(candidate(\"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\t@test(candidate(\"WWW\") == [\"W\", \"WW\", \"WWW\"])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (all_prefixes string)\n  (define result '())\n  (for ([i (in-range (string-length string))])\n    (set! result (append result (list (substring string 0 (+ i 1))))))\n  result)\n\n### Julia version\n\nfunction all_prefixes(string::String)::Vector{String}\n"}, {"name": "HumanEval_121_solution", "language": "jl", "prompt": "function solution(lst::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_121_solution.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = solution;\n\t@test(candidate([5, 8, 7, 1]) == 12)\n\t@test(candidate([3, 3, 3, 3, 3]) == 9)\n\t@test(candidate([30, 13, 24, 321]) == 0)\n\t@test(candidate([5, 9]) == 5)\n\t@test(candidate([2, 4, 8]) == 0)\n\t@test(candidate([30, 13, 23, 32]) == 23)\n\t@test(candidate([3, 13, 2, 9]) == 3)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solution lst)\n  (apply + (filter odd? (map (lambda (x) (list-ref lst x)) (range 0 (length lst) 2)))))\n\n### Julia version\n\nfunction solution(lst::Vector{Int64})::Int64\n"}, {"name": "HumanEval_126_is_sorted", "language": "jl", "prompt": "function is_sorted(lst::Vector{Int64})::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_126_is_sorted.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_sorted;\n\t@test(candidate([5]) == true)\n\t@test(candidate([1, 2, 3, 4, 5]) == true)\n\t@test(candidate([1, 3, 2, 4, 5]) == false)\n\t@test(candidate([1, 2, 3, 4, 5, 6]) == true)\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7]) == true)\n\t@test(candidate([1, 3, 2, 4, 5, 6, 7]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\n\t@test(candidate([1]) == true)\n\t@test(candidate([3, 2, 1]) == false)\n\t@test(candidate([1, 2, 2, 2, 3, 4]) == false)\n\t@test(candidate([1, 2, 3, 3, 3, 4]) == false)\n\t@test(candidate([1, 2, 2, 3, 3, 4]) == true)\n\t@test(candidate([1, 2, 3, 4]) == true)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;;\n(define (is_sorted lst)\n  (define count-digit (make-hash))\n  (for-each (lambda (i) (hash-update! count-digit i add1 0)) lst)\n  (if (ormap (lambda (i) (> (hash-ref count-digit i 0) 2)) lst)\n      #f\n      (let loop ([i 1])\n        (if (< i (length lst))\n            (if (<= (list-ref lst (- i 1)) (list-ref lst i))\n                (loop (+ i 1))\n                #f)\n            #t))))\n\n### Julia version\n\nfunction is_sorted(lst::Vector{Int64})::Bool\n"}, {"name": "HumanEval_69_search", "language": "jl", "prompt": "function search(lst::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_69_search.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = search;\n\t@test(candidate([5, 5, 5, 5, 1]) == 1)\n\t@test(candidate([4, 1, 4, 1, 4, 4]) == 4)\n\t@test(candidate([3, 3]) == -1)\n\t@test(candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8)\n\t@test(candidate([2, 3, 3, 2, 2]) == 2)\n\t@test(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\n\t@test(candidate([3, 2, 8, 2]) == 2)\n\t@test(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\n\t@test(candidate([8, 8, 3, 6, 5, 6, 4]) == -1)\n\t@test(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\n\t@test(candidate([1, 9, 10, 1, 3]) == 1)\n\t@test(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\n\t@test(candidate([1]) == 1)\n\t@test(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\n\t@test(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\n\t@test(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\n\t@test(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)\n\t@test(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\n\t@test(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\n\t@test(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\n\t@test(candidate([10]) == -1)\n\t@test(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\n\t@test(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\n\t@test(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\n\t@test(candidate([3, 10, 10, 9, 2]) == -1)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (search lst)\n  (define frq (make-vector (+ (apply max lst) 1) 0))\n  (for-each (lambda (i) (vector-set! frq i (+ (vector-ref frq i) 1))) lst)\n  (define ans -1)\n  (for ([i (in-range 1 (vector-length frq))])\n    (when (>= (vector-ref frq i) i)\n      (set! ans i)))\n  ans)\n\n### Julia version\n\nfunction search(lst::Vector{Int64})::Int64\n"}, {"name": "HumanEval_43_pairs_sum_to_zero", "language": "jl", "prompt": "function pairs_sum_to_zero(l::Vector{Int64})::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_43_pairs_sum_to_zero.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = pairs_sum_to_zero;\n\t@test(candidate([1, 3, 5, 0]) == false)\n\t@test(candidate([1, 3, -2, 1]) == false)\n\t@test(candidate([1, 2, 3, 7]) == false)\n\t@test(candidate([2, 4, -5, 3, 5, 7]) == true)\n\t@test(candidate([1]) == false)\n\t@test(candidate([-3, 9, -1, 3, 2, 30]) == true)\n\t@test(candidate([-3, 9, -1, 3, 2, 31]) == true)\n\t@test(candidate([-3, 9, -1, 4, 2, 30]) == false)\n\t@test(candidate([-3, 9, -1, 4, 2, 31]) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (pairs_sum_to_zero l)\n  (define (helper l1)\n    (cond [(null? l1) #f]\n          [(member (- (car l1)) (cdr l1)) #t]\n          [else (helper (cdr l1))]))\n  (helper l))\n\n### Julia version\n\nfunction pairs_sum_to_zero(l::Vector{Int64})::Bool\n"}, {"name": "HumanEval_83_starts_one_ends", "language": "jl", "prompt": "function starts_one_ends(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_83_starts_one_ends.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = starts_one_ends;\n\t@test(candidate(1) == 1)\n\t@test(candidate(2) == 18)\n\t@test(candidate(3) == 180)\n\t@test(candidate(4) == 1800)\n\t@test(candidate(5) == 18000)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (starts_one_ends n)\n  (if (= n 1) 1\n      (* 18 (expt 10 (- n 2)))))\n\n### Julia version\n\nfunction starts_one_ends(n::Int64)::Int64\n"}, {"name": "HumanEval_30_get_positive", "language": "jl", "prompt": "function get_positive(l::Vector{Int64})::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_30_get_positive.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = get_positive;\n\t@test(candidate([-1, -2, 4, 5, 6]) == [4, 5, 6])\n\t@test(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\n\t@test(candidate([-1, -2]) == Vector{Int64}([]))\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (get_positive l)\n  (filter (lambda (e) (> e 0)) l))\n\n### Julia version\n\nfunction get_positive(l::Vector{Int64})::Vector{Int64}\n"}, {"name": "HumanEval_28_concatenate", "language": "jl", "prompt": "function concatenate(strings::Vector{String})::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_28_concatenate.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = concatenate;\n\t@test(candidate(Vector{String}([])) == \"\")\n\t@test(candidate([\"x\", \"y\", \"z\"]) == \"xyz\")\n\t@test(candidate([\"x\", \"y\", \"z\", \"w\", \"k\"]) == \"xyzwk\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (concatenate strings)\n  (string-append* strings))\n\n### Julia version\n\nfunction concatenate(strings::Vector{String})::String\n"}, {"name": "HumanEval_132_is_nested", "language": "jl", "prompt": "function is_nested(string::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_132_is_nested.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_nested;\n\t@test(candidate(\"[[]]\") == true)\n\t@test(candidate(\"[]]]]]]][[[[[]\") == false)\n\t@test(candidate(\"[][]\") == false)\n\t@test(candidate(\"[]\") == false)\n\t@test(candidate(\"[[[[]]]]\") == true)\n\t@test(candidate(\"[]]]]]]]]]]\") == false)\n\t@test(candidate(\"[][][[]]\") == true)\n\t@test(candidate(\"[[]\") == false)\n\t@test(candidate(\"[]]\") == false)\n\t@test(candidate(\"[[]][[\") == true)\n\t@test(candidate(\"[[][]]\") == true)\n\t@test(candidate(\"\") == false)\n\t@test(candidate(\"[[[[[[[[\") == false)\n\t@test(candidate(\"]]]]]]]]\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (is_nested string)\n  (define opening-bracket-index '())\n  (define closing-bracket-index '())\n  (for ([i (in-range (string-length string))])\n    (cond [(char=? (string-ref string i) #\\[) (set! opening-bracket-index (append opening-bracket-index (list i)))]\n          [(char=? (string-ref string i) #\\]) (set! closing-bracket-index (cons i closing-bracket-index))]))\n  (define cnt 0)\n  (define i 0)\n  (define l (length closing-bracket-index))\n  (for ([idx opening-bracket-index])\n    (cond [(and (< i l) (< idx (list-ref closing-bracket-index i)))\n           (set! cnt (add1 cnt))\n           (set! i (add1 i))]))\n  (>= cnt 2))\n\n### Julia version\n\nfunction is_nested(string::String)::Bool\n"}, {"name": "HumanEval_48_is_palindrome", "language": "jl", "prompt": "function is_palindrome(text::String)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_48_is_palindrome.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_palindrome;\n\t@test(candidate(\"\") == true)\n\t@test(candidate(\"aba\") == true)\n\t@test(candidate(\"aaaaa\") == true)\n\t@test(candidate(\"zbcd\") == false)\n\t@test(candidate(\"xywyx\") == true)\n\t@test(candidate(\"xywyz\") == false)\n\t@test(candidate(\"xywzx\") == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (is_palindrome text)\n  (for/and ([i (in-range (string-length text))])\n    (equal? (string-ref text i)\n            (string-ref text (- (string-length text) 1 i)))))\n\n### Julia version\n\nfunction is_palindrome(text::String)::Bool\n"}, {"name": "HumanEval_108_count_nums", "language": "jl", "prompt": "function count_nums(arr::Vector{Int64})::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_108_count_nums.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = count_nums;\n\t@test(candidate(Vector{Int64}([])) == 0)\n\t@test(candidate([-1, -2, 0]) == 0)\n\t@test(candidate([1, 1, 2, -2, 3, 4, 5]) == 6)\n\t@test(candidate([1, 6, 9, -6, 0, 1, 5]) == 5)\n\t@test(candidate([1, 100, 98, -7, 1, -1]) == 4)\n\t@test(candidate([12, 23, 34, -45, -56, 0]) == 5)\n\t@test(candidate([0, 1]) == 1)\n\t@test(candidate([1]) == 1)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (count_nums arr)\n  (define (digits_sum n)\n    (let ([neg (if (< n 0) -1 1)])\n      (let ([n (map (lambda (x) (string->number (string x))) (string->list (number->string (* n neg))))])\n        (apply + (cons (* (first n) neg) (rest n))))))\n\n  (length (filter (lambda (x) (> x 0)) (map digits_sum arr))))\n\n### Julia version\n\nfunction count_nums(arr::Vector{Int64})::Int64\n"}, {"name": "HumanEval_25_factorize", "language": "jl", "prompt": "function factorize(n::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_25_factorize.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = factorize;\n\t@test(candidate(2) == [2])\n\t@test(candidate(4) == [2, 2])\n\t@test(candidate(8) == [2, 2, 2])\n\t@test(candidate(57) == [3, 19])\n\t@test(candidate(3249) == [3, 3, 19, 19])\n\t@test(candidate(185193) == [3, 3, 3, 19, 19, 19])\n\t@test(candidate(20577) == [3, 19, 19, 19])\n\t@test(candidate(18) == [2, 3, 3])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (factorize n)\n  (define (isqrt x) (floor (sqrt x)))\n  (define (iter i n)\n    (cond ((> i (isqrt n)) (if (> n 1) (list n) '()))\n          ((zero? (modulo n i)) (cons i (iter i (quotient n i))))\n          (else (iter (+ i 1) n))))\n  (iter 2 n))\n\n### Julia version\n\nfunction factorize(n::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_59_largest_prime_factor", "language": "jl", "prompt": "function largest_prime_factor(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_59_largest_prime_factor.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = largest_prime_factor;\n\t@test(candidate(15) == 5)\n\t@test(candidate(27) == 3)\n\t@test(candidate(63) == 7)\n\t@test(candidate(330) == 11)\n\t@test(candidate(13195) == 29)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (largest_prime_factor n)\n  (define (is_prime k)\n    (and (> k 1) (not (ormap (lambda (i) (= (modulo k i) 0)) (range 2 k)))) )\n  (define largest 1)\n  (for ([j (in-range 2 (add1 n))])\n    (when (and (= (modulo n j) 0) (is_prime j))\n      (set! largest (max largest j))))\n  largest)\n\n### Julia version\n\nfunction largest_prime_factor(n::Int64)::Int64\n"}, {"name": "HumanEval_147_get_max_triples", "language": "jl", "prompt": "function get_max_triples(n::Int64)::Int64\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_147_get_max_triples.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = get_max_triples;\n\t@test(candidate(5) == 1)\n\t@test(candidate(6) == 4)\n\t@test(candidate(10) == 36)\n\t@test(candidate(100) == 53361)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (get_max_triples n)\n  (define A (for/list ([i (in-range 1 (add1 n))]) (- (* i i) i 1)))\n  (define ans '())\n  (for ([i (in-range n)])\n    (for ([j (in-range (add1 i) n)])\n      (for ([k (in-range (add1 j) n)])\n        (when (= (modulo (+ (list-ref A i) (list-ref A j) (list-ref A k)) 3) 0)\n          (set! ans (cons (list (list-ref A i) (list-ref A j) (list-ref A k)) ans))))))\n  (length ans))\n\n### Julia version\n\nfunction get_max_triples(n::Int64)::Int64\n"}, {"name": "HumanEval_86_anti_shuffle", "language": "jl", "prompt": "function anti_shuffle(s::String)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_86_anti_shuffle.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = anti_shuffle;\n\t@test(candidate(\"Hi\") == \"Hi\")\n\t@test(candidate(\"hello\") == \"ehllo\")\n\t@test(candidate(\"number\") == \"bemnru\")\n\t@test(candidate(\"abcd\") == \"abcd\")\n\t@test(candidate(\"Hello World!!!\") == \"Hello !!!Wdlor\")\n\t@test(candidate(\"\") == \"\")\n\t@test(candidate(\"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (anti_shuffle s)\n  (string-join (map (lambda (i) (list->string (sort (string->list i) char<=?))) (string-split s \" \")) \" \"))\n\n### Julia version\n\nfunction anti_shuffle(s::String)::String\n"}, {"name": "HumanEval_84_solve", "language": "jl", "prompt": "function solve(N::Int64)::String\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_84_solve.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = solve;\n\t@test(candidate(1000) == \"1\")\n\t@test(candidate(150) == \"110\")\n\t@test(candidate(147) == \"1100\")\n\t@test(candidate(333) == \"1001\")\n\t@test(candidate(963) == \"10010\")\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (solve N)\n  (number->string (apply + (map (lambda (c) (string->number (string c))) (string->list (number->string N)))) 2))\n\n### Julia version\n\nfunction solve(N::Int64)::String\n"}, {"name": "HumanEval_129_minPath", "language": "jl", "prompt": "function minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_129_minPath.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = minPath;\n\t@test(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1])\n\t@test(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1])\n\t@test(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2])\n\t@test(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1])\n\t@test(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1])\n\t@test(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n\t@test(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n\t@test(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3])\n\t@test(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5])\n\t@test(candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n\t@test(candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n;; \n(define (minPath grid k)\n  (define n (length grid))\n  (define val (+ (* n n) 1))\n  (for ([i (in-range n)])\n    (for ([j (in-range n)])\n      (when (= (list-ref (list-ref grid i) j) 1)\n        (define temp '())\n        (when (> i 0) (set! temp (cons (list-ref (list-ref grid (- i 1)) j) temp)))\n        (when (> j 0) (set! temp (cons (list-ref (list-ref grid i) (- j 1)) temp)))\n        (when (< i (- n 1)) (set! temp (cons (list-ref (list-ref grid (+ i 1)) j) temp)))\n        (when (< j (- n 1)) (set! temp (cons (list-ref (list-ref grid i) (+ j 1)) temp)))\n        (set! val (apply min temp)))))\n  (define ans '())\n  (for ([i (in-range k)])\n    (if (even? i)\n        (set! ans (append ans (list 1)))\n        (set! ans (append ans (list val)))))\n  ans)\n\n### Julia version\n\nfunction minPath(grid::Vector{Vector{Int64}}, k::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_100_make_a_pile", "language": "jl", "prompt": "function make_a_pile(n::Int64)::Vector{Int64}\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_100_make_a_pile.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = make_a_pile;\n\t@test(candidate(3) == [3, 5, 7])\n\t@test(candidate(4) == [4, 6, 8, 10])\n\t@test(candidate(5) == [5, 7, 9, 11, 13])\n\t@test(candidate(6) == [6, 8, 10, 12, 14, 16])\n\t@test(candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22])\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (make_a_pile n)\n  (for/list ([i n])\n    (+ n (* 2 i))))\n\n### Julia version\n\nfunction make_a_pile(n::Int64)::Vector{Int64}\n"}, {"name": "HumanEval_31_is_prime", "language": "jl", "prompt": "function is_prime(n::Int64)::Bool\n", "doctests": "keep", "original": "../datasets/originals/HumanEval_31_is_prime.py", "prompt_terminology": "remove", "source_program": "keep", "target_signature": "keep", "tests": "end\n\nusing Test\n\n@testset begin\n\ncandidate = is_prime;\n\t@test(candidate(6) == false)\n\t@test(candidate(101) == true)\n\t@test(candidate(11) == true)\n\t@test(candidate(13441) == true)\n\t@test(candidate(61) == true)\n\t@test(candidate(4) == false)\n\t@test(candidate(1) == false)\n\t@test(candidate(5) == true)\n\t@test(candidate(11) == true)\n\t@test(candidate(17) == true)\n\t@test(candidate(85) == false)\n\t@test(candidate(77) == false)\n\t@test(candidate(255379) == false)\nend\n", "stop_tokens": ["\n#", "\nend"], "translation_prompt": "You are a helpful and faithful compiler that transpiles Racket code to Julia code. Please translate the following Racket code to Julia?\n\n### Racket version\n\n#lang racket\n\n(define (is_prime n)\n  (if (< n 2)\n      #f\n      (for/and ([k (in-range 2 (- n 1))])\n        (not (= (modulo n k) 0)))))\n\n### Julia version\n\nfunction is_prime(n::Int64)::Bool\n"}]